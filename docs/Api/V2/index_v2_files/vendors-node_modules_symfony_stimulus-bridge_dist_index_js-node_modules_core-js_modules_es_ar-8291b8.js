"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_symfony_stimulus-bridge_dist_index_js-node_modules_core-js_modules_es_ar-8291b8"],{

/***/ "./node_modules/@hotwired/stimulus/dist/stimulus.js":
/*!**********************************************************!*\
  !*** ./node_modules/@hotwired/stimulus/dist/stimulus.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Application: () => (/* binding */ Application),
/* harmony export */   AttributeObserver: () => (/* binding */ AttributeObserver),
/* harmony export */   Context: () => (/* binding */ Context),
/* harmony export */   Controller: () => (/* binding */ Controller),
/* harmony export */   ElementObserver: () => (/* binding */ ElementObserver),
/* harmony export */   IndexedMultimap: () => (/* binding */ IndexedMultimap),
/* harmony export */   Multimap: () => (/* binding */ Multimap),
/* harmony export */   SelectorObserver: () => (/* binding */ SelectorObserver),
/* harmony export */   StringMapObserver: () => (/* binding */ StringMapObserver),
/* harmony export */   TokenListObserver: () => (/* binding */ TokenListObserver),
/* harmony export */   ValueListObserver: () => (/* binding */ ValueListObserver),
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   defaultSchema: () => (/* binding */ defaultSchema),
/* harmony export */   del: () => (/* binding */ del),
/* harmony export */   fetch: () => (/* binding */ fetch),
/* harmony export */   prune: () => (/* binding */ prune)
/* harmony export */ });
/*
Stimulus 3.2.1
Copyright Â© 2023 Basecamp, LLC
 */
class EventListener {
    constructor(eventTarget, eventName, eventOptions) {
        this.eventTarget = eventTarget;
        this.eventName = eventName;
        this.eventOptions = eventOptions;
        this.unorderedBindings = new Set();
    }
    connect() {
        this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
        this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
        this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
        this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
        const extendedEvent = extendEvent(event);
        for (const binding of this.bindings) {
            if (extendedEvent.immediatePropagationStopped) {
                break;
            }
            else {
                binding.handleEvent(extendedEvent);
            }
        }
    }
    hasBindings() {
        return this.unorderedBindings.size > 0;
    }
    get bindings() {
        return Array.from(this.unorderedBindings).sort((left, right) => {
            const leftIndex = left.index, rightIndex = right.index;
            return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
        });
    }
}
function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
        return event;
    }
    else {
        const { stopImmediatePropagation } = event;
        return Object.assign(event, {
            immediatePropagationStopped: false,
            stopImmediatePropagation() {
                this.immediatePropagationStopped = true;
                stopImmediatePropagation.call(this);
            },
        });
    }
}

class Dispatcher {
    constructor(application) {
        this.application = application;
        this.eventListenerMaps = new Map();
        this.started = false;
    }
    start() {
        if (!this.started) {
            this.started = true;
            this.eventListeners.forEach((eventListener) => eventListener.connect());
        }
    }
    stop() {
        if (this.started) {
            this.started = false;
            this.eventListeners.forEach((eventListener) => eventListener.disconnect());
        }
    }
    get eventListeners() {
        return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
    }
    bindingConnected(binding) {
        this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding, clearEventListeners = false) {
        this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
        if (clearEventListeners)
            this.clearEventListenersForBinding(binding);
    }
    handleError(error, message, detail = {}) {
        this.application.handleError(error, `Error ${message}`, detail);
    }
    clearEventListenersForBinding(binding) {
        const eventListener = this.fetchEventListenerForBinding(binding);
        if (!eventListener.hasBindings()) {
            eventListener.disconnect();
            this.removeMappedEventListenerFor(binding);
        }
    }
    removeMappedEventListenerFor(binding) {
        const { eventTarget, eventName, eventOptions } = binding;
        const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
        const cacheKey = this.cacheKey(eventName, eventOptions);
        eventListenerMap.delete(cacheKey);
        if (eventListenerMap.size == 0)
            this.eventListenerMaps.delete(eventTarget);
    }
    fetchEventListenerForBinding(binding) {
        const { eventTarget, eventName, eventOptions } = binding;
        return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
        const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
        const cacheKey = this.cacheKey(eventName, eventOptions);
        let eventListener = eventListenerMap.get(cacheKey);
        if (!eventListener) {
            eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
            eventListenerMap.set(cacheKey, eventListener);
        }
        return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
        const eventListener = new EventListener(eventTarget, eventName, eventOptions);
        if (this.started) {
            eventListener.connect();
        }
        return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
        let eventListenerMap = this.eventListenerMaps.get(eventTarget);
        if (!eventListenerMap) {
            eventListenerMap = new Map();
            this.eventListenerMaps.set(eventTarget, eventListenerMap);
        }
        return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
        const parts = [eventName];
        Object.keys(eventOptions)
            .sort()
            .forEach((key) => {
            parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
        });
        return parts.join(":");
    }
}

const defaultActionDescriptorFilters = {
    stop({ event, value }) {
        if (value)
            event.stopPropagation();
        return true;
    },
    prevent({ event, value }) {
        if (value)
            event.preventDefault();
        return true;
    },
    self({ event, value, element }) {
        if (value) {
            return element === event.target;
        }
        else {
            return true;
        }
    },
};
const descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches = source.match(descriptorPattern) || [];
    let eventName = matches[2];
    let keyFilter = matches[3];
    if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
        eventName += `.${keyFilter}`;
        keyFilter = "";
    }
    return {
        eventTarget: parseEventTarget(matches[4]),
        eventName,
        eventOptions: matches[7] ? parseEventOptions(matches[7]) : {},
        identifier: matches[5],
        methodName: matches[6],
        keyFilter: matches[1] || keyFilter,
    };
}
function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
        return window;
    }
    else if (eventTargetName == "document") {
        return document;
    }
}
function parseEventOptions(eventOptions) {
    return eventOptions
        .split(":")
        .reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
}
function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
        return "window";
    }
    else if (eventTarget == document) {
        return "document";
    }
}

function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
}
function namespaceCamelize(value) {
    return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
}
function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
}
function dasherize(value) {
    return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
}
function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
}

function isSomething(object) {
    return object !== null && object !== undefined;
}
function hasProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
}

const allModifiers = ["meta", "ctrl", "alt", "shift"];
class Action {
    constructor(element, index, descriptor, schema) {
        this.element = element;
        this.index = index;
        this.eventTarget = descriptor.eventTarget || element;
        this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
        this.eventOptions = descriptor.eventOptions || {};
        this.identifier = descriptor.identifier || error("missing identifier");
        this.methodName = descriptor.methodName || error("missing method name");
        this.keyFilter = descriptor.keyFilter || "";
        this.schema = schema;
    }
    static forToken(token, schema) {
        return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
    }
    toString() {
        const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
        const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
        return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
    }
    shouldIgnoreKeyboardEvent(event) {
        if (!this.keyFilter) {
            return false;
        }
        const filters = this.keyFilter.split("+");
        if (this.keyFilterDissatisfied(event, filters)) {
            return true;
        }
        const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
        if (!standardFilter) {
            return false;
        }
        if (!hasProperty(this.keyMappings, standardFilter)) {
            error(`contains unknown key filter: ${this.keyFilter}`);
        }
        return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
    }
    shouldIgnoreMouseEvent(event) {
        if (!this.keyFilter) {
            return false;
        }
        const filters = [this.keyFilter];
        if (this.keyFilterDissatisfied(event, filters)) {
            return true;
        }
        return false;
    }
    get params() {
        const params = {};
        const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
        for (const { name, value } of Array.from(this.element.attributes)) {
            const match = name.match(pattern);
            const key = match && match[1];
            if (key) {
                params[camelize(key)] = typecast(value);
            }
        }
        return params;
    }
    get eventTargetName() {
        return stringifyEventTarget(this.eventTarget);
    }
    get keyMappings() {
        return this.schema.keyMappings;
    }
    keyFilterDissatisfied(event, filters) {
        const [meta, ctrl, alt, shift] = allModifiers.map((modifier) => filters.includes(modifier));
        return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;
    }
}
const defaultEventNames = {
    a: () => "click",
    button: () => "click",
    form: () => "submit",
    details: () => "toggle",
    input: (e) => (e.getAttribute("type") == "submit" ? "click" : "input"),
    select: () => "change",
    textarea: () => "input",
};
function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
        return defaultEventNames[tagName](element);
    }
}
function error(message) {
    throw new Error(message);
}
function typecast(value) {
    try {
        return JSON.parse(value);
    }
    catch (o_O) {
        return value;
    }
}

class Binding {
    constructor(context, action) {
        this.context = context;
        this.action = action;
    }
    get index() {
        return this.action.index;
    }
    get eventTarget() {
        return this.action.eventTarget;
    }
    get eventOptions() {
        return this.action.eventOptions;
    }
    get identifier() {
        return this.context.identifier;
    }
    handleEvent(event) {
        const actionEvent = this.prepareActionEvent(event);
        if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
            this.invokeWithEvent(actionEvent);
        }
    }
    get eventName() {
        return this.action.eventName;
    }
    get method() {
        const method = this.controller[this.methodName];
        if (typeof method == "function") {
            return method;
        }
        throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    applyEventModifiers(event) {
        const { element } = this.action;
        const { actionDescriptorFilters } = this.context.application;
        const { controller } = this.context;
        let passes = true;
        for (const [name, value] of Object.entries(this.eventOptions)) {
            if (name in actionDescriptorFilters) {
                const filter = actionDescriptorFilters[name];
                passes = passes && filter({ name, value, event, element, controller });
            }
            else {
                continue;
            }
        }
        return passes;
    }
    prepareActionEvent(event) {
        return Object.assign(event, { params: this.action.params });
    }
    invokeWithEvent(event) {
        const { target, currentTarget } = event;
        try {
            this.method.call(this.controller, event);
            this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
        }
        catch (error) {
            const { identifier, controller, element, index } = this;
            const detail = { identifier, controller, element, index, event };
            this.context.handleError(error, `invoking action "${this.action}"`, detail);
        }
    }
    willBeInvokedByEvent(event) {
        const eventTarget = event.target;
        if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
            return false;
        }
        if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
            return false;
        }
        if (this.element === eventTarget) {
            return true;
        }
        else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
            return this.scope.containsElement(eventTarget);
        }
        else {
            return this.scope.containsElement(this.action.element);
        }
    }
    get controller() {
        return this.context.controller;
    }
    get methodName() {
        return this.action.methodName;
    }
    get element() {
        return this.scope.element;
    }
    get scope() {
        return this.context.scope;
    }
}

class ElementObserver {
    constructor(element, delegate) {
        this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
        this.element = element;
        this.started = false;
        this.delegate = delegate;
        this.elements = new Set();
        this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
        if (!this.started) {
            this.started = true;
            this.mutationObserver.observe(this.element, this.mutationObserverInit);
            this.refresh();
        }
    }
    pause(callback) {
        if (this.started) {
            this.mutationObserver.disconnect();
            this.started = false;
        }
        callback();
        if (!this.started) {
            this.mutationObserver.observe(this.element, this.mutationObserverInit);
            this.started = true;
        }
    }
    stop() {
        if (this.started) {
            this.mutationObserver.takeRecords();
            this.mutationObserver.disconnect();
            this.started = false;
        }
    }
    refresh() {
        if (this.started) {
            const matches = new Set(this.matchElementsInTree());
            for (const element of Array.from(this.elements)) {
                if (!matches.has(element)) {
                    this.removeElement(element);
                }
            }
            for (const element of Array.from(matches)) {
                this.addElement(element);
            }
        }
    }
    processMutations(mutations) {
        if (this.started) {
            for (const mutation of mutations) {
                this.processMutation(mutation);
            }
        }
    }
    processMutation(mutation) {
        if (mutation.type == "attributes") {
            this.processAttributeChange(mutation.target, mutation.attributeName);
        }
        else if (mutation.type == "childList") {
            this.processRemovedNodes(mutation.removedNodes);
            this.processAddedNodes(mutation.addedNodes);
        }
    }
    processAttributeChange(element, attributeName) {
        if (this.elements.has(element)) {
            if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
                this.delegate.elementAttributeChanged(element, attributeName);
            }
            else {
                this.removeElement(element);
            }
        }
        else if (this.matchElement(element)) {
            this.addElement(element);
        }
    }
    processRemovedNodes(nodes) {
        for (const node of Array.from(nodes)) {
            const element = this.elementFromNode(node);
            if (element) {
                this.processTree(element, this.removeElement);
            }
        }
    }
    processAddedNodes(nodes) {
        for (const node of Array.from(nodes)) {
            const element = this.elementFromNode(node);
            if (element && this.elementIsActive(element)) {
                this.processTree(element, this.addElement);
            }
        }
    }
    matchElement(element) {
        return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
        return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
        for (const element of this.matchElementsInTree(tree)) {
            processor.call(this, element);
        }
    }
    elementFromNode(node) {
        if (node.nodeType == Node.ELEMENT_NODE) {
            return node;
        }
    }
    elementIsActive(element) {
        if (element.isConnected != this.element.isConnected) {
            return false;
        }
        else {
            return this.element.contains(element);
        }
    }
    addElement(element) {
        if (!this.elements.has(element)) {
            if (this.elementIsActive(element)) {
                this.elements.add(element);
                if (this.delegate.elementMatched) {
                    this.delegate.elementMatched(element);
                }
            }
        }
    }
    removeElement(element) {
        if (this.elements.has(element)) {
            this.elements.delete(element);
            if (this.delegate.elementUnmatched) {
                this.delegate.elementUnmatched(element);
            }
        }
    }
}

class AttributeObserver {
    constructor(element, attributeName, delegate) {
        this.attributeName = attributeName;
        this.delegate = delegate;
        this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
        return this.elementObserver.element;
    }
    get selector() {
        return `[${this.attributeName}]`;
    }
    start() {
        this.elementObserver.start();
    }
    pause(callback) {
        this.elementObserver.pause(callback);
    }
    stop() {
        this.elementObserver.stop();
    }
    refresh() {
        this.elementObserver.refresh();
    }
    get started() {
        return this.elementObserver.started;
    }
    matchElement(element) {
        return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
        const match = this.matchElement(tree) ? [tree] : [];
        const matches = Array.from(tree.querySelectorAll(this.selector));
        return match.concat(matches);
    }
    elementMatched(element) {
        if (this.delegate.elementMatchedAttribute) {
            this.delegate.elementMatchedAttribute(element, this.attributeName);
        }
    }
    elementUnmatched(element) {
        if (this.delegate.elementUnmatchedAttribute) {
            this.delegate.elementUnmatchedAttribute(element, this.attributeName);
        }
    }
    elementAttributeChanged(element, attributeName) {
        if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
            this.delegate.elementAttributeValueChanged(element, attributeName);
        }
    }
}

function add(map, key, value) {
    fetch(map, key).add(value);
}
function del(map, key, value) {
    fetch(map, key).delete(value);
    prune(map, key);
}
function fetch(map, key) {
    let values = map.get(key);
    if (!values) {
        values = new Set();
        map.set(key, values);
    }
    return values;
}
function prune(map, key) {
    const values = map.get(key);
    if (values != null && values.size == 0) {
        map.delete(key);
    }
}

class Multimap {
    constructor() {
        this.valuesByKey = new Map();
    }
    get keys() {
        return Array.from(this.valuesByKey.keys());
    }
    get values() {
        const sets = Array.from(this.valuesByKey.values());
        return sets.reduce((values, set) => values.concat(Array.from(set)), []);
    }
    get size() {
        const sets = Array.from(this.valuesByKey.values());
        return sets.reduce((size, set) => size + set.size, 0);
    }
    add(key, value) {
        add(this.valuesByKey, key, value);
    }
    delete(key, value) {
        del(this.valuesByKey, key, value);
    }
    has(key, value) {
        const values = this.valuesByKey.get(key);
        return values != null && values.has(value);
    }
    hasKey(key) {
        return this.valuesByKey.has(key);
    }
    hasValue(value) {
        const sets = Array.from(this.valuesByKey.values());
        return sets.some((set) => set.has(value));
    }
    getValuesForKey(key) {
        const values = this.valuesByKey.get(key);
        return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
        return Array.from(this.valuesByKey)
            .filter(([_key, values]) => values.has(value))
            .map(([key, _values]) => key);
    }
}

class IndexedMultimap extends Multimap {
    constructor() {
        super();
        this.keysByValue = new Map();
    }
    get values() {
        return Array.from(this.keysByValue.keys());
    }
    add(key, value) {
        super.add(key, value);
        add(this.keysByValue, value, key);
    }
    delete(key, value) {
        super.delete(key, value);
        del(this.keysByValue, value, key);
    }
    hasValue(value) {
        return this.keysByValue.has(value);
    }
    getKeysForValue(value) {
        const set = this.keysByValue.get(value);
        return set ? Array.from(set) : [];
    }
}

class SelectorObserver {
    constructor(element, selector, delegate, details) {
        this._selector = selector;
        this.details = details;
        this.elementObserver = new ElementObserver(element, this);
        this.delegate = delegate;
        this.matchesByElement = new Multimap();
    }
    get started() {
        return this.elementObserver.started;
    }
    get selector() {
        return this._selector;
    }
    set selector(selector) {
        this._selector = selector;
        this.refresh();
    }
    start() {
        this.elementObserver.start();
    }
    pause(callback) {
        this.elementObserver.pause(callback);
    }
    stop() {
        this.elementObserver.stop();
    }
    refresh() {
        this.elementObserver.refresh();
    }
    get element() {
        return this.elementObserver.element;
    }
    matchElement(element) {
        const { selector } = this;
        if (selector) {
            const matches = element.matches(selector);
            if (this.delegate.selectorMatchElement) {
                return matches && this.delegate.selectorMatchElement(element, this.details);
            }
            return matches;
        }
        else {
            return false;
        }
    }
    matchElementsInTree(tree) {
        const { selector } = this;
        if (selector) {
            const match = this.matchElement(tree) ? [tree] : [];
            const matches = Array.from(tree.querySelectorAll(selector)).filter((match) => this.matchElement(match));
            return match.concat(matches);
        }
        else {
            return [];
        }
    }
    elementMatched(element) {
        const { selector } = this;
        if (selector) {
            this.selectorMatched(element, selector);
        }
    }
    elementUnmatched(element) {
        const selectors = this.matchesByElement.getKeysForValue(element);
        for (const selector of selectors) {
            this.selectorUnmatched(element, selector);
        }
    }
    elementAttributeChanged(element, _attributeName) {
        const { selector } = this;
        if (selector) {
            const matches = this.matchElement(element);
            const matchedBefore = this.matchesByElement.has(selector, element);
            if (matches && !matchedBefore) {
                this.selectorMatched(element, selector);
            }
            else if (!matches && matchedBefore) {
                this.selectorUnmatched(element, selector);
            }
        }
    }
    selectorMatched(element, selector) {
        this.delegate.selectorMatched(element, selector, this.details);
        this.matchesByElement.add(selector, element);
    }
    selectorUnmatched(element, selector) {
        this.delegate.selectorUnmatched(element, selector, this.details);
        this.matchesByElement.delete(selector, element);
    }
}

class StringMapObserver {
    constructor(element, delegate) {
        this.element = element;
        this.delegate = delegate;
        this.started = false;
        this.stringMap = new Map();
        this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
        if (!this.started) {
            this.started = true;
            this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
            this.refresh();
        }
    }
    stop() {
        if (this.started) {
            this.mutationObserver.takeRecords();
            this.mutationObserver.disconnect();
            this.started = false;
        }
    }
    refresh() {
        if (this.started) {
            for (const attributeName of this.knownAttributeNames) {
                this.refreshAttribute(attributeName, null);
            }
        }
    }
    processMutations(mutations) {
        if (this.started) {
            for (const mutation of mutations) {
                this.processMutation(mutation);
            }
        }
    }
    processMutation(mutation) {
        const attributeName = mutation.attributeName;
        if (attributeName) {
            this.refreshAttribute(attributeName, mutation.oldValue);
        }
    }
    refreshAttribute(attributeName, oldValue) {
        const key = this.delegate.getStringMapKeyForAttribute(attributeName);
        if (key != null) {
            if (!this.stringMap.has(attributeName)) {
                this.stringMapKeyAdded(key, attributeName);
            }
            const value = this.element.getAttribute(attributeName);
            if (this.stringMap.get(attributeName) != value) {
                this.stringMapValueChanged(value, key, oldValue);
            }
            if (value == null) {
                const oldValue = this.stringMap.get(attributeName);
                this.stringMap.delete(attributeName);
                if (oldValue)
                    this.stringMapKeyRemoved(key, attributeName, oldValue);
            }
            else {
                this.stringMap.set(attributeName, value);
            }
        }
    }
    stringMapKeyAdded(key, attributeName) {
        if (this.delegate.stringMapKeyAdded) {
            this.delegate.stringMapKeyAdded(key, attributeName);
        }
    }
    stringMapValueChanged(value, key, oldValue) {
        if (this.delegate.stringMapValueChanged) {
            this.delegate.stringMapValueChanged(value, key, oldValue);
        }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
        if (this.delegate.stringMapKeyRemoved) {
            this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
        }
    }
    get knownAttributeNames() {
        return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
        return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
        return Array.from(this.stringMap.keys());
    }
}

class TokenListObserver {
    constructor(element, attributeName, delegate) {
        this.attributeObserver = new AttributeObserver(element, attributeName, this);
        this.delegate = delegate;
        this.tokensByElement = new Multimap();
    }
    get started() {
        return this.attributeObserver.started;
    }
    start() {
        this.attributeObserver.start();
    }
    pause(callback) {
        this.attributeObserver.pause(callback);
    }
    stop() {
        this.attributeObserver.stop();
    }
    refresh() {
        this.attributeObserver.refresh();
    }
    get element() {
        return this.attributeObserver.element;
    }
    get attributeName() {
        return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
        this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
        const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
        this.tokensUnmatched(unmatchedTokens);
        this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
        this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
        tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
        tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
        this.delegate.tokenMatched(token);
        this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
        this.delegate.tokenUnmatched(token);
        this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
        const previousTokens = this.tokensByElement.getValuesForKey(element);
        const currentTokens = this.readTokensForElement(element);
        const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
        if (firstDifferingIndex == -1) {
            return [[], []];
        }
        else {
            return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
        }
    }
    readTokensForElement(element) {
        const attributeName = this.attributeName;
        const tokenString = element.getAttribute(attributeName) || "";
        return parseTokenString(tokenString, element, attributeName);
    }
}
function parseTokenString(tokenString, element, attributeName) {
    return tokenString
        .trim()
        .split(/\s+/)
        .filter((content) => content.length)
        .map((content, index) => ({ element, attributeName, content, index }));
}
function zip(left, right) {
    const length = Math.max(left.length, right.length);
    return Array.from({ length }, (_, index) => [left[index], right[index]]);
}
function tokensAreEqual(left, right) {
    return left && right && left.index == right.index && left.content == right.content;
}

class ValueListObserver {
    constructor(element, attributeName, delegate) {
        this.tokenListObserver = new TokenListObserver(element, attributeName, this);
        this.delegate = delegate;
        this.parseResultsByToken = new WeakMap();
        this.valuesByTokenByElement = new WeakMap();
    }
    get started() {
        return this.tokenListObserver.started;
    }
    start() {
        this.tokenListObserver.start();
    }
    stop() {
        this.tokenListObserver.stop();
    }
    refresh() {
        this.tokenListObserver.refresh();
    }
    get element() {
        return this.tokenListObserver.element;
    }
    get attributeName() {
        return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
        const { element } = token;
        const { value } = this.fetchParseResultForToken(token);
        if (value) {
            this.fetchValuesByTokenForElement(element).set(token, value);
            this.delegate.elementMatchedValue(element, value);
        }
    }
    tokenUnmatched(token) {
        const { element } = token;
        const { value } = this.fetchParseResultForToken(token);
        if (value) {
            this.fetchValuesByTokenForElement(element).delete(token);
            this.delegate.elementUnmatchedValue(element, value);
        }
    }
    fetchParseResultForToken(token) {
        let parseResult = this.parseResultsByToken.get(token);
        if (!parseResult) {
            parseResult = this.parseToken(token);
            this.parseResultsByToken.set(token, parseResult);
        }
        return parseResult;
    }
    fetchValuesByTokenForElement(element) {
        let valuesByToken = this.valuesByTokenByElement.get(element);
        if (!valuesByToken) {
            valuesByToken = new Map();
            this.valuesByTokenByElement.set(element, valuesByToken);
        }
        return valuesByToken;
    }
    parseToken(token) {
        try {
            const value = this.delegate.parseValueForToken(token);
            return { value };
        }
        catch (error) {
            return { error };
        }
    }
}

class BindingObserver {
    constructor(context, delegate) {
        this.context = context;
        this.delegate = delegate;
        this.bindingsByAction = new Map();
    }
    start() {
        if (!this.valueListObserver) {
            this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
            this.valueListObserver.start();
        }
    }
    stop() {
        if (this.valueListObserver) {
            this.valueListObserver.stop();
            delete this.valueListObserver;
            this.disconnectAllActions();
        }
    }
    get element() {
        return this.context.element;
    }
    get identifier() {
        return this.context.identifier;
    }
    get actionAttribute() {
        return this.schema.actionAttribute;
    }
    get schema() {
        return this.context.schema;
    }
    get bindings() {
        return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
        const binding = new Binding(this.context, action);
        this.bindingsByAction.set(action, binding);
        this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
        const binding = this.bindingsByAction.get(action);
        if (binding) {
            this.bindingsByAction.delete(action);
            this.delegate.bindingDisconnected(binding);
        }
    }
    disconnectAllActions() {
        this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
        this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
        const action = Action.forToken(token, this.schema);
        if (action.identifier == this.identifier) {
            return action;
        }
    }
    elementMatchedValue(element, action) {
        this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
        this.disconnectAction(action);
    }
}

class ValueObserver {
    constructor(context, receiver) {
        this.context = context;
        this.receiver = receiver;
        this.stringMapObserver = new StringMapObserver(this.element, this);
        this.valueDescriptorMap = this.controller.valueDescriptorMap;
    }
    start() {
        this.stringMapObserver.start();
        this.invokeChangedCallbacksForDefaultValues();
    }
    stop() {
        this.stringMapObserver.stop();
    }
    get element() {
        return this.context.element;
    }
    get controller() {
        return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
        if (attributeName in this.valueDescriptorMap) {
            return this.valueDescriptorMap[attributeName].name;
        }
    }
    stringMapKeyAdded(key, attributeName) {
        const descriptor = this.valueDescriptorMap[attributeName];
        if (!this.hasValue(key)) {
            this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
        }
    }
    stringMapValueChanged(value, name, oldValue) {
        const descriptor = this.valueDescriptorNameMap[name];
        if (value === null)
            return;
        if (oldValue === null) {
            oldValue = descriptor.writer(descriptor.defaultValue);
        }
        this.invokeChangedCallback(name, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
        const descriptor = this.valueDescriptorNameMap[key];
        if (this.hasValue(key)) {
            this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
        }
        else {
            this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
        }
    }
    invokeChangedCallbacksForDefaultValues() {
        for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
            if (defaultValue != undefined && !this.controller.data.has(key)) {
                this.invokeChangedCallback(name, writer(defaultValue), undefined);
            }
        }
    }
    invokeChangedCallback(name, rawValue, rawOldValue) {
        const changedMethodName = `${name}Changed`;
        const changedMethod = this.receiver[changedMethodName];
        if (typeof changedMethod == "function") {
            const descriptor = this.valueDescriptorNameMap[name];
            try {
                const value = descriptor.reader(rawValue);
                let oldValue = rawOldValue;
                if (rawOldValue) {
                    oldValue = descriptor.reader(rawOldValue);
                }
                changedMethod.call(this.receiver, value, oldValue);
            }
            catch (error) {
                if (error instanceof TypeError) {
                    error.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error.message}`;
                }
                throw error;
            }
        }
    }
    get valueDescriptors() {
        const { valueDescriptorMap } = this;
        return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
        const descriptors = {};
        Object.keys(this.valueDescriptorMap).forEach((key) => {
            const descriptor = this.valueDescriptorMap[key];
            descriptors[descriptor.name] = descriptor;
        });
        return descriptors;
    }
    hasValue(attributeName) {
        const descriptor = this.valueDescriptorNameMap[attributeName];
        const hasMethodName = `has${capitalize(descriptor.name)}`;
        return this.receiver[hasMethodName];
    }
}

class TargetObserver {
    constructor(context, delegate) {
        this.context = context;
        this.delegate = delegate;
        this.targetsByName = new Multimap();
    }
    start() {
        if (!this.tokenListObserver) {
            this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
            this.tokenListObserver.start();
        }
    }
    stop() {
        if (this.tokenListObserver) {
            this.disconnectAllTargets();
            this.tokenListObserver.stop();
            delete this.tokenListObserver;
        }
    }
    tokenMatched({ element, content: name }) {
        if (this.scope.containsElement(element)) {
            this.connectTarget(element, name);
        }
    }
    tokenUnmatched({ element, content: name }) {
        this.disconnectTarget(element, name);
    }
    connectTarget(element, name) {
        var _a;
        if (!this.targetsByName.has(name, element)) {
            this.targetsByName.add(name, element);
            (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
        }
    }
    disconnectTarget(element, name) {
        var _a;
        if (this.targetsByName.has(name, element)) {
            this.targetsByName.delete(name, element);
            (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
        }
    }
    disconnectAllTargets() {
        for (const name of this.targetsByName.keys) {
            for (const element of this.targetsByName.getValuesForKey(name)) {
                this.disconnectTarget(element, name);
            }
        }
    }
    get attributeName() {
        return `data-${this.context.identifier}-target`;
    }
    get element() {
        return this.context.element;
    }
    get scope() {
        return this.context.scope;
    }
}

function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor) => {
        getOwnStaticArrayValues(constructor, propertyName).forEach((name) => values.add(name));
        return values;
    }, new Set()));
}
function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor) => {
        pairs.push(...getOwnStaticObjectPairs(constructor, propertyName));
        return pairs;
    }, []);
}
function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
        ancestors.push(constructor);
        constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
}
function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
}
function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
}

class OutletObserver {
    constructor(context, delegate) {
        this.started = false;
        this.context = context;
        this.delegate = delegate;
        this.outletsByName = new Multimap();
        this.outletElementsByName = new Multimap();
        this.selectorObserverMap = new Map();
        this.attributeObserverMap = new Map();
    }
    start() {
        if (!this.started) {
            this.outletDefinitions.forEach((outletName) => {
                this.setupSelectorObserverForOutlet(outletName);
                this.setupAttributeObserverForOutlet(outletName);
            });
            this.started = true;
            this.dependentContexts.forEach((context) => context.refresh());
        }
    }
    refresh() {
        this.selectorObserverMap.forEach((observer) => observer.refresh());
        this.attributeObserverMap.forEach((observer) => observer.refresh());
    }
    stop() {
        if (this.started) {
            this.started = false;
            this.disconnectAllOutlets();
            this.stopSelectorObservers();
            this.stopAttributeObservers();
        }
    }
    stopSelectorObservers() {
        if (this.selectorObserverMap.size > 0) {
            this.selectorObserverMap.forEach((observer) => observer.stop());
            this.selectorObserverMap.clear();
        }
    }
    stopAttributeObservers() {
        if (this.attributeObserverMap.size > 0) {
            this.attributeObserverMap.forEach((observer) => observer.stop());
            this.attributeObserverMap.clear();
        }
    }
    selectorMatched(element, _selector, { outletName }) {
        const outlet = this.getOutlet(element, outletName);
        if (outlet) {
            this.connectOutlet(outlet, element, outletName);
        }
    }
    selectorUnmatched(element, _selector, { outletName }) {
        const outlet = this.getOutletFromMap(element, outletName);
        if (outlet) {
            this.disconnectOutlet(outlet, element, outletName);
        }
    }
    selectorMatchElement(element, { outletName }) {
        const selector = this.selector(outletName);
        const hasOutlet = this.hasOutlet(element, outletName);
        const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
        if (selector) {
            return hasOutlet && hasOutletController && element.matches(selector);
        }
        else {
            return false;
        }
    }
    elementMatchedAttribute(_element, attributeName) {
        const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
        if (outletName) {
            this.updateSelectorObserverForOutlet(outletName);
        }
    }
    elementAttributeValueChanged(_element, attributeName) {
        const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
        if (outletName) {
            this.updateSelectorObserverForOutlet(outletName);
        }
    }
    elementUnmatchedAttribute(_element, attributeName) {
        const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
        if (outletName) {
            this.updateSelectorObserverForOutlet(outletName);
        }
    }
    connectOutlet(outlet, element, outletName) {
        var _a;
        if (!this.outletElementsByName.has(outletName, element)) {
            this.outletsByName.add(outletName, outlet);
            this.outletElementsByName.add(outletName, element);
            (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
        }
    }
    disconnectOutlet(outlet, element, outletName) {
        var _a;
        if (this.outletElementsByName.has(outletName, element)) {
            this.outletsByName.delete(outletName, outlet);
            this.outletElementsByName.delete(outletName, element);
            (_a = this.selectorObserverMap
                .get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
        }
    }
    disconnectAllOutlets() {
        for (const outletName of this.outletElementsByName.keys) {
            for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
                for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
                    this.disconnectOutlet(outlet, element, outletName);
                }
            }
        }
    }
    updateSelectorObserverForOutlet(outletName) {
        const observer = this.selectorObserverMap.get(outletName);
        if (observer) {
            observer.selector = this.selector(outletName);
        }
    }
    setupSelectorObserverForOutlet(outletName) {
        const selector = this.selector(outletName);
        const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
        this.selectorObserverMap.set(outletName, selectorObserver);
        selectorObserver.start();
    }
    setupAttributeObserverForOutlet(outletName) {
        const attributeName = this.attributeNameForOutletName(outletName);
        const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
        this.attributeObserverMap.set(outletName, attributeObserver);
        attributeObserver.start();
    }
    selector(outletName) {
        return this.scope.outlets.getSelectorForOutletName(outletName);
    }
    attributeNameForOutletName(outletName) {
        return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
    }
    getOutletNameFromOutletAttributeName(attributeName) {
        return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
    }
    get outletDependencies() {
        const dependencies = new Multimap();
        this.router.modules.forEach((module) => {
            const constructor = module.definition.controllerConstructor;
            const outlets = readInheritableStaticArrayValues(constructor, "outlets");
            outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
        });
        return dependencies;
    }
    get outletDefinitions() {
        return this.outletDependencies.getKeysForValue(this.identifier);
    }
    get dependentControllerIdentifiers() {
        return this.outletDependencies.getValuesForKey(this.identifier);
    }
    get dependentContexts() {
        const identifiers = this.dependentControllerIdentifiers;
        return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
    }
    hasOutlet(element, outletName) {
        return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
    }
    getOutlet(element, outletName) {
        return this.application.getControllerForElementAndIdentifier(element, outletName);
    }
    getOutletFromMap(element, outletName) {
        return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
    }
    get scope() {
        return this.context.scope;
    }
    get schema() {
        return this.context.schema;
    }
    get identifier() {
        return this.context.identifier;
    }
    get application() {
        return this.context.application;
    }
    get router() {
        return this.application.router;
    }
}

class Context {
    constructor(module, scope) {
        this.logDebugActivity = (functionName, detail = {}) => {
            const { identifier, controller, element } = this;
            detail = Object.assign({ identifier, controller, element }, detail);
            this.application.logDebugActivity(this.identifier, functionName, detail);
        };
        this.module = module;
        this.scope = scope;
        this.controller = new module.controllerConstructor(this);
        this.bindingObserver = new BindingObserver(this, this.dispatcher);
        this.valueObserver = new ValueObserver(this, this.controller);
        this.targetObserver = new TargetObserver(this, this);
        this.outletObserver = new OutletObserver(this, this);
        try {
            this.controller.initialize();
            this.logDebugActivity("initialize");
        }
        catch (error) {
            this.handleError(error, "initializing controller");
        }
    }
    connect() {
        this.bindingObserver.start();
        this.valueObserver.start();
        this.targetObserver.start();
        this.outletObserver.start();
        try {
            this.controller.connect();
            this.logDebugActivity("connect");
        }
        catch (error) {
            this.handleError(error, "connecting controller");
        }
    }
    refresh() {
        this.outletObserver.refresh();
    }
    disconnect() {
        try {
            this.controller.disconnect();
            this.logDebugActivity("disconnect");
        }
        catch (error) {
            this.handleError(error, "disconnecting controller");
        }
        this.outletObserver.stop();
        this.targetObserver.stop();
        this.valueObserver.stop();
        this.bindingObserver.stop();
    }
    get application() {
        return this.module.application;
    }
    get identifier() {
        return this.module.identifier;
    }
    get schema() {
        return this.application.schema;
    }
    get dispatcher() {
        return this.application.dispatcher;
    }
    get element() {
        return this.scope.element;
    }
    get parentElement() {
        return this.element.parentElement;
    }
    handleError(error, message, detail = {}) {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.handleError(error, `Error ${message}`, detail);
    }
    targetConnected(element, name) {
        this.invokeControllerMethod(`${name}TargetConnected`, element);
    }
    targetDisconnected(element, name) {
        this.invokeControllerMethod(`${name}TargetDisconnected`, element);
    }
    outletConnected(outlet, element, name) {
        this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
    }
    outletDisconnected(outlet, element, name) {
        this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
    }
    invokeControllerMethod(methodName, ...args) {
        const controller = this.controller;
        if (typeof controller[methodName] == "function") {
            controller[methodName](...args);
        }
    }
}

function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
}
function shadow(constructor, properties) {
    const shadowConstructor = extend(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
}
function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
        const properties = blessing(constructor);
        for (const key in properties) {
            const descriptor = blessedProperties[key] || {};
            blessedProperties[key] = Object.assign(descriptor, properties[key]);
        }
        return blessedProperties;
    }, {});
}
function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
        const descriptor = getShadowedDescriptor(prototype, properties, key);
        if (descriptor) {
            Object.assign(shadowProperties, { [key]: descriptor });
        }
        return shadowProperties;
    }, {});
}
function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
        const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
        if (shadowingDescriptor) {
            descriptor.get = shadowingDescriptor.get || descriptor.get;
            descriptor.set = shadowingDescriptor.set || descriptor.set;
        }
        return descriptor;
    }
}
const getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
        return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
    }
    else {
        return Object.getOwnPropertyNames;
    }
})();
const extend = (() => {
    function extendWithReflect(constructor) {
        function extended() {
            return Reflect.construct(constructor, arguments, new.target);
        }
        extended.prototype = Object.create(constructor.prototype, {
            constructor: { value: extended },
        });
        Reflect.setPrototypeOf(extended, constructor);
        return extended;
    }
    function testReflectExtension() {
        const a = function () {
            this.a.call(this);
        };
        const b = extendWithReflect(a);
        b.prototype.a = function () { };
        return new b();
    }
    try {
        testReflectExtension();
        return extendWithReflect;
    }
    catch (error) {
        return (constructor) => class extended extends constructor {
        };
    }
})();

function blessDefinition(definition) {
    return {
        identifier: definition.identifier,
        controllerConstructor: bless(definition.controllerConstructor),
    };
}

class Module {
    constructor(application, definition) {
        this.application = application;
        this.definition = blessDefinition(definition);
        this.contextsByScope = new WeakMap();
        this.connectedContexts = new Set();
    }
    get identifier() {
        return this.definition.identifier;
    }
    get controllerConstructor() {
        return this.definition.controllerConstructor;
    }
    get contexts() {
        return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
        const context = this.fetchContextForScope(scope);
        this.connectedContexts.add(context);
        context.connect();
    }
    disconnectContextForScope(scope) {
        const context = this.contextsByScope.get(scope);
        if (context) {
            this.connectedContexts.delete(context);
            context.disconnect();
        }
    }
    fetchContextForScope(scope) {
        let context = this.contextsByScope.get(scope);
        if (!context) {
            context = new Context(this, scope);
            this.contextsByScope.set(scope, context);
        }
        return context;
    }
}

class ClassMap {
    constructor(scope) {
        this.scope = scope;
    }
    has(name) {
        return this.data.has(this.getDataKey(name));
    }
    get(name) {
        return this.getAll(name)[0];
    }
    getAll(name) {
        const tokenString = this.data.get(this.getDataKey(name)) || "";
        return tokenize(tokenString);
    }
    getAttributeName(name) {
        return this.data.getAttributeNameForKey(this.getDataKey(name));
    }
    getDataKey(name) {
        return `${name}-class`;
    }
    get data() {
        return this.scope.data;
    }
}

class DataMap {
    constructor(scope) {
        this.scope = scope;
    }
    get element() {
        return this.scope.element;
    }
    get identifier() {
        return this.scope.identifier;
    }
    get(key) {
        const name = this.getAttributeNameForKey(key);
        return this.element.getAttribute(name);
    }
    set(key, value) {
        const name = this.getAttributeNameForKey(key);
        this.element.setAttribute(name, value);
        return this.get(key);
    }
    has(key) {
        const name = this.getAttributeNameForKey(key);
        return this.element.hasAttribute(name);
    }
    delete(key) {
        if (this.has(key)) {
            const name = this.getAttributeNameForKey(key);
            this.element.removeAttribute(name);
            return true;
        }
        else {
            return false;
        }
    }
    getAttributeNameForKey(key) {
        return `data-${this.identifier}-${dasherize(key)}`;
    }
}

class Guide {
    constructor(logger) {
        this.warnedKeysByObject = new WeakMap();
        this.logger = logger;
    }
    warn(object, key, message) {
        let warnedKeys = this.warnedKeysByObject.get(object);
        if (!warnedKeys) {
            warnedKeys = new Set();
            this.warnedKeysByObject.set(object, warnedKeys);
        }
        if (!warnedKeys.has(key)) {
            warnedKeys.add(key);
            this.logger.warn(message, object);
        }
    }
}

function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
}

class TargetSet {
    constructor(scope) {
        this.scope = scope;
    }
    get element() {
        return this.scope.element;
    }
    get identifier() {
        return this.scope.identifier;
    }
    get schema() {
        return this.scope.schema;
    }
    has(targetName) {
        return this.find(targetName) != null;
    }
    find(...targetNames) {
        return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), undefined);
    }
    findAll(...targetNames) {
        return targetNames.reduce((targets, targetName) => [
            ...targets,
            ...this.findAllTargets(targetName),
            ...this.findAllLegacyTargets(targetName),
        ], []);
    }
    findTarget(targetName) {
        const selector = this.getSelectorForTargetName(targetName);
        return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
        const selector = this.getSelectorForTargetName(targetName);
        return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
        const attributeName = this.schema.targetAttributeForScope(this.identifier);
        return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
        const selector = this.getLegacySelectorForTargetName(targetName);
        return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
        const selector = this.getLegacySelectorForTargetName(targetName);
        return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
        const targetDescriptor = `${this.identifier}.${targetName}`;
        return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
        if (element) {
            const { identifier } = this;
            const attributeName = this.schema.targetAttribute;
            const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
            this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". ` +
                `The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
        }
        return element;
    }
    get guide() {
        return this.scope.guide;
    }
}

class OutletSet {
    constructor(scope, controllerElement) {
        this.scope = scope;
        this.controllerElement = controllerElement;
    }
    get element() {
        return this.scope.element;
    }
    get identifier() {
        return this.scope.identifier;
    }
    get schema() {
        return this.scope.schema;
    }
    has(outletName) {
        return this.find(outletName) != null;
    }
    find(...outletNames) {
        return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), undefined);
    }
    findAll(...outletNames) {
        return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
    }
    getSelectorForOutletName(outletName) {
        const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
        return this.controllerElement.getAttribute(attributeName);
    }
    findOutlet(outletName) {
        const selector = this.getSelectorForOutletName(outletName);
        if (selector)
            return this.findElement(selector, outletName);
    }
    findAllOutlets(outletName) {
        const selector = this.getSelectorForOutletName(outletName);
        return selector ? this.findAllElements(selector, outletName) : [];
    }
    findElement(selector, outletName) {
        const elements = this.scope.queryElements(selector);
        return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
    }
    findAllElements(selector, outletName) {
        const elements = this.scope.queryElements(selector);
        return elements.filter((element) => this.matchesElement(element, selector, outletName));
    }
    matchesElement(element, selector, outletName) {
        const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
        return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
    }
}

class Scope {
    constructor(schema, element, identifier, logger) {
        this.targets = new TargetSet(this);
        this.classes = new ClassMap(this);
        this.data = new DataMap(this);
        this.containsElement = (element) => {
            return element.closest(this.controllerSelector) === this.element;
        };
        this.schema = schema;
        this.element = element;
        this.identifier = identifier;
        this.guide = new Guide(logger);
        this.outlets = new OutletSet(this.documentScope, element);
    }
    findElement(selector) {
        return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
        return [
            ...(this.element.matches(selector) ? [this.element] : []),
            ...this.queryElements(selector).filter(this.containsElement),
        ];
    }
    queryElements(selector) {
        return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
        return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
    get isDocumentScope() {
        return this.element === document.documentElement;
    }
    get documentScope() {
        return this.isDocumentScope
            ? this
            : new Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
    }
}

class ScopeObserver {
    constructor(element, schema, delegate) {
        this.element = element;
        this.schema = schema;
        this.delegate = delegate;
        this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
        this.scopesByIdentifierByElement = new WeakMap();
        this.scopeReferenceCounts = new WeakMap();
    }
    start() {
        this.valueListObserver.start();
    }
    stop() {
        this.valueListObserver.stop();
    }
    get controllerAttribute() {
        return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
        const { element, content: identifier } = token;
        return this.parseValueForElementAndIdentifier(element, identifier);
    }
    parseValueForElementAndIdentifier(element, identifier) {
        const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
        let scope = scopesByIdentifier.get(identifier);
        if (!scope) {
            scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
            scopesByIdentifier.set(identifier, scope);
        }
        return scope;
    }
    elementMatchedValue(element, value) {
        const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
        this.scopeReferenceCounts.set(value, referenceCount);
        if (referenceCount == 1) {
            this.delegate.scopeConnected(value);
        }
    }
    elementUnmatchedValue(element, value) {
        const referenceCount = this.scopeReferenceCounts.get(value);
        if (referenceCount) {
            this.scopeReferenceCounts.set(value, referenceCount - 1);
            if (referenceCount == 1) {
                this.delegate.scopeDisconnected(value);
            }
        }
    }
    fetchScopesByIdentifierForElement(element) {
        let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
        if (!scopesByIdentifier) {
            scopesByIdentifier = new Map();
            this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
        }
        return scopesByIdentifier;
    }
}

class Router {
    constructor(application) {
        this.application = application;
        this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
        this.scopesByIdentifier = new Multimap();
        this.modulesByIdentifier = new Map();
    }
    get element() {
        return this.application.element;
    }
    get schema() {
        return this.application.schema;
    }
    get logger() {
        return this.application.logger;
    }
    get controllerAttribute() {
        return this.schema.controllerAttribute;
    }
    get modules() {
        return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
        return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
        this.scopeObserver.start();
    }
    stop() {
        this.scopeObserver.stop();
    }
    loadDefinition(definition) {
        this.unloadIdentifier(definition.identifier);
        const module = new Module(this.application, definition);
        this.connectModule(module);
        const afterLoad = definition.controllerConstructor.afterLoad;
        if (afterLoad) {
            afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
        }
    }
    unloadIdentifier(identifier) {
        const module = this.modulesByIdentifier.get(identifier);
        if (module) {
            this.disconnectModule(module);
        }
    }
    getContextForElementAndIdentifier(element, identifier) {
        const module = this.modulesByIdentifier.get(identifier);
        if (module) {
            return module.contexts.find((context) => context.element == element);
        }
    }
    proposeToConnectScopeForElementAndIdentifier(element, identifier) {
        const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
        if (scope) {
            this.scopeObserver.elementMatchedValue(scope.element, scope);
        }
        else {
            console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
        }
    }
    handleError(error, message, detail) {
        this.application.handleError(error, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
        return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
        this.scopesByIdentifier.add(scope.identifier, scope);
        const module = this.modulesByIdentifier.get(scope.identifier);
        if (module) {
            module.connectContextForScope(scope);
        }
    }
    scopeDisconnected(scope) {
        this.scopesByIdentifier.delete(scope.identifier, scope);
        const module = this.modulesByIdentifier.get(scope.identifier);
        if (module) {
            module.disconnectContextForScope(scope);
        }
    }
    connectModule(module) {
        this.modulesByIdentifier.set(module.identifier, module);
        const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
        scopes.forEach((scope) => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
        this.modulesByIdentifier.delete(module.identifier);
        const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
        scopes.forEach((scope) => module.disconnectContextForScope(scope));
    }
}

const defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`,
    outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
    keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c) => [c, c]))), objectFromEntries("0123456789".split("").map((n) => [n, n]))),
};
function objectFromEntries(array) {
    return array.reduce((memo, [k, v]) => (Object.assign(Object.assign({}, memo), { [k]: v })), {});
}

class Application {
    constructor(element = document.documentElement, schema = defaultSchema) {
        this.logger = console;
        this.debug = false;
        this.logDebugActivity = (identifier, functionName, detail = {}) => {
            if (this.debug) {
                this.logFormattedMessage(identifier, functionName, detail);
            }
        };
        this.element = element;
        this.schema = schema;
        this.dispatcher = new Dispatcher(this);
        this.router = new Router(this);
        this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
    }
    static start(element, schema) {
        const application = new this(element, schema);
        application.start();
        return application;
    }
    async start() {
        await domReady();
        this.logDebugActivity("application", "starting");
        this.dispatcher.start();
        this.router.start();
        this.logDebugActivity("application", "start");
    }
    stop() {
        this.logDebugActivity("application", "stopping");
        this.dispatcher.stop();
        this.router.stop();
        this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
        this.load({ identifier, controllerConstructor });
    }
    registerActionOption(name, filter) {
        this.actionDescriptorFilters[name] = filter;
    }
    load(head, ...rest) {
        const definitions = Array.isArray(head) ? head : [head, ...rest];
        definitions.forEach((definition) => {
            if (definition.controllerConstructor.shouldLoad) {
                this.router.loadDefinition(definition);
            }
        });
    }
    unload(head, ...rest) {
        const identifiers = Array.isArray(head) ? head : [head, ...rest];
        identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
        return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
        const context = this.router.getContextForElementAndIdentifier(element, identifier);
        return context ? context.controller : null;
    }
    handleError(error, message, detail) {
        var _a;
        this.logger.error(`%s\n\n%o\n\n%o`, message, error, detail);
        (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
        detail = Object.assign({ application: this }, detail);
        this.logger.groupCollapsed(`${identifier} #${functionName}`);
        this.logger.log("details:", Object.assign({}, detail));
        this.logger.groupEnd();
    }
}
function domReady() {
    return new Promise((resolve) => {
        if (document.readyState == "loading") {
            document.addEventListener("DOMContentLoaded", () => resolve());
        }
        else {
            resolve();
        }
    });
}

function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
        return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
}
function propertiesForClassDefinition(key) {
    return {
        [`${key}Class`]: {
            get() {
                const { classes } = this;
                if (classes.has(key)) {
                    return classes.get(key);
                }
                else {
                    const attribute = classes.getAttributeName(key);
                    throw new Error(`Missing attribute "${attribute}"`);
                }
            },
        },
        [`${key}Classes`]: {
            get() {
                return this.classes.getAll(key);
            },
        },
        [`has${capitalize(key)}Class`]: {
            get() {
                return this.classes.has(key);
            },
        },
    };
}

function OutletPropertiesBlessing(constructor) {
    const outlets = readInheritableStaticArrayValues(constructor, "outlets");
    return outlets.reduce((properties, outletDefinition) => {
        return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
    }, {});
}
function getOutletController(controller, element, identifier) {
    return controller.application.getControllerForElementAndIdentifier(element, identifier);
}
function getControllerAndEnsureConnectedScope(controller, element, outletName) {
    let outletController = getOutletController(controller, element, outletName);
    if (outletController)
        return outletController;
    controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
    outletController = getOutletController(controller, element, outletName);
    if (outletController)
        return outletController;
}
function propertiesForOutletDefinition(name) {
    const camelizedName = namespaceCamelize(name);
    return {
        [`${camelizedName}Outlet`]: {
            get() {
                const outletElement = this.outlets.find(name);
                const selector = this.outlets.getSelectorForOutletName(name);
                if (outletElement) {
                    const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
                    if (outletController)
                        return outletController;
                    throw new Error(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`);
                }
                throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
            },
        },
        [`${camelizedName}Outlets`]: {
            get() {
                const outlets = this.outlets.findAll(name);
                if (outlets.length > 0) {
                    return outlets
                        .map((outletElement) => {
                        const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
                        if (outletController)
                            return outletController;
                        console.warn(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`, outletElement);
                    })
                        .filter((controller) => controller);
                }
                return [];
            },
        },
        [`${camelizedName}OutletElement`]: {
            get() {
                const outletElement = this.outlets.find(name);
                const selector = this.outlets.getSelectorForOutletName(name);
                if (outletElement) {
                    return outletElement;
                }
                else {
                    throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
                }
            },
        },
        [`${camelizedName}OutletElements`]: {
            get() {
                return this.outlets.findAll(name);
            },
        },
        [`has${capitalize(camelizedName)}Outlet`]: {
            get() {
                return this.outlets.has(name);
            },
        },
    };
}

function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
        return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
}
function propertiesForTargetDefinition(name) {
    return {
        [`${name}Target`]: {
            get() {
                const target = this.targets.find(name);
                if (target) {
                    return target;
                }
                else {
                    throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
                }
            },
        },
        [`${name}Targets`]: {
            get() {
                return this.targets.findAll(name);
            },
        },
        [`has${capitalize(name)}Target`]: {
            get() {
                return this.targets.has(name);
            },
        },
    };
}

function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
        valueDescriptorMap: {
            get() {
                return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
                    const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
                    const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
                    return Object.assign(result, { [attributeName]: valueDescriptor });
                }, {});
            },
        },
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
        return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
}
function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
    const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
    const { key, name, reader: read, writer: write } = definition;
    return {
        [name]: {
            get() {
                const value = this.data.get(key);
                if (value !== null) {
                    return read(value);
                }
                else {
                    return definition.defaultValue;
                }
            },
            set(value) {
                if (value === undefined) {
                    this.data.delete(key);
                }
                else {
                    this.data.set(key, write(value));
                }
            },
        },
        [`has${capitalize(name)}`]: {
            get() {
                return this.data.has(key) || definition.hasCustomDefaultValue;
            },
        },
    };
}
function parseValueDefinitionPair([token, typeDefinition], controller) {
    return valueDescriptorForTokenAndTypeDefinition({
        controller,
        token,
        typeDefinition,
    });
}
function parseValueTypeConstant(constant) {
    switch (constant) {
        case Array:
            return "array";
        case Boolean:
            return "boolean";
        case Number:
            return "number";
        case Object:
            return "object";
        case String:
            return "string";
    }
}
function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
        case "boolean":
            return "boolean";
        case "number":
            return "number";
        case "string":
            return "string";
    }
    if (Array.isArray(defaultValue))
        return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
        return "object";
}
function parseValueTypeObject(payload) {
    const { controller, token, typeObject } = payload;
    const hasType = isSomething(typeObject.type);
    const hasDefault = isSomething(typeObject.default);
    const fullObject = hasType && hasDefault;
    const onlyType = hasType && !hasDefault;
    const onlyDefault = !hasType && hasDefault;
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
    if (onlyType)
        return typeFromObject;
    if (onlyDefault)
        return typeFromDefaultValue;
    if (typeFromObject !== typeFromDefaultValue) {
        const propertyPath = controller ? `${controller}.${token}` : token;
        throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
    }
    if (fullObject)
        return typeFromObject;
}
function parseValueTypeDefinition(payload) {
    const { controller, token, typeDefinition } = payload;
    const typeObject = { controller, token, typeObject: typeDefinition };
    const typeFromObject = parseValueTypeObject(typeObject);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
        return type;
    const propertyPath = controller ? `${controller}.${typeDefinition}` : token;
    throw new Error(`Unknown value type "${propertyPath}" for "${token}" value`);
}
function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
        return defaultValuesByType[constant];
    const hasDefault = hasProperty(typeDefinition, "default");
    const hasType = hasProperty(typeDefinition, "type");
    const typeObject = typeDefinition;
    if (hasDefault)
        return typeObject.default;
    if (hasType) {
        const { type } = typeObject;
        const constantFromType = parseValueTypeConstant(type);
        if (constantFromType)
            return defaultValuesByType[constantFromType];
    }
    return typeDefinition;
}
function valueDescriptorForTokenAndTypeDefinition(payload) {
    const { token, typeDefinition } = payload;
    const key = `${dasherize(token)}-value`;
    const type = parseValueTypeDefinition(payload);
    return {
        type,
        key,
        name: camelize(key),
        get defaultValue() {
            return defaultValueForDefinition(typeDefinition);
        },
        get hasCustomDefaultValue() {
            return parseValueTypeDefault(typeDefinition) !== undefined;
        },
        reader: readers[type],
        writer: writers[type] || writers.default,
    };
}
const defaultValuesByType = {
    get array() {
        return [];
    },
    boolean: false,
    number: 0,
    get object() {
        return {};
    },
    string: "",
};
const readers = {
    array(value) {
        const array = JSON.parse(value);
        if (!Array.isArray(array)) {
            throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
        }
        return array;
    },
    boolean(value) {
        return !(value == "0" || String(value).toLowerCase() == "false");
    },
    number(value) {
        return Number(value.replace(/_/g, ""));
    },
    object(value) {
        const object = JSON.parse(value);
        if (object === null || typeof object != "object" || Array.isArray(object)) {
            throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
        }
        return object;
    },
    string(value) {
        return value;
    },
};
const writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON,
};
function writeJSON(value) {
    return JSON.stringify(value);
}
function writeString(value) {
    return `${value}`;
}

class Controller {
    constructor(context) {
        this.context = context;
    }
    static get shouldLoad() {
        return true;
    }
    static afterLoad(_identifier, _application) {
        return;
    }
    get application() {
        return this.context.application;
    }
    get scope() {
        return this.context.scope;
    }
    get element() {
        return this.scope.element;
    }
    get identifier() {
        return this.scope.identifier;
    }
    get targets() {
        return this.scope.targets;
    }
    get outlets() {
        return this.scope.outlets;
    }
    get classes() {
        return this.scope.classes;
    }
    get data() {
        return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true, } = {}) {
        const type = prefix ? `${prefix}:${eventName}` : eventName;
        const event = new CustomEvent(type, { detail, bubbles, cancelable });
        target.dispatchEvent(event);
        return event;
    }
}
Controller.blessings = [
    ClassPropertiesBlessing,
    TargetPropertiesBlessing,
    ValuePropertiesBlessing,
    OutletPropertiesBlessing,
];
Controller.targets = [];
Controller.outlets = [];
Controller.values = {};




/***/ }),

/***/ "./node_modules/@symfony/stimulus-bridge/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@symfony/stimulus-bridge/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   startStimulusApp: () => (/* binding */ startStimulusApp)
/* harmony export */ });
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var _webpack_loader_symfony_stimulus_bridge_controllers_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webpack/loader!@symfony/stimulus-bridge/controllers.json */ "./node_modules/@symfony/stimulus-bridge/dist/webpack/loader.js!./assets/controllers.json");



/*
Stimulus Webpack Helpers 1.0.0
Copyright Â© 2021 Basecamp, LLC
 */
function definitionsFromContext(context) {
    return context.keys()
        .map((key) => definitionForModuleWithContextAndKey(context, key))
        .filter((value) => value);
}
function definitionForModuleWithContextAndKey(context, key) {
    const identifier = identifierForContextKey(key);
    if (identifier) {
        return definitionForModuleAndIdentifier(context(key), identifier);
    }
}
function definitionForModuleAndIdentifier(module, identifier) {
    const controllerConstructor = module.default;
    if (typeof controllerConstructor == "function") {
        return { identifier, controllerConstructor };
    }
}
function identifierForContextKey(key) {
    const logicalName = (key.match(/^(?:\.\/)?(.+)(?:[_-]controller\..+?)$/) || [])[1];
    if (logicalName) {
        return logicalName.replace(/_/g, "-").replace(/\//g, "--");
    }
}

function startStimulusApp(context) {
    const application = _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Application.start();
    if (true) {
        application.debug = true;
    }
    if (context) {
        application.load(definitionsFromContext(context));
    }
    for (const controllerName in _webpack_loader_symfony_stimulus_bridge_controllers_json__WEBPACK_IMPORTED_MODULE_1__["default"]) {
        if (!_webpack_loader_symfony_stimulus_bridge_controllers_json__WEBPACK_IMPORTED_MODULE_1__["default"].hasOwnProperty(controllerName)) {
            continue;
        }
        application.register(controllerName, _webpack_loader_symfony_stimulus_bridge_controllers_json__WEBPACK_IMPORTED_MODULE_1__["default"][controllerName]);
    }
    return application;
}




/***/ }),

/***/ "./node_modules/core-js/internals/a-callable.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-callable.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-constructor.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/a-constructor.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");

var $TypeError = TypeError;

// `Assert: IsConstructor(argument) is true`
module.exports = function (argument) {
  if (isConstructor(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a constructor');
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-possible-prototype.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isPossiblePrototype = __webpack_require__(/*! ../internals/is-possible-prototype */ "./node_modules/core-js/internals/is-possible-prototype.js");

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (isPossiblePrototype(argument)) return argument;
  throw new $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ "./node_modules/core-js/internals/add-to-unscopables.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] === undefined) {
  defineProperty(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-instance.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/an-instance.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw new $TypeError('Incorrect invocation');
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-for-each.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-for-each.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var $forEach = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").forEach);
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js/internals/array-method-is-strict.js");

var STRICT_METHOD = arrayMethodIsStrict('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach
module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
} : [].forEach;


/***/ }),

/***/ "./node_modules/core-js/internals/array-from.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/array-from.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

var $Array = Array;

// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var IS_CONSTRUCTOR = isConstructor(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
    result = IS_CONSTRUCTOR ? new this() : [];
    iterator = getIterator(O, iteratorMethod);
    next = iterator.next;
    for (;!(step = call(next, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = lengthOfArrayLike(O);
    result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-iteration.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/array-iteration.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE === 1;
  var IS_FILTER = TYPE === 2;
  var IS_SOME = TYPE === 3;
  var IS_EVERY = TYPE === 4;
  var IS_FIND_INDEX = TYPE === 6;
  var IS_FILTER_REJECT = TYPE === 7;
  var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var length = lengthOfArrayLike(self);
    var boundFunction = bind(callbackfn, that);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-method-has-species-support.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/array-method-has-species-support.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var V8_VERSION = __webpack_require__(/*! ../internals/environment-v8-version */ "./node_modules/core-js/internals/environment-v8-version.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-method-is-strict.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/array-method-is-strict.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () { return 1; }, 1);
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-set-length.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/array-set-length.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Safari < 13 does not throw an error in this case
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
  // makes no sense without proper strict mode support
  if (this !== undefined) return true;
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).length = 1;
  } catch (error) {
    return error instanceof TypeError;
  }
}();

module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
    throw new $TypeError('Cannot set read only .length');
  } return O.length = length;
} : function (O, length) {
  return O.length = length;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-slice.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/array-slice.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = uncurryThis([].slice);


/***/ }),

/***/ "./node_modules/core-js/internals/array-sort.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/array-sort.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js/internals/array-slice.js");

var floor = Math.floor;

var sort = function (array, comparefn) {
  var length = array.length;

  if (length < 8) {
    // insertion sort
    var i = 1;
    var element, j;

    while (i < length) {
      j = i;
      element = array[i];
      while (j && comparefn(array[j - 1], element) > 0) {
        array[j] = array[--j];
      }
      if (j !== i++) array[j] = element;
    }
  } else {
    // merge sort
    var middle = floor(length / 2);
    var left = sort(arraySlice(array, 0, middle), comparefn);
    var right = sort(arraySlice(array, middle), comparefn);
    var llength = left.length;
    var rlength = right.length;
    var lindex = 0;
    var rindex = 0;

    while (lindex < llength || rindex < rlength) {
      array[lindex + rindex] = (lindex < llength && rindex < rlength)
        ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]
        : lindex < llength ? left[lindex++] : right[rindex++];
    }
  }

  return array;
};

module.exports = sort;


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-constructor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-constructor.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');
var $Array = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? $Array : C;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-create.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var arraySpeciesConstructor = __webpack_require__(/*! ../internals/array-species-constructor */ "./node_modules/core-js/internals/array-species-constructor.js");

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose(iterator, 'throw', error);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/check-correctness-of-iteration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  try {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  } catch (error) { return false; } // workaround of old WebKit + `eval` bug
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/correct-is-regexp-logic.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-is-regexp-logic.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};


/***/ }),

/***/ "./node_modules/core-js/internals/correct-prototype-getter.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "./node_modules/core-js/internals/create-iter-result-object.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-iter-result-object.js ***!
  \*********************************************************************/
/***/ ((module) => {


// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-non-enumerable-property.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/***/ ((module) => {


module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/create-property.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = function (object, key, value) {
  if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
  else object[key] = value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/date-to-primitive.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/date-to-primitive.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");

var $TypeError = TypeError;

// `Date.prototype[@@toPrimitive](hint)` method implementation
// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive
module.exports = function (hint) {
  anObject(this);
  if (hint === 'string' || hint === 'default') hint = 'string';
  else if (hint !== 'number') throw new $TypeError('Incorrect hint');
  return ordinaryToPrimitive(this, hint);
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-built-in-accessor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in-accessor.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-built-in.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-built-ins.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-ins.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");

module.exports = function (target, src, options) {
  for (var key in src) defineBuiltIn(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-global-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/define-global-property.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(globalThis, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    globalThis[key] = value;
  } return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var document = globalThis.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/internals/does-not-exceed-safe-integer.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/does-not-exceed-safe-integer.js ***!
  \************************************************************************/
/***/ ((module) => {


var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/dom-iterables.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/dom-iterables.js ***!
  \*********************************************************/
/***/ ((module) => {


// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "./node_modules/core-js/internals/dom-token-list-prototype.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/dom-token-list-prototype.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

var classList = documentCreateElement('span').classList;
var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;

module.exports = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;


/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/***/ ((module) => {


// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "./node_modules/core-js/internals/environment-user-agent.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/environment-user-agent.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");

var navigator = globalThis.navigator;
var userAgent = navigator && navigator.userAgent;

module.exports = userAgent ? String(userAgent) : '';


/***/ }),

/***/ "./node_modules/core-js/internals/environment-v8-version.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/environment-v8-version.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var userAgent = __webpack_require__(/*! ../internals/environment-user-agent */ "./node_modules/core-js/internals/environment-user-agent.js");

var process = globalThis.process;
var Deno = globalThis.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ "./node_modules/core-js/internals/environment.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/environment.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/* global Bun, Deno -- detection */
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var userAgent = __webpack_require__(/*! ../internals/environment-user-agent */ "./node_modules/core-js/internals/environment-user-agent.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var userAgentStartsWith = function (string) {
  return userAgent.slice(0, string.length) === string;
};

module.exports = (function () {
  if (userAgentStartsWith('Bun/')) return 'BUN';
  if (userAgentStartsWith('Cloudflare-Workers')) return 'CLOUDFLARE';
  if (userAgentStartsWith('Deno/')) return 'DENO';
  if (userAgentStartsWith('Node.js/')) return 'NODE';
  if (globalThis.Bun && typeof Bun.version == 'string') return 'BUN';
  if (globalThis.Deno && typeof Deno.version == 'object') return 'DENO';
  if (classof(globalThis.process) === 'process') return 'NODE';
  if (globalThis.window && globalThis.document) return 'BROWSER';
  return 'REST';
})();


/***/ }),

/***/ "./node_modules/core-js/internals/error-stack-clear.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/error-stack-clear.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var $Error = Error;
var replace = uncurryThis(''.replace);

var TEST = (function (arg) { return String(new $Error(arg).stack); })('zxcasd');
// eslint-disable-next-line redos/no-vulnerable, sonarjs/slow-regex -- safe
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);

module.exports = function (stack, dropEntries) {
  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {
    while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
  } return stack;
};


/***/ }),

/***/ "./node_modules/core-js/internals/error-stack-install.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/error-stack-install.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var clearErrorStack = __webpack_require__(/*! ../internals/error-stack-clear */ "./node_modules/core-js/internals/error-stack-clear.js");
var ERROR_STACK_INSTALLABLE = __webpack_require__(/*! ../internals/error-stack-installable */ "./node_modules/core-js/internals/error-stack-installable.js");

// non-standard V8
var captureStackTrace = Error.captureStackTrace;

module.exports = function (error, C, stack, dropEntries) {
  if (ERROR_STACK_INSTALLABLE) {
    if (captureStackTrace) captureStackTrace(error, C);
    else createNonEnumerableProperty(error, 'stack', clearErrorStack(stack, dropEntries));
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/error-stack-installable.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/error-stack-installable.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = !fails(function () {
  var error = new Error('a');
  if (!('stack' in error)) return true;
  // eslint-disable-next-line es/no-object-defineproperty -- safe
  Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
  return error.stack !== 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/error-to-string.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/error-to-string.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var normalizeStringArgument = __webpack_require__(/*! ../internals/normalize-string-argument */ "./node_modules/core-js/internals/normalize-string-argument.js");

var nativeErrorToString = Error.prototype.toString;

var INCORRECT_TO_STRING = fails(function () {
  if (DESCRIPTORS) {
    // Chrome 32- incorrectly call accessor
    // eslint-disable-next-line es/no-object-create, es/no-object-defineproperty -- safe
    var object = Object.create(Object.defineProperty({}, 'name', { get: function () {
      return this === object;
    } }));
    if (nativeErrorToString.call(object) !== 'true') return true;
  }
  // FF10- does not properly handle non-strings
  return nativeErrorToString.call({ message: 1, name: 2 }) !== '2: 1'
    // IE8 does not properly handle defaults
    || nativeErrorToString.call({}) !== 'Error';
});

module.exports = INCORRECT_TO_STRING ? function toString() {
  var O = anObject(this);
  var name = normalizeStringArgument(O.name, 'Error');
  var message = normalizeStringArgument(O.message);
  return !name ? message : !message ? name : name + ': ' + message;
} : nativeErrorToString;


/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = globalThis;
  } else if (STATIC) {
    target = globalThis[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = globalThis[TARGET] && globalThis[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/***/ ((module) => {


module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__(/*! ../modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

var SPECIES = wellKnownSymbol('species');
var RegExpPrototype = RegExp.prototype;

module.exports = function (KEY, exec, FORCED, SHAM) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegExp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) !== 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () {
      execCalled = true;
      return null;
    };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    FORCED
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      var $exec = regexp.exec;
      if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: call(nativeRegExpMethod, regexp, str, arg2) };
        }
        return { done: true, value: call(nativeMethod, str, regexp, arg2) };
      }
      return { done: false };
    });

    defineBuiltIn(String.prototype, KEY, methods[0]);
    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
  }

  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-apply.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/function-apply.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-function-prototype-bind, es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind-context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-context.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this-clause */ "./node_modules/core-js/internals/function-uncurry-this-clause.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind-native.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-native.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js/internals/array-slice.js");
var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var $Function = Function;
var concat = uncurryThis([].concat);
var join = uncurryThis([].join);
var factories = {};

var construct = function (C, argsLength, args) {
  if (!hasOwn(factories, argsLength)) {
    var list = [];
    var i = 0;
    for (; i < argsLength; i++) list[i] = 'a[' + i + ']';
    factories[argsLength] = $Function('C,a', 'return new C(' + join(list, ',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
// eslint-disable-next-line es/no-function-prototype-bind -- detection
module.exports = NATIVE_BIND ? $Function.bind : function bind(that /* , ...args */) {
  var F = aCallable(this);
  var Prototype = F.prototype;
  var partArgs = arraySlice(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = concat(partArgs, arraySlice(arguments));
    return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
  };
  if (isObject(Prototype)) boundFunction.prototype = Prototype;
  return boundFunction;
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-call.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-call.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var call = Function.prototype.call;
// eslint-disable-next-line es/no-function-prototype-bind -- safe
module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-name.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-name.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this-accessor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this-accessor.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this-clause.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this-clause.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
// eslint-disable-next-line es/no-function-prototype-bind -- safe
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(globalThis[namespace]) : globalThis[namespace] && globalThis[namespace][method];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator-direct.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator-direct.js ***!
  \***************************************************************/
/***/ ((module) => {


// `GetIteratorDirect(obj)` abstract operation
// https://tc39.es/proposal-iterator-helpers/#sec-getiteratordirect
module.exports = function (obj) {
  return {
    iterator: obj,
    next: obj.next,
    done: false
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator-method.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

var $TypeError = TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw new $TypeError(tryToString(argument) + ' is not iterable');
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-json-replacer-function.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/get-json-replacer-function.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");

var push = uncurryThis([].push);

module.exports = function (replacer) {
  if (isCallable(replacer)) return replacer;
  if (!isArray(replacer)) return;
  var rawLength = replacer.length;
  var keys = [];
  for (var i = 0; i < rawLength; i++) {
    var element = replacer[i];
    if (typeof element == 'string') push(keys, element);
    else if (typeof element == 'number' || classof(element) === 'Number' || classof(element) === 'String') push(keys, toString(element));
  }
  var keysLength = keys.length;
  var root = true;
  return function (key, value) {
    if (root) {
      root = false;
      return value;
    }
    if (isArray(this)) return value;
    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-method.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/get-method.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ "./node_modules/core-js/internals/global-this.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/global-this.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ "./node_modules/core-js/internals/has-own-property.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/has-own-property.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/***/ ((module) => {


module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/html.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ "./node_modules/core-js/internals/inherit-if-required.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/inherit-if-required.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ "./node_modules/core-js/internals/inspect-source.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "./node_modules/core-js/internals/install-error-cause.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/install-error-cause.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

// `InstallErrorCause` abstract operation
// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause
module.exports = function (O, options) {
  if (isObject(options) && 'cause' in options) {
    createNonEnumerableProperty(O, 'cause', options.cause);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js/internals/weak-map-basic-detection.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = globalThis.TypeError;
var WeakMap = globalThis.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array-iterator-method.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/is-array.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-callable.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/is-callable.js ***!
  \*******************************************************/
/***/ ((module) => {


// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-constructor.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/is-constructor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var noop = function () { /* empty */ };
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.test(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, [], argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ "./node_modules/core-js/internals/is-data-descriptor.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/is-data-descriptor.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");

module.exports = function (descriptor) {
  return descriptor !== undefined && (hasOwn(descriptor, 'value') || hasOwn(descriptor, 'writable'));
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "./node_modules/core-js/internals/is-integral-number.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/is-integral-number.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var floor = Math.floor;

// `IsIntegralNumber` abstract operation
// https://tc39.es/ecma262/#sec-isintegralnumber
// eslint-disable-next-line es/no-number-isinteger -- safe
module.exports = Number.isInteger || function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-null-or-undefined.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/is-null-or-undefined.js ***!
  \****************************************************************/
/***/ ((module) => {


// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-possible-prototype.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/is-possible-prototype.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

module.exports = function (argument) {
  return isObject(argument) || argument === null;
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/***/ ((module) => {


module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/internals/is-regexp.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-regexp.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) === 'RegExp');
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-symbol.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-symbol.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterate.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/iterate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");

var $TypeError = TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw new $TypeError(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterator-close.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-close.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterator-create-constructor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-create-constructor.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var IteratorPrototype = (__webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype);
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterator-define.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-define.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var FunctionName = __webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/iterator-create-constructor */ "./node_modules/core-js/internals/iterator-create-constructor.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];

    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    }

    return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME === 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  }
  Iterators[NAME] = defaultIterator;

  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterator-helper-without-closing-on-early-error.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-helper-without-closing-on-early-error.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");

// https://github.com/tc39/ecma262/pull/3467
module.exports = function (METHOD_NAME, ExpectedError) {
  var Iterator = globalThis.Iterator;
  var IteratorPrototype = Iterator && Iterator.prototype;
  var method = IteratorPrototype && IteratorPrototype[METHOD_NAME];

  var CLOSED = false;

  if (method) try {
    method.call({
      next: function () { return { done: true }; },
      'return': function () { CLOSED = true; }
    }, -1);
  } catch (error) {
    // https://bugs.webkit.org/show_bug.cgi?id=291195
    if (!(error instanceof ExpectedError)) CLOSED = false;
  }

  if (!CLOSED) return method;
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators-core.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterators-core.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/***/ ((module) => {


module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/length-of-array-like.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/length-of-array-like.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/make-built-in.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/make-built-in.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js").CONFIGURABLE);
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ "./node_modules/core-js/internals/math-trunc.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/math-trunc.js ***!
  \******************************************************/
/***/ ((module) => {


var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ "./node_modules/core-js/internals/normalize-string-argument.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/normalize-string-argument.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");

module.exports = function (argument, $default) {
  return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);
};


/***/ }),

/***/ "./node_modules/core-js/internals/not-a-regexp.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/not-a-regexp.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isRegExp = __webpack_require__(/*! ../internals/is-regexp */ "./node_modules/core-js/internals/is-regexp.js");

var $TypeError = TypeError;

module.exports = function (it) {
  if (isRegExp(it)) {
    throw new $TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/number-parse-int.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/number-parse-int.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var trim = (__webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js").trim);
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");

var $parseInt = globalThis.parseInt;
var Symbol = globalThis.Symbol;
var ITERATOR = Symbol && Symbol.iterator;
var hex = /^[+-]?0x/i;
var exec = uncurryThis(hex.exec);
var FORCED = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22
  // MS Edge 18- broken with boxed symbols
  || (ITERATOR && !fails(function () { $parseInt(Object(ITERATOR)); }));

// `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix
module.exports = FORCED ? function parseInt(string, radix) {
  var S = trim(toString(string));
  return $parseInt(S, (radix >>> 0) || (exec(hex, S) ? 16 : 10));
} : $parseInt;


/***/ }),

/***/ "./node_modules/core-js/internals/object-create.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var definePropertiesModule = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  // eslint-disable-next-line no-useless-assignment -- avoid memory leak
  activeXDocument = null;
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-properties.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names-external.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names-external.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/* eslint-disable es/no-object-getownpropertynames -- safe */
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var $getOwnPropertyNames = (__webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f);
var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js/internals/array-slice.js");

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && classof(it) === 'Window'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-is-prototype-of.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-is-prototype-of.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var indexOf = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf);
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = __webpack_require__(/*! ../internals/function-uncurry-this-accessor */ "./node_modules/core-js/internals/function-uncurry-this-accessor.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js/internals/a-possible-prototype.js");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    requireObjectCoercible(O);
    aPossiblePrototype(proto);
    if (!isObject(O)) return O;
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "./node_modules/core-js/internals/object-to-array.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-array.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var objectGetPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var $propertyIsEnumerable = (__webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js").f);

var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
var push = uncurryThis([].push);

// in some IE versions, `propertyIsEnumerable` returns incorrect result on integer keys
// of `null` prototype objects
var IE_BUG = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-create -- safe
  var O = Object.create(null);
  O[2] = 2;
  return !propertyIsEnumerable(O, 2);
});

// `Object.{ entries, values }` methods implementation
var createMethod = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf(O) === null;
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || (IE_WORKAROUND ? key in O : propertyIsEnumerable(O, key))) {
        push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

module.exports = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod(false)
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-string.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ "./node_modules/core-js/internals/ordinary-to-primitive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/ordinary-to-primitive.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/core-js/internals/path.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/path.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");

module.exports = globalThis;


/***/ }),

/***/ "./node_modules/core-js/internals/proxy-accessor.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/proxy-accessor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);

module.exports = function (Target, Source, key) {
  key in Target || defineProperty(Target, key, {
    configurable: true,
    get: function () { return Source[key]; },
    set: function (it) { Source[key] = it; }
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-exec-abstract.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-exec-abstract.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

var $TypeError = TypeError;

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (isCallable(exec)) {
    var result = call(exec, R, S);
    if (result !== null) anObject(result);
    return result;
  }
  if (classof(R) === 'RegExp') return call(regexpExec, R, S);
  throw new $TypeError('RegExp#exec called on incompatible receiver');
};


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-exec.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-exec.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
/* eslint-disable regexp/no-useless-quantifier -- testing */
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var regexpFlags = __webpack_require__(/*! ../internals/regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");
var stickyHelpers = __webpack_require__(/*! ../internals/regexp-sticky-helpers */ "./node_modules/core-js/internals/regexp-sticky-helpers.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var getInternalState = (__webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js").get);
var UNSUPPORTED_DOT_ALL = __webpack_require__(/*! ../internals/regexp-unsupported-dot-all */ "./node_modules/core-js/internals/regexp-unsupported-dot-all.js");
var UNSUPPORTED_NCG = __webpack_require__(/*! ../internals/regexp-unsupported-ncg */ "./node_modules/core-js/internals/regexp-unsupported-ncg.js");

var nativeReplace = shared('native-string-replace', String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt = uncurryThis(''.charAt);
var indexOf = uncurryThis(''.indexOf);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  call(nativeExec, re1, 'a');
  call(nativeExec, re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

if (PATCH) {
  patchedExec = function exec(string) {
    var re = this;
    var state = getInternalState(re);
    var str = toString(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match, i, object, group;

    if (raw) {
      raw.lastIndex = re.lastIndex;
      result = call(patchedExec, raw, str);
      re.lastIndex = raw.lastIndex;
      return result;
    }

    var groups = state.groups;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = call(regexpFlags, re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = replace(flags, 'y', '');
      if (indexOf(flags, 'g') === -1) {
        flags += 'g';
      }

      strCopy = stringSlice(str, re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = call(nativeExec, sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = stringSlice(match.input, charsAdded);
        match[0] = stringSlice(match[0], charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn't work for /(.?)?/
      call(nativeReplace, match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    if (match && groups) {
      match.groups = object = create(null);
      for (i = 0; i < groups.length; i++) {
        group = groups[i];
        object[group[0]] = match[group[1]];
      }
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-flags.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-flags.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.hasIndices) result += 'd';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.unicodeSets) result += 'v';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-get-flags.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-get-flags.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var regExpFlags = __webpack_require__(/*! ../internals/regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");

var RegExpPrototype = RegExp.prototype;

module.exports = function (R) {
  var flags = R.flags;
  return flags === undefined && !('flags' in RegExpPrototype) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype, R)
    ? call(regExpFlags, R) : flags;
};


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-sticky-helpers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-sticky-helpers.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");

// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
var $RegExp = globalThis.RegExp;

var UNSUPPORTED_Y = fails(function () {
  var re = $RegExp('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') !== null;
});

// UC Browser bug
// https://github.com/zloirock/core-js/issues/1008
var MISSED_STICKY = UNSUPPORTED_Y || fails(function () {
  return !$RegExp('a', 'y').sticky;
});

var BROKEN_CARET = UNSUPPORTED_Y || fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = $RegExp('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') !== null;
});

module.exports = {
  BROKEN_CARET: BROKEN_CARET,
  MISSED_STICKY: MISSED_STICKY,
  UNSUPPORTED_Y: UNSUPPORTED_Y
};


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-unsupported-dot-all.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-unsupported-dot-all.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");

// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
var $RegExp = globalThis.RegExp;

module.exports = fails(function () {
  var re = $RegExp('.', 's');
  return !(re.dotAll && re.test('\n') && re.flags === 's');
});


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-unsupported-ncg.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-unsupported-ncg.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");

// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
var $RegExp = globalThis.RegExp;

module.exports = fails(function () {
  var re = $RegExp('(?<a>b)', 'g');
  return re.exec('b').groups.a !== 'b' ||
    'b'.replace(re, '$<a>c') !== 'bc';
});


/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/safe-get-built-in.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/safe-get-built-in.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Avoid NodeJS experimental warning
module.exports = function (name) {
  if (!DESCRIPTORS) return globalThis[name];
  var descriptor = getOwnPropertyDescriptor(globalThis, name);
  return descriptor && descriptor.value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/same-value.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/same-value.js ***!
  \******************************************************/
/***/ ((module) => {


// `SameValue` abstract operation
// https://tc39.es/ecma262/#sec-samevalue
// eslint-disable-next-line es/no-object-is -- safe
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare -- NaN check
  return x === y ? x !== 0 || 1 / x === 1 / y : x !== x && y !== y;
};


/***/ }),

/***/ "./node_modules/core-js/internals/schedulers-fix.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/schedulers-fix.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var ENVIRONMENT = __webpack_require__(/*! ../internals/environment */ "./node_modules/core-js/internals/environment.js");
var USER_AGENT = __webpack_require__(/*! ../internals/environment-user-agent */ "./node_modules/core-js/internals/environment-user-agent.js");
var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js/internals/array-slice.js");
var validateArgumentsLength = __webpack_require__(/*! ../internals/validate-arguments-length */ "./node_modules/core-js/internals/validate-arguments-length.js");

var Function = globalThis.Function;
// dirty IE9- and Bun 0.3.0- checks
var WRAP = /MSIE .\./.test(USER_AGENT) || ENVIRONMENT === 'BUN' && (function () {
  var version = globalThis.Bun.version.split('.');
  return version.length < 3 || version[0] === '0' && (version[1] < 3 || version[1] === '3' && version[2] === '0');
})();

// IE9- / Bun 0.3.0- setTimeout / setInterval / setImmediate additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
// https://github.com/oven-sh/bun/issues/1633
module.exports = function (scheduler, hasTimeArg) {
  var firstParamIndex = hasTimeArg ? 2 : 1;
  return WRAP ? function (handler, timeout /* , ...arguments */) {
    var boundArgs = validateArgumentsLength(arguments.length, 1) > firstParamIndex;
    var fn = isCallable(handler) ? handler : Function(handler);
    var params = boundArgs ? arraySlice(arguments, firstParamIndex) : [];
    var callback = boundArgs ? function () {
      apply(fn, this, params);
    } : fn;
    return hasTimeArg ? scheduler(callback, timeout) : scheduler(callback);
  } : scheduler;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn(target, TO_STRING_TAG)) {
    defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-store.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");

var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

(store.versions || (store.versions = [])).push({
  version: '3.42.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: 'Â© 2014-2025 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.42.0/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

module.exports = function (key, value) {
  return store[key] || (store[key] = value || {});
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-multibyte.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/string-multibyte.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-trim.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/string-trim.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");

var replace = uncurryThis(''.replace);
var ltrim = RegExp('^[' + whitespaces + ']+');
var rtrim = RegExp('(^|[^' + whitespaces + '])[' + whitespaces + ']+$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = toString(requireObjectCoercible($this));
    if (TYPE & 1) string = replace(string, ltrim, '');
    if (TYPE & 2) string = replace(string, rtrim, '$1');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ "./node_modules/core-js/internals/symbol-constructor-detection.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/symbol-constructor-detection.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(/*! ../internals/environment-v8-version */ "./node_modules/core-js/internals/environment-v8-version.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");

var $String = globalThis.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ "./node_modules/core-js/internals/symbol-define-to-primitive.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/symbol-define-to-primitive.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");

module.exports = function () {
  var Symbol = getBuiltIn('Symbol');
  var SymbolPrototype = Symbol && Symbol.prototype;
  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
    // `Symbol.prototype[@@toPrimitive]` method
    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
    // eslint-disable-next-line no-unused-vars -- required for .length
    defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function (hint) {
      return call(valueOf, this);
    }, { arity: 1 });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/symbol-registry-detection.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/symbol-registry-detection.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");

/* eslint-disable es/no-symbol -- safe */
module.exports = NATIVE_SYMBOL && !!Symbol['for'] && !!Symbol.keyFor;


/***/ }),

/***/ "./node_modules/core-js/internals/this-number-value.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/this-number-value.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

// `thisNumberValue` abstract operation
// https://tc39.es/ecma262/#sec-thisnumbervalue
module.exports = uncurryThis(1.0.valueOf);


/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-integer-or-infinity.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer-or-infinity.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var trunc = __webpack_require__(/*! ../internals/math-trunc */ "./node_modules/core-js/internals/math-trunc.js");

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-property-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/to-property-key.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-string-tag-support.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "./node_modules/core-js/internals/to-string.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-string.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ "./node_modules/core-js/internals/try-to-string.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/try-to-string.js ***!
  \*********************************************************/
/***/ ((module) => {


var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ "./node_modules/core-js/internals/url-constructor-detection.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/url-constructor-detection.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = !fails(function () {
  // eslint-disable-next-line unicorn/relative-url-style -- required for testing
  var url = new URL('b?a=1&b=2&c=3', 'https://a');
  var params = url.searchParams;
  var params2 = new URLSearchParams('a=1&a=2&b=3');
  var result = '';
  url.pathname = 'c%20d';
  params.forEach(function (value, key) {
    params['delete']('b');
    result += key + value;
  });
  params2['delete']('a', 2);
  // `undefined` case is a Chromium 117 bug
  // https://bugs.chromium.org/p/v8/issues/detail?id=14222
  params2['delete']('b', undefined);
  return (IS_PURE && (!url.toJSON || !params2.has('a', 1) || params2.has('a', 2) || !params2.has('a', undefined) || params2.has('b')))
    || (!params.size && (IS_PURE || !DESCRIPTORS))
    || !params.sort
    || url.href !== 'https://a/c%20d?a=1&c=3'
    || params.get('c') !== '3'
    || String(new URLSearchParams('?a=1')) !== 'a=1'
    || !params[ITERATOR]
    // throws in Edge
    || new URL('https://a@b').username !== 'a'
    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
    // not punycoded in Edge
    || new URL('https://ÑÐµÑÑ').host !== 'xn--e1aybc'
    // not escaped in Chrome 62-
    || new URL('https://a#Ð±').hash !== '#%D0%B1'
    // fails in Chrome 66-
    || result !== 'a1c3'
    // throws in Safari
    || new URL('https://x', undefined).host !== 'x';
});


/***/ }),

/***/ "./node_modules/core-js/internals/use-symbol-as-uid.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");

module.exports = NATIVE_SYMBOL &&
  !Symbol.sham &&
  typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "./node_modules/core-js/internals/v8-prototype-define-bug.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/v8-prototype-define-bug.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),

/***/ "./node_modules/core-js/internals/validate-arguments-length.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/validate-arguments-length.js ***!
  \*********************************************************************/
/***/ ((module) => {


var $TypeError = TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw new $TypeError('Not enough arguments');
  return passed;
};


/***/ }),

/***/ "./node_modules/core-js/internals/weak-map-basic-detection.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/weak-map-basic-detection.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var WeakMap = globalThis.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol-define.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol-define.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/well-known-symbol-wrapped */ "./node_modules/core-js/internals/well-known-symbol-wrapped.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol-wrapped.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol-wrapped.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

exports.f = wellKnownSymbol;


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var Symbol = globalThis.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "./node_modules/core-js/internals/whitespaces.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/whitespaces.js ***!
  \*******************************************************/
/***/ ((module) => {


// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "./node_modules/core-js/internals/wrap-error-constructor-with-cause.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js/internals/wrap-error-constructor-with-cause.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var proxyAccessor = __webpack_require__(/*! ../internals/proxy-accessor */ "./node_modules/core-js/internals/proxy-accessor.js");
var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");
var normalizeStringArgument = __webpack_require__(/*! ../internals/normalize-string-argument */ "./node_modules/core-js/internals/normalize-string-argument.js");
var installErrorCause = __webpack_require__(/*! ../internals/install-error-cause */ "./node_modules/core-js/internals/install-error-cause.js");
var installErrorStack = __webpack_require__(/*! ../internals/error-stack-install */ "./node_modules/core-js/internals/error-stack-install.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

module.exports = function (FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
  var STACK_TRACE_LIMIT = 'stackTraceLimit';
  var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
  var path = FULL_NAME.split('.');
  var ERROR_NAME = path[path.length - 1];
  var OriginalError = getBuiltIn.apply(null, path);

  if (!OriginalError) return;

  var OriginalErrorPrototype = OriginalError.prototype;

  // V8 9.3- bug https://bugs.chromium.org/p/v8/issues/detail?id=12006
  if (!IS_PURE && hasOwn(OriginalErrorPrototype, 'cause')) delete OriginalErrorPrototype.cause;

  if (!FORCED) return OriginalError;

  var BaseError = getBuiltIn('Error');

  var WrappedError = wrapper(function (a, b) {
    var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, undefined);
    var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
    if (message !== undefined) createNonEnumerableProperty(result, 'message', message);
    installErrorStack(result, WrappedError, result.stack, 2);
    if (this && isPrototypeOf(OriginalErrorPrototype, this)) inheritIfRequired(result, this, WrappedError);
    if (arguments.length > OPTIONS_POSITION) installErrorCause(result, arguments[OPTIONS_POSITION]);
    return result;
  });

  WrappedError.prototype = OriginalErrorPrototype;

  if (ERROR_NAME !== 'Error') {
    if (setPrototypeOf) setPrototypeOf(WrappedError, BaseError);
    else copyConstructorProperties(WrappedError, BaseError, { name: true });
  } else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {
    proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);
    proxyAccessor(WrappedError, OriginalError, 'prepareStackTrace');
  }

  copyConstructorProperties(WrappedError, OriginalError);

  if (!IS_PURE) try {
    // Safari 13- bug: WebAssembly errors does not have a proper `.name`
    if (OriginalErrorPrototype.name !== ERROR_NAME) {
      createNonEnumerableProperty(OriginalErrorPrototype, 'name', ERROR_NAME);
    }
    OriginalErrorPrototype.constructor = WrappedError;
  } catch (error) { /* empty */ }

  return WrappedError;
};


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.concat.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.concat.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var doesNotExceedSafeInteger = __webpack_require__(/*! ../internals/does-not-exceed-safe-integer */ "./node_modules/core-js/internals/does-not-exceed-safe-integer.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var V8_VERSION = __webpack_require__(/*! ../internals/environment-v8-version */ "./node_modules/core-js/internals/environment-v8-version.js");

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike(E);
        doesNotExceedSafeInteger(n + len);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        doesNotExceedSafeInteger(n + 1);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.every.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.every.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $every = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").every);
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js/internals/array-method-is-strict.js");

var STRICT_METHOD = arrayMethodIsStrict('every');

// `Array.prototype.every` method
// https://tc39.es/ecma262/#sec-array.prototype.every
$({ target: 'Array', proto: true, forced: !STRICT_METHOD }, {
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.for-each.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.for-each.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var forEach = __webpack_require__(/*! ../internals/array-for-each */ "./node_modules/core-js/internals/array-for-each.js");

// `Array.prototype.forEach` method
// https://tc39.es/ecma262/#sec-array.prototype.foreach
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
$({ target: 'Array', proto: true, forced: [].forEach !== forEach }, {
  forEach: forEach
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.from.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.from.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var from = __webpack_require__(/*! ../internals/array-from */ "./node_modules/core-js/internals/array-from.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  // eslint-disable-next-line es/no-array-from -- required for testing
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.includes.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.includes.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $includes = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").includes);
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

// FF99+ bug
var BROKEN_ON_SPARSE = fails(function () {
  // eslint-disable-next-line es/no-array-prototype-includes -- detection
  return !Array(1).includes();
});

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.index-of.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.index-of.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


/* eslint-disable es/no-array-prototype-indexof -- required for testing */
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this-clause */ "./node_modules/core-js/internals/function-uncurry-this-clause.js");
var $indexOf = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf);
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js/internals/array-method-is-strict.js");

var nativeIndexOf = uncurryThis([].indexOf);

var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict('indexOf');

// `Array.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.indexof
$({ target: 'Array', proto: true, forced: FORCED }, {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? nativeIndexOf(this, searchElement, fromIndex) || 0
      : $indexOf(this, searchElement, fromIndex);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.is-array.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.is-array.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");

// `Array.isArray` method
// https://tc39.es/ecma262/#sec-array.isarray
$({ target: 'Array', stat: true }, {
  isArray: isArray
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.iterator.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var defineIterator = __webpack_require__(/*! ../internals/iterator-define */ "./node_modules/core-js/internals/iterator-define.js");
var createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js/internals/create-iter-result-object.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = null;
    return createIterResultObject(undefined, true);
  }
  switch (state.kind) {
    case 'keys': return createIterResultObject(index, false);
    case 'values': return createIterResultObject(target[index], false);
  } return createIterResultObject([index, target[index]], false);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
  defineProperty(values, 'name', { value: 'values' });
} catch (error) { /* empty */ }


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.push.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.push.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var setArrayLength = __webpack_require__(/*! ../internals/array-set-length */ "./node_modules/core-js/internals/array-set-length.js");
var doesNotExceedSafeInteger = __webpack_require__(/*! ../internals/does-not-exceed-safe-integer */ "./node_modules/core-js/internals/does-not-exceed-safe-integer.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var INCORRECT_TO_LENGTH = fails(function () {
  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;
});

// V8 <= 121 and Safari <= 15.4; FF < 23 throws InternalError
// https://bugs.chromium.org/p/v8/issues/detail?id=12681
var properErrorOnNonWritableLength = function () {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).push();
  } catch (error) {
    return error instanceof TypeError;
  }
};

var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();

// `Array.prototype.push` method
// https://tc39.es/ecma262/#sec-array.prototype.push
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var argCount = arguments.length;
    doesNotExceedSafeInteger(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O[len] = arguments[i];
      len++;
    }
    setArrayLength(O, len);
    return len;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.slice.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.slice.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");
var nativeSlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js/internals/array-slice.js");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');

var SPECIES = wellKnownSymbol('species');
var $Array = Array;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = lengthOfArrayLike(O);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (isConstructor(Constructor) && (Constructor === $Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === $Array || Constructor === undefined) {
        return nativeSlice(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? $Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.date.to-json.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.date.to-json.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");

var FORCED = fails(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
});

// `Date.prototype.toJSON` method
// https://tc39.es/ecma262/#sec-date.prototype.tojson
$({ target: 'Date', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O, 'number');
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.date.to-primitive.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.date.to-primitive.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var dateToPrimitive = __webpack_require__(/*! ../internals/date-to-primitive */ "./node_modules/core-js/internals/date-to-primitive.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var DatePrototype = Date.prototype;

// `Date.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive
if (!hasOwn(DatePrototype, TO_PRIMITIVE)) {
  defineBuiltIn(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.date.to-string.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.date.to-string.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


// TODO: Remove from `core-js@4`
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");

var DatePrototype = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var nativeDateToString = uncurryThis(DatePrototype[TO_STRING]);
var thisTimeValue = uncurryThis(DatePrototype.getTime);

// `Date.prototype.toString` method
// https://tc39.es/ecma262/#sec-date.prototype.tostring
if (String(new Date(NaN)) !== INVALID_DATE) {
  defineBuiltIn(DatePrototype, TO_STRING, function toString() {
    var value = thisTimeValue(this);
    // eslint-disable-next-line no-self-compare -- NaN check
    return value === value ? nativeDateToString(this) : INVALID_DATE;
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.error.cause.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.error.cause.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


/* eslint-disable no-unused-vars -- required for functions `.length` */
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
var wrapErrorConstructorWithCause = __webpack_require__(/*! ../internals/wrap-error-constructor-with-cause */ "./node_modules/core-js/internals/wrap-error-constructor-with-cause.js");

var WEB_ASSEMBLY = 'WebAssembly';
var WebAssembly = globalThis[WEB_ASSEMBLY];

// eslint-disable-next-line es/no-error-cause -- feature detection
var FORCED = new Error('e', { cause: 7 }).cause !== 7;

var exportGlobalErrorCauseWrapper = function (ERROR_NAME, wrapper) {
  var O = {};
  O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
  $({ global: true, constructor: true, arity: 1, forced: FORCED }, O);
};

var exportWebAssemblyErrorCauseWrapper = function (ERROR_NAME, wrapper) {
  if (WebAssembly && WebAssembly[ERROR_NAME]) {
    var O = {};
    O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + '.' + ERROR_NAME, wrapper, FORCED);
    $({ target: WEB_ASSEMBLY, stat: true, constructor: true, arity: 1, forced: FORCED }, O);
  }
};

// https://tc39.es/ecma262/#sec-nativeerror
exportGlobalErrorCauseWrapper('Error', function (init) {
  return function Error(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('EvalError', function (init) {
  return function EvalError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('RangeError', function (init) {
  return function RangeError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('ReferenceError', function (init) {
  return function ReferenceError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('SyntaxError', function (init) {
  return function SyntaxError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('TypeError', function (init) {
  return function TypeError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('URIError', function (init) {
  return function URIError(message) { return apply(init, this, arguments); };
});
exportWebAssemblyErrorCauseWrapper('CompileError', function (init) {
  return function CompileError(message) { return apply(init, this, arguments); };
});
exportWebAssemblyErrorCauseWrapper('LinkError', function (init) {
  return function LinkError(message) { return apply(init, this, arguments); };
});
exportWebAssemblyErrorCauseWrapper('RuntimeError', function (init) {
  return function RuntimeError(message) { return apply(init, this, arguments); };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.error.to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.error.to-string.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var errorToString = __webpack_require__(/*! ../internals/error-to-string */ "./node_modules/core-js/internals/error-to-string.js");

var ErrorPrototype = Error.prototype;

// `Error.prototype.toString` method fix
// https://tc39.es/ecma262/#sec-error.prototype.tostring
if (ErrorPrototype.toString !== errorToString) {
  defineBuiltIn(ErrorPrototype, 'toString', errorToString);
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.function.bind.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.function.bind.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind */ "./node_modules/core-js/internals/function-bind.js");

// `Function.prototype.bind` method
// https://tc39.es/ecma262/#sec-function.prototype.bind
// eslint-disable-next-line es/no-function-prototype-bind -- detection
$({ target: 'Function', proto: true, forced: Function.bind !== bind }, {
  bind: bind
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.function.name.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.function.name.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var FUNCTION_NAME_EXISTS = (__webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js").EXISTS);
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");

var FunctionPrototype = Function.prototype;
var functionToString = uncurryThis(FunctionPrototype.toString);
var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
var regExpExec = uncurryThis(nameRE.exec);
var NAME = 'name';

// Function instances `.name` property
// https://tc39.es/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
  defineBuiltInAccessor(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return regExpExec(nameRE, functionToString(this))[1];
      } catch (error) {
        return '';
      }
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.iterator.constructor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.iterator.constructor.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var IteratorPrototype = (__webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype);
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var CONSTRUCTOR = 'constructor';
var ITERATOR = 'Iterator';
var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var $TypeError = TypeError;
var NativeIterator = globalThis[ITERATOR];

// FF56- have non-standard global helper `Iterator`
var FORCED = IS_PURE
  || !isCallable(NativeIterator)
  || NativeIterator.prototype !== IteratorPrototype
  // FF44- non-standard `Iterator` passes previous tests
  || !fails(function () { NativeIterator({}); });

var IteratorConstructor = function Iterator() {
  anInstance(this, IteratorPrototype);
  if (getPrototypeOf(this) === IteratorPrototype) throw new $TypeError('Abstract class Iterator not directly constructable');
};

var defineIteratorPrototypeAccessor = function (key, value) {
  if (DESCRIPTORS) {
    defineBuiltInAccessor(IteratorPrototype, key, {
      configurable: true,
      get: function () {
        return value;
      },
      set: function (replacement) {
        anObject(this);
        if (this === IteratorPrototype) throw new $TypeError("You can't redefine this property");
        if (hasOwn(this, key)) this[key] = replacement;
        else createProperty(this, key, replacement);
      }
    });
  } else IteratorPrototype[key] = value;
};

if (!hasOwn(IteratorPrototype, TO_STRING_TAG)) defineIteratorPrototypeAccessor(TO_STRING_TAG, ITERATOR);

if (FORCED || !hasOwn(IteratorPrototype, CONSTRUCTOR) || IteratorPrototype[CONSTRUCTOR] === Object) {
  defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);
}

IteratorConstructor.prototype = IteratorPrototype;

// `Iterator` constructor
// https://tc39.es/ecma262/#sec-iterator
$({ global: true, constructor: true, forced: FORCED }, {
  Iterator: IteratorConstructor
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.iterator.every.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.iterator.every.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getIteratorDirect = __webpack_require__(/*! ../internals/get-iterator-direct */ "./node_modules/core-js/internals/get-iterator-direct.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");
var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__(/*! ../internals/iterator-helper-without-closing-on-early-error */ "./node_modules/core-js/internals/iterator-helper-without-closing-on-early-error.js");

var everyWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError('every', TypeError);

// `Iterator.prototype.every` method
// https://tc39.es/ecma262/#sec-iterator.prototype.every
$({ target: 'Iterator', proto: true, real: true, forced: everyWithoutClosingOnEarlyError }, {
  every: function every(predicate) {
    anObject(this);
    try {
      aCallable(predicate);
    } catch (error) {
      iteratorClose(this, 'throw', error);
    }

    if (everyWithoutClosingOnEarlyError) return call(everyWithoutClosingOnEarlyError, this, predicate);

    var record = getIteratorDirect(this);
    var counter = 0;
    return !iterate(record, function (value, stop) {
      if (!predicate(value, counter++)) return stop();
    }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.iterator.for-each.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.iterator.for-each.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getIteratorDirect = __webpack_require__(/*! ../internals/get-iterator-direct */ "./node_modules/core-js/internals/get-iterator-direct.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");
var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__(/*! ../internals/iterator-helper-without-closing-on-early-error */ "./node_modules/core-js/internals/iterator-helper-without-closing-on-early-error.js");

var forEachWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError('forEach', TypeError);

// `Iterator.prototype.forEach` method
// https://tc39.es/ecma262/#sec-iterator.prototype.foreach
$({ target: 'Iterator', proto: true, real: true, forced: forEachWithoutClosingOnEarlyError }, {
  forEach: function forEach(fn) {
    anObject(this);
    try {
      aCallable(fn);
    } catch (error) {
      iteratorClose(this, 'throw', error);
    }

    if (forEachWithoutClosingOnEarlyError) return call(forEachWithoutClosingOnEarlyError, this, fn);

    var record = getIteratorDirect(this);
    var counter = 0;
    iterate(record, function (value) {
      fn(value, counter++);
    }, { IS_RECORD: true });
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.json.stringify.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.json.stringify.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js/internals/array-slice.js");
var getReplacerFunction = __webpack_require__(/*! ../internals/get-json-replacer-function */ "./node_modules/core-js/internals/get-json-replacer-function.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");

var $String = String;
var $stringify = getBuiltIn('JSON', 'stringify');
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var replace = uncurryThis(''.replace);
var numberToString = uncurryThis(1.0.toString);

var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
  var symbol = getBuiltIn('Symbol')('stringify detection');
  // MS Edge converts symbol values to JSON as {}
  return $stringify([symbol]) !== '[null]'
    // WebKit converts symbol values to JSON as null
    || $stringify({ a: symbol }) !== '{}'
    // V8 throws on boxed symbols
    || $stringify(Object(symbol)) !== '{}';
});

// https://github.com/tc39/proposal-well-formed-stringify
var ILL_FORMED_UNICODE = fails(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
    || $stringify('\uDEAD') !== '"\\udead"';
});

var stringifyWithSymbolsFix = function (it, replacer) {
  var args = arraySlice(arguments);
  var $replacer = getReplacerFunction(replacer);
  if (!isCallable($replacer) && (it === undefined || isSymbol(it))) return; // IE8 returns string on undefined
  args[1] = function (key, value) {
    // some old implementations (like WebKit) could pass numbers as keys
    if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
    if (!isSymbol(value)) return value;
  };
  return apply($stringify, null, args);
};

var fixIllFormed = function (match, offset, string) {
  var prev = charAt(string, offset - 1);
  var next = charAt(string, offset + 1);
  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  } return match;
};

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  $({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice(arguments);
      var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.constructor.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var getOwnPropertyNames = (__webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f);
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var thisNumberValue = __webpack_require__(/*! ../internals/this-number-value */ "./node_modules/core-js/internals/this-number-value.js");
var trim = (__webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js").trim);

var NUMBER = 'Number';
var NativeNumber = globalThis[NUMBER];
var PureNumberNamespace = path[NUMBER];
var NumberPrototype = NativeNumber.prototype;
var TypeError = globalThis.TypeError;
var stringSlice = uncurryThis(''.slice);
var charCodeAt = uncurryThis(''.charCodeAt);

// `ToNumeric` abstract operation
// https://tc39.es/ecma262/#sec-tonumeric
var toNumeric = function (value) {
  var primValue = toPrimitive(value, 'number');
  return typeof primValue == 'bigint' ? primValue : toNumber(primValue);
};

// `ToNumber` abstract operation
// https://tc39.es/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, 'number');
  var first, third, radix, maxCode, digits, length, index, code;
  if (isSymbol(it)) throw new TypeError('Cannot convert a Symbol value to a number');
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = charCodeAt(it, 0);
    if (first === 43 || first === 45) {
      third = charCodeAt(it, 2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (charCodeAt(it, 1)) {
        // fast equal of /^0b[01]+$/i
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal of /^0o[0-7]+$/i
        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        default:
          return +it;
      }
      digits = stringSlice(it, 2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = charCodeAt(digits, index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

var FORCED = isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'));

var calledWithNew = function (dummy) {
  // includes check on 1..constructor(foo) case
  return isPrototypeOf(NumberPrototype, dummy) && fails(function () { thisNumberValue(dummy); });
};

// `Number` constructor
// https://tc39.es/ecma262/#sec-number-constructor
var NumberWrapper = function Number(value) {
  var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
  return calledWithNew(this) ? inheritIfRequired(Object(n), this, NumberWrapper) : n;
};

NumberWrapper.prototype = NumberPrototype;
if (FORCED && !IS_PURE) NumberPrototype.constructor = NumberWrapper;

$({ global: true, constructor: true, wrap: true, forced: FORCED }, {
  Number: NumberWrapper
});

// Use `internal/copy-constructor-properties` helper in `core-js@4`
var copyConstructorProperties = function (target, source) {
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(source) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,' +
    // ESNext
    'fromString,range'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (hasOwn(source, key = keys[j]) && !hasOwn(target, key)) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};

if (IS_PURE && PureNumberNamespace) copyConstructorProperties(path[NUMBER], PureNumberNamespace);
if (FORCED || IS_PURE) copyConstructorProperties(path[NUMBER], NativeNumber);


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.is-integer.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.is-integer.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isIntegralNumber = __webpack_require__(/*! ../internals/is-integral-number */ "./node_modules/core-js/internals/is-integral-number.js");

// `Number.isInteger` method
// https://tc39.es/ecma262/#sec-number.isinteger
$({ target: 'Number', stat: true }, {
  isInteger: isIntegralNumber
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.create.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.create.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


// TODO: Remove from `core-js@4`
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  create: create
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.define-property.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.define-property.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
// eslint-disable-next-line es/no-object-defineproperty -- safe
$({ target: 'Object', stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
  defineProperty: defineProperty
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.entries.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.entries.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $entries = (__webpack_require__(/*! ../internals/object-to-array */ "./node_modules/core-js/internals/object-to-array.js").entries);

// `Object.entries` method
// https://tc39.es/ecma262/#sec-object.entries
$({ target: 'Object', stat: true }, {
  entries: function entries(O) {
    return $entries(O);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-own-property-descriptor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-own-property-descriptor.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var nativeGetOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var FORCED = !DESCRIPTORS || fails(function () { nativeGetOwnPropertyDescriptor(1); });

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-own-property-symbols.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-own-property-symbols.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FORCED = !NATIVE_SYMBOL || fails(function () { getOwnPropertySymbolsModule.f(1); });

// `Object.getOwnPropertySymbols` method
// https://tc39.es/ecma262/#sec-object.getownpropertysymbols
$({ target: 'Object', stat: true, forced: FORCED }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-prototype-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-prototype-of.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var nativeGetPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});



/***/ }),

/***/ "./node_modules/core-js/modules/es.object.keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.keys.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var nativeKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.set-prototype-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.set-prototype-of.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
$({ target: 'Object', stat: true }, {
  setPrototypeOf: setPrototypeOf
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var toString = __webpack_require__(/*! ../internals/object-to-string */ "./node_modules/core-js/internals/object-to-string.js");

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  defineBuiltIn(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.values.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.values.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $values = (__webpack_require__(/*! ../internals/object-to-array */ "./node_modules/core-js/internals/object-to-array.js").values);

// `Object.values` method
// https://tc39.es/ecma262/#sec-object.values
$({ target: 'Object', stat: true }, {
  values: function values(O) {
    return $values(O);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.parse-int.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.parse-int.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $parseInt = __webpack_require__(/*! ../internals/number-parse-int */ "./node_modules/core-js/internals/number-parse-int.js");

// `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix
$({ global: true, forced: parseInt !== $parseInt }, {
  parseInt: $parseInt
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.construct.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.construct.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
var bind = __webpack_require__(/*! ../internals/function-bind */ "./node_modules/core-js/internals/function-bind.js");
var aConstructor = __webpack_require__(/*! ../internals/a-constructor */ "./node_modules/core-js/internals/a-constructor.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var nativeConstruct = getBuiltIn('Reflect', 'construct');
var ObjectPrototype = Object.prototype;
var push = [].push;

// `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});

var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});

var FORCED = NEW_TARGET_BUG || ARGS_BUG;

$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
  construct: function construct(Target, args /* , newTarget */) {
    aConstructor(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target === newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      apply(push, $args, args);
      return new (apply(bind, Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : ObjectPrototype);
    var result = apply(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.get.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.get.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isDataDescriptor = __webpack_require__(/*! ../internals/is-data-descriptor */ "./node_modules/core-js/internals/is-data-descriptor.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");

// `Reflect.get` method
// https://tc39.es/ecma262/#sec-reflect.get
function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject(target) === receiver) return target[propertyKey];
  descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);
  if (descriptor) return isDataDescriptor(descriptor)
    ? descriptor.value
    : descriptor.get === undefined ? undefined : call(descriptor.get, receiver);
  if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
}

$({ target: 'Reflect', stat: true }, {
  get: get
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.to-string-tag.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.to-string-tag.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");

$({ global: true }, { Reflect: {} });

// Reflect[@@toStringTag] property
// https://tc39.es/ecma262/#sec-reflect-@@tostringtag
setToStringTag(globalThis.Reflect, 'Reflect', true);


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.exec.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.exec.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var exec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.test.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.test.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__(/*! ../modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");

var DELEGATES_TO_EXEC = function () {
  var execCalled = false;
  var re = /[ac]/;
  re.exec = function () {
    execCalled = true;
    return /./.exec.apply(this, arguments);
  };
  return re.test('abc') === true && execCalled;
}();

var nativeTest = /./.test;

// `RegExp.prototype.test` method
// https://tc39.es/ecma262/#sec-regexp.prototype.test
$({ target: 'RegExp', proto: true, forced: !DELEGATES_TO_EXEC }, {
  test: function (S) {
    var R = anObject(this);
    var string = toString(S);
    var exec = R.exec;
    if (!isCallable(exec)) return call(nativeTest, R, string);
    var result = call(exec, R, string);
    if (result === null) return false;
    anObject(result);
    return true;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.to-string.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var PROPER_FUNCTION_NAME = (__webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js").PROPER);
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var $toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var getRegExpFlags = __webpack_require__(/*! ../internals/regexp-get-flags */ "./node_modules/core-js/internals/regexp-get-flags.js");

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) !== '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  defineBuiltIn(RegExpPrototype, TO_STRING, function toString() {
    var R = anObject(this);
    var pattern = $toString(R.source);
    var flags = $toString(getRegExpFlags(R));
    return '/' + pattern + '/' + flags;
  }, { unsafe: true });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.from-code-point.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.from-code-point.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");

var $RangeError = RangeError;
var fromCharCode = String.fromCharCode;
// eslint-disable-next-line es/no-string-fromcodepoint -- required for testing
var $fromCodePoint = String.fromCodePoint;
var join = uncurryThis([].join);

// length should be 1, old FF problem
var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length !== 1;

// `String.fromCodePoint` method
// https://tc39.es/ecma262/#sec-string.fromcodepoint
$({ target: 'String', stat: true, arity: 1, forced: INCORRECT_LENGTH }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  fromCodePoint: function fromCodePoint(x) {
    var elements = [];
    var length = arguments.length;
    var i = 0;
    var code;
    while (length > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw new $RangeError(code + ' is not a valid code point');
      elements[i] = code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00);
    } return join(elements, '');
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.includes.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.includes.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var notARegExp = __webpack_require__(/*! ../internals/not-a-regexp */ "./node_modules/core-js/internals/not-a-regexp.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var correctIsRegExpLogic = __webpack_require__(/*! ../internals/correct-is-regexp-logic */ "./node_modules/core-js/internals/correct-is-regexp-logic.js");

var stringIndexOf = uncurryThis(''.indexOf);

// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~stringIndexOf(
      toString(requireObjectCoercible(this)),
      toString(notARegExp(searchString)),
      arguments.length > 1 ? arguments[1] : undefined
    );
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.iterator.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var charAt = (__webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").charAt);
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var defineIterator = __webpack_require__(/*! ../internals/iterator-define */ "./node_modules/core-js/internals/iterator-define.js");
var createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js/internals/create-iter-result-object.js");

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: toString(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return createIterResultObject(undefined, true);
  point = charAt(string, index);
  state.index += point.length;
  return createIterResultObject(point, false);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.search.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.search.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var fixRegExpWellKnownSymbolLogic = __webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var sameValue = __webpack_require__(/*! ../internals/same-value */ "./node_modules/core-js/internals/same-value.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");

// @@search logic
fixRegExpWellKnownSymbolLogic('search', function (SEARCH, nativeSearch, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.es/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = requireObjectCoercible(this);
      var searcher = isObject(regexp) ? getMethod(regexp, SEARCH) : undefined;
      return searcher ? call(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
    function (string) {
      var rx = anObject(this);
      var S = toString(string);
      var res = maybeCallNative(nativeSearch, rx, S);

      if (res.done) return res.value;

      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.substr.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.substr.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");

var stringSlice = uncurryThis(''.slice);
var max = Math.max;
var min = Math.min;

// eslint-disable-next-line unicorn/prefer-string-slice -- required for testing
var FORCED = !''.substr || 'ab'.substr(-1) !== 'b';

// `String.prototype.substr` method
// https://tc39.es/ecma262/#sec-string.prototype.substr
$({ target: 'String', proto: true, forced: FORCED }, {
  substr: function substr(start, length) {
    var that = toString(requireObjectCoercible(this));
    var size = that.length;
    var intStart = toIntegerOrInfinity(start);
    var intLength, intEnd;
    if (intStart === Infinity) intStart = 0;
    if (intStart < 0) intStart = max(size + intStart, 0);
    intLength = length === undefined ? size : toIntegerOrInfinity(length);
    if (intLength <= 0 || intLength === Infinity) return '';
    intEnd = min(intStart + intLength, size);
    return intStart >= intEnd ? '' : stringSlice(that, intStart, intEnd);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.constructor.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var $toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var nativeObjectCreate = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertyNamesExternal = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js/internals/object-get-own-property-names-external.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var definePropertiesModule = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/well-known-symbol-wrapped */ "./node_modules/core-js/internals/well-known-symbol-wrapped.js");
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js/internals/well-known-symbol-define.js");
var defineSymbolToPrimitive = __webpack_require__(/*! ../internals/symbol-define-to-primitive */ "./node_modules/core-js/internals/symbol-define-to-primitive.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var $forEach = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").forEach);

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';

var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);

var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = globalThis.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var RangeError = globalThis.RangeError;
var TypeError = globalThis.TypeError;
var QObject = globalThis.QObject;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push = uncurryThis([].push);

var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var WellKnownSymbolsStore = shared('wks');

// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var fallbackDefineProperty = function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
};

var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a !== 7;
}) ? fallbackDefineProperty : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPropertyKey(P);
  anObject(Attributes);
  if (hasOwn(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, nativeObjectCreate(null)));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPropertyKey(V);
  var enumerable = call(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P]
    ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
  });
  return result;
};

var $getOwnPropertySymbols = function (O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
      push(result, AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (isPrototypeOf(SymbolPrototype, this)) throw new TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      var $this = this === undefined ? globalThis : this;
      if ($this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
      if (hasOwn($this, HIDDEN) && hasOwn($this[HIDDEN], tag)) $this[HIDDEN][tag] = false;
      var descriptor = createPropertyDescriptor(1, value);
      try {
        setSymbolDescriptor($this, tag, descriptor);
      } catch (error) {
        if (!(error instanceof RangeError)) throw error;
        fallbackDefineProperty($this, tag, descriptor);
      }
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  SymbolPrototype = $Symbol[PROTOTYPE];

  defineBuiltIn(SymbolPrototype, 'toString', function toString() {
    return getInternalState(this).tag;
  });

  defineBuiltIn($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    defineBuiltInAccessor(SymbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      defineBuiltIn(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames
});

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.description.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.description.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// `Symbol.prototype.description` getter
// https://tc39.es/ecma262/#sec-symbol.prototype.description

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");

var NativeSymbol = globalThis.Symbol;
var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;

if (DESCRIPTORS && isCallable(NativeSymbol) && (!('description' in SymbolPrototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString(arguments[0]);
    var result = isPrototypeOf(SymbolPrototype, this)
      // eslint-disable-next-line sonarjs/inconsistent-function-call -- ok
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };

  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  SymbolWrapper.prototype = SymbolPrototype;
  SymbolPrototype.constructor = SymbolWrapper;

  var NATIVE_SYMBOL = String(NativeSymbol('description detection')) === 'Symbol(description detection)';
  var thisSymbolValue = uncurryThis(SymbolPrototype.valueOf);
  var symbolDescriptiveString = uncurryThis(SymbolPrototype.toString);
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  var replace = uncurryThis(''.replace);
  var stringSlice = uncurryThis(''.slice);

  defineBuiltInAccessor(SymbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = thisSymbolValue(this);
      if (hasOwn(EmptyStringDescriptionStore, symbol)) return '';
      var string = symbolDescriptiveString(symbol);
      var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, constructor: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.for.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.for.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(/*! ../internals/symbol-registry-detection */ "./node_modules/core-js/internals/symbol-registry-detection.js");

var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.for` method
// https://tc39.es/ecma262/#sec-symbol.for
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  'for': function (key) {
    var string = toString(key);
    if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = getBuiltIn('Symbol')(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.iterator.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js/internals/well-known-symbol-define.js");

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(/*! ../modules/es.symbol.constructor */ "./node_modules/core-js/modules/es.symbol.constructor.js");
__webpack_require__(/*! ../modules/es.symbol.for */ "./node_modules/core-js/modules/es.symbol.for.js");
__webpack_require__(/*! ../modules/es.symbol.key-for */ "./node_modules/core-js/modules/es.symbol.key-for.js");
__webpack_require__(/*! ../modules/es.json.stringify */ "./node_modules/core-js/modules/es.json.stringify.js");
__webpack_require__(/*! ../modules/es.object.get-own-property-symbols */ "./node_modules/core-js/modules/es.object.get-own-property-symbols.js");


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.key-for.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.key-for.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(/*! ../internals/symbol-registry-detection */ "./node_modules/core-js/internals/symbol-registry-detection.js");

var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.keyFor` method
// https://tc39.es/ecma262/#sec-symbol.keyfor
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw new TypeError(tryToString(sym) + ' is not a symbol');
    if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.to-primitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.to-primitive.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js/internals/well-known-symbol-define.js");
var defineSymbolToPrimitive = __webpack_require__(/*! ../internals/symbol-define-to-primitive */ "./node_modules/core-js/internals/symbol-define-to-primitive.js");

// `Symbol.toPrimitive` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.toprimitive
defineWellKnownSymbol('toPrimitive');

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.iterator.constructor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.iterator.constructor.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


// TODO: Remove from `core-js@4`
__webpack_require__(/*! ../modules/es.iterator.constructor */ "./node_modules/core-js/modules/es.iterator.constructor.js");


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.iterator.every.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.iterator.every.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


// TODO: Remove from `core-js@4`
__webpack_require__(/*! ../modules/es.iterator.every */ "./node_modules/core-js/modules/es.iterator.every.js");


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.iterator.for-each.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.iterator.for-each.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


// TODO: Remove from `core-js@4`
__webpack_require__(/*! ../modules/es.iterator.for-each */ "./node_modules/core-js/modules/es.iterator.for-each.js");


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom-collections.for-each.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.for-each.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");
var DOMTokenListPrototype = __webpack_require__(/*! ../internals/dom-token-list-prototype */ "./node_modules/core-js/internals/dom-token-list-prototype.js");
var forEach = __webpack_require__(/*! ../internals/array-for-each */ "./node_modules/core-js/internals/array-for-each.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

var handlePrototype = function (CollectionPrototype) {
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
};

for (var COLLECTION_NAME in DOMIterables) {
  if (DOMIterables[COLLECTION_NAME]) {
    handlePrototype(globalThis[COLLECTION_NAME] && globalThis[COLLECTION_NAME].prototype);
  }
}

handlePrototype(DOMTokenListPrototype);


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom-collections.iterator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");
var DOMTokenListPrototype = __webpack_require__(/*! ../internals/dom-token-list-prototype */ "./node_modules/core-js/internals/dom-token-list-prototype.js");
var ArrayIteratorMethods = __webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayValues = ArrayIteratorMethods.values;

var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    setToStringTag(CollectionPrototype, COLLECTION_NAME, true);
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
};

for (var COLLECTION_NAME in DOMIterables) {
  handlePrototype(globalThis[COLLECTION_NAME] && globalThis[COLLECTION_NAME].prototype, COLLECTION_NAME);
}

handlePrototype(DOMTokenListPrototype, 'DOMTokenList');


/***/ }),

/***/ "./node_modules/core-js/modules/web.set-interval.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/web.set-interval.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var schedulersFix = __webpack_require__(/*! ../internals/schedulers-fix */ "./node_modules/core-js/internals/schedulers-fix.js");

var setInterval = schedulersFix(globalThis.setInterval, true);

// Bun / IE9- setInterval additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
$({ global: true, bind: true, forced: globalThis.setInterval !== setInterval }, {
  setInterval: setInterval
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.set-timeout.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/web.set-timeout.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var schedulersFix = __webpack_require__(/*! ../internals/schedulers-fix */ "./node_modules/core-js/internals/schedulers-fix.js");

var setTimeout = schedulersFix(globalThis.setTimeout, true);

// Bun / IE9- setTimeout additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
$({ global: true, bind: true, forced: globalThis.setTimeout !== setTimeout }, {
  setTimeout: setTimeout
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.timers.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/web.timers.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(/*! ../modules/web.set-interval */ "./node_modules/core-js/modules/web.set-interval.js");
__webpack_require__(/*! ../modules/web.set-timeout */ "./node_modules/core-js/modules/web.set-timeout.js");


/***/ }),

/***/ "./node_modules/core-js/modules/web.url-search-params.constructor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/modules/web.url-search-params.constructor.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
__webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
__webpack_require__(/*! ../modules/es.string.from-code-point */ "./node_modules/core-js/modules/es.string.from-code-point.js");
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var safeGetBuiltIn = __webpack_require__(/*! ../internals/safe-get-built-in */ "./node_modules/core-js/internals/safe-get-built-in.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var USE_NATIVE_URL = __webpack_require__(/*! ../internals/url-constructor-detection */ "./node_modules/core-js/internals/url-constructor-detection.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/iterator-create-constructor */ "./node_modules/core-js/internals/iterator-create-constructor.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var $toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");
var createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js/internals/create-iter-result-object.js");
var validateArgumentsLength = __webpack_require__(/*! ../internals/validate-arguments-length */ "./node_modules/core-js/internals/validate-arguments-length.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var arraySort = __webpack_require__(/*! ../internals/array-sort */ "./node_modules/core-js/internals/array-sort.js");

var ITERATOR = wellKnownSymbol('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);

var nativeFetch = safeGetBuiltIn('fetch');
var NativeRequest = safeGetBuiltIn('Request');
var Headers = safeGetBuiltIn('Headers');
var RequestPrototype = NativeRequest && NativeRequest.prototype;
var HeadersPrototype = Headers && Headers.prototype;
var TypeError = globalThis.TypeError;
var encodeURIComponent = globalThis.encodeURIComponent;
var fromCharCode = String.fromCharCode;
var fromCodePoint = getBuiltIn('String', 'fromCodePoint');
var $parseInt = parseInt;
var charAt = uncurryThis(''.charAt);
var join = uncurryThis([].join);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var shift = uncurryThis([].shift);
var splice = uncurryThis([].splice);
var split = uncurryThis(''.split);
var stringSlice = uncurryThis(''.slice);
var exec = uncurryThis(/./.exec);

var plus = /\+/g;
var FALLBACK_REPLACER = '\uFFFD';
var VALID_HEX = /^[0-9a-f]+$/i;

var parseHexOctet = function (string, start) {
  var substr = stringSlice(string, start, start + 2);
  if (!exec(VALID_HEX, substr)) return NaN;

  return $parseInt(substr, 16);
};

var getLeadingOnes = function (octet) {
  var count = 0;
  for (var mask = 0x80; mask > 0 && (octet & mask) !== 0; mask >>= 1) {
    count++;
  }
  return count;
};

var utf8Decode = function (octets) {
  var codePoint = null;

  switch (octets.length) {
    case 1:
      codePoint = octets[0];
      break;
    case 2:
      codePoint = (octets[0] & 0x1F) << 6 | (octets[1] & 0x3F);
      break;
    case 3:
      codePoint = (octets[0] & 0x0F) << 12 | (octets[1] & 0x3F) << 6 | (octets[2] & 0x3F);
      break;
    case 4:
      codePoint = (octets[0] & 0x07) << 18 | (octets[1] & 0x3F) << 12 | (octets[2] & 0x3F) << 6 | (octets[3] & 0x3F);
      break;
  }

  return codePoint > 0x10FFFF ? null : codePoint;
};

var decode = function (input) {
  input = replace(input, plus, ' ');
  var length = input.length;
  var result = '';
  var i = 0;

  while (i < length) {
    var decodedChar = charAt(input, i);

    if (decodedChar === '%') {
      if (charAt(input, i + 1) === '%' || i + 3 > length) {
        result += '%';
        i++;
        continue;
      }

      var octet = parseHexOctet(input, i + 1);

      // eslint-disable-next-line no-self-compare -- NaN check
      if (octet !== octet) {
        result += decodedChar;
        i++;
        continue;
      }

      i += 2;
      var byteSequenceLength = getLeadingOnes(octet);

      if (byteSequenceLength === 0) {
        decodedChar = fromCharCode(octet);
      } else {
        if (byteSequenceLength === 1 || byteSequenceLength > 4) {
          result += FALLBACK_REPLACER;
          i++;
          continue;
        }

        var octets = [octet];
        var sequenceIndex = 1;

        while (sequenceIndex < byteSequenceLength) {
          i++;
          if (i + 3 > length || charAt(input, i) !== '%') break;

          var nextByte = parseHexOctet(input, i + 1);

          // eslint-disable-next-line no-self-compare -- NaN check
          if (nextByte !== nextByte) {
            i += 3;
            break;
          }
          if (nextByte > 191 || nextByte < 128) break;

          push(octets, nextByte);
          i += 2;
          sequenceIndex++;
        }

        if (octets.length !== byteSequenceLength) {
          result += FALLBACK_REPLACER;
          continue;
        }

        var codePoint = utf8Decode(octets);
        if (codePoint === null) {
          result += FALLBACK_REPLACER;
        } else {
          decodedChar = fromCodePoint(codePoint);
        }
      }
    }

    result += decodedChar;
    i++;
  }

  return result;
};

var find = /[!'()~]|%20/g;

var replacements = {
  '!': '%21',
  "'": '%27',
  '(': '%28',
  ')': '%29',
  '~': '%7E',
  '%20': '+'
};

var replacer = function (match) {
  return replacements[match];
};

var serialize = function (it) {
  return replace(encodeURIComponent(it), find, replacer);
};

var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
  setInternalState(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    target: getInternalParamsState(params).entries,
    index: 0,
    kind: kind
  });
}, URL_SEARCH_PARAMS, function next() {
  var state = getInternalIteratorState(this);
  var target = state.target;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = null;
    return createIterResultObject(undefined, true);
  }
  var entry = target[index];
  switch (state.kind) {
    case 'keys': return createIterResultObject(entry.key, false);
    case 'values': return createIterResultObject(entry.value, false);
  } return createIterResultObject([entry.key, entry.value], false);
}, true);

var URLSearchParamsState = function (init) {
  this.entries = [];
  this.url = null;

  if (init !== undefined) {
    if (isObject(init)) this.parseObject(init);
    else this.parseQuery(typeof init == 'string' ? charAt(init, 0) === '?' ? stringSlice(init, 1) : init : $toString(init));
  }
};

URLSearchParamsState.prototype = {
  type: URL_SEARCH_PARAMS,
  bindURL: function (url) {
    this.url = url;
    this.update();
  },
  parseObject: function (object) {
    var entries = this.entries;
    var iteratorMethod = getIteratorMethod(object);
    var iterator, next, step, entryIterator, entryNext, first, second;

    if (iteratorMethod) {
      iterator = getIterator(object, iteratorMethod);
      next = iterator.next;
      while (!(step = call(next, iterator)).done) {
        entryIterator = getIterator(anObject(step.value));
        entryNext = entryIterator.next;
        if (
          (first = call(entryNext, entryIterator)).done ||
          (second = call(entryNext, entryIterator)).done ||
          !call(entryNext, entryIterator).done
        ) throw new TypeError('Expected sequence with length 2');
        push(entries, { key: $toString(first.value), value: $toString(second.value) });
      }
    } else for (var key in object) if (hasOwn(object, key)) {
      push(entries, { key: key, value: $toString(object[key]) });
    }
  },
  parseQuery: function (query) {
    if (query) {
      var entries = this.entries;
      var attributes = split(query, '&');
      var index = 0;
      var attribute, entry;
      while (index < attributes.length) {
        attribute = attributes[index++];
        if (attribute.length) {
          entry = split(attribute, '=');
          push(entries, {
            key: decode(shift(entry)),
            value: decode(join(entry, '='))
          });
        }
      }
    }
  },
  serialize: function () {
    var entries = this.entries;
    var result = [];
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      push(result, serialize(entry.key) + '=' + serialize(entry.value));
    } return join(result, '&');
  },
  update: function () {
    this.entries.length = 0;
    this.parseQuery(this.url.query);
  },
  updateURL: function () {
    if (this.url) this.url.update();
  }
};

// `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams
var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
  anInstance(this, URLSearchParamsPrototype);
  var init = arguments.length > 0 ? arguments[0] : undefined;
  var state = setInternalState(this, new URLSearchParamsState(init));
  if (!DESCRIPTORS) this.size = state.entries.length;
};

var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

defineBuiltIns(URLSearchParamsPrototype, {
  // `URLSearchParams.prototype.append` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    var state = getInternalParamsState(this);
    validateArgumentsLength(arguments.length, 2);
    push(state.entries, { key: $toString(name), value: $toString(value) });
    if (!DESCRIPTORS) this.length++;
    state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  'delete': function (name /* , value */) {
    var state = getInternalParamsState(this);
    var length = validateArgumentsLength(arguments.length, 1);
    var entries = state.entries;
    var key = $toString(name);
    var $value = length < 2 ? undefined : arguments[1];
    var value = $value === undefined ? $value : $toString($value);
    var index = 0;
    while (index < entries.length) {
      var entry = entries[index];
      if (entry.key === key && (value === undefined || entry.value === value)) {
        splice(entries, index, 1);
        if (value !== undefined) break;
      } else index++;
    }
    if (!DESCRIPTORS) this.size = entries.length;
    state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get(name) {
    var entries = getInternalParamsState(this).entries;
    validateArgumentsLength(arguments.length, 1);
    var key = $toString(name);
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) return entries[index].value;
    }
    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    var entries = getInternalParamsState(this).entries;
    validateArgumentsLength(arguments.length, 1);
    var key = $toString(name);
    var result = [];
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) push(result, entries[index].value);
    }
    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has(name /* , value */) {
    var entries = getInternalParamsState(this).entries;
    var length = validateArgumentsLength(arguments.length, 1);
    var key = $toString(name);
    var $value = length < 2 ? undefined : arguments[1];
    var value = $value === undefined ? $value : $toString($value);
    var index = 0;
    while (index < entries.length) {
      var entry = entries[index++];
      if (entry.key === key && (value === undefined || entry.value === value)) return true;
    }
    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set(name, value) {
    var state = getInternalParamsState(this);
    validateArgumentsLength(arguments.length, 1);
    var entries = state.entries;
    var found = false;
    var key = $toString(name);
    var val = $toString(value);
    var index = 0;
    var entry;
    for (; index < entries.length; index++) {
      entry = entries[index];
      if (entry.key === key) {
        if (found) splice(entries, index--, 1);
        else {
          found = true;
          entry.value = val;
        }
      }
    }
    if (!found) push(entries, { key: key, value: val });
    if (!DESCRIPTORS) this.size = entries.length;
    state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort() {
    var state = getInternalParamsState(this);
    arraySort(state.entries, function (a, b) {
      return a.key > b.key ? 1 : -1;
    });
    state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach(callback /* , thisArg */) {
    var entries = getInternalParamsState(this).entries;
    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined);
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys() {
    return new URLSearchParamsIterator(this, 'keys');
  },
  // `URLSearchParams.prototype.values` method
  values: function values() {
    return new URLSearchParamsIterator(this, 'values');
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries() {
    return new URLSearchParamsIterator(this, 'entries');
  }
}, { enumerable: true });

// `URLSearchParams.prototype[@@iterator]` method
defineBuiltIn(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: 'entries' });

// `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
defineBuiltIn(URLSearchParamsPrototype, 'toString', function toString() {
  return getInternalParamsState(this).serialize();
}, { enumerable: true });

// `URLSearchParams.prototype.size` getter
// https://github.com/whatwg/url/pull/734
if (DESCRIPTORS) defineBuiltInAccessor(URLSearchParamsPrototype, 'size', {
  get: function size() {
    return getInternalParamsState(this).entries.length;
  },
  configurable: true,
  enumerable: true
});

setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

$({ global: true, constructor: true, forced: !USE_NATIVE_URL }, {
  URLSearchParams: URLSearchParamsConstructor
});

// Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`
if (!USE_NATIVE_URL && isCallable(Headers)) {
  var headersHas = uncurryThis(HeadersPrototype.has);
  var headersSet = uncurryThis(HeadersPrototype.set);

  var wrapRequestOptions = function (init) {
    if (isObject(init)) {
      var body = init.body;
      var headers;
      if (classof(body) === URL_SEARCH_PARAMS) {
        headers = init.headers ? new Headers(init.headers) : new Headers();
        if (!headersHas(headers, 'content-type')) {
          headersSet(headers, 'content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
        return create(init, {
          body: createPropertyDescriptor(0, $toString(body)),
          headers: createPropertyDescriptor(0, headers)
        });
      }
    } return init;
  };

  if (isCallable(nativeFetch)) {
    $({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, {
      fetch: function fetch(input /* , init */) {
        return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
      }
    });
  }

  if (isCallable(NativeRequest)) {
    var RequestConstructor = function Request(input /* , init */) {
      anInstance(this, RequestPrototype);
      return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
    };

    RequestPrototype.constructor = RequestConstructor;
    RequestConstructor.prototype = RequestPrototype;

    $({ global: true, constructor: true, dontCallGetSet: true, forced: true }, {
      Request: RequestConstructor
    });
  }
}

module.exports = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};


/***/ }),

/***/ "./node_modules/core-js/modules/web.url-search-params.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/web.url-search-params.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(/*! ../modules/web.url-search-params.constructor */ "./node_modules/core-js/modules/web.url-search-params.constructor.js");


/***/ }),

/***/ "./node_modules/tw-elements/dist/js/tw-elements.es.min.js":
/*!****************************************************************!*\
  !*** ./node_modules/tw-elements/dist/js/tw-elements.es.min.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alert: () => (/* binding */ Ko),
/* harmony export */   Animate: () => (/* binding */ wr),
/* harmony export */   Autocomplete: () => (/* binding */ id),
/* harmony export */   Button: () => (/* binding */ kc),
/* harmony export */   Carousel: () => (/* binding */ Xt),
/* harmony export */   Chart: () => (/* binding */ Lh),
/* harmony export */   Chip: () => (/* binding */ vi),
/* harmony export */   ChipsInput: () => (/* binding */ XA),
/* harmony export */   Clipboard: () => (/* binding */ Uh),
/* harmony export */   Collapse: () => (/* binding */ Qt),
/* harmony export */   Datatable: () => (/* binding */ Hh),
/* harmony export */   Datepicker: () => (/* binding */ og),
/* harmony export */   Datetimepicker: () => (/* binding */ Qh),
/* harmony export */   Dropdown: () => (/* binding */ $t),
/* harmony export */   InfiniteScroll: () => (/* binding */ Xh),
/* harmony export */   Input: () => (/* binding */ V),
/* harmony export */   LazyLoad: () => (/* binding */ or),
/* harmony export */   Lightbox: () => (/* binding */ nn),
/* harmony export */   LoadingManagement: () => (/* binding */ Gh),
/* harmony export */   Modal: () => (/* binding */ zo),
/* harmony export */   MultiRangeSlider: () => (/* binding */ sd),
/* harmony export */   Offcanvas: () => (/* binding */ js),
/* harmony export */   PerfectScrollbar: () => (/* binding */ Bh),
/* harmony export */   Popconfirm: () => (/* binding */ Wh),
/* harmony export */   Popover: () => (/* binding */ nh),
/* harmony export */   Rating: () => (/* binding */ GA),
/* harmony export */   Ripple: () => (/* binding */ ei),
/* harmony export */   ScrollSpy: () => (/* binding */ ah),
/* harmony export */   Select: () => (/* binding */ kr),
/* harmony export */   Sidenav: () => (/* binding */ Ci),
/* harmony export */   SmoothScroll: () => (/* binding */ zh),
/* harmony export */   Stepper: () => (/* binding */ UA),
/* harmony export */   Sticky: () => (/* binding */ td),
/* harmony export */   Tab: () => (/* binding */ lh),
/* harmony export */   Timepicker: () => (/* binding */ Sg),
/* harmony export */   Toast: () => (/* binding */ Xo),
/* harmony export */   Tooltip: () => (/* binding */ ri),
/* harmony export */   Touch: () => (/* binding */ Kh),
/* harmony export */   Validation: () => (/* binding */ jh),
/* harmony export */   initTE: () => (/* binding */ qA)
/* harmony export */ });
/*!
* TW Elements 1.1.0
* 
* TW Elements is an open-source UI kit of advanced components for TailwindCSS.
* Copyright Â© 2023 MDBootstrap.com
* 
* Unless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
* In addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.
* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
* 
* If you would like to purchase a COMMERCIAL, non-AGPL license for TWE, please check out our pricing: https://tw-elements.com/pro/
*/
var hd = Object.defineProperty;
var dd = (s, t, e) => t in s ? hd(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;
var wt = (s, t, e) => (dd(s, typeof t != "symbol" ? t + "" : t, e), e);
const In = (() => {
  const s = {};
  let t = 1;
  return {
    set(e, i, n) {
      typeof e[i] > "u" && (e[i] = {
        key: i,
        id: t
      }, t++), s[e[i].id] = n;
    },
    get(e, i) {
      if (!e || typeof e[i] > "u")
        return null;
      const n = e[i];
      return n.key === i ? s[n.id] : null;
    },
    delete(e, i) {
      if (typeof e[i] > "u")
        return;
      const n = e[i];
      n.key === i && (delete s[n.id], delete e[i]);
    }
  };
})(), A = {
  setData(s, t, e) {
    In.set(s, t, e);
  },
  getData(s, t) {
    return In.get(s, t);
  },
  removeData(s, t) {
    In.delete(s, t);
  }
}, ud = 1e6, pd = 1e3, Ho = "transitionend", _d = (s) => s == null ? `${s}` : {}.toString.call(s).match(/\s([a-z]+)/i)[1].toLowerCase(), et = (s) => {
  do
    s += Math.floor(Math.random() * ud);
  while (document.getElementById(s));
  return s;
}, pc = (s) => {
  let t = s.getAttribute("data-te-target");
  if (!t || t === "#") {
    let e = s.getAttribute("href");
    if (!e || !e.includes("#") && !e.startsWith("."))
      return null;
    e.includes("#") && !e.startsWith("#") && (e = `#${e.split("#")[1]}`), t = e && e !== "#" ? e.trim() : null;
  }
  return t;
}, lr = (s) => {
  const t = pc(s);
  return t && document.querySelector(t) ? t : null;
}, te = (s) => {
  const t = pc(s);
  return t ? document.querySelector(t) : null;
}, cn = (s) => {
  if (!s)
    return 0;
  let { transitionDuration: t, transitionDelay: e } = window.getComputedStyle(s);
  const i = Number.parseFloat(t), n = Number.parseFloat(e);
  return !i && !n ? 0 : (t = t.split(",")[0], e = e.split(",")[0], (Number.parseFloat(t) + Number.parseFloat(e)) * pd);
}, _c = (s) => {
  s.dispatchEvent(new Event(Ho));
}, Xe = (s) => !s || typeof s != "object" ? !1 : (typeof s.jquery < "u" && (s = s[0]), typeof s.nodeType < "u"), ee = (s) => Xe(s) ? s.jquery ? s[0] : s : typeof s == "string" && s.length > 0 ? document.querySelector(s) : null, I = (s, t, e) => {
  Object.keys(e).forEach((i) => {
    const n = e[i], o = t[i], r = o && Xe(o) ? "element" : _d(o);
    if (!new RegExp(n).test(r))
      throw new Error(
        `${s.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${n}".`
      );
  });
}, Mt = (s) => {
  if (!s || s.getClientRects().length === 0)
    return !1;
  if (s.style && s.parentNode && s.parentNode.style) {
    const t = getComputedStyle(s), e = getComputedStyle(s.parentNode);
    return getComputedStyle(s).getPropertyValue("visibility") === "visible" || t.display !== "none" && e.display !== "none" && t.visibility !== "hidden";
  }
  return !1;
}, be = (s) => !s || s.nodeType !== Node.ELEMENT_NODE || s.classList.contains("disabled") ? !0 : typeof s.disabled < "u" ? s.disabled : s.hasAttribute("disabled") && s.getAttribute("disabled") !== "false", fc = (s) => {
  if (!document.documentElement.attachShadow)
    return null;
  if (typeof s.getRootNode == "function") {
    const t = s.getRootNode();
    return t instanceof ShadowRoot ? t : null;
  }
  return s instanceof ShadowRoot ? s : s.parentNode ? fc(s.parentNode) : null;
}, hn = () => function() {
}, si = (s) => {
  s.offsetHeight;
}, mc = () => {
  const { jQuery: s } = window;
  return s && !document.body.hasAttribute("data-te-no-jquery") ? s : null;
}, Dn = [], gc = (s) => {
  document.readyState === "loading" ? (Dn.length || document.addEventListener("DOMContentLoaded", () => {
    Dn.forEach((t) => t());
  }), Dn.push(s)) : s();
}, W = () => document.documentElement.dir === "rtl", fd = (s) => Array.from(s), $ = (s) => document.createElement(s), ge = (s) => {
  typeof s == "function" && s();
}, bc = (s, t, e = !0) => {
  if (!e) {
    ge(s);
    return;
  }
  const i = 5, n = cn(t) + i;
  let o = !1;
  const r = ({ target: a }) => {
    a === t && (o = !0, t.removeEventListener(Ho, r), ge(s));
  };
  t.addEventListener(Ho, r), setTimeout(() => {
    o || _c(t);
  }, n);
}, vc = (s, t, e, i) => {
  let n = s.indexOf(t);
  if (n === -1)
    return s[!e && i ? s.length - 1 : 0];
  const o = s.length;
  return n += e ? 1 : -1, i && (n = (n + o) % o), s[Math.max(0, Math.min(n, o - 1))];
}, md = /[^.]*(?=\..*)\.|.*/, gd = /\..*/, bd = /::\d+$/, $n = {};
let Hr = 1;
const vd = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, Td = /^(mouseenter|mouseleave)/i, Tc = /* @__PURE__ */ new Set([
  "click",
  "dblclick",
  "mouseup",
  "mousedown",
  "contextmenu",
  "mousewheel",
  "DOMMouseScroll",
  "mouseover",
  "mouseout",
  "mousemove",
  "selectstart",
  "selectend",
  "keydown",
  "keypress",
  "keyup",
  "orientationchange",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointercancel",
  "gesturestart",
  "gesturechange",
  "gestureend",
  "focus",
  "blur",
  "change",
  "reset",
  "select",
  "submit",
  "focusin",
  "focusout",
  "load",
  "unload",
  "beforeunload",
  "resize",
  "move",
  "DOMContentLoaded",
  "readystatechange",
  "error",
  "abort",
  "scroll"
]);
function Ec(s, t) {
  return t && `${t}::${Hr++}` || s.uidEvent || Hr++;
}
function Cc(s) {
  const t = Ec(s);
  return s.uidEvent = t, $n[t] = $n[t] || {}, $n[t];
}
function Ed(s, t) {
  return function e(i) {
    return i.delegateTarget = s, e.oneOff && c.off(s, i.type, t), t.apply(s, [i]);
  };
}
function Cd(s, t, e) {
  return function i(n) {
    const o = s.querySelectorAll(t);
    for (let { target: r } = n; r && r !== this; r = r.parentNode)
      for (let a = o.length; a--; "")
        if (o[a] === r)
          return n.delegateTarget = r, i.oneOff && c.off(s, n.type, e), e.apply(r, [n]);
    return null;
  };
}
function Ac(s, t, e = null) {
  const i = Object.keys(s);
  for (let n = 0, o = i.length; n < o; n++) {
    const r = s[i[n]];
    if (r.originalHandler === t && r.delegationSelector === e)
      return r;
  }
  return null;
}
function yc(s, t, e) {
  const i = typeof t == "string", n = i ? e : t;
  let o = wc(s);
  return Tc.has(o) || (o = s), [i, n, o];
}
function Vr(s, t, e, i, n) {
  if (typeof t != "string" || !s)
    return;
  if (e || (e = i, i = null), Td.test(t)) {
    const g = (m) => function(b) {
      if (!b.relatedTarget || b.relatedTarget !== b.delegateTarget && !b.delegateTarget.contains(b.relatedTarget))
        return m.call(this, b);
    };
    i ? i = g(i) : e = g(e);
  }
  const [o, r, a] = yc(
    t,
    e,
    i
  ), l = Cc(s), p = l[a] || (l[a] = {}), u = Ac(
    p,
    r,
    o ? e : null
  );
  if (u) {
    u.oneOff = u.oneOff && n;
    return;
  }
  const _ = Ec(
    r,
    t.replace(md, "")
  ), f = o ? Cd(s, e, i) : Ed(s, e);
  f.delegationSelector = o ? e : null, f.originalHandler = r, f.oneOff = n, f.uidEvent = _, p[_] = f, s.addEventListener(a, f, o);
}
function Vo(s, t, e, i, n) {
  const o = Ac(t[e], i, n);
  o && (s.removeEventListener(e, o, !!n), delete t[e][o.uidEvent]);
}
function Ad(s, t, e, i) {
  const n = t[e] || {};
  Object.keys(n).forEach((o) => {
    if (o.includes(i)) {
      const r = n[o];
      Vo(
        s,
        t,
        e,
        r.originalHandler,
        r.delegationSelector
      );
    }
  });
}
function wc(s) {
  return s = s.replace(gd, ""), vd[s] || s;
}
const c = {
  on(s, t, e, i) {
    Vr(s, t, e, i, !1);
  },
  one(s, t, e, i) {
    Vr(s, t, e, i, !0);
  },
  off(s, t, e, i) {
    if (typeof t != "string" || !s)
      return;
    const [n, o, r] = yc(
      t,
      e,
      i
    ), a = r !== t, l = Cc(s), p = t.startsWith(".");
    if (typeof o < "u") {
      if (!l || !l[r])
        return;
      Vo(
        s,
        l,
        r,
        o,
        n ? e : null
      );
      return;
    }
    p && Object.keys(l).forEach((_) => {
      Ad(
        s,
        l,
        _,
        t.slice(1)
      );
    });
    const u = l[r] || {};
    Object.keys(u).forEach((_) => {
      const f = _.replace(bd, "");
      if (!a || t.includes(f)) {
        const g = u[_];
        Vo(
          s,
          l,
          r,
          g.originalHandler,
          g.delegationSelector
        );
      }
    });
  },
  trigger(s, t, e) {
    if (typeof t != "string" || !s)
      return null;
    const i = mc(), n = wc(t), o = t !== n, r = Tc.has(n);
    let a, l = !0, p = !0, u = !1, _ = null;
    return o && i && (a = i.Event(t, e), i(s).trigger(a), l = !a.isPropagationStopped(), p = !a.isImmediatePropagationStopped(), u = a.isDefaultPrevented()), r ? (_ = document.createEvent("HTMLEvents"), _.initEvent(n, l, !0)) : _ = new CustomEvent(t, {
      bubbles: l,
      cancelable: !0
    }), typeof e < "u" && Object.keys(e).forEach((f) => {
      Object.defineProperty(_, f, {
        get() {
          return e[f];
        }
      });
    }), u && _.preventDefault(), p && s.dispatchEvent(_), _.defaultPrevented && typeof a < "u" && a.preventDefault(), _;
  }
}, K = {
  on(s, t, e, i) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      c.on(s, n[o], e, i);
  },
  off(s, t, e, i) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      c.off(s, n[o], e, i);
  }
}, yd = "5.1.3";
class ft {
  constructor(t) {
    t = ee(t), t && (this._element = t, A.setData(this._element, this.constructor.DATA_KEY, this));
  }
  dispose() {
    A.removeData(this._element, this.constructor.DATA_KEY), c.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t) => {
      this[t] = null;
    });
  }
  _queueCallback(t, e, i = !0) {
    bc(t, e, i);
  }
  /** Static */
  static getInstance(t) {
    return A.getData(ee(t), this.DATA_KEY);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static get VERSION() {
    return yd;
  }
  static get NAME() {
    throw new Error(
      'You have to implement the static method "NAME", for each component!'
    );
  }
  static get DATA_KEY() {
    return `te.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
}
const wd = "button", kd = "active";
class kc extends ft {
  // Getters
  static get NAME() {
    return wd;
  }
  // Public
  toggle() {
    this._element.setAttribute(
      "aria-pressed",
      this._element.classList.toggle(kd)
    );
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = kc.getOrCreateInstance(this);
      t === "toggle" && e[t]();
    });
  }
}
var st = "top", ut = "bottom", pt = "right", nt = "left", ji = "auto", ni = [st, ut, pt, nt], Ae = "start", Ge = "end", xc = "clippingParents", cr = "viewport", Be = "popper", Oc = "reference", Wo = /* @__PURE__ */ ni.reduce(function(s, t) {
  return s.concat([t + "-" + Ae, t + "-" + Ge]);
}, []), hr = /* @__PURE__ */ [].concat(ni, [ji]).reduce(function(s, t) {
  return s.concat([t, t + "-" + Ae, t + "-" + Ge]);
}, []), Sc = "beforeRead", Ic = "read", Dc = "afterRead", $c = "beforeMain", Lc = "main", Nc = "afterMain", Mc = "beforeWrite", Rc = "write", Pc = "afterWrite", dn = [Sc, Ic, Dc, $c, Lc, Nc, Mc, Rc, Pc];
function Rt(s) {
  return s ? (s.nodeName || "").toLowerCase() : null;
}
function _t(s) {
  if (s == null)
    return window;
  if (s.toString() !== "[object Window]") {
    var t = s.ownerDocument;
    return t && t.defaultView || window;
  }
  return s;
}
function ye(s) {
  var t = _t(s).Element;
  return s instanceof t || s instanceof Element;
}
function dt(s) {
  var t = _t(s).HTMLElement;
  return s instanceof t || s instanceof HTMLElement;
}
function dr(s) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = _t(s).ShadowRoot;
  return s instanceof t || s instanceof ShadowRoot;
}
function xd(s) {
  var t = s.state;
  Object.keys(t.elements).forEach(function(e) {
    var i = t.styles[e] || {}, n = t.attributes[e] || {}, o = t.elements[e];
    !dt(o) || !Rt(o) || (Object.assign(o.style, i), Object.keys(n).forEach(function(r) {
      var a = n[r];
      a === !1 ? o.removeAttribute(r) : o.setAttribute(r, a === !0 ? "" : a);
    }));
  });
}
function Od(s) {
  var t = s.state, e = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
    Object.keys(t.elements).forEach(function(i) {
      var n = t.elements[i], o = t.attributes[i] || {}, r = Object.keys(t.styles.hasOwnProperty(i) ? t.styles[i] : e[i]), a = r.reduce(function(l, p) {
        return l[p] = "", l;
      }, {});
      !dt(n) || !Rt(n) || (Object.assign(n.style, a), Object.keys(o).forEach(function(l) {
        n.removeAttribute(l);
      }));
    });
  };
}
const ur = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: xd,
  effect: Od,
  requires: ["computeStyles"]
};
function Et(s) {
  return s.split("-")[0];
}
var ve = Math.max, un = Math.min, qe = Math.round;
function Fo() {
  var s = navigator.userAgentData;
  return s != null && s.brands && Array.isArray(s.brands) ? s.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function Bc() {
  return !/^((?!chrome|android).)*safari/i.test(Fo());
}
function Ze(s, t, e) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  var i = s.getBoundingClientRect(), n = 1, o = 1;
  t && dt(s) && (n = s.offsetWidth > 0 && qe(i.width) / s.offsetWidth || 1, o = s.offsetHeight > 0 && qe(i.height) / s.offsetHeight || 1);
  var r = ye(s) ? _t(s) : window, a = r.visualViewport, l = !Bc() && e, p = (i.left + (l && a ? a.offsetLeft : 0)) / n, u = (i.top + (l && a ? a.offsetTop : 0)) / o, _ = i.width / n, f = i.height / o;
  return {
    width: _,
    height: f,
    top: u,
    right: p + _,
    bottom: u + f,
    left: p,
    x: p,
    y: u
  };
}
function pr(s) {
  var t = Ze(s), e = s.offsetWidth, i = s.offsetHeight;
  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - i) <= 1 && (i = t.height), {
    x: s.offsetLeft,
    y: s.offsetTop,
    width: e,
    height: i
  };
}
function Hc(s, t) {
  var e = t.getRootNode && t.getRootNode();
  if (s.contains(t))
    return !0;
  if (e && dr(e)) {
    var i = t;
    do {
      if (i && s.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function At(s) {
  return _t(s).getComputedStyle(s);
}
function Sd(s) {
  return ["table", "td", "th"].indexOf(Rt(s)) >= 0;
}
function ie(s) {
  return ((ye(s) ? s.ownerDocument : (
    // $FlowFixMe[prop-missing]
    s.document
  )) || window.document).documentElement;
}
function mn(s) {
  return Rt(s) === "html" ? s : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    s.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    s.parentNode || // DOM Element detected
    (dr(s) ? s.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    ie(s)
  );
}
function Wr(s) {
  return !dt(s) || // https://github.com/popperjs/popper-core/issues/837
  At(s).position === "fixed" ? null : s.offsetParent;
}
function Id(s) {
  var t = /firefox/i.test(Fo()), e = /Trident/i.test(Fo());
  if (e && dt(s)) {
    var i = At(s);
    if (i.position === "fixed")
      return null;
  }
  var n = mn(s);
  for (dr(n) && (n = n.host); dt(n) && ["html", "body"].indexOf(Rt(n)) < 0; ) {
    var o = At(n);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return n;
    n = n.parentNode;
  }
  return null;
}
function Ki(s) {
  for (var t = _t(s), e = Wr(s); e && Sd(e) && At(e).position === "static"; )
    e = Wr(e);
  return e && (Rt(e) === "html" || Rt(e) === "body" && At(e).position === "static") ? t : e || Id(s) || t;
}
function _r(s) {
  return ["top", "bottom"].indexOf(s) >= 0 ? "x" : "y";
}
function Mi(s, t, e) {
  return ve(s, un(t, e));
}
function Dd(s, t, e) {
  var i = Mi(s, t, e);
  return i > e ? e : i;
}
function Vc() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function Wc(s) {
  return Object.assign({}, Vc(), s);
}
function Fc(s, t) {
  return t.reduce(function(e, i) {
    return e[i] = s, e;
  }, {});
}
var $d = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, Wc(typeof t != "number" ? t : Fc(t, ni));
};
function Ld(s) {
  var t, e = s.state, i = s.name, n = s.options, o = e.elements.arrow, r = e.modifiersData.popperOffsets, a = Et(e.placement), l = _r(a), p = [nt, pt].indexOf(a) >= 0, u = p ? "height" : "width";
  if (!(!o || !r)) {
    var _ = $d(n.padding, e), f = pr(o), g = l === "y" ? st : nt, m = l === "y" ? ut : pt, b = e.rects.reference[u] + e.rects.reference[l] - r[l] - e.rects.popper[u], v = r[l] - e.rects.reference[l], T = Ki(o), y = T ? l === "y" ? T.clientHeight || 0 : T.clientWidth || 0 : 0, C = b / 2 - v / 2, E = _[g], w = y - f[u] - _[m], k = y / 2 - f[u] / 2 + C, D = Mi(E, k, w), O = l;
    e.modifiersData[i] = (t = {}, t[O] = D, t.centerOffset = D - k, t);
  }
}
function Nd(s) {
  var t = s.state, e = s.options, i = e.element, n = i === void 0 ? "[data-popper-arrow]" : i;
  if (n != null && !(typeof n == "string" && (n = t.elements.popper.querySelector(n), !n))) {
    if ({}.NODE_ENV !== "production" && (dt(n) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !Hc(t.elements.popper, n)) {
      ({}).NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    t.elements.arrow = n;
  }
}
const Yc = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: Ld,
  effect: Nd,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Qe(s) {
  return s.split("-")[1];
}
var Md = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function Rd(s, t) {
  var e = s.x, i = s.y, n = t.devicePixelRatio || 1;
  return {
    x: qe(e * n) / n || 0,
    y: qe(i * n) / n || 0
  };
}
function Fr(s) {
  var t, e = s.popper, i = s.popperRect, n = s.placement, o = s.variation, r = s.offsets, a = s.position, l = s.gpuAcceleration, p = s.adaptive, u = s.roundOffsets, _ = s.isFixed, f = r.x, g = f === void 0 ? 0 : f, m = r.y, b = m === void 0 ? 0 : m, v = typeof u == "function" ? u({
    x: g,
    y: b
  }) : {
    x: g,
    y: b
  };
  g = v.x, b = v.y;
  var T = r.hasOwnProperty("x"), y = r.hasOwnProperty("y"), C = nt, E = st, w = window;
  if (p) {
    var k = Ki(e), D = "clientHeight", O = "clientWidth";
    if (k === _t(e) && (k = ie(e), At(k).position !== "static" && a === "absolute" && (D = "scrollHeight", O = "scrollWidth")), k = k, n === st || (n === nt || n === pt) && o === Ge) {
      E = ut;
      var x = _ && k === w && w.visualViewport ? w.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        k[D]
      );
      b -= x - i.height, b *= l ? 1 : -1;
    }
    if (n === nt || (n === st || n === ut) && o === Ge) {
      C = pt;
      var L = _ && k === w && w.visualViewport ? w.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        k[O]
      );
      g -= L - i.width, g *= l ? 1 : -1;
    }
  }
  var S = Object.assign({
    position: a
  }, p && Md), N = u === !0 ? Rd({
    x: g,
    y: b
  }, _t(e)) : {
    x: g,
    y: b
  };
  if (g = N.x, b = N.y, l) {
    var P;
    return Object.assign({}, S, (P = {}, P[E] = y ? "0" : "", P[C] = T ? "0" : "", P.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + g + "px, " + b + "px)" : "translate3d(" + g + "px, " + b + "px, 0)", P));
  }
  return Object.assign({}, S, (t = {}, t[E] = y ? b + "px" : "", t[C] = T ? g + "px" : "", t.transform = "", t));
}
function Pd(s) {
  var t = s.state, e = s.options, i = e.gpuAcceleration, n = i === void 0 ? !0 : i, o = e.adaptive, r = o === void 0 ? !0 : o, a = e.roundOffsets, l = a === void 0 ? !0 : a;
  if ({}.NODE_ENV !== "production") {
    var p = At(t.elements.popper).transitionProperty || "";
    r && ["transform", "top", "right", "bottom", "left"].some(function(_) {
      return p.indexOf(_) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var u = {
    placement: Et(t.placement),
    variation: Qe(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: n,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Fr(Object.assign({}, u, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: r,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Fr(Object.assign({}, u, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const fr = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: Pd,
  data: {}
};
var ns = {
  passive: !0
};
function Bd(s) {
  var t = s.state, e = s.instance, i = s.options, n = i.scroll, o = n === void 0 ? !0 : n, r = i.resize, a = r === void 0 ? !0 : r, l = _t(t.elements.popper), p = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && p.forEach(function(u) {
    u.addEventListener("scroll", e.update, ns);
  }), a && l.addEventListener("resize", e.update, ns), function() {
    o && p.forEach(function(u) {
      u.removeEventListener("scroll", e.update, ns);
    }), a && l.removeEventListener("resize", e.update, ns);
  };
}
const mr = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: Bd,
  data: {}
};
var Hd = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Ws(s) {
  return s.replace(/left|right|bottom|top/g, function(t) {
    return Hd[t];
  });
}
var Vd = {
  start: "end",
  end: "start"
};
function Yr(s) {
  return s.replace(/start|end/g, function(t) {
    return Vd[t];
  });
}
function gr(s) {
  var t = _t(s), e = t.pageXOffset, i = t.pageYOffset;
  return {
    scrollLeft: e,
    scrollTop: i
  };
}
function br(s) {
  return Ze(ie(s)).left + gr(s).scrollLeft;
}
function Wd(s, t) {
  var e = _t(s), i = ie(s), n = e.visualViewport, o = i.clientWidth, r = i.clientHeight, a = 0, l = 0;
  if (n) {
    o = n.width, r = n.height;
    var p = Bc();
    (p || !p && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: o,
    height: r,
    x: a + br(s),
    y: l
  };
}
function Fd(s) {
  var t, e = ie(s), i = gr(s), n = (t = s.ownerDocument) == null ? void 0 : t.body, o = ve(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = ve(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -i.scrollLeft + br(s), l = -i.scrollTop;
  return At(n || e).direction === "rtl" && (a += ve(e.clientWidth, n ? n.clientWidth : 0) - o), {
    width: o,
    height: r,
    x: a,
    y: l
  };
}
function vr(s) {
  var t = At(s), e = t.overflow, i = t.overflowX, n = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + n + i);
}
function jc(s) {
  return ["html", "body", "#document"].indexOf(Rt(s)) >= 0 ? s.ownerDocument.body : dt(s) && vr(s) ? s : jc(mn(s));
}
function Ri(s, t) {
  var e;
  t === void 0 && (t = []);
  var i = jc(s), n = i === ((e = s.ownerDocument) == null ? void 0 : e.body), o = _t(i), r = n ? [o].concat(o.visualViewport || [], vr(i) ? i : []) : i, a = t.concat(r);
  return n ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(Ri(mn(r)))
  );
}
function Yo(s) {
  return Object.assign({}, s, {
    left: s.x,
    top: s.y,
    right: s.x + s.width,
    bottom: s.y + s.height
  });
}
function Yd(s, t) {
  var e = Ze(s, !1, t === "fixed");
  return e.top = e.top + s.clientTop, e.left = e.left + s.clientLeft, e.bottom = e.top + s.clientHeight, e.right = e.left + s.clientWidth, e.width = s.clientWidth, e.height = s.clientHeight, e.x = e.left, e.y = e.top, e;
}
function jr(s, t, e) {
  return t === cr ? Yo(Wd(s, e)) : ye(t) ? Yd(t, e) : Yo(Fd(ie(s)));
}
function jd(s) {
  var t = Ri(mn(s)), e = ["absolute", "fixed"].indexOf(At(s).position) >= 0, i = e && dt(s) ? Ki(s) : s;
  return ye(i) ? t.filter(function(n) {
    return ye(n) && Hc(n, i) && Rt(n) !== "body";
  }) : [];
}
function Kd(s, t, e, i) {
  var n = t === "clippingParents" ? jd(s) : [].concat(t), o = [].concat(n, [e]), r = o[0], a = o.reduce(function(l, p) {
    var u = jr(s, p, i);
    return l.top = ve(u.top, l.top), l.right = un(u.right, l.right), l.bottom = un(u.bottom, l.bottom), l.left = ve(u.left, l.left), l;
  }, jr(s, r, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function Kc(s) {
  var t = s.reference, e = s.element, i = s.placement, n = i ? Et(i) : null, o = i ? Qe(i) : null, r = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, l;
  switch (n) {
    case st:
      l = {
        x: r,
        y: t.y - e.height
      };
      break;
    case ut:
      l = {
        x: r,
        y: t.y + t.height
      };
      break;
    case pt:
      l = {
        x: t.x + t.width,
        y: a
      };
      break;
    case nt:
      l = {
        x: t.x - e.width,
        y: a
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var p = n ? _r(n) : null;
  if (p != null) {
    var u = p === "y" ? "height" : "width";
    switch (o) {
      case Ae:
        l[p] = l[p] - (t[u] / 2 - e[u] / 2);
        break;
      case Ge:
        l[p] = l[p] + (t[u] / 2 - e[u] / 2);
        break;
    }
  }
  return l;
}
function Je(s, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = i === void 0 ? s.placement : i, o = e.strategy, r = o === void 0 ? s.strategy : o, a = e.boundary, l = a === void 0 ? xc : a, p = e.rootBoundary, u = p === void 0 ? cr : p, _ = e.elementContext, f = _ === void 0 ? Be : _, g = e.altBoundary, m = g === void 0 ? !1 : g, b = e.padding, v = b === void 0 ? 0 : b, T = Wc(typeof v != "number" ? v : Fc(v, ni)), y = f === Be ? Oc : Be, C = s.rects.popper, E = s.elements[m ? y : f], w = Kd(ye(E) ? E : E.contextElement || ie(s.elements.popper), l, u, r), k = Ze(s.elements.reference), D = Kc({
    reference: k,
    element: C,
    strategy: "absolute",
    placement: n
  }), O = Yo(Object.assign({}, C, D)), x = f === Be ? O : k, L = {
    top: w.top - x.top + T.top,
    bottom: x.bottom - w.bottom + T.bottom,
    left: w.left - x.left + T.left,
    right: x.right - w.right + T.right
  }, S = s.modifiersData.offset;
  if (f === Be && S) {
    var N = S[n];
    Object.keys(L).forEach(function(P) {
      var ot = [pt, ut].indexOf(P) >= 0 ? 1 : -1, rt = [st, ut].indexOf(P) >= 0 ? "y" : "x";
      L[P] += N[rt] * ot;
    });
  }
  return L;
}
function zd(s, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = e.boundary, o = e.rootBoundary, r = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, p = l === void 0 ? hr : l, u = Qe(i), _ = u ? a ? Wo : Wo.filter(function(m) {
    return Qe(m) === u;
  }) : ni, f = _.filter(function(m) {
    return p.indexOf(m) >= 0;
  });
  f.length === 0 && (f = _, {}.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var g = f.reduce(function(m, b) {
    return m[b] = Je(s, {
      placement: b,
      boundary: n,
      rootBoundary: o,
      padding: r
    })[Et(b)], m;
  }, {});
  return Object.keys(g).sort(function(m, b) {
    return g[m] - g[b];
  });
}
function Ud(s) {
  if (Et(s) === ji)
    return [];
  var t = Ws(s);
  return [Yr(s), t, Yr(t)];
}
function Xd(s) {
  var t = s.state, e = s.options, i = s.name;
  if (!t.modifiersData[i]._skip) {
    for (var n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !0 : r, l = e.fallbackPlacements, p = e.padding, u = e.boundary, _ = e.rootBoundary, f = e.altBoundary, g = e.flipVariations, m = g === void 0 ? !0 : g, b = e.allowedAutoPlacements, v = t.options.placement, T = Et(v), y = T === v, C = l || (y || !m ? [Ws(v)] : Ud(v)), E = [v].concat(C).reduce(function(Oe, Vt) {
      return Oe.concat(Et(Vt) === ji ? zd(t, {
        placement: Vt,
        boundary: u,
        rootBoundary: _,
        padding: p,
        flipVariations: m,
        allowedAutoPlacements: b
      }) : Vt);
    }, []), w = t.rects.reference, k = t.rects.popper, D = /* @__PURE__ */ new Map(), O = !0, x = E[0], L = 0; L < E.length; L++) {
      var S = E[L], N = Et(S), P = Qe(S) === Ae, ot = [st, ut].indexOf(N) >= 0, rt = ot ? "width" : "height", G = Je(t, {
        placement: S,
        boundary: u,
        rootBoundary: _,
        altBoundary: f,
        padding: p
      }), vt = ot ? P ? pt : nt : P ? ut : st;
      w[rt] > k[rt] && (vt = Ws(vt));
      var Ji = Ws(vt), oe = [];
      if (o && oe.push(G[N] <= 0), a && oe.push(G[vt] <= 0, G[Ji] <= 0), oe.every(function(Oe) {
        return Oe;
      })) {
        x = S, O = !1;
        break;
      }
      D.set(S, oe);
    }
    if (O)
      for (var ts = m ? 3 : 1, kn = function(Vt) {
        var di = E.find(function(is) {
          var re = D.get(is);
          if (re)
            return re.slice(0, Vt).every(function(xn) {
              return xn;
            });
        });
        if (di)
          return x = di, "break";
      }, hi = ts; hi > 0; hi--) {
        var es = kn(hi);
        if (es === "break")
          break;
      }
    t.placement !== x && (t.modifiersData[i]._skip = !0, t.placement = x, t.reset = !0);
  }
}
const zc = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Xd,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function Kr(s, t, e) {
  return e === void 0 && (e = {
    x: 0,
    y: 0
  }), {
    top: s.top - t.height - e.y,
    right: s.right - t.width + e.x,
    bottom: s.bottom - t.height + e.y,
    left: s.left - t.width - e.x
  };
}
function zr(s) {
  return [st, pt, ut, nt].some(function(t) {
    return s[t] >= 0;
  });
}
function Gd(s) {
  var t = s.state, e = s.name, i = t.rects.reference, n = t.rects.popper, o = t.modifiersData.preventOverflow, r = Je(t, {
    elementContext: "reference"
  }), a = Je(t, {
    altBoundary: !0
  }), l = Kr(r, i), p = Kr(a, n, o), u = zr(l), _ = zr(p);
  t.modifiersData[e] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: p,
    isReferenceHidden: u,
    hasPopperEscaped: _
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": _
  });
}
const Uc = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Gd
};
function qd(s, t, e) {
  var i = Et(s), n = [nt, st].indexOf(i) >= 0 ? -1 : 1, o = typeof e == "function" ? e(Object.assign({}, t, {
    placement: s
  })) : e, r = o[0], a = o[1];
  return r = r || 0, a = (a || 0) * n, [nt, pt].indexOf(i) >= 0 ? {
    x: a,
    y: r
  } : {
    x: r,
    y: a
  };
}
function Zd(s) {
  var t = s.state, e = s.options, i = s.name, n = e.offset, o = n === void 0 ? [0, 0] : n, r = hr.reduce(function(u, _) {
    return u[_] = qd(_, t.rects, o), u;
  }, {}), a = r[t.placement], l = a.x, p = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += p), t.modifiersData[i] = r;
}
const Xc = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: Zd
};
function Qd(s) {
  var t = s.state, e = s.name;
  t.modifiersData[e] = Kc({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const Tr = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: Qd,
  data: {}
};
function Jd(s) {
  return s === "x" ? "y" : "x";
}
function tu(s) {
  var t = s.state, e = s.options, i = s.name, n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !1 : r, l = e.boundary, p = e.rootBoundary, u = e.altBoundary, _ = e.padding, f = e.tether, g = f === void 0 ? !0 : f, m = e.tetherOffset, b = m === void 0 ? 0 : m, v = Je(t, {
    boundary: l,
    rootBoundary: p,
    padding: _,
    altBoundary: u
  }), T = Et(t.placement), y = Qe(t.placement), C = !y, E = _r(T), w = Jd(E), k = t.modifiersData.popperOffsets, D = t.rects.reference, O = t.rects.popper, x = typeof b == "function" ? b(Object.assign({}, t.rects, {
    placement: t.placement
  })) : b, L = typeof x == "number" ? {
    mainAxis: x,
    altAxis: x
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, x), S = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, N = {
    x: 0,
    y: 0
  };
  if (k) {
    if (o) {
      var P, ot = E === "y" ? st : nt, rt = E === "y" ? ut : pt, G = E === "y" ? "height" : "width", vt = k[E], Ji = vt + v[ot], oe = vt - v[rt], ts = g ? -O[G] / 2 : 0, kn = y === Ae ? D[G] : O[G], hi = y === Ae ? -O[G] : -D[G], es = t.elements.arrow, Oe = g && es ? pr(es) : {
        width: 0,
        height: 0
      }, Vt = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : Vc(), di = Vt[ot], is = Vt[rt], re = Mi(0, D[G], Oe[G]), xn = C ? D[G] / 2 - ts - re - di - L.mainAxis : kn - re - di - L.mainAxis, nd = C ? -D[G] / 2 + ts + re + is + L.mainAxis : hi + re + is + L.mainAxis, On = t.elements.arrow && Ki(t.elements.arrow), od = On ? E === "y" ? On.clientTop || 0 : On.clientLeft || 0 : 0, Ir = (P = S == null ? void 0 : S[E]) != null ? P : 0, rd = vt + xn - Ir - od, ad = vt + nd - Ir, Dr = Mi(g ? un(Ji, rd) : Ji, vt, g ? ve(oe, ad) : oe);
      k[E] = Dr, N[E] = Dr - vt;
    }
    if (a) {
      var $r, ld = E === "x" ? st : nt, cd = E === "x" ? ut : pt, ae = k[w], ss = w === "y" ? "height" : "width", Lr = ae + v[ld], Nr = ae - v[cd], Sn = [st, nt].indexOf(T) !== -1, Mr = ($r = S == null ? void 0 : S[w]) != null ? $r : 0, Rr = Sn ? Lr : ae - D[ss] - O[ss] - Mr + L.altAxis, Pr = Sn ? ae + D[ss] + O[ss] - Mr - L.altAxis : Nr, Br = g && Sn ? Dd(Rr, ae, Pr) : Mi(g ? Rr : Lr, ae, g ? Pr : Nr);
      k[w] = Br, N[w] = Br - ae;
    }
    t.modifiersData[i] = N;
  }
}
const Gc = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: tu,
  requiresIfExists: ["offset"]
};
function eu(s) {
  return {
    scrollLeft: s.scrollLeft,
    scrollTop: s.scrollTop
  };
}
function iu(s) {
  return s === _t(s) || !dt(s) ? gr(s) : eu(s);
}
function su(s) {
  var t = s.getBoundingClientRect(), e = qe(t.width) / s.offsetWidth || 1, i = qe(t.height) / s.offsetHeight || 1;
  return e !== 1 || i !== 1;
}
function nu(s, t, e) {
  e === void 0 && (e = !1);
  var i = dt(t), n = dt(t) && su(t), o = ie(t), r = Ze(s, n, e), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (i || !i && !e) && ((Rt(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  vr(o)) && (a = iu(t)), dt(t) ? (l = Ze(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = br(o))), {
    x: r.left + a.scrollLeft - l.x,
    y: r.top + a.scrollTop - l.y,
    width: r.width,
    height: r.height
  };
}
function ou(s) {
  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), i = [];
  s.forEach(function(o) {
    t.set(o.name, o);
  });
  function n(o) {
    e.add(o.name);
    var r = [].concat(o.requires || [], o.requiresIfExists || []);
    r.forEach(function(a) {
      if (!e.has(a)) {
        var l = t.get(a);
        l && n(l);
      }
    }), i.push(o);
  }
  return s.forEach(function(o) {
    e.has(o.name) || n(o);
  }), i;
}
function ru(s) {
  var t = ou(s);
  return dn.reduce(function(e, i) {
    return e.concat(t.filter(function(n) {
      return n.phase === i;
    }));
  }, []);
}
function au(s) {
  var t;
  return function() {
    return t || (t = new Promise(function(e) {
      Promise.resolve().then(function() {
        t = void 0, e(s());
      });
    })), t;
  };
}
function Wt(s) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    e[i - 1] = arguments[i];
  return [].concat(e).reduce(function(n, o) {
    return n.replace(/%s/, o);
  }, s);
}
var le = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', lu = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', Ur = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function cu(s) {
  s.forEach(function(t) {
    [].concat(Object.keys(t), Ur).filter(function(e, i, n) {
      return n.indexOf(e) === i;
    }).forEach(function(e) {
      switch (e) {
        case "name":
          typeof t.name != "string" && console.error(Wt(le, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"'));
          break;
        case "enabled":
          typeof t.enabled != "boolean" && console.error(Wt(le, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"'));
          break;
        case "phase":
          dn.indexOf(t.phase) < 0 && console.error(Wt(le, t.name, '"phase"', "either " + dn.join(", "), '"' + String(t.phase) + '"'));
          break;
        case "fn":
          typeof t.fn != "function" && console.error(Wt(le, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "effect":
          t.effect != null && typeof t.effect != "function" && console.error(Wt(le, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "requires":
          t.requires != null && !Array.isArray(t.requires) && console.error(Wt(le, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(t.requiresIfExists) || console.error(Wt(le, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + Ur.map(function(i) {
            return '"' + i + '"';
          }).join(", ") + '; but "' + e + '" was provided.');
      }
      t.requires && t.requires.forEach(function(i) {
        s.find(function(n) {
          return n.name === i;
        }) == null && console.error(Wt(lu, String(t.name), i, i));
      });
    });
  });
}
function hu(s, t) {
  var e = /* @__PURE__ */ new Set();
  return s.filter(function(i) {
    var n = t(i);
    if (!e.has(n))
      return e.add(n), !0;
  });
}
function du(s) {
  var t = s.reduce(function(e, i) {
    var n = e[i.name];
    return e[i.name] = n ? Object.assign({}, n, i, {
      options: Object.assign({}, n.options, i.options),
      data: Object.assign({}, n.data, i.data)
    }) : i, e;
  }, {});
  return Object.keys(t).map(function(e) {
    return t[e];
  });
}
var Xr = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", uu = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", Gr = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function qr() {
  for (var s = arguments.length, t = new Array(s), e = 0; e < s; e++)
    t[e] = arguments[e];
  return !t.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function gn(s) {
  s === void 0 && (s = {});
  var t = s, e = t.defaultModifiers, i = e === void 0 ? [] : e, n = t.defaultOptions, o = n === void 0 ? Gr : n;
  return function(a, l, p) {
    p === void 0 && (p = o);
    var u = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Gr, o),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, _ = [], f = !1, g = {
      state: u,
      setOptions: function(T) {
        var y = typeof T == "function" ? T(u.options) : T;
        b(), u.options = Object.assign({}, o, u.options, y), u.scrollParents = {
          reference: ye(a) ? Ri(a) : a.contextElement ? Ri(a.contextElement) : [],
          popper: Ri(l)
        };
        var C = ru(du([].concat(i, u.options.modifiers)));
        if (u.orderedModifiers = C.filter(function(S) {
          return S.enabled;
        }), {}.NODE_ENV !== "production") {
          var E = hu([].concat(C, u.options.modifiers), function(S) {
            var N = S.name;
            return N;
          });
          if (cu(E), Et(u.options.placement) === ji) {
            var w = u.orderedModifiers.find(function(S) {
              var N = S.name;
              return N === "flip";
            });
            w || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var k = At(l), D = k.marginTop, O = k.marginRight, x = k.marginBottom, L = k.marginLeft;
          [D, O, x, L].some(function(S) {
            return parseFloat(S);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return m(), g.update();
      },
      // Sync update â it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var T = u.elements, y = T.reference, C = T.popper;
          if (!qr(y, C)) {
            ({}).NODE_ENV !== "production" && console.error(Xr);
            return;
          }
          u.rects = {
            reference: nu(y, Ki(C), u.options.strategy === "fixed"),
            popper: pr(C)
          }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(S) {
            return u.modifiersData[S.name] = Object.assign({}, S.data);
          });
          for (var E = 0, w = 0; w < u.orderedModifiers.length; w++) {
            if ({}.NODE_ENV !== "production" && (E += 1, E > 100)) {
              console.error(uu);
              break;
            }
            if (u.reset === !0) {
              u.reset = !1, w = -1;
              continue;
            }
            var k = u.orderedModifiers[w], D = k.fn, O = k.options, x = O === void 0 ? {} : O, L = k.name;
            typeof D == "function" && (u = D({
              state: u,
              options: x,
              name: L,
              instance: g
            }) || u);
          }
        }
      },
      // Async and optimistically optimized update â it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: au(function() {
        return new Promise(function(v) {
          g.forceUpdate(), v(u);
        });
      }),
      destroy: function() {
        b(), f = !0;
      }
    };
    if (!qr(a, l))
      return {}.NODE_ENV !== "production" && console.error(Xr), g;
    g.setOptions(p).then(function(v) {
      !f && p.onFirstUpdate && p.onFirstUpdate(v);
    });
    function m() {
      u.orderedModifiers.forEach(function(v) {
        var T = v.name, y = v.options, C = y === void 0 ? {} : y, E = v.effect;
        if (typeof E == "function") {
          var w = E({
            state: u,
            name: T,
            instance: g,
            options: C
          }), k = function() {
          };
          _.push(w || k);
        }
      });
    }
    function b() {
      _.forEach(function(v) {
        return v();
      }), _ = [];
    }
    return g;
  };
}
var pu = /* @__PURE__ */ gn(), _u = [mr, Tr, fr, ur], fu = /* @__PURE__ */ gn({
  defaultModifiers: _u
}), mu = [mr, Tr, fr, ur, Xc, zc, Gc, Yc, Uc], se = /* @__PURE__ */ gn({
  defaultModifiers: mu
});
const qc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  afterMain: Nc,
  afterRead: Dc,
  afterWrite: Pc,
  applyStyles: ur,
  arrow: Yc,
  auto: ji,
  basePlacements: ni,
  beforeMain: $c,
  beforeRead: Sc,
  beforeWrite: Mc,
  bottom: ut,
  clippingParents: xc,
  computeStyles: fr,
  createPopper: se,
  createPopperBase: pu,
  createPopperLite: fu,
  detectOverflow: Je,
  end: Ge,
  eventListeners: mr,
  flip: zc,
  hide: Uc,
  left: nt,
  main: Lc,
  modifierPhases: dn,
  offset: Xc,
  placements: hr,
  popper: Be,
  popperGenerator: gn,
  popperOffsets: Tr,
  preventOverflow: Gc,
  read: Ic,
  reference: Oc,
  right: pt,
  start: Ae,
  top: st,
  variationPlacements: Wo,
  viewport: cr,
  write: Rc
}, Symbol.toStringTag, { value: "Module" }));
function Ln(s) {
  return s === "true" ? !0 : s === "false" ? !1 : s === Number(s).toString() ? Number(s) : s === "" || s === "null" ? null : s;
}
function Nn(s) {
  return s.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
const h = {
  setDataAttribute(s, t, e) {
    s.setAttribute(`data-te-${Nn(t)}`, e);
  },
  removeDataAttribute(s, t) {
    s.removeAttribute(`data-te-${Nn(t)}`);
  },
  getDataAttributes(s) {
    if (!s)
      return {};
    const t = {};
    return Object.keys(s.dataset).filter((e) => e.startsWith("te")).forEach((e) => {
      if (e.startsWith("teClass"))
        return;
      let i = e.replace(/^te/, "");
      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = Ln(s.dataset[e]);
    }), t;
  },
  getDataClassAttributes(s) {
    if (!s)
      return {};
    const t = {
      ...s.dataset
    };
    return Object.keys(t).filter((e) => e.startsWith("teClass")).forEach((e) => {
      let i = e.replace(/^teClass/, "");
      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = Ln(t[e]);
    }), t;
  },
  getDataAttribute(s, t) {
    return Ln(
      s.getAttribute(`data-te-${Nn(t)}`)
    );
  },
  offset(s) {
    const t = s.getBoundingClientRect();
    return {
      top: t.top + document.body.scrollTop,
      left: t.left + document.body.scrollLeft
    };
  },
  position(s) {
    return {
      top: s.offsetTop,
      left: s.offsetLeft
    };
  },
  style(s, t) {
    Object.assign(s.style, t);
  },
  toggleClass(s, t) {
    s && Mn(t).forEach((e) => {
      s.classList.contains(e) ? s.classList.remove(e) : s.classList.add(e);
    });
  },
  addClass(s, t) {
    Mn(t).forEach(
      (e) => !s.classList.contains(e) && s.classList.add(e)
    );
  },
  addStyle(s, t) {
    Object.keys(t).forEach((e) => {
      s.style[e] = t[e];
    });
  },
  removeClass(s, t) {
    Mn(t).forEach(
      (e) => s.classList.contains(e) && s.classList.remove(e)
    );
  },
  hasClass(s, t) {
    return s.classList.contains(t);
  },
  maxOffset(s) {
    const t = s.getBoundingClientRect();
    return {
      top: t.top + Math.max(
        document.body.scrollTop,
        document.documentElement.scrollTop,
        window.scrollY
      ),
      left: t.left + Math.max(
        document.body.scrollLeft,
        document.documentElement.scrollLeft,
        window.scrollX
      )
    };
  }
};
function Mn(s) {
  return typeof s == "string" ? s.split(" ") : Array.isArray(s) ? s : !1;
}
const gu = 3, d = {
  closest(s, t) {
    return s.closest(t);
  },
  matches(s, t) {
    return s.matches(t);
  },
  find(s, t = document.documentElement) {
    return [].concat(
      ...Element.prototype.querySelectorAll.call(t, s)
    );
  },
  findOne(s, t = document.documentElement) {
    return Element.prototype.querySelector.call(t, s);
  },
  children(s, t) {
    return [].concat(...s.children).filter((i) => i.matches(t));
  },
  parents(s, t) {
    const e = [];
    let i = s.parentNode;
    for (; i && i.nodeType === Node.ELEMENT_NODE && i.nodeType !== gu; )
      this.matches(i, t) && e.push(i), i = i.parentNode;
    return e;
  },
  prev(s, t) {
    let e = s.previousElementSibling;
    for (; e; ) {
      if (e.matches(t))
        return [e];
      e = e.previousElementSibling;
    }
    return [];
  },
  next(s, t) {
    let e = s.nextElementSibling;
    for (; e; ) {
      if (this.matches(e, t))
        return [e];
      e = e.nextElementSibling;
    }
    return [];
  },
  focusableChildren(s) {
    const t = [
      "a",
      "button",
      "input",
      "textarea",
      "select",
      "details",
      "[tabindex]",
      '[contenteditable="true"]'
    ].map((e) => `${e}:not([tabindex^="-"])`).join(", ");
    return this.find(t, s).filter(
      (e) => !be(e) && Mt(e)
    );
  }
}, Rn = "dropdown", bu = "te.dropdown", xe = `.${bu}`, Er = ".data-api", Fs = "Escape", Zr = "Space", Qr = "Tab", jo = "ArrowUp", Ys = "ArrowDown", vu = 2, Tu = new RegExp(
  `${jo}|${Ys}|${Fs}`
), Eu = `hide${xe}`, Cu = `hidden${xe}`, Au = `show${xe}`, yu = `shown${xe}`, wu = `click${xe}${Er}`, Jr = `keydown${xe}${Er}`, ku = `keyup${xe}${Er}`, Ft = "show", xu = "dropup", Ou = "dropend", Su = "dropstart", Iu = "[data-te-navbar-ref]", os = "[data-te-dropdown-toggle-ref]", Pn = "[data-te-dropdown-menu-ref]", Du = "[data-te-navbar-nav-ref]", $u = "[data-te-dropdown-menu-ref] [data-te-dropdown-item-ref]:not(.disabled):not(:disabled)", Lu = W() ? "top-end" : "top-start", Nu = W() ? "top-start" : "top-end", Mu = W() ? "bottom-end" : "bottom-start", Ru = W() ? "bottom-start" : "bottom-end", Pu = W() ? "left-start" : "right-start", Bu = W() ? "right-start" : "left-start", Hu = [{ opacity: "0" }, { opacity: "1" }], Vu = [{ opacity: "1" }, { opacity: "0" }], ta = {
  iterations: 1,
  easing: "ease",
  fill: "both"
}, Wu = {
  offset: [0, 2],
  boundary: "clippingParents",
  reference: "toggle",
  display: "dynamic",
  popperConfig: null,
  autoClose: !0,
  dropdownAnimation: "on",
  animationDuration: 550
}, Fu = {
  offset: "(array|string|function)",
  boundary: "(string|element)",
  reference: "(string|element|object)",
  display: "string",
  popperConfig: "(null|object|function)",
  autoClose: "(boolean|string)",
  dropdownAnimation: "string",
  animationDuration: "number"
};
class $t extends ft {
  constructor(t, e) {
    super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._fadeOutAnimate = null;
    const i = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;
    this._animationCanPlay = this._config.dropdownAnimation === "on" && !i, this._didInit = !1, this._init();
  }
  // Getters
  static get Default() {
    return Wu;
  }
  static get DefaultType() {
    return Fu;
  }
  static get NAME() {
    return Rn;
  }
  // Public
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (be(this._element) || this._isShown(this._menu))
      return;
    const t = {
      relatedTarget: this._element
    };
    if (c.trigger(
      this._element,
      Au,
      t
    ).defaultPrevented)
      return;
    const i = $t.getParentFromElement(this._element);
    this._inNavbar ? h.setDataAttribute(this._menu, "popper", "none") : this._createPopper(i), "ontouchstart" in document.documentElement && !i.closest(Du) && [].concat(...document.body.children).forEach((n) => c.on(n, "mouseover", hn)), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.setAttribute(`data-te-dropdown-${Ft}`, ""), this._animationCanPlay && this._menu.animate(Hu, {
      ...ta,
      duration: this._config.animationDuration
    }), this._element.setAttribute(`data-te-dropdown-${Ft}`, ""), setTimeout(
      () => {
        c.trigger(this._element, yu, t);
      },
      this._animationCanPlay ? this._config.animationDuration : 0
    );
  }
  hide() {
    if (be(this._element) || !this._isShown(this._menu))
      return;
    const t = {
      relatedTarget: this._element
    };
    this._completeHide(t);
  }
  dispose() {
    this._popper && this._popper.destroy(), super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
  }
  // Private
  _init() {
    this._didInit || (c.on(
      document,
      Jr,
      os,
      $t.dataApiKeydownHandler
    ), c.on(
      document,
      Jr,
      Pn,
      $t.dataApiKeydownHandler
    ), c.on(document, wu, $t.clearMenus), c.on(document, ku, $t.clearMenus), this._didInit = !0);
  }
  _completeHide(t) {
    this._fadeOutAnimate && this._fadeOutAnimate.playState === "running" || c.trigger(
      this._element,
      Eu,
      t
    ).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((i) => c.off(i, "mouseover", hn)), this._animationCanPlay && (this._fadeOutAnimate = this._menu.animate(Vu, {
      ...ta,
      duration: this._config.animationDuration
    })), setTimeout(
      () => {
        this._popper && this._popper.destroy(), this._menu.removeAttribute(`data-te-dropdown-${Ft}`), this._element.removeAttribute(`data-te-dropdown-${Ft}`), this._element.setAttribute("aria-expanded", "false"), h.removeDataAttribute(this._menu, "popper"), c.trigger(this._element, Cu, t);
      },
      this._animationCanPlay ? this._config.animationDuration : 0
    ));
  }
  _getConfig(t) {
    if (t = {
      ...this.constructor.Default,
      ...h.getDataAttributes(this._element),
      ...t
    }, I(Rn, t, this.constructor.DefaultType), typeof t.reference == "object" && !Xe(t.reference) && typeof t.reference.getBoundingClientRect != "function")
      throw new TypeError(
        `${Rn.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`
      );
    return t;
  }
  _createPopper(t) {
    if (typeof qc > "u")
      throw new TypeError(
        "Bootstrap's dropdowns require Popper (https://popper.js.org)"
      );
    let e = this._element;
    this._config.reference === "parent" ? e = t : Xe(this._config.reference) ? e = ee(this._config.reference) : typeof this._config.reference == "object" && (e = this._config.reference);
    const i = this._getPopperConfig(), n = i.modifiers.find(
      (o) => o.name === "applyStyles" && o.enabled === !1
    );
    this._popper = se(
      e,
      this._menu,
      i
    ), n && h.setDataAttribute(this._menu, "popper", "static");
  }
  _isShown(t = this._element) {
    return t.dataset[`teDropdown${Ft.charAt(0).toUpperCase() + Ft.slice(1)}`] === "";
  }
  _getMenuElement() {
    return d.next(this._element, Pn)[0];
  }
  _getPlacement() {
    const t = this._element.parentNode;
    if (t.dataset.teDropdownPosition === Ou)
      return Pu;
    if (t.dataset.teDropdownPosition === Su)
      return Bu;
    const e = t.dataset.teDropdownAlignment === "end";
    return t.dataset.teDropdownPosition === xu ? e ? Nu : Lu : e ? Ru : Mu;
  }
  _detectNavbar() {
    return this._element.closest(Iu) !== null;
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _getPopperConfig() {
    const t = {
      placement: this._getPlacement(),
      modifiers: [
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }
      ]
    };
    return this._config.display === "static" && (t.modifiers = [
      {
        name: "applyStyles",
        enabled: !1
      }
    ]), {
      ...t,
      ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(t) : this._config.popperConfig
    };
  }
  _selectMenuItem({ key: t, target: e }) {
    const i = d.find(
      $u,
      this._menu
    ).filter(Mt);
    i.length && vc(
      i,
      e,
      t === Ys,
      !i.includes(e)
    ).focus();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = $t.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
  static clearMenus(t) {
    if (t && (t.button === vu || t.type === "keyup" && t.key !== Qr))
      return;
    const e = d.find(os);
    for (let i = 0, n = e.length; i < n; i++) {
      const o = $t.getInstance(e[i]);
      if (!o || o._config.autoClose === !1 || !o._isShown())
        continue;
      const r = {
        relatedTarget: o._element
      };
      if (t) {
        const a = t.composedPath(), l = a.includes(o._menu);
        if (a.includes(o._element) || o._config.autoClose === "inside" && !l || o._config.autoClose === "outside" && l || o._menu.contains(t.target) && (t.type === "keyup" && t.key === Qr || /input|select|option|textarea|form/i.test(t.target.tagName)))
          continue;
        t.type === "click" && (r.clickEvent = t);
      }
      o._completeHide(r);
    }
  }
  static getParentFromElement(t) {
    return te(t) || t.parentNode;
  }
  static dataApiKeydownHandler(t) {
    if (/input|textarea/i.test(t.target.tagName) ? t.key === Zr || t.key !== Fs && (t.key !== Ys && t.key !== jo || t.target.closest(Pn)) : !Tu.test(t.key))
      return;
    const e = this.dataset[`teDropdown${Ft.charAt(0).toUpperCase() + Ft.slice(1)}`] === "";
    if (!e && t.key === Fs || (t.preventDefault(), t.stopPropagation(), be(this)))
      return;
    const i = this.matches(os) ? this : d.prev(this, os)[0], n = $t.getOrCreateInstance(i);
    if (t.key === Fs) {
      n.hide();
      return;
    }
    if (t.key === jo || t.key === Ys) {
      e || n.show(), n._selectMenuItem(t);
      return;
    }
    (!e || t.key === Zr) && $t.clearMenus();
  }
}
const Bn = "collapse", Zc = "te.collapse", bn = `.${Zc}`, ea = {
  toggle: !0,
  parent: null
}, Yu = {
  toggle: "boolean",
  parent: "(null|element)"
}, ju = `show${bn}`, Ku = `shown${bn}`, zu = `hide${bn}`, Uu = `hidden${bn}`, Hn = "data-te-collapse-show", ia = "data-te-collapse-collapsed", rs = "data-te-collapse-collapsing", Xu = "data-te-collapse-horizontal", We = "data-te-collapse-item", sa = `:scope [${We}] [${We}]`, Gu = "width", qu = "height", Zu = "[data-te-collapse-item][data-te-collapse-show], [data-te-collapse-item][data-te-collapse-collapsing]", na = "[data-te-collapse-init]", Qu = {
  visible: "!visible",
  hidden: "hidden",
  baseTransition: "overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none",
  collapsing: "h-0 transition-[height] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none",
  collapsingHorizontal: "w-0 h-auto transition-[width] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none"
}, Ju = {
  visible: "string",
  hidden: "string",
  baseTransition: "string",
  collapsing: "string",
  collapsingHorizontal: "string"
};
class Qt extends ft {
  constructor(t, e, i) {
    super(t), this._isTransitioning = !1, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._triggerArray = [];
    const n = d.find(na);
    for (let o = 0, r = n.length; o < r; o++) {
      const a = n[o], l = lr(a), p = d.find(l).filter(
        (u) => u === this._element
      );
      l !== null && p.length && (this._selector = l, this._triggerArray.push(a));
    }
    this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
  }
  // Getters
  static get Default() {
    return ea;
  }
  static get NAME() {
    return Bn;
  }
  // Public
  toggle() {
    this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (this._isTransitioning || this._isShown())
      return;
    let t = [], e;
    if (this._config.parent) {
      const u = d.find(
        sa,
        this._config.parent
      );
      t = d.find(
        Zu,
        this._config.parent
      ).filter((_) => !u.includes(_));
    }
    const i = d.findOne(this._selector);
    if (t.length) {
      const u = t.find((_) => i !== _);
      if (e = u ? Qt.getInstance(u) : null, e && e._isTransitioning)
        return;
    }
    if (c.trigger(this._element, ju).defaultPrevented)
      return;
    t.forEach((u) => {
      i !== u && Qt.getOrCreateInstance(u, { toggle: !1 }).hide(), e || A.setData(u, Zc, null);
    });
    const o = this._getDimension(), r = o === "height" ? this._classes.collapsing : this._classes.collapsingHorizontal;
    h.removeClass(this._element, this._classes.visible), h.removeClass(this._element, this._classes.hidden), h.addClass(this._element, r), this._element.removeAttribute(We), this._element.setAttribute(rs, ""), this._element.style[o] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
    const a = () => {
      this._isTransitioning = !1, h.removeClass(this._element, this._classes.hidden), h.removeClass(this._element, r), h.addClass(this._element, this._classes.visible), this._element.removeAttribute(rs), this._element.setAttribute(We, ""), this._element.setAttribute(Hn, ""), this._element.style[o] = "", c.trigger(this._element, Ku);
    }, p = `scroll${o[0].toUpperCase() + o.slice(1)}`;
    this._queueCallback(a, this._element, !0), this._element.style[o] = `${this._element[p]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown() || c.trigger(this._element, zu).defaultPrevented)
      return;
    const e = this._getDimension(), i = e === "height" ? this._classes.collapsing : this._classes.collapsingHorizontal;
    this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, si(this._element), h.addClass(this._element, i), h.removeClass(this._element, this._classes.visible), h.removeClass(this._element, this._classes.hidden), this._element.setAttribute(rs, ""), this._element.removeAttribute(We), this._element.removeAttribute(Hn);
    const n = this._triggerArray.length;
    for (let r = 0; r < n; r++) {
      const a = this._triggerArray[r], l = te(a);
      l && !this._isShown(l) && this._addAriaAndCollapsedClass([a], !1);
    }
    this._isTransitioning = !0;
    const o = () => {
      this._isTransitioning = !1, h.removeClass(this._element, i), h.addClass(this._element, this._classes.visible), h.addClass(this._element, this._classes.hidden), this._element.removeAttribute(rs), this._element.setAttribute(We, ""), c.trigger(this._element, Uu);
    };
    this._element.style[e] = "", this._queueCallback(o, this._element, !0);
  }
  _isShown(t = this._element) {
    return t.hasAttribute(Hn);
  }
  // Private
  _getConfig(t) {
    return t = {
      ...ea,
      ...h.getDataAttributes(this._element),
      ...t
    }, t.toggle = !!t.toggle, t.parent = ee(t.parent), I(Bn, t, Yu), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...Qu,
      ...e,
      ...t
    }, I(Bn, t, Ju), t;
  }
  _getDimension() {
    return this._element.hasAttribute(Xu) ? Gu : qu;
  }
  _initializeChildren() {
    if (!this._config.parent)
      return;
    const t = d.find(
      sa,
      this._config.parent
    );
    d.find(na, this._config.parent).filter((e) => !t.includes(e)).forEach((e) => {
      const i = te(e);
      i && this._addAriaAndCollapsedClass([e], this._isShown(i));
    });
  }
  _addAriaAndCollapsedClass(t, e) {
    t.length && t.forEach((i) => {
      e ? i.removeAttribute(ia) : i.setAttribute(`${ia}`, ""), i.setAttribute("aria-expanded", e);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = {};
      typeof t == "string" && /show|hide/.test(t) && (e.toggle = !1);
      const i = Qt.getOrCreateInstance(this, e);
      if (typeof t == "string") {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t]();
      }
    });
  }
}
const oa = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", ra = ".sticky-top";
class ti {
  constructor() {
    this._element = document.body;
  }
  getWidth() {
    const t = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - t);
  }
  hide() {
    const t = this.getWidth();
    this._disableOverFlow(), this._setElementAttributes(
      this._element,
      "paddingRight",
      (e) => e + t
    ), this._setElementAttributes(
      oa,
      "paddingRight",
      (e) => e + t
    ), this._setElementAttributes(
      ra,
      "marginRight",
      (e) => e - t
    );
  }
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
  }
  _setElementAttributes(t, e, i) {
    const n = this.getWidth(), o = (r) => {
      if (r !== this._element && window.innerWidth > r.clientWidth + n)
        return;
      this._saveInitialAttribute(r, e);
      const a = window.getComputedStyle(r)[e];
      r.style[e] = `${i(
        Number.parseFloat(a)
      )}px`;
    };
    this._applyManipulationCallback(t, o);
  }
  reset() {
    this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(oa, "paddingRight"), this._resetElementAttributes(ra, "marginRight");
  }
  _saveInitialAttribute(t, e) {
    const i = t.style[e];
    i && h.setDataAttribute(t, e, i);
  }
  _resetElementAttributes(t, e) {
    const i = (n) => {
      const o = h.getDataAttribute(n, e);
      typeof o > "u" ? n.style.removeProperty(e) : (h.removeDataAttribute(n, e), n.style[e] = o);
    };
    this._applyManipulationCallback(t, i);
  }
  _applyManipulationCallback(t, e) {
    Xe(t) ? e(t) : d.find(t, this._element).forEach(e);
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }
}
const tp = {
  isVisible: !0,
  // if false, we use the backdrop helper without adding any element to the dom
  isAnimated: !1,
  rootElement: "body",
  // give the choice to place backdrop under different elements
  clickCallback: null,
  backdropClasses: null
}, ep = {
  isVisible: "boolean",
  isAnimated: "boolean",
  rootElement: "(element|string)",
  clickCallback: "(function|null)",
  backdropClasses: "(array|string|null)"
}, Qc = "backdrop", aa = `mousedown.te.${Qc}`;
class Cr {
  constructor(t) {
    this._config = this._getConfig(t), this._isAppended = !1, this._element = null;
  }
  show(t) {
    if (!this._config.isVisible) {
      ge(t);
      return;
    }
    this._append(), this._config.isAnimated && si(this._getElement());
    const e = this._config.backdropClasses || [
      "opacity-50",
      "transition-all",
      "duration-300",
      "ease-in-out",
      "fixed",
      "top-0",
      "left-0",
      "z-[1040]",
      "bg-black",
      "w-screen",
      "h-screen"
    ];
    h.removeClass(this._getElement(), "opacity-0"), h.addClass(this._getElement(), e), this._element.setAttribute("data-te-backdrop-show", ""), this._emulateAnimation(() => {
      ge(t);
    });
  }
  hide(t) {
    if (!this._config.isVisible) {
      ge(t);
      return;
    }
    this._element.removeAttribute("data-te-backdrop-show"), this._getElement().classList.add("opacity-0"), this._getElement().classList.remove("opacity-50"), this._emulateAnimation(() => {
      this.dispose(), ge(t);
    });
  }
  // Private
  _getElement() {
    if (!this._element) {
      const t = document.createElement("div");
      t.className = this._config.className, this._config.isAnimated && t.classList.add("opacity-50"), this._element = t;
    }
    return this._element;
  }
  _getConfig(t) {
    return t = {
      ...tp,
      ...typeof t == "object" ? t : {}
    }, t.rootElement = ee(t.rootElement), I(Qc, t, ep), t;
  }
  _append() {
    this._isAppended || (this._config.rootElement.append(this._getElement()), c.on(this._getElement(), aa, () => {
      ge(this._config.clickCallback);
    }), this._isAppended = !0);
  }
  dispose() {
    this._isAppended && (c.off(this._element, aa), this._element.remove(), this._isAppended = !1);
  }
  _emulateAnimation(t) {
    bc(
      t,
      this._getElement(),
      this._config.isAnimated
    );
  }
}
class zi {
  constructor(t, e = {}, i) {
    this._element = t, this._toggler = i, this._event = e.event || "blur", this._condition = e.condition || (() => !0), this._selector = e.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex="-1"])', this._onlyVisible = e.onlyVisible || !1, this._focusableElements = [], this._firstElement = null, this._lastElement = null, this.handler = (n) => {
      this._condition(n) && !n.shiftKey && n.target === this._lastElement ? (n.preventDefault(), this._firstElement.focus()) : this._condition(n) && n.shiftKey && n.target === this._firstElement && (n.preventDefault(), this._lastElement.focus());
    };
  }
  trap() {
    this._setElements(), this._init(), this._setFocusTrap();
  }
  disable() {
    this._focusableElements.forEach((t) => {
      t.removeEventListener(this._event, this.handler);
    }), this._toggler && this._toggler.focus();
  }
  update() {
    this._setElements(), this._setFocusTrap();
  }
  _init() {
    const t = (e) => {
      !this._firstElement || e.key !== "Tab" || this._focusableElements.includes(e.target) || (e.preventDefault(), this._firstElement.focus(), window.removeEventListener("keydown", t));
    };
    window.addEventListener("keydown", t);
  }
  _filterVisible(t) {
    return t.filter((e) => {
      if (!Mt(e))
        return !1;
      const i = d.parents(e, "*");
      for (let n = 0; n < i.length; n++) {
        const o = window.getComputedStyle(i[n]);
        if (o && (o.display === "none" || o.visibility === "hidden"))
          return !1;
      }
      return !0;
    });
  }
  _setElements() {
    this._focusableElements = d.focusableChildren(this._element), this._onlyVisible && (this._focusableElements = this._filterVisible(this._focusableElements)), this._firstElement = this._focusableElements[0], this._lastElement = this._focusableElements[this._focusableElements.length - 1];
  }
  _setFocusTrap() {
    this._focusableElements.forEach((t, e) => {
      e === this._focusableElements.length - 1 || e === 0 ? t.addEventListener(this._event, this.handler) : t.removeEventListener(this._event, this.handler);
    });
  }
}
let la = [];
const vn = (s, t = "hide") => {
  const e = `click.dismiss${s.EVENT_KEY}`, i = s.NAME;
  la.includes(i) || (la.push(i), c.on(
    document,
    e,
    `[data-te-${i}-dismiss]`,
    function(n) {
      if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), be(this))
        return;
      const o = te(this) || this.closest(`.${i}`) || this.closest(`[data-te-${i}-init]`);
      if (!o)
        return;
      s.getOrCreateInstance(o)[t]();
    }
  ));
}, ca = "offcanvas", ip = "te.offcanvas", oi = `.${ip}`, sp = ".data-api", np = `load${oi}${sp}`, op = "Escape", ha = {
  backdrop: !0,
  keyboard: !0,
  scroll: !1
}, rp = {
  backdrop: "boolean",
  keyboard: "boolean",
  scroll: "boolean"
}, da = "show", ap = "[data-te-offcanvas-init][data-te-offcanvas-show]", lp = `show${oi}`, cp = `shown${oi}`, hp = `hide${oi}`, dp = `hidden${oi}`, up = `keydown.dismiss${oi}`;
class js extends ft {
  constructor(t, e) {
    super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners(), this._didInit = !1, this._init();
  }
  // Getters
  static get NAME() {
    return ca;
  }
  static get Default() {
    return ha;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    if (this._isShown || c.trigger(this._element, lp, {
      relatedTarget: t
    }).defaultPrevented)
      return;
    this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || new ti().hide(), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.setAttribute(`data-te-offcanvas-${da}`, "");
    const i = () => {
      this._config.scroll || this._focustrap.trap(), c.trigger(this._element, cp, { relatedTarget: t });
    };
    this._queueCallback(i, this._element, !0);
  }
  hide() {
    if (!this._isShown || c.trigger(this._element, hp).defaultPrevented)
      return;
    this._focustrap.disable(), this._element.blur(), this._isShown = !1, this._element.removeAttribute(`data-te-offcanvas-${da}`), this._backdrop.hide();
    const e = () => {
      this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || new ti().reset(), c.trigger(this._element, dp);
    };
    this._queueCallback(e, this._element, !0);
  }
  dispose() {
    this._backdrop.dispose(), this._focustrap.disable(), super.dispose();
  }
  // Private
  _init() {
    this._didInit || (c.on(
      window,
      np,
      () => d.find(ap).forEach(
        (t) => js.getOrCreateInstance(t).show()
      )
    ), this._didInit = !0, vn(js));
  }
  _getConfig(t) {
    return t = {
      ...ha,
      ...h.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, I(ca, t, rp), t;
  }
  _initializeBackDrop() {
    return new Cr({
      isVisible: this._config.backdrop,
      isAnimated: !0,
      rootElement: this._element.parentNode,
      clickCallback: () => this.hide()
    });
  }
  _initializeFocusTrap() {
    return new zi(this._element, {
      event: "keydown",
      condition: (t) => t.key === "Tab"
    });
  }
  _addEventListeners() {
    c.on(this._element, up, (t) => {
      this._config.keyboard && t.key === op && this.hide();
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = js.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const Vn = "alert", pp = "te.alert", Jc = `.${pp}`, _p = `close${Jc}`, fp = `closed${Jc}`, ui = "data-te-alert-show", mp = {
  animation: "boolean",
  autohide: "boolean",
  autoclose: "boolean",
  delay: "number"
}, ua = {
  animation: !0,
  autohide: !0,
  autoclose: !1,
  delay: 1e3
}, gp = {
  fadeIn: "animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none",
  fadeOut: "animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none"
}, bp = {
  fadeIn: "string",
  fadeOut: "string"
};
class Ko extends ft {
  constructor(t, e, i) {
    super(t), this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._didInit = !1, this._init();
  }
  // Getters
  static get DefaultType() {
    return mp;
  }
  static get Default() {
    return ua;
  }
  static get NAME() {
    return Vn;
  }
  // Public
  close() {
    if (c.trigger(this._element, _p).defaultPrevented)
      return;
    let e = 0;
    this._config.animation && (e = 300, h.addClass(this._element, this._classes.fadeOut)), this._element.removeAttribute(ui), setTimeout(() => {
      this._queueCallback(
        () => this._destroyElement(),
        this._element,
        this._config.animation
      );
    }, e);
  }
  show() {
    if (this._element) {
      if (this._config.autohide && this._setupAutohide(), (this._config.autoclose || this._config.autoclose && this._config.autohide) && this._setupAutoclose(), !this._element.hasAttribute(ui) && (h.removeClass(this._element, "hidden"), h.addClass(this._element, "block"), Mt(this._element))) {
        const t = (e) => {
          h.removeClass(this._element, "hidden"), h.addClass(this._element, "block"), c.off(e.target, "animationend", t);
        };
        this._element.setAttribute(ui, ""), c.on(this._element, "animationend", t);
      }
      this._config.animation && (h.removeClass(this._element, this._classes.fadeOut), h.addClass(this._element, this._classes.fadeIn));
    }
  }
  hide() {
    if (this._element && this._element.hasAttribute(ui)) {
      this._element.removeAttribute(ui);
      const t = (e) => {
        h.addClass(this._element, "hidden"), h.removeClass(this._element, "block"), this._timeout !== null && (clearTimeout(this._timeout), this._timeout = null), c.off(e.target, "animationend", t);
      };
      c.on(this._element, "animationend", t), h.removeClass(this._element, this._classes.fadeIn), h.addClass(this._element, this._classes.fadeOut);
    }
  }
  // Private
  _init() {
    this._didInit || (vn(Ko, "close"), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...ua,
      ...h.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, I(Vn, t, this.constructor.DefaultType), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...gp,
      ...e,
      ...t
    }, I(Vn, t, bp), t;
  }
  _setupAutohide() {
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }
  _setupAutoclose() {
    this._timeout = setTimeout(() => {
      this.close();
    }, this._config.delay);
  }
  _destroyElement() {
    this._element.remove(), c.trigger(this._element, fp), this.dispose();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Ko.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const Wn = "carousel", vp = "te.carousel", mt = `.${vp}`, th = ".data-api", Tp = "ArrowLeft", Ep = "ArrowRight", Cp = 500, Ap = 40, pa = {
  interval: 5e3,
  keyboard: !0,
  ride: !1,
  pause: "hover",
  wrap: !0,
  touch: !0
}, yp = {
  interval: "(number|boolean)",
  keyboard: "boolean",
  ride: "(boolean|string)",
  pause: "(string|boolean)",
  wrap: "boolean",
  touch: "boolean"
}, wp = {
  pointer: "touch-pan-y",
  block: "!block",
  visible: "data-[te-carousel-fade]:opacity-100 data-[te-carousel-fade]:z-[1]",
  invisible: "data-[te-carousel-fade]:z-0 data-[te-carousel-fade]:opacity-0 data-[te-carousel-fade]:duration-[600ms] data-[te-carousel-fade]:delay-600",
  slideRight: "translate-x-full",
  slideLeft: "-translate-x-full"
}, kp = {
  pointer: "string",
  block: "string",
  visible: "string",
  invisible: "string",
  slideRight: "string",
  slideLeft: "string"
}, ce = "next", he = "prev", fe = "left", Ei = "right", xp = {
  [Tp]: Ei,
  [Ep]: fe
}, Op = `slide${mt}`, Fn = `slid${mt}`, Sp = `keydown${mt}`, Ip = `mouseenter${mt}`, Dp = `mouseleave${mt}`, $p = `touchstart${mt}`, Lp = `touchmove${mt}`, Np = `touchend${mt}`, Mp = `pointerdown${mt}`, Rp = `pointerup${mt}`, Pp = `dragstart${mt}`, Bp = `load${mt}${th}`, Hp = `click${mt}${th}`, _a = "data-te-carousel-init", de = "data-te-carousel-active", Vp = "data-te-carousel-item-end", Yn = "data-te-carousel-item-start", Wp = "data-te-carousel-item-next", Fp = "data-te-carousel-item-prev", Yp = "data-te-carousel-pointer-event", jp = "[data-te-carousel-init]", eh = "[data-te-carousel-active]", Ar = "[data-te-carousel-item]", Se = `${eh}${Ar}`, Kp = `${Ar} img`, zp = "[data-te-carousel-item-next], [data-te-carousel-item-prev]", Up = "[data-te-carousel-indicators]", Xp = "[data-te-target]", Gp = "[data-te-slide], [data-te-slide-to]", qp = "touch", Zp = "pen";
class Xt extends ft {
  constructor(t, e, i) {
    super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._indicatorsElement = d.findOne(
      Up,
      this._element
    ), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = !!window.PointerEvent, this._setActiveElementClass(), this._addEventListeners(), this._didInit = !1, this._init(), this._config.ride === "carousel" && this.cycle();
  }
  // Getters
  static get Default() {
    return pa;
  }
  static get NAME() {
    return Wn;
  }
  // Public
  next() {
    this._slide(ce);
  }
  nextWhenVisible() {
    !document.hidden && Mt(this._element) && this.next();
  }
  prev() {
    this._slide(he);
  }
  pause(t) {
    t || (this._isPaused = !0), d.findOne(zp, this._element) && (_c(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;
  }
  cycle(t) {
    t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval(
      (document.visibilityState ? this.nextWhenVisible : this.next).bind(
        this
      ),
      this._config.interval
    ));
  }
  to(t) {
    this._activeElement = d.findOne(
      Se,
      this._element
    );
    const e = this._getItemIndex(this._activeElement);
    if (t > this._items.length - 1 || t < 0)
      return;
    if (this._isSliding) {
      c.one(this._element, Fn, () => this.to(t));
      return;
    }
    if (e === t) {
      this.pause(), this.cycle();
      return;
    }
    const i = t > e ? ce : he;
    this._slide(i, this._items[t]);
  }
  // Private
  _init() {
    this._didInit || (c.on(
      document,
      Hp,
      Gp,
      Xt.dataApiClickHandler
    ), c.on(window, Bp, () => {
      const t = d.find(jp);
      for (let e = 0, i = t.length; e < i; e++)
        Xt.carouselInterface(
          t[e],
          Xt.getInstance(t[e])
        );
    }), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...pa,
      ...h.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, I(Wn, t, yp), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...wp,
      ...e,
      ...t
    }, I(Wn, t, kp), t;
  }
  _enableCycle() {
    if (this._config.ride) {
      if (this._isSliding) {
        c.one(this._element, Fn, () => this.cycle());
        return;
      }
      this.cycle();
    }
  }
  _applyInitialClasses() {
    const t = d.findOne(
      Se,
      this._element
    );
    t.classList.add(
      this._classes.block,
      ...this._classes.visible.split(" ")
    ), this._setActiveIndicatorElement(t);
  }
  _handleSwipe() {
    const t = Math.abs(this.touchDeltaX);
    if (t <= Ap)
      return;
    const e = t / this.touchDeltaX;
    this.touchDeltaX = 0, e && this._slide(e > 0 ? Ei : fe);
  }
  _setActiveElementClass() {
    this._activeElement = d.findOne(
      Se,
      this._element
    ), h.addClass(this._activeElement, "hidden");
  }
  _addEventListeners() {
    this._config.keyboard && c.on(
      this._element,
      Sp,
      (t) => this._keydown(t)
    ), this._config.pause === "hover" && (c.on(
      this._element,
      Ip,
      (t) => this.pause(t)
    ), c.on(
      this._element,
      Dp,
      (t) => this._enableCycle(t)
    )), this._config.touch && this._touchSupported && this._addTouchEventListeners(), this._applyInitialClasses();
  }
  _addTouchEventListeners() {
    const t = (o) => this._pointerEvent && (o.pointerType === Zp || o.pointerType === qp), e = (o) => {
      t(o) ? this.touchStartX = o.clientX : this._pointerEvent || (this.touchStartX = o.touches[0].clientX);
    }, i = (o) => {
      this.touchDeltaX = o.touches && o.touches.length > 1 ? 0 : o.touches[0].clientX - this.touchStartX;
    }, n = (o) => {
      t(o) && (this.touchDeltaX = o.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(
        (r) => this._enableCycle(r),
        Cp + this._config.interval
      ));
    };
    d.find(Kp, this._element).forEach(
      (o) => {
        c.on(
          o,
          Pp,
          (r) => r.preventDefault()
        );
      }
    ), this._pointerEvent ? (c.on(
      this._element,
      Mp,
      (o) => e(o)
    ), c.on(this._element, Rp, (o) => n(o)), this._element.classList.add(this._classes.pointer), this._element.setAttribute(`${Yp}`, "")) : (c.on(this._element, $p, (o) => e(o)), c.on(this._element, Lp, (o) => i(o)), c.on(this._element, Np, (o) => n(o)));
  }
  _keydown(t) {
    if (/input|textarea/i.test(t.target.tagName))
      return;
    const e = xp[t.key];
    e && (t.preventDefault(), this._slide(e));
  }
  _getItemIndex(t) {
    return this._items = t && t.parentNode ? d.find(Ar, t.parentNode) : [], this._items.indexOf(t);
  }
  _getItemByOrder(t, e) {
    const i = t === ce;
    return vc(
      this._items,
      e,
      i,
      this._config.wrap
    );
  }
  _triggerSlideEvent(t, e) {
    const i = this._getItemIndex(t), n = this._getItemIndex(
      d.findOne(Se, this._element)
    );
    return c.trigger(this._element, Op, {
      relatedTarget: t,
      direction: e,
      from: n,
      to: i
    });
  }
  _setActiveIndicatorElement(t) {
    if (this._indicatorsElement) {
      const e = d.findOne(
        eh,
        this._indicatorsElement
      );
      e.removeAttribute(de), e.removeAttribute("aria-current"), e.classList.remove("!opacity-100");
      const i = d.find(
        Xp,
        this._indicatorsElement
      );
      for (let n = 0; n < i.length; n++)
        if (Number.parseInt(
          i[n].getAttribute("data-te-slide-to"),
          10
        ) === this._getItemIndex(t)) {
          i[n].setAttribute(`${de}`, ""), i[n].setAttribute("aria-current", "true"), i[n].classList.add("!opacity-100");
          break;
        }
    }
  }
  _updateInterval() {
    const t = this._activeElement || d.findOne(Se, this._element);
    if (!t)
      return;
    const e = Number.parseInt(
      t.getAttribute("data-te-interval"),
      10
    );
    e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval;
  }
  _slide(t, e) {
    const i = this._directionToOrder(t), n = d.findOne(
      Se,
      this._element
    ), o = this._getItemIndex(n), r = e || this._getItemByOrder(i, n), a = this._getItemIndex(r), l = !!this._interval, p = i === ce, u = p ? Yn : Vp, _ = p ? Wp : Fp, f = this._orderToDirection(i), g = u === Yn ? this._classes.slideLeft : this._classes.slideRight, m = u !== Yn ? this._classes.slideLeft : this._classes.slideRight;
    if (r && r.hasAttribute(de)) {
      this._isSliding = !1;
      return;
    }
    if (this._isSliding || this._triggerSlideEvent(r, f).defaultPrevented || !n || !r)
      return;
    this._isSliding = !0, l && this.pause(), this._setActiveIndicatorElement(r), this._activeElement = r;
    const v = () => {
      c.trigger(this._element, Fn, {
        relatedTarget: r,
        direction: f,
        from: o,
        to: a
      });
    };
    if (this._element.hasAttribute(_a)) {
      r.setAttribute(`${_}`, ""), r.classList.add(this._classes.block, m), si(r), n.setAttribute(`${u}`, ""), n.classList.add(
        g,
        ...this._classes.invisible.split(" ")
      ), n.classList.remove(...this._classes.visible.split(" ")), r.setAttribute(`${u}`, ""), r.classList.add(...this._classes.visible.split(" ")), r.classList.remove(
        this._classes.slideRight,
        this._classes.slideLeft
      );
      const T = () => {
        r.removeAttribute(u), r.removeAttribute(_), r.setAttribute(`${de}`, ""), n.removeAttribute(de), n.classList.remove(
          g,
          ...this._classes.invisible.split(" "),
          this._classes.block
        ), n.removeAttribute(_), n.removeAttribute(u), this._isSliding = !1, setTimeout(v, 0);
      };
      this._queueCallback(T, n, !0);
    } else
      n.removeAttribute(de), n.classList.remove(this._classes.block), r.setAttribute(`${de}`, ""), r.classList.add(this._classes.block), this._isSliding = !1, v();
    l && this.cycle();
  }
  _directionToOrder(t) {
    return [Ei, fe].includes(t) ? W() ? t === fe ? he : ce : t === fe ? ce : he : t;
  }
  _orderToDirection(t) {
    return [ce, he].includes(t) ? W() ? t === he ? fe : Ei : t === he ? Ei : fe : t;
  }
  // Static
  static carouselInterface(t, e) {
    const i = Xt.getOrCreateInstance(t, e);
    let { _config: n } = i;
    typeof e == "object" && (n = {
      ...n,
      ...e
    });
    const o = typeof e == "string" ? e : e.slide;
    if (typeof e == "number") {
      i.to(e);
      return;
    }
    if (typeof o == "string") {
      if (typeof i[o] > "u")
        throw new TypeError(`No method named "${o}"`);
      i[o]();
    } else
      n.interval && n.ride === !0 && i.pause();
  }
  static jQueryInterface(t) {
    return this.each(function() {
      Xt.carouselInterface(this, t);
    });
  }
  static dataApiClickHandler(t) {
    const e = te(this);
    if (!e || !e.hasAttribute(_a))
      return;
    const i = {
      ...h.getDataAttributes(e),
      ...h.getDataAttributes(this)
    }, n = this.getAttribute("data-te-slide-to");
    n && (i.interval = !1), Xt.carouselInterface(e, i), n && Xt.getInstance(e).to(n), t.preventDefault();
  }
}
const jn = "modal", Qp = "te.modal", yt = `.${Qp}`, fa = "Escape", ma = {
  backdrop: !0,
  keyboard: !0,
  focus: !0,
  modalNonInvasive: !1
}, Jp = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  focus: "boolean",
  modalNonInvasive: "boolean"
}, t_ = {
  show: "transform-none",
  static: "scale-[1.02]",
  staticProperties: "transition-scale duration-300 ease-in-out",
  backdrop: "opacity-50 transition-all duration-300 ease-in-out fixed top-0 left-0 z-[1040] bg-black w-screen h-screen"
}, e_ = {
  show: "string",
  static: "string",
  staticProperties: "string",
  backdrop: "string"
}, i_ = `hide${yt}`, s_ = `hidePrevented${yt}`, n_ = `hidden${yt}`, o_ = `show${yt}`, r_ = `shown${yt}`, ga = `resize${yt}`, ba = `click.dismiss${yt}`, va = `keydown.dismiss${yt}`, a_ = `mouseup.dismiss${yt}`, Ta = `mousedown.dismiss${yt}`, Ea = "data-te-modal-open", Ca = "data-te-open", pi = "[data-te-modal-dialog-ref]", l_ = "[data-te-modal-body-ref]";
class zo extends ft {
  constructor(t, e, i) {
    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._dialog = d.findOne(pi, this._element), this._backdrop = this._config.modalNonInvasive ? null : this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new ti(), this._didInit = !1, this._init();
  }
  // Getters
  static get Default() {
    return ma;
  }
  static get NAME() {
    return jn;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    this._isShown || this._isTransitioning || c.trigger(this._element, o_, {
      relatedTarget: t
    }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), !this._config.modalNonInvasive && this._scrollBar.hide(), document.body.setAttribute(Ea, "true"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), c.on(this._dialog, Ta, () => {
      c.one(this._element, a_, (i) => {
        i.target === this._element && (this._ignoreBackdropClick = !0);
      });
    }), this._showElement(t), !this._config.modalNonInvasive && this._showBackdrop());
  }
  hide() {
    if (!this._isShown || this._isTransitioning || c.trigger(this._element, i_).defaultPrevented)
      return;
    this._isShown = !1;
    const e = this._isAnimated();
    e && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.disable(), d.findOne(pi, this._element).classList.remove(this._classes.show), c.off(this._element, ba), c.off(this._dialog, Ta), this._queueCallback(() => this._hideModal(), this._element, e), this._element.removeAttribute(Ca);
  }
  dispose() {
    [window, document, this._dialog].forEach(
      (t) => c.off(t, yt)
    ), this._backdrop && this._backdrop.dispose(), this._focustrap.disable(), super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }
  // Private
  _init() {
    this._didInit || (vn(zo), this._didInit = !0);
  }
  _initializeBackDrop() {
    return new Cr({
      isVisible: !!this._config.backdrop,
      // 'static' option will be translated to true, and booleans will keep their value
      isAnimated: this._isAnimated(),
      backdropClasses: this._classes.backdrop
    });
  }
  _initializeFocusTrap() {
    return new zi(this._element, {
      event: "keydown",
      condition: (t) => t.key === "Tab"
    });
  }
  _getConfig(t) {
    return t = {
      ...ma,
      ...h.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, I(jn, t, Jp), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...t_,
      ...e,
      ...t
    }, I(jn, t, e_), t;
  }
  _showElement(t) {
    const e = this._isAnimated(), i = d.findOne(l_, this._dialog);
    (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) && document.body.append(this._element), this._element.style.display = "block", this._element.classList.remove("hidden"), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.setAttribute(`${Ca}`, "true"), this._element.scrollTop = 0;
    const n = d.findOne(pi, this._element);
    n.classList.add(this._classes.show), n.classList.remove("opacity-0"), n.classList.add("opacity-100"), i && (i.scrollTop = 0), e && si(this._element);
    const o = () => {
      this._config.focus && this._focustrap.trap(), this._isTransitioning = !1, c.trigger(this._element, r_, {
        relatedTarget: t
      });
    };
    this._queueCallback(o, this._dialog, e);
  }
  _setEscapeEvent() {
    this._isShown ? c.on(document, va, (t) => {
      this._config.keyboard && t.key === fa ? (t.preventDefault(), this.hide()) : !this._config.keyboard && t.key === fa && this._triggerBackdropTransition();
    }) : c.off(this._element, va);
  }
  _setResizeEvent() {
    this._isShown ? c.on(window, ga, () => this._adjustDialog()) : c.off(window, ga);
  }
  _hideModal() {
    const t = d.findOne(pi, this._element);
    t.classList.remove(this._classes.show), t.classList.remove("opacity-100"), t.classList.add("opacity-0");
    const e = cn(t);
    setTimeout(() => {
      this._element.style.display = "none";
    }, e), this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop && this._backdrop.hide(() => {
      document.body.removeAttribute(Ea), this._resetAdjustments(), !this._config.modalNonInvasive && this._scrollBar.reset(), c.trigger(this._element, n_);
    });
  }
  _showBackdrop(t) {
    c.on(this._element, ba, (e) => {
      if (this._ignoreBackdropClick) {
        this._ignoreBackdropClick = !1;
        return;
      }
      e.target === e.currentTarget && (this._config.backdrop === !0 ? this.hide() : this._config.backdrop === "static" && this._triggerBackdropTransition());
    }), this._backdrop && this._backdrop.show(t);
  }
  _isAnimated() {
    return !!d.findOne(pi, this._element);
  }
  _triggerBackdropTransition() {
    if (c.trigger(this._element, s_).defaultPrevented)
      return;
    const { classList: e, scrollHeight: i, style: n } = this._element, o = i > document.documentElement.clientHeight;
    if (!o && n.overflowY === "hidden" || e.contains(this._classes.static))
      return;
    o || (n.overflowY = "hidden"), e.add(...this._classes.static.split(" ")), e.add(...this._classes.staticProperties.split(" "));
    const r = cn(this._element);
    this._queueCallback(() => {
      e.remove(this._classes.static), setTimeout(() => {
        e.remove(...this._classes.staticProperties.split(" "));
      }, r), o || this._queueCallback(() => {
        n.overflowY = "";
      }, this._dialog);
    }, this._dialog), this._element.focus();
  }
  // ----------------------------------------------------------------------
  // the following methods are used to handle overflowing modals
  // ----------------------------------------------------------------------
  _adjustDialog() {
    const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), i = e > 0;
    (!i && t && !W() || i && !t && W()) && (this._element.style.paddingLeft = `${e}px`), (i && !t && !W() || !i && t && W()) && (this._element.style.paddingRight = `${e}px`);
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      const i = zo.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
}
const c_ = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), ih = /^aria-[\w-]*$/i, h_ = /^data-te-[\w-]*$/i, d_ = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, u_ = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, p_ = (s, t) => {
  const e = s.nodeName.toLowerCase();
  if (t.includes(e))
    return c_.has(e) ? !!(d_.test(s.nodeValue) || u_.test(s.nodeValue)) : !0;
  const i = t.filter(
    (n) => n instanceof RegExp
  );
  for (let n = 0, o = i.length; n < o; n++)
    if (i[n].test(e))
      return !0;
  return !1;
}, sh = {
  // Global attributes allowed on any supplied element below.
  "*": [
    "class",
    "dir",
    "id",
    "lang",
    "role",
    ih,
    h_
  ],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
}, __ = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", ih],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
function pn(s, t, e) {
  if (!s.length)
    return s;
  if (e && typeof e == "function")
    return e(s);
  const n = new window.DOMParser().parseFromString(s, "text/html"), o = [].concat(...n.body.querySelectorAll("*"));
  for (let r = 0, a = o.length; r < a; r++) {
    const l = o[r], p = l.nodeName.toLowerCase();
    if (!Object.keys(t).includes(p)) {
      l.remove();
      continue;
    }
    const u = [].concat(...l.attributes), _ = [].concat(
      t["*"] || [],
      t[p] || []
    );
    u.forEach((f) => {
      p_(f, _) || l.removeAttribute(f.nodeName);
    });
  }
  return n.body.innerHTML;
}
const Aa = "tooltip", f_ = "te.tooltip", kt = `.${f_}`, m_ = "te-tooltip", g_ = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), b_ = {
  animation: "boolean",
  template: "string",
  title: "(string|element|function)",
  trigger: "string",
  delay: "(number|object)",
  html: "boolean",
  selector: "(string|boolean)",
  placement: "(string|function)",
  offset: "(array|string|function)",
  container: "(string|element|boolean)",
  fallbackPlacements: "array",
  boundary: "(string|element)",
  customClass: "(string|function)",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  allowList: "object",
  popperConfig: "(null|object|function)"
}, v_ = {
  AUTO: "auto",
  TOP: "top",
  RIGHT: W() ? "left" : "right",
  BOTTOM: "bottom",
  LEFT: W() ? "right" : "left"
}, T_ = {
  animation: !0,
  template: '<div class="opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal" role="tooltip"><div data-te-tooltip-inner-ref class="tooltip-inner max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded"></div></div>',
  trigger: "hover focus",
  title: "",
  delay: 0,
  html: !1,
  selector: !1,
  placement: "top",
  offset: [0, 0],
  container: !1,
  fallbackPlacements: ["top", "right", "bottom", "left"],
  boundary: "clippingParents",
  customClass: "",
  sanitize: !0,
  sanitizeFn: null,
  allowList: __,
  popperConfig: { hide: !0 }
}, E_ = {
  HIDE: `hide${kt}`,
  HIDDEN: `hidden${kt}`,
  SHOW: `show${kt}`,
  SHOWN: `shown${kt}`,
  INSERTED: `inserted${kt}`,
  CLICK: `click${kt}`,
  FOCUSIN: `focusin${kt}`,
  FOCUSOUT: `focusout${kt}`,
  MOUSEENTER: `mouseenter${kt}`,
  MOUSELEAVE: `mouseleave${kt}`
}, C_ = "fade", A_ = "modal", Kn = "show", _i = "show", zn = "out", ya = ".tooltip-inner", wa = `.${A_}`, ka = "hide.te.modal", fi = "hover", Un = "focus", y_ = "click", w_ = "manual";
class ri extends ft {
  constructor(t, e) {
    if (typeof qc > "u")
      throw new TypeError(
        "Bootstrap's tooltips require Popper (https://popper.js.org)"
      );
    super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();
  }
  // Getters
  static get Default() {
    return T_;
  }
  static get NAME() {
    return Aa;
  }
  static get Event() {
    return E_;
  }
  static get DefaultType() {
    return b_;
  }
  // Public
  enable() {
    this._isEnabled = !0;
  }
  disable() {
    this._isEnabled = !1;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle(t) {
    if (this._isEnabled)
      if (t) {
        const e = this._initializeOnDelegatedTarget(t);
        e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);
      } else {
        if (this.getTipElement().classList.contains(Kn)) {
          this._leave(null, this);
          return;
        }
        this._enter(null, this);
      }
  }
  dispose() {
    clearTimeout(this._timeout), c.off(
      this._element.closest(wa),
      ka,
      this._hideModalHandler
    ), this.tip && this.tip.remove(), this._disposePopper(), super.dispose();
  }
  show() {
    if (this._element.style.display === "none")
      throw new Error("Please use show on visible elements");
    if (!(this.isWithContent() && this._isEnabled))
      return;
    const t = c.trigger(
      this._element,
      this.constructor.Event.SHOW
    ), e = fc(this._element), i = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);
    if (t.defaultPrevented || !i)
      return;
    this.constructor.NAME === "tooltip" && this.tip && this.getTitle() !== this.tip.querySelector(ya).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);
    const n = this.getTipElement(), o = et(this.constructor.NAME);
    n.setAttribute("id", o), this._element.setAttribute("aria-describedby", o), this._config.animation && setTimeout(() => {
      this.tip.classList.add("opacity-100"), this.tip.classList.remove("opacity-0");
    }, 100);
    const r = typeof this._config.placement == "function" ? this._config.placement.call(this, n, this._element) : this._config.placement, a = this._getAttachment(r);
    this._addAttachmentClass(a);
    const { container: l } = this._config;
    if (A.setData(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l.append(n), c.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = se(
      this._element,
      n,
      this._getPopperConfig(a)
    ), n.getAttribute("id").includes("tooltip"))
      switch (r) {
        case "bottom":
          n.classList.add("py-[0.4rem]");
          break;
        case "left":
          n.classList.add("px-[0.4rem]");
          break;
        case "right":
          n.classList.add("px-[0.4rem]");
          break;
        default:
          n.classList.add("py-[0.4rem]");
          break;
      }
    const u = this._resolvePossibleFunction(this._config.customClass);
    u && n.classList.add(...u.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((g) => {
      c.on(g, "mouseover", hn);
    });
    const _ = () => {
      const g = this._hoverState;
      this._hoverState = null, c.trigger(this._element, this.constructor.Event.SHOWN), g === zn && this._leave(null, this);
    }, f = this.tip.classList.contains("transition-opacity");
    this._queueCallback(_, this.tip, f);
  }
  hide() {
    if (!this._popper)
      return;
    const t = this.getTipElement(), e = () => {
      this._isWithActiveTrigger() || (this._hoverState !== _i && t.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), c.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper());
    };
    if (c.trigger(
      this._element,
      this.constructor.Event.HIDE
    ).defaultPrevented)
      return;
    t.classList.add("opacity-0"), t.classList.remove("opacity-100"), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((o) => c.off(o, "mouseover", hn)), this._activeTrigger[y_] = !1, this._activeTrigger[Un] = !1, this._activeTrigger[fi] = !1;
    const n = this.tip.classList.contains("opacity-0");
    this._queueCallback(e, this.tip, n), this._hoverState = "";
  }
  update() {
    this._popper !== null && this._popper.update();
  }
  // Protected
  isWithContent() {
    return !!this.getTitle();
  }
  getTipElement() {
    if (this.tip)
      return this.tip;
    const t = document.createElement("div");
    t.innerHTML = this._config.template;
    const e = t.children[0];
    return this.setContent(e), e.classList.remove(C_, Kn), this.tip = e, this.tip;
  }
  setContent(t) {
    this._sanitizeAndSetContent(t, this.getTitle(), ya);
  }
  _sanitizeAndSetContent(t, e, i) {
    const n = d.findOne(i, t);
    if (!e && n) {
      n.remove();
      return;
    }
    this.setElementContent(n, e);
  }
  setElementContent(t, e) {
    if (t !== null) {
      if (Xe(e)) {
        e = ee(e), this._config.html ? e.parentNode !== t && (t.innerHTML = "", t.append(e)) : t.textContent = e.textContent;
        return;
      }
      this._config.html ? (this._config.sanitize && (e = pn(
        e,
        this._config.allowList,
        this._config.sanitizeFn
      )), t.innerHTML = e) : t.textContent = e;
    }
  }
  getTitle() {
    const t = this._element.getAttribute("data-te-original-title") || this._config.title;
    return this._resolvePossibleFunction(t);
  }
  updateAttachment(t) {
    return t === "right" ? "end" : t === "left" ? "start" : t;
  }
  // Private
  _initializeOnDelegatedTarget(t, e) {
    return e || this.constructor.getOrCreateInstance(
      t.delegateTarget,
      this._getDelegateConfig()
    );
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _resolvePossibleFunction(t) {
    return typeof t == "function" ? t.call(this._element) : t;
  }
  _getPopperConfig(t) {
    const e = {
      placement: t,
      modifiers: [
        {
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        },
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        },
        {
          name: "onChange",
          enabled: !0,
          phase: "afterWrite",
          fn: (i) => this._handlePopperPlacementChange(i)
        }
      ],
      onFirstUpdate: (i) => {
        i.options.placement !== i.placement && this._handlePopperPlacementChange(i);
      }
    };
    return {
      ...e,
      ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(e) : this._config.popperConfig
    };
  }
  _addAttachmentClass(t) {
    this.getTipElement().classList.add(
      `${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`
    );
  }
  _getAttachment(t) {
    return v_[t.toUpperCase()];
  }
  _setListeners() {
    this._config.trigger.split(" ").forEach((e) => {
      if (e === "click")
        c.on(
          this._element,
          this.constructor.Event.CLICK,
          this._config.selector,
          (i) => this.toggle(i)
        );
      else if (e !== w_) {
        const i = e === fi ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, n = e === fi ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
        c.on(
          this._element,
          i,
          this._config.selector,
          (o) => this._enter(o)
        ), c.on(
          this._element,
          n,
          this._config.selector,
          (o) => this._leave(o)
        );
      }
    }), this._hideModalHandler = () => {
      this._element && this.hide();
    }, c.on(
      this._element.closest(wa),
      ka,
      this._hideModalHandler
    ), this._config.selector ? this._config = {
      ...this._config,
      trigger: "manual",
      selector: ""
    } : this._fixTitle();
  }
  _fixTitle() {
    const t = this._element.getAttribute("title"), e = typeof this._element.getAttribute(
      "data-te-original-title"
    );
    (t || e !== "string") && (this._element.setAttribute("data-te-original-title", t || ""), t && !this._element.getAttribute("aria-label") && !this._element.textContent && this._element.setAttribute("aria-label", t), this._element.setAttribute("title", ""));
  }
  _enter(t, e) {
    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusin" ? Un : fi] = !0), e.getTipElement().classList.contains(Kn) || e._hoverState === _i) {
      e._hoverState = _i;
      return;
    }
    if (clearTimeout(e._timeout), e._hoverState = _i, !e._config.delay || !e._config.delay.show) {
      e.show();
      return;
    }
    e._timeout = setTimeout(() => {
      e._hoverState === _i && e.show();
    }, e._config.delay.show);
  }
  _leave(t, e) {
    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusout" ? Un : fi] = e._element.contains(t.relatedTarget)), !e._isWithActiveTrigger()) {
      if (clearTimeout(e._timeout), e._hoverState = zn, !e._config.delay || !e._config.delay.hide) {
        e.hide();
        return;
      }
      e._timeout = setTimeout(() => {
        e._hoverState === zn && e.hide();
      }, e._config.delay.hide);
    }
  }
  _isWithActiveTrigger() {
    for (const t in this._activeTrigger)
      if (this._activeTrigger[t])
        return !0;
    return !1;
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return Object.keys(e).forEach((i) => {
      g_.has(i) && delete e[i];
    }), t = {
      ...this.constructor.Default,
      ...e,
      ...typeof t == "object" && t ? t : {}
    }, t.container = t.container === !1 ? document.body : ee(t.container), typeof t.delay == "number" && (t.delay = {
      show: t.delay,
      hide: t.delay
    }), typeof t.title == "number" && (t.title = t.title.toString()), typeof t.content == "number" && (t.content = t.content.toString()), I(Aa, t, this.constructor.DefaultType), t.sanitize && (t.template = pn(
      t.template,
      t.allowList,
      t.sanitizeFn
    )), t;
  }
  _getDelegateConfig() {
    const t = {};
    for (const e in this._config)
      this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);
    return t;
  }
  _cleanTipClass() {
    const t = this.getTipElement(), e = new RegExp(
      `(^|\\s)${this._getBasicClassPrefix()}\\S+`,
      "g"
    ), i = t.getAttribute("class").match(e);
    i !== null && i.length > 0 && i.map((n) => n.trim()).forEach((n) => t.classList.remove(n));
  }
  _getBasicClassPrefix() {
    return m_;
  }
  _handlePopperPlacementChange(t) {
    const { state: e } = t;
    e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));
  }
  _disposePopper() {
    this._popper && (this._popper.destroy(), this._popper = null);
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = ri.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const k_ = "popover", x_ = "te.popover", xt = `.${x_}`, O_ = "te-popover", S_ = {
  ...ri.Default,
  placement: "right",
  offset: [0, 8],
  trigger: "click",
  content: "",
  template: '<div class="opacity-0 transition-opacity duration-150 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-[0_0px_3px_0_rgba(0,0,0,0.07),0_2px_2px_0_rgba(0,0,0,0.04)] text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:bg-neutral-700 dark:border-0 dark:text-white data-[popper-reference-hidden]:hidden" role="tooltip"><h3 class="popover-header py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-neutral-500"></h3><div class="popover-body p-4 text-[#212529] dark:text-white"></div></div>'
}, I_ = {
  ...ri.DefaultType,
  content: "(string|element|function)"
}, D_ = {
  HIDE: `hide${xt}`,
  HIDDEN: `hidden${xt}`,
  SHOW: `show${xt}`,
  SHOWN: `shown${xt}`,
  INSERTED: `inserted${xt}`,
  CLICK: `click${xt}`,
  FOCUSIN: `focusin${xt}`,
  FOCUSOUT: `focusout${xt}`,
  MOUSEENTER: `mouseenter${xt}`,
  MOUSELEAVE: `mouseleave${xt}`
}, $_ = ".popover-header", L_ = ".popover-body";
class nh extends ri {
  // Getters
  static get Default() {
    return S_;
  }
  static get NAME() {
    return k_;
  }
  static get Event() {
    return D_;
  }
  static get DefaultType() {
    return I_;
  }
  // Overrides
  isWithContent() {
    return this.getTitle() || this._getContent();
  }
  setContent(t) {
    this._sanitizeAndSetContent(t, this.getTitle(), $_), this._sanitizeAndSetContent(t, this._getContent(), L_);
  }
  // Private
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }
  _getBasicClassPrefix() {
    return O_;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = nh.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const Xn = "scrollspy", N_ = "te.scrollspy", yr = `.${N_}`, xa = {
  offset: 10,
  method: "auto",
  target: ""
}, M_ = {
  offset: "number",
  method: "string",
  target: "(string|element)"
}, R_ = {
  active: "!text-primary dark:!text-primary-400 font-semibold border-l-[0.125rem] border-solid border-primary dark:border-primary-400"
}, P_ = {
  active: "string"
}, B_ = `activate${yr}`, H_ = `scroll${yr}`, Gn = "data-te-nav-link-active", oh = "[data-te-dropdown-item-ref]", V_ = "[data-te-nav-list-ref]", Uo = "[data-te-nav-link-ref]", W_ = "[data-te-nav-item-ref]", rh = "[data-te-list-group-item-ref]", qn = `${Uo}, ${rh}, ${oh}`, F_ = "[data-te-dropdown-ref]", Y_ = "[data-te-dropdown-toggle-ref]", j_ = "maxOffset", Oa = "position";
class ah extends ft {
  constructor(t, e, i) {
    super(t), this._scrollElement = this._element.tagName === "BODY" ? window : this._element, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, c.on(this._scrollElement, H_, () => this._process()), this.refresh(), this._process();
  }
  // Getters
  static get Default() {
    return xa;
  }
  static get NAME() {
    return Xn;
  }
  // Public
  refresh() {
    const t = this._scrollElement === this._scrollElement.window ? j_ : Oa, e = this._config.method === "auto" ? t : this._config.method, i = e === Oa ? this._getScrollTop() : 0;
    this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), d.find(
      qn,
      this._config.target
    ).map((o) => {
      const r = lr(o), a = r ? d.findOne(r) : null;
      if (a) {
        const l = a.getBoundingClientRect();
        if (l.width || l.height)
          return [
            h[e](a).top + i,
            r
          ];
      }
      return null;
    }).filter((o) => o).sort((o, r) => o[0] - r[0]).forEach((o) => {
      this._offsets.push(o[0]), this._targets.push(o[1]);
    });
  }
  dispose() {
    c.off(this._scrollElement, yr), super.dispose();
  }
  // Private
  _getConfig(t) {
    return t = {
      ...xa,
      ...h.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, t.target = ee(t.target) || document.documentElement, I(Xn, t, M_), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...R_,
      ...e,
      ...t
    }, I(Xn, t, P_), t;
  }
  _getScrollTop() {
    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
  }
  _getScrollHeight() {
    return this._scrollElement.scrollHeight || Math.max(
      document.body.scrollHeight,
      document.documentElement.scrollHeight
    );
  }
  _getOffsetHeight() {
    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
  }
  _process() {
    const t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(), i = this._config.offset + e - this._getOffsetHeight();
    if (this._scrollHeight !== e && this.refresh(), t >= i) {
      const n = this._targets[this._targets.length - 1];
      this._activeTarget !== n && this._activate(n);
      return;
    }
    if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) {
      this._activeTarget = null, this._clear();
      return;
    }
    for (let n = this._offsets.length; n--; )
      this._activeTarget !== this._targets[n] && t >= this._offsets[n] && (typeof this._offsets[n + 1] > "u" || t < this._offsets[n + 1]) && this._activate(this._targets[n]);
  }
  _activate(t) {
    this._activeTarget = t, this._clear();
    const e = qn.split(",").map(
      (n) => `${n}[data-te-target="${t}"],${n}[href="${t}"]`
    ), i = d.findOne(e.join(","), this._config.target);
    i.classList.add(...this._classes.active.split(" ")), i.setAttribute(Gn, ""), i.getAttribute(oh) ? d.findOne(
      Y_,
      i.closest(F_)
    ).classList.add(...this._classes.active.split(" ")) : d.parents(i, V_).forEach(
      (n) => {
        d.prev(
          n,
          `${Uo}, ${rh}`
        ).forEach((o) => {
          o.classList.add(...this._classes.active.split(" ")), o.setAttribute(Gn, "");
        }), d.prev(n, W_).forEach(
          (o) => {
            d.children(o, Uo).forEach(
              (r) => r.classList.add(...this._classes.active.split(" "))
            );
          }
        );
      }
    ), c.trigger(this._scrollElement, B_, {
      relatedTarget: t
    });
  }
  _clear() {
    d.find(qn, this._config.target).filter(
      (t) => t.classList.contains(...this._classes.active.split(" "))
    ).forEach((t) => {
      t.classList.remove(...this._classes.active.split(" ")), t.removeAttribute(Gn);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = ah.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const Sa = "tab", K_ = "te.tab", Tn = `.${K_}`, z_ = `hide${Tn}`, U_ = `hidden${Tn}`, X_ = `show${Tn}`, G_ = `shown${Tn}`, q_ = "data-te-dropdown-menu-ref", He = "data-te-tab-active", Ks = "data-te-nav-active", Z_ = "[data-te-dropdown-ref]", Q_ = "[data-te-nav-ref]", Ia = `[${He}]`, J_ = `[${Ks}]`, Da = ":scope > li > .active", tf = "[data-te-dropdown-toggle-ref]", ef = ":scope > [data-te-dropdown-menu-ref] [data-te-dropdown-show]", sf = {
  show: "opacity-100",
  hide: "opacity-0"
}, nf = {
  show: "string",
  hide: "string"
};
class lh extends ft {
  constructor(t, e) {
    super(t), this._classes = this._getClasses(e);
  }
  // Getters
  static get NAME() {
    return Sa;
  }
  // Public
  show() {
    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.getAttribute(Ks) === "")
      return;
    let t;
    const e = te(this._element), i = this._element.closest(Q_), n = d.findOne(
      J_,
      i
    );
    if (i) {
      const l = i.nodeName === "UL" || i.nodeName === "OL" ? Da : Ia;
      t = d.find(l, i), t = t[t.length - 1];
    }
    const o = t ? c.trigger(t, z_, {
      relatedTarget: this._element
    }) : null;
    if (c.trigger(this._element, X_, {
      relatedTarget: t
    }).defaultPrevented || o !== null && o.defaultPrevented)
      return;
    this._activate(
      this._element,
      i,
      null,
      n,
      this._element
    );
    const a = () => {
      c.trigger(t, U_, {
        relatedTarget: this._element
      }), c.trigger(this._element, G_, {
        relatedTarget: t
      });
    };
    e ? this._activate(
      e,
      e.parentNode,
      a,
      n,
      this._element
    ) : a();
  }
  // Private
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...sf,
      ...e,
      ...t
    }, I(Sa, t, nf), t;
  }
  _activate(t, e, i, n, o) {
    const a = (e && (e.nodeName === "UL" || e.nodeName === "OL") ? d.find(Da, e) : d.children(e, Ia))[0], l = i && a && a.hasAttribute(He), p = () => this._transitionComplete(
      t,
      a,
      i,
      n,
      o
    );
    a && l ? (h.removeClass(a, this._classes.show), h.addClass(a, this._classes.hide), this._queueCallback(p, t, !0)) : p();
  }
  _transitionComplete(t, e, i, n, o) {
    if (e && n) {
      e.removeAttribute(He), n.removeAttribute(Ks);
      const a = d.findOne(
        ef,
        e.parentNode
      );
      a && a.removeAttribute(He), e.getAttribute("role") === "tab" && e.setAttribute("aria-selected", !1);
    }
    t.setAttribute(He, ""), o.setAttribute(Ks, ""), t.getAttribute("role") === "tab" && t.setAttribute("aria-selected", !0), si(t), t.classList.contains(this._classes.hide) && (h.removeClass(t, this._classes.hide), h.addClass(t, this._classes.show));
    let r = t.parentNode;
    if (r && r.nodeName === "LI" && (r = r.parentNode), r && r.hasAttribute(q_)) {
      const a = t.closest(Z_);
      a && d.find(tf, a).forEach(
        (l) => l.setAttribute(He, "")
      ), t.setAttribute("aria-expanded", !0);
    }
    i && i();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = lh.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const Zn = "toast", of = "te.toast", ne = `.${of}`, rf = `mouseover${ne}`, af = `mouseout${ne}`, lf = `focusin${ne}`, cf = `focusout${ne}`, hf = `hide${ne}`, df = `hidden${ne}`, uf = `show${ne}`, pf = `shown${ne}`, $a = "data-te-toast-hide", Qn = "data-te-toast-show", as = "data-te-toast-showing", _f = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
}, La = {
  animation: !0,
  autohide: !0,
  delay: 5e3
}, ff = {
  fadeIn: "animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none",
  fadeOut: "animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none"
}, mf = {
  fadeIn: "string",
  fadeOut: "string"
};
class Xo extends ft {
  constructor(t, e, i) {
    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners(), this._didInit = !1, this._init();
  }
  // Getters
  static get DefaultType() {
    return _f;
  }
  static get Default() {
    return La;
  }
  static get NAME() {
    return Zn;
  }
  // Public
  show() {
    if (c.trigger(this._element, uf).defaultPrevented)
      return;
    this._clearTimeout(), this._config.animation && (h.removeClass(this._element, this._classes.fadeOut), h.addClass(this._element, this._classes.fadeIn));
    const e = () => {
      this._element.removeAttribute(as), c.trigger(this._element, pf), this._maybeScheduleHide();
    };
    this._element.removeAttribute($a), si(this._element), this._element.setAttribute(Qn, ""), this._element.setAttribute(as, ""), this._queueCallback(e, this._element, this._config.animation);
  }
  hide() {
    if (!this._element || this._element.dataset.teToastShow === void 0 || c.trigger(this._element, hf).defaultPrevented)
      return;
    const e = () => {
      let i = 0;
      this._config.animation && (i = 300, h.removeClass(this._element, this._classes.fadeIn), h.addClass(this._element, this._classes.fadeOut)), setTimeout(() => {
        this._element.setAttribute($a, ""), this._element.removeAttribute(as), this._element.removeAttribute(Qn), c.trigger(this._element, df);
      }, i);
    };
    this._element.setAttribute(as, ""), this._queueCallback(e, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout(), this._element.dataset.teToastShow !== void 0 && this._element.removeAttribute(Qn), super.dispose();
  }
  // Private
  _init() {
    this._didInit || (vn(Xo), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...La,
      ...h.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, I(Zn, t, this.constructor.DefaultType), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...ff,
      ...e,
      ...t
    }, I(Zn, t, mf), t;
  }
  _maybeScheduleHide() {
    this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay)));
  }
  _onInteraction(t, e) {
    switch (t.type) {
      case "mouseover":
      case "mouseout":
        this._hasMouseInteraction = e;
        break;
      case "focusin":
      case "focusout":
        this._hasKeyboardInteraction = e;
        break;
    }
    if (e) {
      this._clearTimeout();
      return;
    }
    const i = t.relatedTarget;
    this._element === i || this._element.contains(i) || this._maybeScheduleHide();
  }
  _setListeners() {
    c.on(
      this._element,
      rf,
      (t) => this._onInteraction(t, !0)
    ), c.on(
      this._element,
      af,
      (t) => this._onInteraction(t, !1)
    ), c.on(
      this._element,
      lf,
      (t) => this._onInteraction(t, !0)
    ), c.on(
      this._element,
      cf,
      (t) => this._onInteraction(t, !1)
    );
  }
  _clearTimeout() {
    clearTimeout(this._timeout), this._timeout = null;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Xo.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
(() => {
  var s = { 454: (i, n, o) => {
    o.d(n, { Z: () => l });
    var r = o(645), a = o.n(r)()(function(p) {
      return p[1];
    });
    a.push([i.id, "INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}", ""]);
    const l = a;
  }, 645: (i) => {
    i.exports = function(n) {
      var o = [];
      return o.toString = function() {
        return this.map(function(r) {
          var a = n(r);
          return r[2] ? "@media ".concat(r[2], " {").concat(a, "}") : a;
        }).join("");
      }, o.i = function(r, a, l) {
        typeof r == "string" && (r = [[null, r, ""]]);
        var p = {};
        if (l)
          for (var u = 0; u < this.length; u++) {
            var _ = this[u][0];
            _ != null && (p[_] = !0);
          }
        for (var f = 0; f < r.length; f++) {
          var g = [].concat(r[f]);
          l && p[g[0]] || (a && (g[2] ? g[2] = "".concat(a, " and ").concat(g[2]) : g[2] = a), o.push(g));
        }
      }, o;
    };
  }, 810: () => {
    (function() {
      if (typeof window < "u")
        try {
          var i = new window.CustomEvent("test", { cancelable: !0 });
          if (i.preventDefault(), i.defaultPrevented !== !0)
            throw new Error("Could not prevent default");
        } catch {
          var n = function(r, a) {
            var l, p;
            return (a = a || {}).bubbles = !!a.bubbles, a.cancelable = !!a.cancelable, (l = document.createEvent("CustomEvent")).initCustomEvent(r, a.bubbles, a.cancelable, a.detail), p = l.preventDefault, l.preventDefault = function() {
              p.call(this);
              try {
                Object.defineProperty(this, "defaultPrevented", { get: function() {
                  return !0;
                } });
              } catch {
                this.defaultPrevented = !0;
              }
            }, l;
          };
          n.prototype = window.Event.prototype, window.CustomEvent = n;
        }
    })();
  }, 379: (i, n, o) => {
    var r, a = function() {
      var C = {};
      return function(E) {
        if (C[E] === void 0) {
          var w = document.querySelector(E);
          if (window.HTMLIFrameElement && w instanceof window.HTMLIFrameElement)
            try {
              w = w.contentDocument.head;
            } catch {
              w = null;
            }
          C[E] = w;
        }
        return C[E];
      };
    }(), l = [];
    function p(C) {
      for (var E = -1, w = 0; w < l.length; w++)
        if (l[w].identifier === C) {
          E = w;
          break;
        }
      return E;
    }
    function u(C, E) {
      for (var w = {}, k = [], D = 0; D < C.length; D++) {
        var O = C[D], x = E.base ? O[0] + E.base : O[0], L = w[x] || 0, S = "".concat(x, " ").concat(L);
        w[x] = L + 1;
        var N = p(S), P = { css: O[1], media: O[2], sourceMap: O[3] };
        N !== -1 ? (l[N].references++, l[N].updater(P)) : l.push({ identifier: S, updater: y(P, E), references: 1 }), k.push(S);
      }
      return k;
    }
    function _(C) {
      var E = document.createElement("style"), w = C.attributes || {};
      if (w.nonce === void 0) {
        var k = o.nc;
        k && (w.nonce = k);
      }
      if (Object.keys(w).forEach(function(O) {
        E.setAttribute(O, w[O]);
      }), typeof C.insert == "function")
        C.insert(E);
      else {
        var D = a(C.insert || "head");
        if (!D)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
        D.appendChild(E);
      }
      return E;
    }
    var f, g = (f = [], function(C, E) {
      return f[C] = E, f.filter(Boolean).join(`
`);
    });
    function m(C, E, w, k) {
      var D = w ? "" : k.media ? "@media ".concat(k.media, " {").concat(k.css, "}") : k.css;
      if (C.styleSheet)
        C.styleSheet.cssText = g(E, D);
      else {
        var O = document.createTextNode(D), x = C.childNodes;
        x[E] && C.removeChild(x[E]), x.length ? C.insertBefore(O, x[E]) : C.appendChild(O);
      }
    }
    function b(C, E, w) {
      var k = w.css, D = w.media, O = w.sourceMap;
      if (D ? C.setAttribute("media", D) : C.removeAttribute("media"), O && typeof btoa < "u" && (k += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(O)))), " */")), C.styleSheet)
        C.styleSheet.cssText = k;
      else {
        for (; C.firstChild; )
          C.removeChild(C.firstChild);
        C.appendChild(document.createTextNode(k));
      }
    }
    var v = null, T = 0;
    function y(C, E) {
      var w, k, D;
      if (E.singleton) {
        var O = T++;
        w = v || (v = _(E)), k = m.bind(null, w, O, !1), D = m.bind(null, w, O, !0);
      } else
        w = _(E), k = b.bind(null, w, E), D = function() {
          (function(x) {
            if (x.parentNode === null)
              return !1;
            x.parentNode.removeChild(x);
          })(w);
        };
      return k(C), function(x) {
        if (x) {
          if (x.css === C.css && x.media === C.media && x.sourceMap === C.sourceMap)
            return;
          k(C = x);
        } else
          D();
      };
    }
    i.exports = function(C, E) {
      (E = E || {}).singleton || typeof E.singleton == "boolean" || (E.singleton = (r === void 0 && (r = !!(window && document && document.all && !window.atob)), r));
      var w = u(C = C || [], E);
      return function(k) {
        if (k = k || [], Object.prototype.toString.call(k) === "[object Array]") {
          for (var D = 0; D < w.length; D++) {
            var O = p(w[D]);
            l[O].references--;
          }
          for (var x = u(k, E), L = 0; L < w.length; L++) {
            var S = p(w[L]);
            l[S].references === 0 && (l[S].updater(), l.splice(S, 1));
          }
          w = x;
        }
      };
    };
  } }, t = {};
  function e(i) {
    var n = t[i];
    if (n !== void 0)
      return n.exports;
    var o = t[i] = { id: i, exports: {} };
    return s[i](o, o.exports, e), o.exports;
  }
  e.n = (i) => {
    var n = i && i.__esModule ? () => i.default : () => i;
    return e.d(n, { a: n }), n;
  }, e.d = (i, n) => {
    for (var o in n)
      e.o(n, o) && !e.o(i, o) && Object.defineProperty(i, o, { enumerable: !0, get: n[o] });
  }, e.o = (i, n) => Object.prototype.hasOwnProperty.call(i, n), (() => {
    var i = e(379), n = e.n(i), o = e(454);
    function r(l) {
      if (!l.hasAttribute("autocompleted")) {
        l.setAttribute("autocompleted", "");
        var p = new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !0, detail: null });
        l.dispatchEvent(p) || (l.value = "");
      }
    }
    function a(l) {
      l.hasAttribute("autocompleted") && (l.removeAttribute("autocompleted"), l.dispatchEvent(new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !1, detail: null })));
    }
    n()(o.Z, { insert: "head", singleton: !1 }), o.Z.locals, e(810), document.addEventListener("animationstart", function(l) {
      l.animationName === "onautofillstart" ? r(l.target) : a(l.target);
    }, !0), document.addEventListener("input", function(l) {
      l.inputType !== "insertReplacementText" && "data" in l ? a(l.target) : r(l.target);
    }, !0);
  })();
})();
const Jn = "input", ls = "te.input", ch = "data-te-input-wrapper-init", hh = "data-te-input-notch-ref", dh = "data-te-input-notch-leading-ref", uh = "data-te-input-notch-middle-ref", gf = "data-te-input-notch-trailing-ref", bf = "data-te-input-helper-ref", vf = "data-te-input-placeholder-active", Yt = "data-te-input-state-active", Na = "data-te-input-focused", Ma = "data-te-input-form-counter", cs = `[${ch}] input`, hs = `[${ch}] textarea`, Ie = `[${hh}]`, Ra = `[${dh}]`, Pa = `[${uh}]`, Tf = `[${bf}]`, Ef = {
  inputFormWhite: !1
}, Cf = {
  inputFormWhite: "(boolean)"
}, ph = {
  notch: "group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none",
  notchLeading: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0",
  notchLeadingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchLeadingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[-1px_0_0_#ffffff,_0_1px_0_0_#ffffff,_0_-1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  notchMiddle: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent",
  notchMiddleNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchMiddleWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  notchTrailing: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0",
  notchTrailingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchTrailingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[1px_0_0_#ffffff,_0_-1px_0_0_#ffffff,_0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  counter: "text-right leading-[1.6]"
}, Af = {
  notch: "string",
  notchLeading: "string",
  notchLeadingNormal: "string",
  notchLeadingWhite: "string",
  notchMiddle: "string",
  notchMiddleNormal: "string",
  notchMiddleWhite: "string",
  notchTrailing: "string",
  notchTrailingNormal: "string",
  notchTrailingWhite: "string",
  counter: "string"
};
class V {
  constructor(t, e, i) {
    this._config = this._getConfig(e, t), this._element = t, this._classes = this._getClasses(i), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = !1, this._helper = null, this._counter = !1, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (A.setData(t, ls, this), this.init());
  }
  // Getters
  static get NAME() {
    return Jn;
  }
  get input() {
    return d.findOne("input", this._element) || d.findOne("textarea", this._element);
  }
  // Public
  init() {
    this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._getEvents(), this._initiated = !0);
  }
  update() {
    this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();
  }
  forceActive() {
    this.input.setAttribute(Yt, ""), d.findOne(Ie, this.input.parentNode).setAttribute(
      Yt,
      ""
    );
  }
  forceInactive() {
    this.input.removeAttribute(Yt), d.findOne(
      Ie,
      this.input.parentNode
    ).removeAttribute(Yt);
  }
  dispose() {
    this._removeBorder(), A.removeData(this._element, ls), this._element = null;
  }
  // Private
  _getConfig(t, e) {
    return t = {
      ...Ef,
      ...h.getDataAttributes(e),
      ...typeof t == "object" ? t : {}
    }, I(Jn, t, Cf), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...ph,
      ...e,
      ...t
    }, I(Jn, t, Af), t;
  }
  _getLabelData() {
    this._label = d.findOne("label", this._element), this._label === null ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());
  }
  _getHelper() {
    this._helper = d.findOne(Tf, this._element);
  }
  _getCounter() {
    this._counter = h.getDataAttribute(
      this.input,
      "inputShowcounter"
    ), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());
  }
  _getEvents() {
    c.on(
      this._element,
      "focus",
      "input",
      V.activate(new V())
    ), c.on(
      this._element,
      "input",
      "input",
      V.activate(new V())
    ), c.on(
      this._element,
      "blur",
      "input",
      V.deactivate(new V())
    ), c.on(
      this._element,
      "focus",
      "textarea",
      V.activate(new V())
    ), c.on(
      this._element,
      "input",
      "textarea",
      V.activate(new V())
    ), c.on(
      this._element,
      "blur",
      "textarea",
      V.deactivate(new V())
    ), c.on(window, "shown.te.modal", (t) => {
      d.find(cs, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.update();
        }
      ), d.find(hs, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.update();
        }
      );
    }), c.on(window, "shown.te.dropdown", (t) => {
      const e = t.target.parentNode.querySelector(
        "[data-te-dropdown-menu-ref]"
      );
      e && (d.find(cs, e).forEach(
        (i) => {
          const n = V.getInstance(i.parentNode);
          n && n.update();
        }
      ), d.find(hs, e).forEach(
        (i) => {
          const n = V.getInstance(i.parentNode);
          n && n.update();
        }
      ));
    }), c.on(window, "shown.te.tab", (t) => {
      let e;
      t.target.href ? e = t.target.href.split("#")[1] : e = h.getDataAttribute(t.target, "target").split(
        "#"
      )[1];
      const i = d.findOne(`#${e}`);
      d.find(cs, i).forEach((n) => {
        const o = V.getInstance(n.parentNode);
        o && o.update();
      }), d.find(hs, i).forEach(
        (n) => {
          const o = V.getInstance(n.parentNode);
          o && o.update();
        }
      );
    }), c.on(window, "reset", (t) => {
      d.find(cs, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.forceInactive();
        }
      ), d.find(hs, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.forceInactive();
        }
      );
    }), c.on(window, "onautocomplete", (t) => {
      const e = V.getInstance(t.target.parentNode);
      !e || !t.cancelable || e.forceActive();
    });
  }
  _showCounter() {
    if (d.find(
      `[${Ma}]`,
      this._element
    ).length > 0)
      return;
    this._counterElement = document.createElement("div"), h.addClass(this._counterElement, this._classes.counter), this._counterElement.setAttribute(Ma, "");
    const e = this.input.value.length;
    this._counterElement.innerHTML = `${e} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();
  }
  _bindCounter() {
    c.on(this.input, "input", () => {
      const t = this.input.value.length;
      this._counterElement.innerHTML = `${t} / ${this._maxLength}`;
    });
  }
  _toggleDefaultDatePlaceholder(t = this.input) {
    if (!(t.getAttribute("type") === "date"))
      return;
    !(document.activeElement === t) && !t.value ? t.style.opacity = 0 : t.style.opacity = 1;
  }
  _showPlaceholder() {
    this.input.setAttribute(vf, "");
  }
  _getNotchData() {
    this._notchMiddle = d.findOne(
      Pa,
      this._element
    ), this._notchLeading = d.findOne(
      Ra,
      this._element
    );
  }
  _getLabelWidth() {
    this._labelWidth = this._label.clientWidth * 0.8 + 8;
  }
  _getLabelPositionInInputGroup() {
    if (this._labelMarginLeft = 0, !this._element.hasAttribute("data-te-input-group-ref"))
      return;
    const t = this.input, e = d.prev(
      t,
      "[data-te-input-group-text-ref]"
    )[0];
    e === void 0 ? this._labelMarginLeft = 0 : this._labelMarginLeft = e.offsetWidth - 1;
  }
  _applyDivs() {
    const t = this._config.inputFormWhite ? this._classes.notchLeadingWhite : this._classes.notchLeadingNormal, e = this._config.inputFormWhite ? this._classes.notchMiddleWhite : this._classes.notchMiddleNormal, i = this._config.inputFormWhite ? this._classes.notchTrailingWhite : this._classes.notchTrailingNormal, n = d.find(Ie, this._element), o = $("div");
    h.addClass(o, this._classes.notch), o.setAttribute(hh, ""), this._notchLeading = $("div"), h.addClass(
      this._notchLeading,
      `${this._classes.notchLeading} ${t}`
    ), this._notchLeading.setAttribute(dh, ""), this._notchMiddle = $("div"), h.addClass(
      this._notchMiddle,
      `${this._classes.notchMiddle} ${e}`
    ), this._notchMiddle.setAttribute(uh, ""), this._notchTrailing = $("div"), h.addClass(
      this._notchTrailing,
      `${this._classes.notchTrailing} ${i}`
    ), this._notchTrailing.setAttribute(gf, ""), !(n.length >= 1) && (o.append(this._notchLeading), o.append(this._notchMiddle), o.append(this._notchTrailing), this._element.append(o));
  }
  _applyNotch() {
    this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);
  }
  _removeBorder() {
    const t = d.findOne(Ie, this._element);
    t && t.remove();
  }
  _activate(t) {
    gc(() => {
      this._getElements(t);
      const e = t ? t.target : this.input, i = d.findOne(
        Ie,
        this._element
      );
      t && t.type === "focus" && i && i.setAttribute(Na, ""), e.value !== "" && (e.setAttribute(Yt, ""), i && i.setAttribute(Yt, "")), this._toggleDefaultDatePlaceholder(e);
    });
  }
  _getElements(t) {
    if (t && (this._element = t.target.parentNode, this._label = d.findOne("label", this._element)), t && this._label) {
      const e = this._labelWidth;
      this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = d.findOne(
        Pa,
        t.target.parentNode
      ), this._notchLeading = d.findOne(
        Ra,
        t.target.parentNode
      ), this._applyNotch());
    }
  }
  _deactivate(t) {
    const e = t ? t.target : this.input, i = d.findOne(
      Ie,
      e.parentNode
    );
    i.removeAttribute(Na), e.value === "" && (e.removeAttribute(Yt), i.removeAttribute(Yt)), this._toggleDefaultDatePlaceholder(e);
  }
  static activate(t) {
    return function(e) {
      t._activate(e);
    };
  }
  static deactivate(t) {
    return function(e) {
      t._deactivate(e);
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, ls);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new V(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, ls);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Ba = "animation", to = "te.animation", yf = {
  animation: "string",
  animationStart: "string",
  animationShowOnLoad: "boolean",
  onStart: "(null|function)",
  onEnd: "(null|function)",
  onHide: "(null|function)",
  onShow: "(null|function)",
  animationOnScroll: "(string)",
  animationWindowHeight: "number",
  animationOffset: "(number|string)",
  animationDelay: "(number|string)",
  animationReverse: "boolean",
  animationInterval: "(number|string)",
  animationRepeat: "(number|boolean)",
  animationReset: "boolean"
}, wf = {
  animation: "fade",
  animationStart: "onClick",
  animationShowOnLoad: !0,
  onStart: null,
  onEnd: null,
  onHide: null,
  onShow: null,
  animationOnScroll: "once",
  animationWindowHeight: 0,
  animationOffset: 0,
  animationDelay: 0,
  animationReverse: !1,
  animationInterval: 0,
  animationRepeat: !1,
  animationReset: !1
};
class wr {
  constructor(t, e) {
    this._element = t, this._animateElement = this._getAnimateElement(), this._isFirstScroll = !0, this._repeatAnimateOnScroll = !0, this._options = this._getConfig(e), this._element && (A.setData(t, to, this), this._init());
  }
  // Getters
  static get NAME() {
    return Ba;
  }
  // Public
  init() {
    this._init();
  }
  startAnimation() {
    this._startAnimation();
  }
  stopAnimation() {
    this._clearAnimationClass();
  }
  changeAnimationType(t) {
    this._options.animation = t;
  }
  dispose() {
    c.off(this._element, "mousedown"), c.off(this._animateElement, "animationend"), c.off(window, "scroll"), c.off(this._element, "mouseover"), A.removeData(this._element, to), this._element = null, this._animateElement = null, this._isFirstScroll = null, this._repeatAnimateOnScroll = null, this._options = null;
  }
  // Private
  _init() {
    switch (this._options.animationStart) {
      case "onHover":
        this._bindHoverEvents();
        break;
      case "onLoad":
        this._startAnimation();
        break;
      case "onScroll":
        this._bindScrollEvents();
        break;
      case "onClick":
        this._bindClickEvents();
        break;
    }
    this._bindTriggerOnEndCallback(), this._options.animationReset && this._bindResetAnimationAfterFinish();
  }
  _getAnimateElement() {
    const t = h.getDataAttribute(
      this._element,
      "animation-target"
    );
    return t ? d.find(t)[0] : this._element;
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._animateElement);
    return t = {
      ...wf,
      ...e,
      ...t
    }, I(Ba, t, yf), t;
  }
  _animateOnScroll() {
    const t = h.offset(this._animateElement).top, e = this._animateElement.offsetHeight, i = window.innerHeight, n = t + this._options.animationOffset <= i && t + this._options.animationOffset + e >= 0, o = this._animateElement.style.visibility === "visible";
    switch (!0) {
      case (n && this._isFirstScroll):
        this._isFirstScroll = !1, this._startAnimation();
        break;
      case (!n && this._isFirstScroll):
        this._isFirstScroll = !1, this._hideAnimateElement();
        break;
      case (n && !o && this._repeatAnimateOnScroll):
        this._options.animationOnScroll !== "repeat" && (this._repeatAnimateOnScroll = !1), this._callback(this._options.onShow), this._showAnimateElement(), this._startAnimation();
        break;
      case (!n && o && this._repeatAnimateOnScroll):
        this._hideAnimateElement(), this._clearAnimationClass(), this._callback(this._options.onHide);
        break;
    }
  }
  _addAnimatedClass() {
    h.addClass(
      this._animateElement,
      `animate-${this._options.animation}`
    );
  }
  _clearAnimationClass() {
    this._animateElement.classList.remove(`animate-${this._options.animation}`);
  }
  _startAnimation() {
    this._callback(this._options.onStart), this._addAnimatedClass(), this._options.animationRepeat && !this._options.animationInterval && this._setAnimationRepeat(), this._options.animationReverse && this._setAnimationReverse(), this._options.animationDelay && this._setAnimationDelay(), this._options.animationDuration && this._setAnimationDuration(), this._options.animationInterval && this._setAnimationInterval();
  }
  _setAnimationReverse() {
    h.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === !0 ? "infinite" : "2",
      animationDirection: "alternate"
    });
  }
  _setAnimationDuration() {
    h.style(this._animateElement, {
      animationDuration: `${this._options.animationDuration}ms`
    });
  }
  _setAnimationDelay() {
    h.style(this._animateElement, {
      animationDelay: `${this._options.animationDelay}ms`
    });
  }
  _setAnimationRepeat() {
    h.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === !0 ? "infinite" : this._options.animationRepeat
    });
  }
  _setAnimationInterval() {
    c.on(this._animateElement, "animationend", () => {
      this._clearAnimationClass(), setTimeout(() => {
        this._addAnimatedClass();
      }, this._options.animationInterval);
    });
  }
  _hideAnimateElement() {
    h.style(this._animateElement, { visibility: "hidden" });
  }
  _showAnimateElement() {
    h.style(this._animateElement, { visibility: "visible" });
  }
  _bindResetAnimationAfterFinish() {
    c.on(this._animateElement, "animationend", () => {
      this._clearAnimationClass();
    });
  }
  _bindTriggerOnEndCallback() {
    c.on(this._animateElement, "animationend", () => {
      this._callback(this._options.onEnd);
    });
  }
  _bindScrollEvents() {
    this._options.animationShowOnLoad || this._animateOnScroll(), c.on(window, "scroll", () => {
      this._animateOnScroll();
    });
  }
  _bindClickEvents() {
    c.on(this._element, "mousedown", () => {
      this._startAnimation();
    });
  }
  _bindHoverEvents() {
    c.one(this._element, "mouseover", () => {
      this._startAnimation();
    }), c.one(this._animateElement, "animationend", () => {
      setTimeout(() => {
        this._bindHoverEvents();
      }, 100);
    });
  }
  _callback(t) {
    t instanceof Function && t();
  }
  // Static
  static autoInit(t) {
    t._init();
  }
  static jQueryInterface(t) {
    new wr(this[0], t).init();
  }
  static getInstance(t) {
    return A.getData(t, to);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const kf = {
  property: "color",
  defaultValue: null,
  inherit: !0
}, De = (s, t) => {
  const { property: e, defaultValue: i, inherit: n } = { ...kf, ...t }, o = document.createElement("div");
  o.classList.add(s), document.body.appendChild(o);
  const a = window.getComputedStyle(o)[e] || i, p = window.getComputedStyle(o.parentElement)[e];
  return document.body.removeChild(o), !n && p && a === p ? i : a || i;
}, eo = "ripple", ds = "te.ripple", xf = "rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%", Of = ["[data-te-ripple-init]"], us = [0, 0, 0], Sf = [
  {
    name: "primary",
    gradientColor: De("text-primary", { defaultValue: "#3B71CA", inherit: !1 })
  },
  {
    name: "secondary",
    gradientColor: De("text-secondary", { defaultValue: "#9FA6B2", inherit: !1 })
  },
  {
    name: "success",
    gradientColor: De("text-success", { defaultValue: "#14A44D", inherit: !1 })
  },
  {
    name: "danger",
    gradientColor: De("text-danger", { defaultValue: "#DC4C64", inherit: !1 })
  },
  {
    name: "warning",
    gradientColor: De("text-warning", { defaultValue: "#E4A11B", inherit: !1 })
  },
  {
    name: "info",
    gradientColor: De("text-info", { defaultValue: "#54B4D3", inherit: !1 })
  },
  {
    name: "light",
    gradientColor: "#fbfbfb"
  },
  {
    name: "dark",
    gradientColor: "#262626"
  }
], Ha = 0.5, If = {
  rippleCentered: !1,
  rippleColor: "",
  rippleColorDark: "",
  rippleDuration: "500ms",
  rippleRadius: 0,
  rippleUnbound: !1
}, Df = {
  rippleCentered: "boolean",
  rippleColor: "string",
  rippleColorDark: "string",
  rippleDuration: "string",
  rippleRadius: "number",
  rippleUnbound: "boolean"
}, $f = {
  ripple: "relative overflow-hidden inline-block align-bottom",
  rippleWave: "rounded-[50%] opacity-50 pointer-events-none absolute touch-none scale-0 transition-[transform,_opacity] ease-[cubic-bezier(0,0,0.15,1),_cubic-bezier(0,0,0.15,1)] z-[999]",
  unbound: "overflow-visible"
}, Lf = {
  ripple: "string",
  rippleWave: "string",
  unbound: "string"
};
class ei {
  constructor(t, e, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._element && (A.setData(t, ds, this), h.addClass(this._element, this._classes.ripple)), this._clickHandler = this._createRipple.bind(this), this._rippleTimer = null, this._isMinWidthSet = !1, this._initialClasses = null, this.init();
  }
  // Getters
  static get NAME() {
    return eo;
  }
  // Public
  init() {
    this._addClickEvent(this._element);
  }
  dispose() {
    A.removeData(this._element, ds), c.off(this._element, "click", this._clickHandler), this._element = null, this._options = null;
  }
  // Private
  _autoInit(t) {
    Of.forEach((e) => {
      d.closest(t.target, e) && (this._element = d.closest(t.target, e));
    }), this._element.style.minWidth || (h.style(this._element, {
      "min-width": getComputedStyle(this._element).width
    }), this._isMinWidthSet = !0), this._options = this._getConfig(), this._classes = this._getClasses(), this._initialClasses = [...this._element.classList], h.addClass(this._element, this._classes.ripple), this._createRipple(t);
  }
  _addClickEvent(t) {
    c.on(t, "mousedown", this._clickHandler);
  }
  _createRipple(t) {
    this._element.className.indexOf(this._classes.ripple) < 0 && h.addClass(this._element, this._classes.ripple);
    const { layerX: e, layerY: i } = t, n = t.offsetX || e, o = t.offsetY || i, r = this._element.offsetHeight, a = this._element.offsetWidth, l = this._durationToMsNumber(this._options.rippleDuration), p = {
      offsetX: this._options.rippleCentered ? r / 2 : n,
      offsetY: this._options.rippleCentered ? a / 2 : o,
      height: r,
      width: a
    }, u = this._getDiameter(p), _ = this._options.rippleRadius || u / 2, f = {
      delay: l * Ha,
      duration: l - l * Ha
    }, g = {
      left: this._options.rippleCentered ? `${a / 2 - _}px` : `${n - _}px`,
      top: this._options.rippleCentered ? `${r / 2 - _}px` : `${o - _}px`,
      height: `${this._options.rippleRadius * 2 || u}px`,
      width: `${this._options.rippleRadius * 2 || u}px`,
      transitionDelay: `0s, ${f.delay}ms`,
      transitionDuration: `${l}ms, ${f.duration}ms`
    }, m = $("div");
    this._createHTMLRipple({
      wrapper: this._element,
      ripple: m,
      styles: g
    }), this._removeHTMLRipple({ ripple: m, duration: l });
  }
  _createHTMLRipple({ wrapper: t, ripple: e, styles: i }) {
    Object.keys(i).forEach(
      (n) => e.style[n] = i[n]
    ), h.addClass(e, this._classes.rippleWave), e.setAttribute("data-te-ripple-ref", ""), this._addColor(e, t), this._toggleUnbound(t), this._appendRipple(e, t);
  }
  _removeHTMLRipple({ ripple: t, duration: e }) {
    this._rippleTimer && (clearTimeout(this._rippleTimer), this._rippleTimer = null), t && setTimeout(() => {
      t.classList.add("!opacity-0");
    }, 10), this._rippleTimer = setTimeout(() => {
      if (t && (t.remove(), this._element)) {
        d.find("[data-te-ripple-ref]", this._element).forEach(
          (n) => {
            n.remove();
          }
        ), this._isMinWidthSet && (h.style(this._element, { "min-width": "" }), this._isMinWidthSet = !1);
        const i = this._initialClasses ? this._addedNewRippleClasses(
          this._classes.ripple,
          this._initialClasses
        ) : this._classes.ripple.split(" ");
        h.removeClass(this._element, i);
      }
    }, e);
  }
  _addedNewRippleClasses(t, e) {
    return t.split(" ").filter(
      (i) => e.findIndex((n) => i === n) === -1
    );
  }
  _durationToMsNumber(t) {
    return Number(t.replace("ms", "").replace("s", "000"));
  }
  _getConfig(t = {}) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...If,
      ...e,
      ...t
    }, I(eo, t, Df), t;
  }
  _getClasses(t = {}) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...$f,
      ...e,
      ...t
    }, I(eo, t, Lf), t;
  }
  _getDiameter({ offsetX: t, offsetY: e, height: i, width: n }) {
    const o = e <= i / 2, r = t <= n / 2, a = (f, g) => Math.sqrt(f ** 2 + g ** 2), l = e === i / 2 && t === n / 2, p = {
      first: o === !0 && r === !1,
      second: o === !0 && r === !0,
      third: o === !1 && r === !0,
      fourth: o === !1 && r === !1
    }, u = {
      topLeft: a(t, e),
      topRight: a(n - t, e),
      bottomLeft: a(t, i - e),
      bottomRight: a(n - t, i - e)
    };
    let _ = 0;
    return l || p.fourth ? _ = u.topLeft : p.third ? _ = u.topRight : p.second ? _ = u.bottomRight : p.first && (_ = u.bottomLeft), _ * 2;
  }
  _appendRipple(t, e) {
    e.appendChild(t), setTimeout(() => {
      h.addClass(t, "opacity-0 scale-100");
    }, 50);
  }
  _toggleUnbound(t) {
    this._options.rippleUnbound === !0 ? h.addClass(t, this._classes.unbound) : h.removeClass(t, this._classes.unbound);
  }
  _addColor(t) {
    let e = this._options.rippleColor || "rgb(0,0,0)";
    (localStorage.theme === "dark" || !("theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) && (e = this._options.rippleColorDark || this._options.rippleColor);
    const i = Sf.find(
      (r) => r.name === e.toLowerCase()
    ), n = i ? this._colorToRGB(i.gradientColor).join(",") : this._colorToRGB(e).join(","), o = xf.split("{{color}}").join(`${n}`);
    t.style.backgroundImage = `radial-gradient(circle, ${o})`;
  }
  _colorToRGB(t) {
    function e(o) {
      return o.length < 7 && (o = `#${o[1]}${o[1]}${o[2]}${o[2]}${o[3]}${o[3]}`), [
        parseInt(o.substr(1, 2), 16),
        parseInt(o.substr(3, 2), 16),
        parseInt(o.substr(5, 2), 16)
      ];
    }
    function i(o) {
      const r = document.body.appendChild(
        document.createElement("fictum")
      ), a = "rgb(1, 2, 3)";
      return r.style.color = a, r.style.color !== a || (r.style.color = o, r.style.color === a || r.style.color === "") ? us : (o = getComputedStyle(r).color, document.body.removeChild(r), o);
    }
    function n(o) {
      return o = o.match(/[.\d]+/g).map((r) => +Number(r)), o.length = 3, o;
    }
    return t.toLowerCase() === "transparent" ? us : t[0] === "#" ? e(t) : (t.indexOf("rgb") === -1 && (t = i(t)), t.indexOf("rgb") === 0 ? n(t) : us);
  }
  // Static
  static autoInitial(t) {
    return function(e) {
      t._autoInit(e);
    };
  }
  static jQueryInterface(t) {
    return this.each(function() {
      return A.getData(this, ds) ? null : new ei(this, t);
    });
  }
  static getInstance(t) {
    return A.getData(t, ds);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
function tt(s) {
  return s.getDate();
}
function zs(s) {
  return s.getDay();
}
function Y(s) {
  return s.getMonth();
}
function B(s) {
  return s.getFullYear();
}
function Nf(s, t, e) {
  const i = e.startDay, n = i > 0 ? 7 - i : 0, r = new Date(s, t).getDay() + n;
  return r >= 7 ? r - 7 : r;
}
function Go(s) {
  return Mf(s).getDate();
}
function Mf(s) {
  return Ct(s.getFullYear(), s.getMonth() + 1, 0);
}
function je() {
  return /* @__PURE__ */ new Date();
}
function at(s, t) {
  return lt(s, t * 12);
}
function lt(s, t) {
  const e = Ct(
    s.getFullYear(),
    s.getMonth() + t,
    s.getDate()
  ), i = tt(s), n = tt(e);
  return i !== n && e.setDate(0), e;
}
function $e(s, t) {
  return Ct(s.getFullYear(), s.getMonth(), s.getDate() + t);
}
function Ct(s, t, e) {
  const i = new Date(s, t, e);
  return s >= 0 && s < 100 && i.setFullYear(i.getFullYear() - 1900), i;
}
function Va(s) {
  const t = s.split("-"), e = t[0], i = t[1], n = t[2];
  return Ct(e, i, n);
}
function Rf(s) {
  return !Number.isNaN(s.getTime());
}
function Fe(s, t) {
  return B(s) - B(t) || Y(s) - Y(t) || tt(s) - tt(t);
}
function me(s, t) {
  return s.setHours(0, 0, 0, 0), t.setHours(0, 0, 0, 0), s.getTime() === t.getTime();
}
function Us(s, t) {
  const i = B(s) - Bf();
  return Pf(i, t);
}
function Pf(s, t) {
  return (s % t + t) % t;
}
function Bf(s, t, e) {
  let i = 0;
  return e ? i = B(e) - s + 1 : t && (i = B(t)), i;
}
function _n(s, t, e, i, n, o) {
  const r = /* @__PURE__ */ new Date();
  r.setHours(0, 0, 0, 0);
  const a = t && Fe(s, t) <= -1, l = e && Fe(s, e) >= 1, p = n && Fe(s, r) <= -1, u = o && Fe(s, r) >= 1, _ = i && i(s) === !1;
  return a || l || _ || p || u;
}
function _h(s, t, e, i, n, o) {
  const r = /* @__PURE__ */ new Date(), a = i && B(i), l = i && Y(i), p = e && B(e), u = e && Y(e), _ = B(r), f = Y(r), g = l && a && (t > a || t === a && s > l), m = u && p && (t < p || t === p && s < u), b = n && (t < _ || t === _ && s < f), v = o && (t > _ || t === _ && s > f);
  return g || m || b || v;
}
function qo(s, t, e, i, n) {
  const o = t && B(t), r = e && B(e), a = B(/* @__PURE__ */ new Date()), l = r && s > r, p = o && s < o, u = i && s < a, _ = n && s > a;
  return l || p || u || _;
}
function Hf(s, t, e, i, n, o, r, a) {
  const l = /* @__PURE__ */ new Date();
  return l.setHours(0, 0, 0, 0), (s && o && Fe(o, l) < 0 || s) && (o = l), o && Pi(
    t,
    o,
    e,
    i,
    n,
    o,
    r,
    a
  );
}
function Vf(s, t, e, i, n, o, r, a) {
  const l = /* @__PURE__ */ new Date();
  return l.setHours(0, 0, 0, 0), (s && n && Fe(n, l) < 0 || s) && (n = l), n && Pi(
    t,
    n,
    e,
    i,
    n,
    o,
    r,
    a
  );
}
function Pi(s, t, e, i, n, o, r, a) {
  return e === "days" ? B(s) === B(t) && Y(s) === Y(t) : e === "months" ? B(s) === B(t) : e === "years" ? B(t) >= a && B(t) <= r : !1;
}
const Wf = "data-te-datepicker-modal-container-ref", Ff = "data-te-datepicker-dropdown-container-ref", Yf = "data-te-dropdown-backdrop-ref", jf = "data-te-datepicker-date-text-ref", Wa = "data-te-datepicker-view-ref", Kf = "data-te-datepicker-previous-button-ref", zf = "data-te-datepicker-next-button-ref", Uf = "data-te-datepicker-ok-button-ref", Xf = "data-te-datepicker-cancel-button-ref", Gf = "data-te-datepicker-clear-button-ref", qf = "data-te-datepicker-view-change-button-ref";
function Zf(s, t, e, i, n, o, r, a, l, p) {
  const u = Y(s), _ = B(s), f = tt(s), g = zs(s), m = $("div"), b = `
        ${Fa(
    s,
    u,
    _,
    t,
    e,
    i,
    n,
    o,
    r,
    a,
    p
  )}
    `, v = `
      ${Jf(f, g, u, n, p)}
      ${Fa(
    s,
    u,
    _,
    t,
    e,
    i,
    n,
    o,
    r,
    a,
    p
  )}
    `;
  return n.inline ? (h.addClass(m, p.datepickerDropdownContainer), m.setAttribute(Ff, l), m.innerHTML = b) : (h.addClass(m, p.modalContainer), m.setAttribute(Wf, l), m.innerHTML = v), m;
}
function Qf(s) {
  const t = $("div");
  return h.addClass(t, s), t.setAttribute(Yf, ""), t;
}
function Jf(s, t, e, i, n) {
  return `
      <div class="${n.datepickerHeader}" data-te-datepicker-header>
        <div class="${n.datepickerTitle}">
          <span class="${n.datepickerTitleText}">${i.title}</span>
        </div>
        <div class="${n.datepickerDate}">
          <span class="${n.datepickerDateText}" ${jf} >${i.weekdaysShort[t]}, ${i.monthsShort[e]} ${s}</span>
        </div>
      </div>
    `;
}
function Fa(s, t, e, i, n, o, r, a, l, p, u) {
  let _;
  return r.inline ? _ = `
    <div class="${u.datepickerMain}">
      ${ja(t, e, r, u)}
      <div class="${u.datepickerView}" ${Wa} tabindex="0">
        ${Ya(
    s,
    e,
    i,
    n,
    o,
    r,
    a,
    l,
    p,
    u
  )}
      </div>
    </div>
  ` : _ = `
    <div class="${u.datepickerMain}">
      ${ja(t, e, r, u)}
      <div class="${u.datepickerView}" ${Wa} tabindex="0">
        ${Ya(
    s,
    e,
    i,
    n,
    o,
    r,
    a,
    l,
    p,
    u
  )}
      </div>
      ${tm(r, u)}
    </div>
  `, _;
}
function Ya(s, t, e, i, n, o, r, a, l, p) {
  let u;
  return o.view === "days" ? u = Xs(s, e, o, p) : o.view === "months" ? u = Gs(
    t,
    i,
    n,
    o,
    r,
    p
  ) : u = qs(
    s,
    i,
    o,
    a,
    l,
    p
  ), u;
}
function ja(s, t, e, i) {
  return `
    <div class="${i.datepickerDateControls}">
      <button class="${i.datepickerViewChangeButton}" aria-label="${e.switchToMultiYearViewLabel}" ${qf}>
        ${e.monthsFull[s]} ${t} ${Lt(
    e,
    i
  )}
      </button>
      <div class="${i.datepickerArrowControls}">
        <button class="${i.datepickerPreviousButton}" aria-label="${e.prevMonthLabel}" ${Kf}>${e.changeMonthIconTemplate}</button>
        <button class="${i.datepickerNextButton}" aria-label="${e.nextMonthLabel}" ${zf}>${e.changeMonthIconTemplate}</button>
      </div>
    </div>
    `;
}
function Lt(s, t) {
  return `
  <span class="${t.datepickerViewChangeIcon}">
  ${s.viewChangeIconTemplate}
  </span>
  `;
}
function tm(s, t) {
  const e = `<button class="${t.datepickerFooterBtn}" aria-label="${s.okBtnLabel}" ${Uf}>${s.okBtnText}</button>`, i = `<button class="${t.datepickerFooterBtn}" aria-label="${s.cancelBtnLabel}" ${Xf}>${s.cancelBtnText}</button>`, n = `<button class="${t.datepickerFooterBtn} ${t.datepickerClearBtn}" aria-label="${s.clearBtnLabel}" ${Gf}>${s.clearBtnText}</button>`;
  return `
        <div class="${t.datepickerFooter}">
          
        ${s.removeClearBtn ? "" : n}
        ${s.removeCancelBtn ? "" : i}
        ${s.removeOkBtn ? "" : e}
        </div>
      `;
}
function Xs(s, t, e, i) {
  const n = em(s, t, e), r = `
      <tr>
        ${e.weekdaysNarrow.map((l, p) => `<th class="${i.datepickerDayHeading}" scope="col" aria-label="${e.weekdaysFull[p]}">${l}</th>`).join("")}
      </tr>
    `, a = n.map((l) => `
        <tr>
          ${l.map((p) => `
              <td
              class="${i.datepickerCell} ${i.datepickerCellSmall}"
              data-te-date="${B(p.date)}-${Y(
    p.date
  )}-${tt(p.date)}"
              aria-label="${p.date}"
              aria-selected="${p.isSelected}"
              ${p.isSelected ? "data-te-datepicker-cell-selected" : ""}
              ${!p.currentMonth || p.disabled ? "data-te-datepicker-cell-disabled" : ""}
              ${p.isToday ? "data-te-datepicker-cell-current" : ""}
              >
                <div
                  class="${i.datepickerCellContent} ${i.datepickerCellContentSmall}"
                  style="${p.currentMonth ? "display: block" : "display: none"}"
                  >
                  ${p.dayNumber}
                  </div>
              </td>
            `).join("")}
        </tr>
      `).join("");
  return `
      <table class="${i.datepickerTable}">
        <thead>
          ${r}
        </thead>
        <tbody>
         ${a}
        </tbody>
      </table>
    `;
}
function em(s, t, e) {
  const i = [], n = Y(s), o = Y(lt(s, -1)), r = Y(lt(s, 1)), a = B(s), l = Nf(a, n, e), p = Go(s), u = Go(lt(s, -1)), _ = 7;
  let f = 1, g = !1;
  for (let m = 1; m < _; m++) {
    const b = [];
    if (m === 1) {
      const v = u - l + 1;
      for (let y = v; y <= u; y++) {
        const C = Ct(a, o, y);
        b.push({
          date: C,
          currentMonth: g,
          isSelected: t && me(C, t),
          isToday: me(C, je()),
          dayNumber: tt(C)
        });
      }
      g = !0;
      const T = _ - b.length;
      for (let y = 0; y < T; y++) {
        const C = Ct(a, n, f);
        b.push({
          date: C,
          currentMonth: g,
          isSelected: t && me(C, t),
          isToday: me(C, je()),
          dayNumber: tt(C),
          disabled: _n(
            C,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), f++;
      }
    } else
      for (let v = 1; v < 8; v++) {
        f > p && (f = 1, g = !1);
        const T = Ct(
          a,
          g ? n : r,
          f
        );
        b.push({
          date: T,
          currentMonth: g,
          isSelected: t && me(T, t),
          isToday: me(T, je()),
          dayNumber: tt(T),
          disabled: _n(
            T,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), f++;
      }
    i.push(b);
  }
  return i;
}
function Gs(s, t, e, i, n, o) {
  const r = im(i, n), a = Y(je()), l = B(je()), p = `
      ${r.map((u) => `
          <tr>
            ${u.map((_) => {
    const f = i.monthsShort.indexOf(_);
    return `
                <td class="${o.datepickerCell} ${o.datepickerCellLarge}"
                ${_h(
      f,
      s,
      i.min,
      i.max,
      i.disablePast,
      i.disableFuture
    ) ? "data-te-datepicker-cell-disabled" : ""}
                
                data-te-month="${f}" data-te-year="${s}" aria-label="${_}, ${s}"
                ${f === e && s === t ? "data-te-datepicker-cell-selected" : ""}
                ${f === a && s === l ? "data-te-datepicker-cell-current" : ""}" data-te-month="${f}" data-te-year="${s}" aria-label="${_}, ${s}">
                  <div class="${o.datepickerCellContent} ${o.datepickerCellContentLarge}">${_}</div>
                </td>
              `;
  }).join("")}
          </tr>
        `).join("")}
    `;
  return `
      <table class="${o.datepickerTable}">
        <tbody>
         ${p}
        </tbody>
      </table>
    `;
}
function im(s, t) {
  const e = [];
  let i = [];
  for (let n = 0; n < s.monthsShort.length; n++)
    if (i.push(s.monthsShort[n]), i.length === t) {
      const o = i;
      e.push(o), i = [];
    }
  return e;
}
function qs(s, t, e, i, n, o) {
  const r = sm(s, i, n), a = B(je()), l = `
    ${r.map((p) => `
        <tr>
          ${p.map((u) => `
              <td class="${o.datepickerCell} ${o.datepickerCellLarge}"  aria-label="${u}" data-te-year="${u}"
              ${qo(
    u,
    e.min,
    e.max,
    e.disablePast,
    e.disableFuture
  ) ? "data-te-datepicker-cell-disabled" : ""}
              ${u === t ? "data-te-datepicker-cell-selected" : ""}
              ${u === a ? "data-te-datepicker-cell-current" : ""}
              >
                <div class="${o.datepickerCellContent} ${o.datepickerCellContentLarge}">${u}</div>
              </td>
            `).join("")}
        </tr>
      `).join("")}
  `;
  return `
      <table class="${o.datepickerTable}">
        <tbody>
        ${l}
        </tbody>
      </table>
    `;
}
function sm(s, t, e) {
  const i = [], n = B(s), o = Us(s, t), r = n - o;
  let a = [];
  for (let l = 0; l < t; l++)
    if (a.push(r + l), a.length === e) {
      const p = a;
      i.push(p), a = [];
    }
  return i;
}
function nm(s, t) {
  return `
    <button id="${s}" type="button" class="${t}" data-te-datepicker-toggle-button-ref data-te-datepicker-toggle-ref>
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
      <path fill-rule="evenodd" d="M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z" clip-rule="evenodd" />
      </svg>  
    </button>
  `;
}
const Ke = 37, U = 38, ze = 39, z = 40, Te = 36, Ee = 35, io = 33, so = 34, it = 13, Zs = 32, we = 27, ke = 9, om = 8, rm = 46, Tt = 24, ps = 4, _s = 4, no = "datepicker", Qs = "te.datepicker", En = `.${Qs}`, am = ".data-api", lm = `close${En}`, cm = `open${En}`, hm = `dateChange${En}`, fs = `click${En}${am}`, fh = "data-te-datepicker-modal-container-ref", mh = "data-te-datepicker-dropdown-container-ref", ms = "[data-te-datepicker-toggle-ref]", dm = `[${fh}]`, um = `[${mh}]`, pm = "[data-te-datepicker-view-change-button-ref]", _m = "[data-te-datepicker-previous-button-ref]", fm = "[data-te-datepicker-next-button-ref]", mm = "[data-te-datepicker-ok-button-ref]", gm = "[data-te-datepicker-cancel-button-ref]", bm = "[data-te-datepicker-clear-button-ref]", vm = "[data-te-datepicker-view-ref]", Tm = "[data-te-datepicker-toggle-button-ref]", Em = "[data-te-datepicker-date-text-ref]", Cm = "[data-te-dropdown-backdrop-ref]", Am = "animate-[fade-in_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", ym = "animate-[fade-out_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", wm = "animate-[fade-in_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", km = "animate-[fade-out_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", xm = "flex flex-col fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[328px] h-[512px] bg-white rounded-[0.6rem] shadow-lg z-[1066] xs:max-md:landscape:w-[475px] xs:max-md:landscape:h-[360px] xs:max-md:landscape:flex-row dark:bg-zinc-700", Om = "w-full h-full fixed top-0 right-0 left-0 bottom-0 bg-black/40 z-[1065]", Sm = "relative h-full", Im = "xs:max-md:landscape:h-full h-[120px] px-6 bg-primary flex flex-col rounded-t-lg dark:bg-zinc-800", Dm = "h-8 flex flex-col justify-end", $m = "text-[10px] font-normal uppercase tracking-[1.7px] text-white", Lm = "xs:max-md:landscape:mt-24 h-[72px] flex flex-col justify-end", Nm = "text-[34px] font-normal text-white", Mm = "outline-none px-3", Rm = "px-3 pt-2.5 pb-0 flex justify-between text-black/[64]", Pm = "flex items-center outline-none p-2.5 text-neutral-500 font-medium text-[0.9rem] rounded-xl shadow-none bg-transparent m-0 border-none hover:bg-neutral-200 focus:bg-neutral-200  dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10", Bm = "mt-2.5", Hm = "p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent mr-6 hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:mx-auto", Vm = "p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:rotate-180 [&>svg]:mx-auto", Wm = "h-14 flex absolute w-full bottom-0 justify-end items-center px-3", Fm = "outline-none bg-white text-primary border-none cursor-pointer py-0 px-2.5 uppercase text-[0.8rem] leading-10 font-medium h-10 tracking-[.1rem] rounded-[10px] mb-2.5 hover:bg-neutral-200 focus:bg-neutral-200 dark:bg-transparent dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10", Ym = "mr-auto", jm = "w-10 h-10 text-center text-[12px] font-normal dark:text-white", Km = "text-center data-[te-datepicker-cell-disabled]:text-neutral-300 data-[te-datepicker-cell-disabled]:cursor-default data-[te-datepicker-cell-disabled]:pointer-events-none data-[te-datepicker-cell-disabled]:hover:cursor-default hover:cursor-pointer group", zm = "w-10 h-10 xs:max-md:landscape:w-8 xs:max-md:landscape:h-8", Um = "w-[76px] h-[42px]", Xm = "mx-auto group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-neutral-300 group-[[data-te-datepicker-cell-selected]]:bg-primary group-[[data-te-datepicker-cell-selected]]:text-white group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-neutral-100 group-[[data-te-datepicker-cell-focused]]:data-[te-datepicker-cell-selected]:bg-primary group-[[data-te-datepicker-cell-current]]:border-solid group-[[data-te-datepicker-cell-current]]:border-black group-[[data-te-datepicker-cell-current]]:border dark:group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-white/10 dark:group-[[data-te-datepicker-cell-current]]:border-white dark:text-white dark:group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-white/10 dark:group-[[data-te-datepicker-cell-disabled]]:text-neutral-500", Gm = "w-9 h-9 leading-9 rounded-[50%] text-[13px]", qm = "w-[72px] h-10 leading-10 py-[1px] px-0.5 rounded-[999px]", Zm = "mx-auto w-[304px]", Qm = "flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-0.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200", Jm = "inline-block pointer-events-none ml-[3px] [&>svg]:w-4 [&>svg]:h-4 [&>svg]:fill-neutral-500 dark:[&>svg]:fill-white", tg = "w-[328px] h-[380px] bg-white rounded-lg shadow-[0px_2px_15px_-3px_rgba(0,0,0,.07),_0px_10px_20px_-2px_rgba(0,0,0,.04)] z-[1066] dark:bg-zinc-700", eg = {
  title: "Select date",
  container: "body",
  disablePast: !1,
  disableFuture: !1,
  monthsFull: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  monthsShort: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  weekdaysFull: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  weekdaysNarrow: ["S", "M", "T", "W", "T", "F", "S"],
  okBtnText: "Ok",
  clearBtnText: "Clear",
  cancelBtnText: "Cancel",
  okBtnLabel: "Confirm selection",
  clearBtnLabel: "Clear selection",
  cancelBtnLabel: "Cancel selection",
  nextMonthLabel: "Next month",
  prevMonthLabel: "Previous month",
  nextYearLabel: "Next year",
  prevYearLabel: "Previous year",
  changeMonthIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
  </svg>
  `,
  nextMultiYearLabel: "Next 24 years",
  prevMultiYearLabel: "Previous 24 years",
  switchToMultiYearViewLabel: "Choose year and month",
  switchToMonthViewLabel: "Choose date",
  switchToDayViewLabel: "Choose date",
  startDate: null,
  startDay: 0,
  format: "dd/mm/yyyy",
  view: "days",
  viewChangeIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="0" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
  </svg>
  `,
  min: null,
  max: null,
  filter: null,
  inline: !1,
  toggleButton: !0,
  disableToggleButton: !1,
  disableInput: !1,
  animations: !0,
  confirmDateOnSelect: !1,
  removeOkBtn: !1,
  removeCancelBtn: !1,
  removeClearBtn: !1
}, ig = {
  title: "string",
  container: "string",
  disablePast: "boolean",
  disableFuture: "boolean",
  monthsFull: "array",
  monthsShort: "array",
  weekdaysFull: "array",
  weekdaysShort: "array",
  weekdaysNarrow: "array",
  okBtnText: "string",
  clearBtnText: "string",
  cancelBtnText: "string",
  okBtnLabel: "string",
  clearBtnLabel: "string",
  cancelBtnLabel: "string",
  nextMonthLabel: "string",
  prevMonthLabel: "string",
  nextYearLabel: "string",
  prevYearLabel: "string",
  nextMultiYearLabel: "string",
  prevMultiYearLabel: "string",
  changeMonthIconTemplate: "string",
  switchToMultiYearViewLabel: "string",
  switchToMonthViewLabel: "string",
  switchToDayViewLabel: "string",
  startDate: "(null|string|date)",
  startDay: "number",
  format: "string",
  view: "string",
  viewChangeIconTemplate: "string",
  min: "(null|string|date)",
  max: "(null|string|date)",
  filter: "(null|function)",
  inline: "boolean",
  toggleButton: "boolean",
  disableToggleButton: "boolean",
  disableInput: "boolean",
  animations: "boolean",
  confirmDateOnSelect: "boolean",
  removeOkBtn: "boolean",
  removeCancelBtn: "boolean",
  removeClearBtn: "boolean"
}, sg = {
  fadeIn: Am,
  fadeOut: ym,
  fadeInShort: wm,
  fadeOutShort: km,
  modalContainer: xm,
  datepickerBackdrop: Om,
  datepickerMain: Sm,
  datepickerHeader: Im,
  datepickerTitle: Dm,
  datepickerTitleText: $m,
  datepickerDate: Lm,
  datepickerDateText: Nm,
  datepickerView: Mm,
  datepickerDateControls: Rm,
  datepickerViewChangeButton: Pm,
  datepickerViewChangeIcon: Jm,
  datepickerArrowControls: Bm,
  datepickerPreviousButton: Hm,
  datepickerNextButton: Vm,
  datepickerFooter: Wm,
  datepickerFooterBtn: Fm,
  datepickerClearBtn: Ym,
  datepickerDayHeading: jm,
  datepickerCell: Km,
  datepickerCellSmall: zm,
  datepickerCellLarge: Um,
  datepickerCellContent: Xm,
  datepickerCellContentSmall: Gm,
  datepickerCellContentLarge: qm,
  datepickerTable: Zm,
  datepickerToggleButton: Qm,
  datepickerDropdownContainer: tg
}, ng = {
  fadeIn: "string",
  fadeOut: "string",
  fadeInShort: "string",
  fadeOutShort: "string",
  modalContainer: "string",
  datepickerBackdrop: "string",
  datepickerMain: "string",
  datepickerHeader: "string",
  datepickerTitle: "string",
  datepickerTitleText: "string",
  datepickerDate: "string",
  datepickerDateText: "string",
  datepickerView: "string",
  datepickerDateControls: "string",
  datepickerViewChangeButton: "string",
  datepickerArrowControls: "string",
  datepickerPreviousButton: "string",
  datepickerNextButton: "string",
  datepickerFooter: "string",
  datepickerFooterBtn: "string",
  datepickerClearBtn: "string",
  datepickerDayHeading: "string",
  datepickerCell: "string",
  datepickerCellSmall: "string",
  datepickerCellLarge: "string",
  datepickerCellContent: "string",
  datepickerCellContentSmall: "string",
  datepickerCellContentLarge: "string",
  datepickerTable: "string",
  datepickerToggleButton: "string",
  datepickerDropdownContainer: "string"
};
class og {
  constructor(t, e, i) {
    this._element = t, this._input = d.findOne("input", this._element), this._options = this._getConfig(e), this._classes = this._getClasses(i), this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = this._options.view, this._popper = null, this._focusTrap = null, this._isOpen = !1, this._toggleButtonId = et("datepicker-toggle-"), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this._scrollBar = new ti(), this._element && A.setData(t, Qs, this), this._init(), this.toggleButton && this._options.disableToggle && (this.toggleButton.disabled = "true"), this._options.disableInput && (this._input.disabled = "true");
  }
  // Getters
  static get NAME() {
    return no;
  }
  get container() {
    return d.findOne(
      `[${fh}='${this._toggleButtonId}']`
    ) || d.findOne(
      `[${mh}='${this._toggleButtonId}']`
    );
  }
  get options() {
    return this._options;
  }
  get activeCell() {
    let t;
    return this._view === "days" && (t = this._getActiveDayCell()), this._view === "months" && (t = this._getActiveMonthCell()), this._view === "years" && (t = this._getActiveYearCell()), t;
  }
  get activeDay() {
    return tt(this._activeDate);
  }
  get activeMonth() {
    return Y(this._activeDate);
  }
  get activeYear() {
    return B(this._activeDate);
  }
  get firstYearInView() {
    return this.activeYear - Us(this._activeDate, Tt);
  }
  get lastYearInView() {
    return this.firstYearInView + Tt - 1;
  }
  get viewChangeButton() {
    return d.findOne(pm, this.container);
  }
  get previousButton() {
    return d.findOne(_m, this.container);
  }
  get nextButton() {
    return d.findOne(fm, this.container);
  }
  get okButton() {
    return d.findOne(mm, this.container);
  }
  get cancelButton() {
    return d.findOne(gm, this.container);
  }
  get clearButton() {
    return d.findOne(bm, this.container);
  }
  get datesContainer() {
    return d.findOne(vm, this.container);
  }
  get toggleButton() {
    return d.findOne(Tm, this._element);
  }
  update(t = {}) {
    this._options = this._getConfig({ ...this._options, ...t });
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    if (t = {
      ...eg,
      ...e,
      ...t
    }, I(no, t, ig), t.max && typeof t.max == "string" && (t.max = new Date(t.max)), t.min && typeof t.min == "string" && (t.min = new Date(t.min)), t.startDay && t.startDay !== 0) {
      const i = this._getNewDaysOrderArray(t);
      t.weekdaysNarrow = i;
    }
    return t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...sg,
      ...e,
      ...t
    }, I(no, t, ng), t;
  }
  _getContainer() {
    return d.findOne(this._options.container);
  }
  _getNewDaysOrderArray(t) {
    const e = t.startDay, i = t.weekdaysNarrow;
    return i.slice(e).concat(i.slice(0, e));
  }
  _init() {
    !this.toggleButton && this._options.toggleButton && (this._appendToggleButton(), (this._input.readOnly || this._input.disabled) && (this.toggleButton.style.pointerEvents = "none")), this._listenToUserInput(), this._listenToToggleClick(), this._listenToToggleKeydown();
  }
  _appendToggleButton() {
    const t = nm(
      this._toggleButtonId,
      this._classes.datepickerToggleButton
    );
    this._element.insertAdjacentHTML("beforeend", t);
  }
  open() {
    if (this._input.readOnly || this._input.disabled)
      return;
    const t = c.trigger(this._element, cm);
    if (this._isOpen || t.defaultPrevented)
      return;
    this._setInitialDate();
    const e = Qf(this._classes.datepickerBackdrop), i = Zf(
      this._activeDate,
      this._selectedDate,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      _s,
      Tt,
      ps,
      this._toggleButtonId,
      this._classes
    );
    this._options.inline ? this._openDropdown(i) : (this._openModal(e, i), this._scrollBar.hide()), this._animations && (h.addClass(this.container, this._classes.fadeIn), h.addClass(e, this._classes.fadeInShort)), this._setFocusTrap(this.container), this._listenToDateSelection(), this._addControlsListeners(), this._updateControlsDisabledState(), this._listenToEscapeClick(), this._listenToKeyboardNavigation(), this._listenToDatesContainerFocus(), this._listenToDatesContainerBlur(), this._asyncFocusDatesContainer(), this._updateViewControlsAndAttributes(this._view), this._isOpen = !0, setTimeout(() => {
      this._listenToOutsideClick();
    }, 0);
  }
  _openDropdown(t) {
    this._popper = se(this._input, t, {
      placement: "bottom-start"
    }), this._getContainer().appendChild(t);
  }
  _openModal(t, e) {
    const i = this._getContainer();
    i.appendChild(t), i.appendChild(e);
  }
  _setFocusTrap(t) {
    this._focusTrap = new zi(t, {
      event: "keydown",
      condition: (e) => e.key === "Tab"
    }), this._focusTrap.trap();
  }
  _listenToUserInput() {
    c.on(this._input, "input", (t) => {
      this._handleUserInput(t.target.value);
    });
  }
  _listenToToggleClick() {
    c.on(
      this._element,
      fs,
      ms,
      (t) => {
        t.preventDefault(), this.open();
      }
    );
  }
  _listenToToggleKeydown() {
    c.on(
      this._element,
      "keydown",
      ms,
      (t) => {
        t.keyCode === it && !this._isOpen && this.open();
      }
    );
  }
  _listenToDateSelection() {
    c.on(this.datesContainer, "click", (t) => {
      this._handleDateSelection(t);
    });
  }
  _handleDateSelection(t) {
    const e = t.target.nodeName === "DIV" ? t.target.parentNode.dataset : t.target.dataset, i = t.target.nodeName === "DIV" ? t.target.parentNode : t.target;
    if (e.teDate && this._pickDay(e.teDate, i), e.teMonth && e.teYear) {
      const n = parseInt(e.teMonth, 10), o = parseInt(e.teYear, 10);
      this._pickMonth(n, o);
    }
    if (e.teYear && !e.teMonth) {
      const n = parseInt(e.teYear, 10);
      this._pickYear(n);
    }
    this._options.inline || this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _updateHeaderDate(t, e, i) {
    const n = d.findOne(
      Em,
      this.container
    ), o = Y(t), r = tt(t), a = zs(t);
    n.innerHTML = `${i[a]}, ${e[o]} ${r}`;
  }
  _addControlsListeners() {
    c.on(this.nextButton, "click", () => {
      this._view === "days" ? this.nextMonth() : this._view === "years" ? this.nextYears() : this.nextYear(), this._updateControlsDisabledState();
    }), c.on(this.previousButton, "click", () => {
      this._view === "days" ? this.previousMonth() : this._view === "years" ? this.previousYears() : this.previousYear(), this._updateControlsDisabledState();
    }), c.on(this.viewChangeButton, "click", () => {
      this._view === "days" ? this._changeView("years") : (this._view === "years" || this._view === "months") && this._changeView("days");
    }), this._options.inline || this._listenToFooterButtonsClick();
  }
  _listenToFooterButtonsClick() {
    c.on(this.okButton, "click", () => this.handleOk()), c.on(this.cancelButton, "click", () => this.handleCancel()), c.on(this.clearButton, "click", () => this.handleClear());
  }
  _listenToOutsideClick() {
    c.on(document, fs, (t) => {
      const e = t.target === this.container, i = this.container && this.container.contains(t.target);
      !e && !i && this.close();
    });
  }
  _listenToEscapeClick() {
    c.on(document, "keydown", (t) => {
      t.keyCode === we && this._isOpen && this.close();
    });
  }
  _listenToKeyboardNavigation() {
    c.on(this.datesContainer, "keydown", (t) => {
      this._handleKeydown(t);
    });
  }
  _listenToDatesContainerFocus() {
    c.on(this.datesContainer, "focus", () => {
      this._focusActiveCell(this.activeCell);
    });
  }
  _listenToDatesContainerBlur() {
    c.on(this.datesContainer, "blur", () => {
      this._removeCurrentFocusStyles();
    });
  }
  _handleKeydown(t) {
    this._view === "days" && this._handleDaysViewKeydown(t), this._view === "months" && this._handleMonthsViewKeydown(t), this._view === "years" && this._handleYearsViewKeydown(t);
  }
  _handleDaysViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell;
    switch (t.keyCode) {
      case Ke:
        this._activeDate = $e(this._activeDate, W() ? 1 : -1);
        break;
      case ze:
        this._activeDate = $e(this._activeDate, W() ? -1 : 1);
        break;
      case U:
        this._activeDate = $e(this._activeDate, -7);
        break;
      case z:
        this._activeDate = $e(this._activeDate, 7);
        break;
      case Te:
        this._activeDate = $e(
          this._activeDate,
          1 - tt(this._activeDate)
        );
        break;
      case Ee:
        this._activeDate = $e(
          this._activeDate,
          Go(this._activeDate) - tt(this._activeDate)
        );
        break;
      case io:
        this._activeDate = lt(this._activeDate, -1);
        break;
      case so:
        this._activeDate = lt(this._activeDate, 1);
        break;
      case it:
      case Zs:
        this._selectDate(this._activeDate), this._handleDateSelection(t), t.preventDefault();
        return;
      default:
        return;
    }
    Pi(
      e,
      this._activeDate,
      this._view,
      Tt,
      this._options.min,
      this._options.max
    ) || this._changeView("days"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _asyncFocusDatesContainer() {
    setTimeout(() => {
      this.datesContainer.focus();
    }, 0);
  }
  _focusActiveCell(t) {
    t && t.setAttribute("data-te-datepicker-cell-focused", "");
  }
  _removeHighlightFromCell(t) {
    t && t.removeAttribute("data-te-datepicker-cell-focused");
  }
  _getActiveDayCell() {
    const t = d.find("td", this.datesContainer);
    return Array.from(t).find((i) => {
      const n = Va(i.dataset.teDate);
      return me(n, this._activeDate);
    });
  }
  _handleMonthsViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell;
    switch (t.keyCode) {
      case Ke:
        this._activeDate = lt(this._activeDate, W() ? 1 : -1);
        break;
      case ze:
        this._activeDate = lt(this._activeDate, W() ? -1 : 1);
        break;
      case U:
        this._activeDate = lt(this._activeDate, -4);
        break;
      case z:
        this._activeDate = lt(this._activeDate, 4);
        break;
      case Te:
        this._activeDate = lt(this._activeDate, -this.activeMonth);
        break;
      case Ee:
        this._activeDate = lt(this._activeDate, 11 - this.activeMonth);
        break;
      case io:
        this._activeDate = at(this._activeDate, -1);
        break;
      case so:
        this._activeDate = at(this._activeDate, 1);
        break;
      case it:
      case Zs:
        this._selectMonth(this.activeMonth);
        return;
      default:
        return;
    }
    Pi(
      e,
      this._activeDate,
      this._view,
      Tt,
      this._options.min,
      this._options.max
    ) || this._changeView("months"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveMonthCell() {
    const t = d.find("td", this.datesContainer);
    return Array.from(t).find((i) => {
      const n = parseInt(i.dataset.teYear, 10), o = parseInt(i.dataset.teMonth, 10);
      return n === this.activeYear && o === this.activeMonth;
    });
  }
  _handleYearsViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell, n = 4, o = 24;
    switch (t.keyCode) {
      case Ke:
        this._activeDate = at(this._activeDate, W() ? 1 : -1);
        break;
      case ze:
        this._activeDate = at(this._activeDate, W() ? -1 : 1);
        break;
      case U:
        this._activeDate = at(this._activeDate, -n);
        break;
      case z:
        this._activeDate = at(this._activeDate, n);
        break;
      case Te:
        this._activeDate = at(
          this._activeDate,
          -Us(this._activeDate, o)
        );
        break;
      case Ee:
        this._activeDate = at(
          this._activeDate,
          o - Us(this._activeDate, o) - 1
        );
        break;
      case io:
        this._activeDate = at(this._activeDate, -o);
        break;
      case so:
        this._activeDate = at(this._activeDate, o);
        break;
      case it:
      case Zs:
        this._selectYear(this.activeYear);
        return;
      default:
        return;
    }
    Pi(
      e,
      this._activeDate,
      this._view,
      Tt,
      this._options.min,
      this._options.max
    ) || this._changeView("years"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveYearCell() {
    const t = d.find("td", this.datesContainer);
    return Array.from(t).find((i) => parseInt(i.dataset.teYear, 10) === this.activeYear);
  }
  _setInitialDate() {
    this._input.value ? this._handleUserInput(this._input.value) : this._options.startDate ? this._activeDate = new Date(this._options.startDate) : this._activeDate = /* @__PURE__ */ new Date();
  }
  close() {
    const t = c.trigger(this._element, lm);
    !this._isOpen || t.defaultPrevented || (this._removeDatepickerListeners(), this._animations && h.addClass(this.container, this._classes.fadeOut), this._options.inline ? this._closeDropdown() : this._closeModal(), this._isOpen = !1, this._view = this._options.view, this.toggleButton ? this.toggleButton.focus() : this._input.focus());
  }
  _closeDropdown() {
    const t = d.findOne(um), e = this._getContainer();
    window.matchMedia("(prefers-reduced-motion: reduce)").matches && (t && e.removeChild(t), this._popper && this._popper.destroy()), t.addEventListener("animationend", () => {
      t && e.removeChild(t), this._popper && this._popper.destroy();
    }), this._removeFocusTrap();
  }
  _closeModal() {
    const t = d.findOne(Cm), e = d.findOne(dm);
    !e || !t || (this._animations ? (h.addClass(t, this._classes.fadeOutShort), t.addEventListener("animationend", () => {
      this._removePicker(t, e), this._scrollBar.reset();
    })) : (this._removePicker(t, e), this._scrollBar.reset()));
  }
  _removePicker(t, e) {
    const i = this._getContainer();
    i.removeChild(t), i.removeChild(e);
  }
  _removeFocusTrap() {
    this._focusTrap && (this._focusTrap.disable(), this._focusTrap = null);
  }
  _removeDatepickerListeners() {
    c.off(this.nextButton, "click"), c.off(this.previousButton, "click"), c.off(this.viewChangeButton, "click"), c.off(this.okButton, "click"), c.off(this.cancelButton, "click"), c.off(this.clearButton, "click"), c.off(this.datesContainer, "click"), c.off(this.datesContainer, "keydown"), c.off(this.datesContainer, "focus"), c.off(this.datesContainer, "blur"), c.off(document, fs);
  }
  dispose() {
    this._isOpen && this.close(), this._removeInputAndToggleListeners();
    const t = d.findOne(
      `#${this._toggleButtonId}`
    );
    t && this._element.removeChild(t), A.removeData(this._element, Qs), this._element = null, this._input = null, this._options = null, this._activeDate = null, this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = null, this._popper = null, this._focusTrap = null;
  }
  _removeInputAndToggleListeners() {
    c.off(this._input, "input"), c.off(
      this._element,
      fs,
      ms
    ), c.off(this._element, "keydown", ms);
  }
  handleOk() {
    this._confirmSelection(this._headerDate), this.close();
  }
  _selectDate(t, e = this.activeCell) {
    const { min: i, max: n, filter: o, disablePast: r, disableFuture: a } = this._options;
    _n(t, i, n, o, r, a) || (this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._selectedDate = t, this._selectedYear = B(t), this._selectedMonth = Y(t), this._headerDate = t, (this._options.inline || this.options.confirmDateOnSelect) && (this._confirmSelection(t), this.close()));
  }
  _selectYear(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerYear = t, this._asyncChangeView("months");
  }
  _selectMonth(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerMonth = t, this._asyncChangeView("days");
  }
  _removeSelectedStyles(t) {
    t && t.removeAttribute("data-te-datepicker-cell-selected");
  }
  _addSelectedStyles(t) {
    t && t.setAttribute("data-te-datepicker-cell-selected", "");
  }
  _confirmSelection(t) {
    if (t) {
      const e = this.formatDate(t);
      this._input.value = e, c.trigger(this._element, hm, { date: t }), c.trigger(this._input, "input");
    }
  }
  handleCancel() {
    this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this.close();
  }
  handleClear() {
    this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null, this._removeCurrentSelectionStyles(), this._input.value = "", this._setInitialDate(), this._changeView("days"), this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _removeCurrentSelectionStyles() {
    const t = d.findOne(
      "[data-te-datepicker-cell-selected]",
      this.container
    );
    t && t.removeAttribute("data-te-datepicker-cell-selected");
  }
  _removeCurrentFocusStyles() {
    const t = d.findOne(
      "[data-te-datepicker-cell-focused]",
      this.container
    );
    t && t.removeAttribute("data-te-datepicker-cell-focused");
  }
  formatDate(t) {
    const e = tt(t), i = this._addLeadingZero(tt(t)), n = this._options.weekdaysShort[zs(t)], o = this._options.weekdaysFull[zs(t)], r = Y(t) + 1, a = this._addLeadingZero(Y(t) + 1), l = this._options.monthsShort[Y(t)], p = this._options.monthsFull[Y(t)], u = B(t).toString().length === 2 ? B(t) : B(t).toString().slice(2, 4), _ = B(t), f = this._options.format.split(
      /(d{1,4}|m{1,4}|y{4}|yy|!.)/g
    );
    let g = "";
    return f.forEach((m) => {
      switch (m) {
        case "dddd":
          m = m.replace(m, o);
          break;
        case "ddd":
          m = m.replace(m, n);
          break;
        case "dd":
          m = m.replace(m, i);
          break;
        case "d":
          m = m.replace(m, e);
          break;
        case "mmmm":
          m = m.replace(m, p);
          break;
        case "mmm":
          m = m.replace(m, l);
          break;
        case "mm":
          m = m.replace(m, a);
          break;
        case "m":
          m = m.replace(m, r);
          break;
        case "yyyy":
          m = m.replace(m, _);
          break;
        case "yy":
          m = m.replace(m, u);
          break;
      }
      g += m;
    }), g;
  }
  _addLeadingZero(t) {
    return parseInt(t, 10) < 10 ? `0${t}` : t;
  }
  _pickDay(t, e) {
    const i = Va(t), { min: n, max: o, filter: r, disablePast: a, disableFuture: l } = this._options;
    _n(i, n, o, r, a, l) || (this._activeDate = i, this._selectDate(i, e));
  }
  _pickYear(t) {
    const { min: e, max: i, disablePast: n, disableFuture: o } = this._options;
    if (qo(t, e, i, n, o))
      return;
    const r = Ct(t, this.activeMonth, this.activeDay);
    this._activeDate = r, this._selectedDate = r, this._selectYear(t);
  }
  _pickMonth(t, e) {
    const { min: i, max: n, disablePast: o, disableFuture: r } = this._options;
    if (_h(t, e, i, n, o, r) || qo(e, i, n, o, r))
      return;
    const a = Ct(e, t, this.activeDay);
    this._activeDate = a, this._selectMonth(t);
  }
  nextMonth() {
    const t = lt(this._activeDate, 1), e = Xs(
      t,
      this._headerDate,
      this._options,
      this._classes
    );
    this._activeDate = t, this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  previousMonth() {
    const t = lt(this._activeDate, -1);
    this._activeDate = t;
    const e = Xs(
      t,
      this._headerDate,
      this._options,
      this._classes
    );
    this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  nextYear() {
    const t = at(this._activeDate, 1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    );
    const e = Gs(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      _s,
      this._classes
    );
    this.datesContainer.innerHTML = e;
  }
  previousYear() {
    const t = at(this._activeDate, -1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    );
    const e = Gs(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      _s,
      this._classes
    );
    this.datesContainer.innerHTML = e;
  }
  nextYears() {
    const t = at(this._activeDate, 24);
    this._activeDate = t;
    const e = qs(
      t,
      this._selectedYear,
      this._options,
      Tt,
      ps,
      this._classes
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  previousYears() {
    const t = at(this._activeDate, -24);
    this._activeDate = t;
    const e = qs(
      t,
      this._selectedYear,
      this._options,
      Tt,
      ps,
      this._classes
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  _asyncChangeView(t) {
    setTimeout(() => {
      this._changeView(t);
    }, 0);
  }
  _changeView(t) {
    this._view = t, this.datesContainer.blur(), t === "days" && (this.datesContainer.innerHTML = Xs(
      this._activeDate,
      this._headerDate,
      this._options,
      this._classes
    )), t === "months" && (this.datesContainer.innerHTML = Gs(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      _s,
      this._classes
    )), t === "years" && (this.datesContainer.innerHTML = qs(
      this._activeDate,
      this._selectedYear,
      this._options,
      Tt,
      ps,
      this._classes
    )), this.datesContainer.focus(), this._updateViewControlsAndAttributes(t), this._updateControlsDisabledState();
  }
  _updateViewControlsAndAttributes(t) {
    t === "days" && (this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToMultiYearViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevMonthLabel
    ), this.nextButton.setAttribute("aria-label", this._options.nextMonthLabel)), t === "months" && (this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToDayViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevYearLabel
    ), this.nextButton.setAttribute("aria-label", this._options.nextYearLabel)), t === "years" && (this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToMonthViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevMultiYearLabel
    ), this.nextButton.setAttribute(
      "aria-label",
      this._options.nextMultiYearLabel
    ));
  }
  _updateControlsDisabledState() {
    Hf(
      this._options.disableFuture,
      this._activeDate,
      this._view,
      Tt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.nextButton.disabled = !0 : this.nextButton.disabled = !1, Vf(
      this._options.disablePast,
      this._activeDate,
      this._view,
      Tt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.previousButton.disabled = !0 : this.previousButton.disabled = !1;
  }
  _handleUserInput(t) {
    const e = this._getDelimeters(this._options.format), i = this._parseDate(t, this._options.format, e);
    Rf(i) ? (this._activeDate = i, this._selectedDate = i, this._selectedYear = B(i), this._selectedMonth = Y(i), this._headerDate = i) : (this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null);
  }
  _getDelimeters(t) {
    return t.match(/[^(dmy)]{1,}/g);
  }
  _parseDate(t, e, i) {
    let n;
    i[0] !== i[1] ? n = i[0] + i[1] : n = i[0];
    const o = new RegExp(`[${n}]`), r = t.split(o), a = e.split(o), l = e.indexOf("mmm") !== -1, p = [];
    for (let b = 0; b < a.length; b++)
      a[b].indexOf("yy") !== -1 && (p[0] = { value: r[b], format: a[b] }), a[b].indexOf("m") !== -1 && (p[1] = { value: r[b], format: a[b] }), a[b].indexOf("d") !== -1 && a[b].length <= 2 && (p[2] = { value: r[b], format: a[b] });
    let u;
    e.indexOf("mmmm") !== -1 ? u = this._options.monthsFull : u = this._options.monthsShort;
    const _ = Number(p[0].value), f = l ? this.getMonthNumberByMonthName(p[1].value, u) : Number(p[1].value) - 1, g = Number(p[2].value);
    return Ct(_, f, g);
  }
  getMonthNumberByMonthName(t, e) {
    return e.findIndex((i) => i === t);
  }
  static getInstance(t) {
    return A.getData(t, Qs);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const rg = ({
  format24: s,
  okLabel: t,
  cancelLabel: e,
  headID: i,
  footerID: n,
  bodyID: o,
  pickerID: r,
  clearLabel: a,
  inline: l,
  showClearBtn: p,
  amLabel: u,
  pmLabel: _
}, f) => {
  const g = `<div id='${r}' class='${f.timepickerWrapper}' data-te-timepicker-wrapper>
      <div class="${f.timepickerContainer}">
        <div class="${f.timepickerElements}" data-te-timepicker-elements-wrapper>
        <div id='${i}' class='${f.timepickerHead}' style='padding-right:${s ? 50 : 10}px'>
        <div class='${f.timepickerHeadContent}'>
            <div class="${f.timepickerCurrentWrapper}">
              <span class="${f.timepickerCurrentButtonWrapper}">
                <button type='button' class='${f.timepickerCurrentButton}' tabindex="0" data-te-timepicker-active data-te-timepicker-current data-te-timepicker-hour data-te-ripple-init>21</button>
              </span>
              <button type='button' class='${f.timepickerDot}' disabled>:</button>
            <span class="${f.timepickerCurrentButtonWrapper}">
              <button type='button' class='${f.timepickerCurrentButton}' tabindex="0" data-te-timepicker-current data-te-timepicker-minute data-te-ripple-init>21</button>
            </span>
            </div>
            ${s ? "" : `<div class="${f.timepickerModeWrapper}">
                  <button type='button' class="${f.timepickerModeAm}" tabindex="0" data-te-timepicker-am data-te-timepicker-hour-mode data-te-ripple-init>${u}</button>
                  <button class="${f.timepickerModePm}" tabindex="0" data-te-timepicker-pm data-te-timepicker-hour-mode data-te-ripple-init>${_}</button>
                </div>`}
        </div>
      </div>
      ${l ? "" : `<div id='${o}' class='${f.timepickerClockWrapper}' data-te-timepicker-clock-wrapper>
            <div class='${f.timepickerClock}' data-te-timepicker-clock>
              <span class='${f.timepickerMiddleDot}' data-te-timepicker-middle-dot></span>
              <div class='${f.timepickerHandPointer}' data-te-timepicker-hand-pointer>
                <div class='${f.timepickerPointerCircle}' data-te-timepicker-circle></div>
              </div>
              ${s ? '<div class="' + f.timepickerClockInner + '" data-te-timepicker-clock-inner></div>' : ""}
            </div>
          </div>`}
    </div>
    <div id='${n}' class='${f.timepickerFooterWrapper}'>
      <div class="${f.timepickerFooter}">
        ${p ? `<button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-clear tabindex="0" data-te-ripple-init>${a}</button>` : ""}
        <button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-cancel tabindex="0" data-te-ripple-init>${e}</button>
        <button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>
      </div>
    </div>
  </div>
</div>`, m = `<div id='${r}' class='${f.timepickerInlineWrapper}' data-te-timepicker-wrapper>
        <div class="${f.timepickerInlineContainer}">
          <div class="${f.timepickerInlineElements}" data-te-timepicker-elements-wrapper>
          <div id='${i}' class='${f.timepickerInlineHead}'
          style='padding-right:10px'>
          <div class='${f.timepickerInlineHeadContent}'>
              <div class="${f.timepickerCurrentWrapper}">
                <span class="${f.timepickerInlineHourWrapper}" data-te-timepicker-inline-hour-icons>
                  <span class="${f.timepickerInlineIconUp}" data-te-timepicker-icon-up data-te-timepicker-icon-inline-hour>
                    <span class="${f.timepickerInlineIconSvg}">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                      </svg>   
                    </span>
                  </span>
                  <button type='button' class='${f.timepickerInlineCurrentButton}' data-te-timepicker-hour data-te-timepicker-current data-te-timepicker-current-inline tabindex="0" data-te-ripple-init>21</button>
                  <span class="${f.timepickerInlineIconDown}" data-te-timepicker-icon-inline-hour data-te-timepicker-icon-down>
                    <span class="${f.timepickerInlineIconSvg}">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                      </svg>  
                    </span>
                  </span>
                </span>
                <button type='button' class='${f.timepickerInlineDot}' data-te-timepicker-current-inline disabled>:</button>
              <span class="${f.timepickerCurrentMinuteWrapper}">
                <span class="${f.timepickerInlineIconUp}" data-te-timepicker-icon-up data-te-timepicker-icon-inline-minute>
                  <span class="${f.timepickerInlineIconSvg}">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                    </svg>
                  </span>
                </span>
                <button type='button' class='${f.timepickerInlineCurrentButton}' data-te-timepicker-minute data-te-timepicker-current data-te-timepicker-current-inline tabindex="0" data-te-ripple-init>21</button>
                <span class="${f.timepickerInlineIconDown}" data-te-timepicker-icon-inline-minute data-te-timepicker-icon-down>
                  <span class="${f.timepickerInlineIconSvg}">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                    </svg> 
                  </span>
                </span>
              </span>
              </div>
              ${s ? "" : `<div class="${f.timepickerInlineModeWrapper}">
                      <button type='button' class="${f.timepickerInlineModeAm}" data-te-timepicker-am data-te-timepicker-hour-mode tabindex="0" data-te-ripple-init>${u}</button>
                      <button class="${f.timepickerInlineModePm}" data-te-timepicker-hour-mode data-te-timepicker-pm tabindex="0" data-te-ripple-init>${_}</button>
                      <button type='button' class='${f.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>
                    </div>`}
              ${s ? `<button class='${f.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>` : ""}
          </div>
        </div>
      </div>
    </div>
</div>`;
  return l ? m : g;
}, ag = (s, t, e) => {
  const { iconSVG: i } = s;
  return `
  <button id="${t}" tabindex="0" type="button" class="${e.timepickerToggleButton}" data-te-toggle="timepicker" data-te-timepicker-toggle-button data-te-timepicker-icon>
    ${i}
  </button>
`;
}, Cn = "data-te-timepicker-disabled", gs = "data-te-timepicker-active", Ce = (s) => {
  if (s === "")
    return;
  let t, e, i, n;
  return gh(s) ? (t = s.getHours(), n = t, e = s.getMinutes(), t %= 12, n === 0 && t === 0 && (i = "AM"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? "PM" : "AM"), e = e < 10 ? `0${e}` : e) : ([t, e, i] = R(s, !1), n = t, t %= 12, n === 0 && t === 0 && (i = "AM"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? "PM" : "AM")), {
    hours: t,
    minutes: e,
    amOrPm: i
  };
}, gh = (s) => s && Object.prototype.toString.call(s) === "[object Date]" && !Number.isNaN(s), Ka = (s) => {
  if (s === "")
    return;
  let t, e;
  return gh(s) ? (t = s.getHours(), e = s.getMinutes()) : [t, e] = R(s, !1), e = Number(e) < 10 ? `0${Number(e)}` : e, {
    hours: t,
    minutes: e
  };
}, lg = (s, t, e) => c.on(document, s, t, ({ target: i }) => {
  if (i.hasAttribute(gs))
    return;
  document.querySelectorAll(t).forEach((o) => {
    o.hasAttribute(gs) && (h.removeClass(o, e.opacity), o.removeAttribute(gs));
  }), h.addClass(i, e.opacity), i.setAttribute(gs, "");
}), za = ({ clientX: s, clientY: t, touches: e }, i, n = !1) => {
  const { left: o, top: r } = i.getBoundingClientRect();
  let a = {};
  return !n || !e ? a = {
    x: s - o,
    y: t - r
  } : n && Object.keys(e).length > 0 && (a = {
    x: e[0].clientX - o,
    y: e[0].clientY - r
  }), a;
}, bs = () => navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
  navigator.userAgent
), R = (s, t = !0) => t ? s.value.replace(/:/gi, " ").split(" ") : s.replace(/:/gi, " ").split(" "), bh = (s, t) => {
  const [e, i, n] = R(s, !1), [o, r, a] = R(t, !1);
  return n === "PM" && a === "AM" || n === a && e > o || i > r;
}, vh = () => {
  const s = /* @__PURE__ */ new Date(), t = s.getHours(), e = s.getMinutes();
  return `${t}:${e < 10 ? `0${e}` : e}`;
}, Gt = (s, t, e) => {
  if (!t)
    return s;
  let i = vh();
  return e && (i = `${Ce(i).hours}:${Ce(i).minutes} ${Ce(i).amOrPm}`), (s !== "" && bh(i, s) || s === "") && (s = i), s;
}, qt = (s, t, e) => {
  if (!t)
    return s;
  let i = vh();
  return e && (i = `${Ce(i).hours}:${Ce(i).minutes} ${Ce(i).amOrPm}`), (s !== "" && !bh(i, s) || s === "") && (s = i), s;
}, cg = ({ format12: s, maxTime: t, minTime: e, disablePast: i, disableFuture: n }, o, r) => {
  const a = R(o)[1];
  e = Gt(e, i, s), t = qt(t, n, s);
  const [l, p, u] = R(t, !1), [_, f, g] = R(e, !1);
  if (u !== void 0 || g !== void 0)
    return [r, a];
  if (!(l !== "" && _ === "" && Number(r) > Number(l)) && !(l === "" && _ !== "" && p === void 0 && f !== "" && Number(r) < Number(_)))
    return [r, a];
}, Ua = (s, t, e, i) => {
  s.forEach((n) => {
    t = t === "12" && i ? "0" : t, (n.textContent === "00" || Number(n.textContent === "12" && i ? "0" : n.textContent) > t) && (h.addClass(n, e.tipsDisabled), n.setAttribute(Cn, ""));
  });
}, Xa = (s, t, e, i) => {
  s.forEach((n) => {
    t = t === "12" && i ? "0" : t, n.textContent !== "00" && Number(n.textContent === "12" && i ? "0" : n.textContent) < Number(t) && (h.addClass(n, e.tipsDisabled), n.setAttribute(Cn, ""));
  });
}, Th = (s, t, e, i) => {
  if (t === "12" || t === "24")
    return;
  const n = e ? 12 : 24;
  return i === "max" ? (Number(s) === n ? 0 : Number(s)) > Number(t) : (Number(s) === n ? 0 : Number(s)) < Number(t);
}, hg = (s, t, e, i, n, o) => {
  s.forEach((r) => {
    (Th(i, e, o, "max") || Number(r.textContent) > t && Number(i) === Number(e)) && (h.addClass(r, n.tipsDisabled), r.setAttribute(Cn, ""));
  });
}, dg = (s, t, e, i, n, o) => {
  s.forEach((r) => {
    (Th(i, e, o, "min") || Number(r.textContent) < t && Number(i) === Number(e)) && (h.addClass(r, n.tipsDisabled), r.setAttribute(Cn, ""));
  });
}, ug = (s) => s.startsWith("0") ? Number(s.slice(1)) : Number(s), Bi = "timepicker", M = `data-te-${Bi}`, Ga = "[data-te-toggle]", Js = `te.${Bi}`, Pt = `.${Js}`, Bt = ".data-api", qa = `click${Pt}${Bt}`, vs = `keydown${Pt}${Bt}`, Za = `mousedown${Pt}${Bt}`, Qa = `mouseup${Pt}${Bt}`, Ja = `mousemove${Pt}${Bt}`, tl = `mouseleave${Pt}${Bt}`, el = `mouseover${Pt}${Bt}`, il = `touchmove${Pt}${Bt}`, sl = `touchend${Pt}${Bt}`, nl = `touchstart${Pt}${Bt}`, pg = `[${M}-am]`, _g = `[${M}-pm]`, fg = `[${M}-format24]`, Ts = `[${M}-current]`, Es = `[${M}-hour-mode]`, mg = `[${M}-toggle-button]`, oo = `${M}-cancel`, ol = `${M}-clear`, ro = `${M}-submit`, gg = `${M}-icon`, ao = `${M}-icon-up`, lo = `${M}-icon-down`, bg = `${M}-icon-inline-hour`, vg = `${M}-icon-inline-minute`, rl = `${M}-inline-hour-icons`, Tg = `${M}-current-inline`, Eg = "readonly", Cg = `${M}-invalid-feedback`, co = `${M}-is-invalid`, jt = `${M}-disabled`, H = `${M}-active`, Ag = `${M}-input`, ue = `${M}-clock`, mi = `${M}-clock-inner`, ho = `${M}-wrapper`, al = `${M}-clock-wrapper`, Cs = `${M}-hour`, uo = `${M}-minute`, As = `${M}-tips-element`, X = `${M}-tips-hours`, q = `${M}-tips-minutes`, ht = `${M}-tips-inner`, ys = `${M}-tips-inner-element`, ll = `${M}-middle-dot`, po = `${M}-hand-pointer`, _o = `${M}-circle`, cl = `${M}-modal`, yg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>`, wg = {
  appendValidationInfo: !0,
  bodyID: "",
  cancelLabel: "Cancel",
  clearLabel: "Clear",
  closeModalOnBackdropClick: !0,
  closeModalOnMinutesClick: !1,
  container: "body",
  defaultTime: "",
  disabled: !1,
  disablePast: !1,
  disableFuture: !1,
  enableValidation: !0,
  focusInputAfterApprove: !1,
  footerID: "",
  format12: !0,
  format24: !1,
  headID: "",
  increment: !1,
  inline: !1,
  invalidLabel: "Invalid Time Format",
  maxTime: "",
  minTime: "",
  modalID: "",
  okLabel: "Ok",
  overflowHidden: !0,
  pickerID: "",
  readOnly: !1,
  showClearBtn: !0,
  switchHoursToMinutesOnClick: !0,
  iconSVG: yg,
  withIcon: !0,
  pmLabel: "PM",
  amLabel: "AM",
  animations: !0
}, kg = {
  appendValidationInfo: "boolean",
  bodyID: "string",
  cancelLabel: "string",
  clearLabel: "string",
  closeModalOnBackdropClick: "boolean",
  closeModalOnMinutesClick: "boolean",
  container: "string",
  disabled: "boolean",
  disablePast: "boolean",
  disableFuture: "boolean",
  enableValidation: "boolean",
  footerID: "string",
  format12: "boolean",
  format24: "boolean",
  headID: "string",
  increment: "boolean",
  inline: "boolean",
  invalidLabel: "string",
  modalID: "string",
  okLabel: "string",
  overflowHidden: "boolean",
  pickerID: "string",
  readOnly: "boolean",
  showClearBtn: "boolean",
  switchHoursToMinutesOnClick: "boolean",
  defaultTime: "(string|date|number)",
  iconSVG: "string",
  withIcon: "boolean",
  pmLabel: "string",
  amLabel: "string",
  animations: "boolean"
}, xg = {
  tips: "absolute rounded-[100%] w-[32px] h-[32px] text-center cursor-pointer text-[1.1rem] rounded-[100%] bg-transparent flex justify-center items-center font-light focus:outline-none selection:bg-transparent",
  tipsActive: "text-white bg-[#3b71ca] font-normal",
  tipsDisabled: "text-[#b3afaf] pointer-events-none bg-transparent",
  transform: "transition-[transform,height] ease-in-out duration-[400ms]",
  modal: "z-[1065]",
  clockAnimation: "animate-[show-up-clock_350ms_linear]",
  opacity: "!opacity-100",
  timepickerWrapper: "touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col fixed",
  timepickerContainer: "flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)] min-[320px]:max-[825px]:landscape:rounded-lg",
  timepickerElements: "flex flex-col min-w-[310px] min-h-[325px] bg-white rounded-t-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape:min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around",
  timepickerHead: "bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg pr-[24px] pl-[50px] py-[10px] min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center",
  timepickerHeadContent: "min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly",
  timepickerCurrentWrapper: "[direction:ltr] rtl:[direction:rtl]",
  timepickerCurrentButtonWrapper: "relative h-full",
  timepickerCurrentButton: "text-[3.75rem] font-light leading-[1.2] tracking-[-0.00833em] text-white opacity-[.54] border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none ",
  timepickerDot: "font-light leading-[1.2] tracking-[-0.00833em] text-[3.75rem] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal",
  timepickerModeWrapper: "flex flex-col justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row",
  timepickerModeAm: "p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none",
  timepickerModePm: "p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none",
  timepickerClockWrapper: "min-w-[310px] max-w-[325px] min-h-[305px] overflow-x-hidden h-full flex justify-center flex-col items-center dark:bg-zinc-500",
  timepickerClock: "relative rounded-[100%] w-[260px] h-[260px] cursor-default my-0 mx-auto bg-[#00000012] dark:bg-zinc-600/50",
  timepickerMiddleDot: "top-1/2 left-1/2 w-[6px] h-[6px] -translate-y-1/2 -translate-x-1/2 rounded-[50%] bg-[#3b71ca] absolute",
  timepickerHandPointer: "bg-[#3b71ca] bottom-1/2 h-2/5 left-[calc(50%-1px)] rtl:!left-auto origin-[center_bottom_0] rtl:!origin-[50%_50%_0] w-[2px] absolute",
  timepickerPointerCircle: "-top-[21px] -left-[15px] w-[4px] border-[14px] border-solid border-[#3b71ca] h-[4px] box-content rounded-[100%] absolute",
  timepickerClockInner: "absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2 w-[160px] h-[160px] rounded-[100%]",
  timepickerFooterWrapper: "rounded-b-lg flex justify-between items-center w-full h-[56px] px-[12px] bg-white dark:bg-zinc-500",
  timepickerFooter: "w-full flex justify-between",
  timepickerFooterButton: "text-[0.8rem] min-w-[64px] box-border font-medium leading-[40px] rounded-[10px] tracking-[0.1rem] uppercase text-[#3b71ca] dark:text-white border-none bg-transparent transition-[background-color,box-shadow,border] duration-[250ms] ease-[cubic-bezier(0.4,0,0.2,1)] delay-[0ms] outline-none py-0 px-[10px] h-[40px] mb-[10px] hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none",
  timepickerInlineWrapper: "touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col rounded-lg",
  timepickerInlineContainer: "flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)]",
  timepickerInlineElements: "flex flex-col min-h-[auto] min-w-[310px] bg-white rounded-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:rounded-bl-lg min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape::min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around",
  timepickerInlineHead: "bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center p-0 rounded-b-lg",
  timepickerInlineHeadContent: "min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly items-center",
  timepickerInlineHourWrapper: "relative h-full !opacity-100",
  timepickerCurrentMinuteWrapper: "relative h-full",
  timepickerInlineIconUp: "absolute text-white -top-[35px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center",
  timepickerInlineIconSvg: "h-4 w-4",
  timepickerInlineCurrentButton: "font-light leading-[1.2] tracking-[-0.00833em] text-white border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal !opacity-100 cursor-pointer focus:bg-[#00000026] hover:outline-none focus:outline-none text-[2.5rem] hover:bg-[unset]",
  timepickerInlineIconDown: "absolute text-white -bottom-[47px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center",
  timepickerInlineDot: "font-light leading-[1.2] tracking-[-0.00833em] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal text-[2.5rem]",
  timepickerInlineModeWrapper: "flex justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row",
  timepickerInlineModeAm: "hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer mr-2 ml-6",
  timepickerInlineModePm: "hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer",
  timepickerInlineSubmitButton: "hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none text-[0.8rem] box-border font-medium leading-[40px] tracking-[.1rem] uppercase border-none bg-transparent [transition:background-color_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,box-shadow_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,border_250ms_cubic-bezier(0.4,0,0.2,1)_0ms] outline-none rounded-[100%] h-[48px] min-w-[48px] inline-block ml-[30px] text-white py-1 px-2 mb-0",
  timepickerToggleButton: "h-4 w-4 ml-auto absolute outline-none border-none bg-transparent right-1.5 top-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)] cursor-pointer hover:text-[#3b71ca] focus:text-[#3b71ca] dark:hover:text-[#3b71ca] dark:focus:text-[#3b71ca] dark:text-white"
}, Og = {
  tips: "string",
  tipsActive: "string",
  tipsDisabled: "string",
  transform: "string",
  modal: "string",
  clockAnimation: "string",
  opacity: "string",
  timepickerWrapper: "string",
  timepickerContainer: "string",
  timepickerElements: "string",
  timepickerHead: "string",
  timepickerHeadContent: "string",
  timepickerCurrentWrapper: "string",
  timepickerCurrentButtonWrapper: "string",
  timepickerCurrentButton: "string",
  timepickerDot: "string",
  timepickerModeWrapper: "string",
  timepickerModeAm: "string",
  timepickerModePm: "string",
  timepickerClockWrapper: "string",
  timepickerClock: "string",
  timepickerMiddleDot: "string",
  timepickerHandPointer: "string",
  timepickerPointerCircle: "string",
  timepickerClockInner: "string",
  timepickerFooterWrapper: "string",
  timepickerFooterButton: "string",
  timepickerInlineWrapper: "string",
  timepickerInlineContainer: "string",
  timepickerInlineElements: "string",
  timepickerInlineHead: "string",
  timepickerInlineHeadContent: "string",
  timepickerInlineHourWrapper: "string",
  timepickerCurrentMinuteWrapper: "string",
  timepickerInlineIconUp: "string",
  timepickerInlineIconSvg: "string",
  timepickerInlineCurrentButton: "string",
  timepickerInlineIconDown: "string",
  timepickerInlineDot: "string",
  timepickerInlineModeWrapper: "string",
  timepickerInlineModeAm: "string",
  timepickerInlineModePm: "string",
  timepickerInlineSubmitButton: "string",
  timepickerToggleButton: "string"
};
class Sg {
  constructor(t, e = {}, i) {
    wt(this, "_toggleAmPm", (t) => {
      t === "PM" ? (this._isPmEnabled = !0, this._isAmEnabled = !1) : t === "AM" && (this._isPmEnabled = !1, this._isAmEnabled = !0);
    });
    wt(this, "_toggleBackgroundColorCircle", (t) => {
      if (this._modal.querySelector(`${t}[${H}]`) !== null) {
        h.addStyle(this._circle, {
          backgroundColor: "#1976d2"
        });
        return;
      }
      h.addStyle(this._circle, {
        backgroundColor: "transparent"
      });
    });
    wt(this, "_toggleClassActive", (t, { textContent: e }, i) => {
      const n = [...t].find(
        (o) => Number(o) === Number(e)
      );
      return i.forEach((o) => {
        if (!o.hasAttribute(jt)) {
          if (o.textContent === n) {
            h.addClass(o, this._classes.tipsActive), o.setAttribute(H, "");
            return;
          }
          h.removeClass(o, this._classes.tipsActive), o.removeAttribute(H);
        }
      });
    });
    wt(this, "_makeMinutesDegrees", (t, e) => {
      const { increment: i } = this._options;
      return t < 0 ? (e = Math.round(360 + t / 6) % 60, t = 360 + Math.round(t / 6) * 6) : (e = Math.round(t / 6) % 60, t = Math.round(t / 6) * 6), i && (t = Math.round(t / 30) * 30, e = Math.round(t / 6) * 6 / 6, e === 60 && (e = "00")), t >= 360 && (t = 0), {
        degrees: t,
        minute: e,
        addDegrees: i ? 30 : 6
      };
    });
    wt(this, "_makeHourDegrees", (t, e, i) => {
      if (t)
        return this._hasTargetInnerClass(t) ? e < 0 ? (i = Math.round(360 + e / 30) % 24, e = 360 + e) : (i = Math.round(e / 30) + 12, i === 12 && (i = "00")) : e < 0 ? (i = Math.round(360 + e / 30) % 12, e = 360 + e) : (i = Math.round(e / 30) % 12, (i === 0 || i > 12) && (i = 12)), e >= 360 && (e = 0), {
          degrees: e,
          hour: i,
          addDegrees: 30
        };
    });
    wt(this, "_makeInnerHoursDegrees", (t, e) => (t < 0 ? (e = Math.round(360 + t / 30) % 24, t = 360 + t) : (e = Math.round(t / 30) + 12, e === 12 && (e = "00")), {
      degrees: t,
      hour: e,
      addDegrees: 30
    }));
    wt(this, "_getAppendClock", (t = [], e = `[${ue}]`, i) => {
      let { minTime: n, maxTime: o } = this._options;
      const { inline: r, format12: a, disablePast: l, disableFuture: p } = this._options;
      n = Gt(n, l, a), o = qt(o, p, a);
      const [u, _, f] = R(
        o,
        !1
      ), [g, m, b] = R(
        n,
        !1
      );
      !r && a && this._isInvalidTimeFormat && !this._AM.hasAttribute(H) && (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, ""));
      const v = d.findOne(e), T = 360 / t.length;
      function y(k) {
        return k * (Math.PI / 180);
      }
      if (v === null)
        return;
      const C = (v.offsetWidth - 32) / 2, E = (v.offsetHeight - 32) / 2, w = C - 4;
      setTimeout(() => {
        let k;
        a && (k = d.findOne(
          `${Es}[${H}]`
        ).textContent), this._handleDisablingTipsMinTime(
          k,
          b,
          m,
          g
        ), this._handleDisablingTipsMaxTime(
          k,
          f,
          _,
          u
        );
      }, 0), [...t].forEach((k, D) => {
        const O = y(D * T), x = $("span"), L = $("span");
        L.innerHTML = k, h.addClass(x, this._classes.tips), x.setAttribute(i, "");
        const S = x.offsetWidth, N = x.offsetHeight;
        return h.addStyle(x, {
          left: `${C + Math.sin(O) * w - S}px`,
          bottom: `${E + Math.cos(O) * w - N}px`
        }), t.includes("05") && x.setAttribute(q, ""), t.includes("13") ? L.setAttribute(ys, "") : L.setAttribute(As, ""), x.appendChild(L), v.appendChild(x);
      });
    });
    this._element = t, this._element && A.setData(t, Js, this), this._document = document, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._currentTime = null, this._toggleButtonId = et("timepicker-toggle-"), this.hoursArray = [
      "12",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "10",
      "11"
    ], this.innerHours = [
      "00",
      "13",
      "14",
      "15",
      "16",
      "17",
      "18",
      "19",
      "20",
      "21",
      "22",
      "23"
    ], this.minutesArray = [
      "00",
      "05",
      "10",
      "15",
      "20",
      "25",
      "30",
      "35",
      "40",
      "45",
      "50",
      "55"
    ], this.input = d.findOne("input", this._element), this.dataWithIcon = t.dataset.withIcon, this.dataToggle = t.dataset.toggle, this.customIcon = d.findOne(
      mg,
      this._element
    ), this._checkToggleButton(), this.inputFormatShow = d.findOne(
      fg,
      this._element
    ), this.inputFormat = this.inputFormatShow === null ? "" : Object.values(this.inputFormatShow.dataset)[0], this.elementToggle = d.findOne(
      Ga,
      this._element
    ), this.toggleElement = Object.values(
      t.querySelector(Ga).dataset
    )[0], this._hour = null, this._minutes = null, this._AM = null, this._PM = null, this._wrapper = null, this._modal = null, this._hand = null, this._circle = null, this._focusTrap = null, this._popper = null, this._interval = null, this._timeoutInterval = null, this._inputValue = this._options.defaultTime !== "" ? this._options.defaultTime : this.input.value, this._options.format24 && (this._options.format12 = !1, this._currentTime = Ka(this._inputValue)), this._options.format12 && (this._options.format24 = !1, this._currentTime = Ce(this._inputValue)), this._options.readOnly && this.input.setAttribute(Eg, !0), this.inputFormat === "true" && this.inputFormat !== "" && (this._options.format12 = !1, this._options.format24 = !0, this._currentTime = Ka(this._inputValue)), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this.init(), this._isHours = !0, this._isMinutes = !1, this._isInvalidTimeFormat = !1, this._isMouseMove = !1, this._isInner = !1, this._isAmEnabled = !1, this._isPmEnabled = !1, this._options.format12 && !this._options.defaultTime && (this._isPmEnabled = !0), this._objWithDataOnChange = { degrees: null }, this._scrollBar = new ti();
  }
  // Getters
  static get NAME() {
    return Bi;
  }
  // Public
  init() {
    const { format12: t, format24: e, enableValidation: i } = this._options;
    let n, o, r;
    if (this.input.setAttribute(Ag, ""), this._currentTime !== void 0) {
      const { hours: a, minutes: l, amOrPm: p } = this._currentTime;
      n = Number(a) < 10 ? 0 : "", o = `${n}${Number(a)}:${l}`, r = p, t ? this.input.value = `${o} ${r}` : e && (this.input.value = `${o}`);
    } else
      n = "", o = "", r = "", this.input.value = "";
    this.input.value.length > 0 && this.input.value !== "" && (this.input.setAttribute(H, ""), c.trigger(this.input, "input")), !(this._options === null && this._element === null) && (i && this._getValidate("keydown change blur focus"), this._handleOpen(), this._listenToToggleKeydown());
  }
  dispose() {
    this._removeModal(), this._element !== null && A.removeData(this._element, Js), setTimeout(() => {
      this._element = null, this._options = null, this.input = null, this._focusTrap = null;
    }, 350), c.off(
      this._element,
      "click",
      `[data-te-toggle='${this.toggleElement}']`
    ), c.off(
      this._element,
      "keydown",
      `[data-te-toggle='${this.toggleElement}']`
    );
  }
  update(t = {}) {
    this._options = this._getConfig({ ...this._options, ...t });
  }
  // private
  _checkToggleButton() {
    this.customIcon === null && (this.dataWithIcon !== void 0 && (this._options.withIcon = null, this.dataWithIcon === "true" && this._appendToggleButton(this._options)), this._options.withIcon && this._appendToggleButton(this._options));
  }
  _appendToggleButton() {
    const t = ag(
      this._options,
      this._toggleButtonId,
      this._classes
    );
    this.input.insertAdjacentHTML("afterend", t);
  }
  _getDomElements() {
    this._hour = d.findOne(`[${Cs}]`), this._minutes = d.findOne(`[${uo}]`), this._AM = d.findOne(pg), this._PM = d.findOne(_g), this._wrapper = d.findOne(`[${ho}]`), this._modal = d.findOne(`[${cl}]`), this._hand = d.findOne(`[${po}]`), this._circle = d.findOne(`[${_o}]`), this._clock = d.findOne(`[${ue}]`), this._clockInner = d.findOne(
      `[${mi}]`
    );
  }
  _handlerMaxMinHoursOptions(t, e, i, n, o, r) {
    if (!e && !i)
      return !0;
    const { format24: a, format12: l, disablePast: p, disableFuture: u } = this._options, { _isAmEnabled: _, _isPmEnabled: f } = this, g = r.keyCode, m = r.target.hasAttribute(mi) || r.target.hasAttribute(ht) || r.target.hasAttribute(ys);
    i = Gt(i, p, l), e = qt(e, u, l), typeof e != "number" && (e = R(e, !1)[0]);
    const b = e !== "" ? e * 30 : "", v = i !== "" ? i * 30 : "";
    t < 0 && (t = 360 + t), t = t === 360 ? 0 : t;
    const T = () => {
      const D = document.querySelectorAll(
        `[${As}]`
      ), O = document.querySelectorAll(
        `[${ys}]`
      ), x = ug(this._hour.innerText);
      let L, S, N;
      return g === U ? S = 1 : g === z && (S = -1), x === 12 && g === U ? N = 1 : x === 0 && g === U ? N = 13 : x === 0 && g === z ? N = 23 : x === 13 && g === z ? N = 0 : x === 1 && g === z ? N = 12 : N = x + S, D.forEach((P) => {
        Number(P.textContent) === N && (L = P);
      }), O.forEach((P) => {
        Number(P.textContent) === N && (L = P);
      }), !L.parentElement.hasAttribute(jt);
    }, y = () => {
      const D = i !== "" && i > 12 ? (i - 12) * 30 : "", O = e !== "" && e > 12 ? (e - 12) * 30 : "";
      if (!(D && t < D || O && t > O || e && e < 12))
        return !0;
    };
    if (a && r.type !== "keydown" && m)
      return y();
    if (r.type === "keydown")
      return T();
    const C = !o || o === "PM" && f || i !== "" && o === "AM" && _, E = !n || n === "PM" && f || e !== "" && n === "AM" && _, w = () => {
      const D = v === 360 && l ? 0 : v;
      if (i) {
        if (o === "PM" && _ || C && t < D)
          return;
      } else
        return !0;
      return !0;
    }, k = () => {
      const D = b === 360 && l ? 0 : b;
      if (e) {
        if (n === "AM" && f || E && t > D)
          return;
      } else
        return !0;
      return !0;
    };
    return w() && k();
  }
  _handleKeyboard() {
    c.on(this._document, vs, "", (t) => {
      let e, i, n;
      const {
        increment: o,
        maxTime: r,
        minTime: a,
        format12: l,
        disablePast: p,
        disableFuture: u
      } = this._options;
      let _ = R(a, !1)[0], f = R(r, !1)[0];
      const g = R(a, !1)[2], m = R(r, !1)[2];
      _ = Gt(_, p, l), f = qt(f, u, l), typeof f != "number" && (f = R(f, !1)[0]);
      const b = d.findOne(`[${q}]`) === null, v = d.findOne(`[${ht}]`) !== null, T = Number(this._hand.style.transform.replace(/[^\d-]/g, "")), y = d.find(
        `[${q}]`,
        this._modal
      ), C = d.find(
        `[${X}]`,
        this._modal
      ), E = d.find(
        `[${ht}]`,
        this._modal
      );
      let w = this._makeHourDegrees(t.target, T, e).hour;
      const { degrees: k, addDegrees: D } = this._makeHourDegrees(
        t.target,
        T,
        e
      );
      let { minute: O, degrees: x } = this._makeMinutesDegrees(T, i);
      const L = this._makeMinutesDegrees(
        T,
        i
      ).addDegrees;
      let { hour: S } = this._makeInnerHoursDegrees(
        T,
        n
      );
      if (t.keyCode === we) {
        const N = d.findOne(
          `[${oo}]`,
          this._modal
        );
        c.trigger(N, "click");
      } else if (b) {
        if (v && (t.keyCode === ze && (this._isInner = !1, h.addStyle(this._hand, {
          height: "calc(40% + 1px)"
        }), this._hour.textContent = this._setHourOrMinute(
          w > 12 ? 1 : w
        ), this._toggleClassActive(this.hoursArray, this._hour, C), this._toggleClassActive(this.innerHours, this._hour, E)), t.keyCode === Ke && (this._isInner = !0, h.addStyle(this._hand, {
          height: "21.5%"
        }), this._hour.textContent = this._setHourOrMinute(
          S >= 24 || S === "00" ? 0 : S
        ), this._toggleClassActive(this.innerHours, this._hour, E), this._toggleClassActive(
          this.hoursArray,
          this._hour - 1,
          C
        ))), t.keyCode === U) {
          if (!this._handlerMaxMinHoursOptions(
            k + 30,
            f,
            _,
            m,
            g,
            t
          ))
            return;
          h.addStyle(this._hand, {
            transform: `rotateZ(${k + D}deg)`
          }), this._isInner ? (S += 1, S === 24 ? S = 0 : (S === 25 || S === "001") && (S = 13), this._hour.textContent = this._setHourOrMinute(S), this._toggleClassActive(this.innerHours, this._hour, E)) : (w += 1, this._hour.textContent = this._setHourOrMinute(
            w > 12 ? 1 : w
          ), this._toggleClassActive(this.hoursArray, this._hour, C));
        }
        if (t.keyCode === z) {
          if (!this._handlerMaxMinHoursOptions(
            k - 30,
            f,
            _,
            m,
            g,
            t
          ))
            return;
          h.addStyle(this._hand, {
            transform: `rotateZ(${k - D}deg)`
          }), this._isInner ? (S -= 1, S === 12 ? S = 0 : S === -1 && (S = 23), this._hour.textContent = this._setHourOrMinute(S), this._toggleClassActive(this.innerHours, this._hour, E)) : (w -= 1, this._hour.textContent = this._setHourOrMinute(
            w === 0 ? 12 : w
          ), this._toggleClassActive(this.hoursArray, this._hour, C));
        }
      } else
        t.keyCode === U && (x += L, h.addStyle(this._hand, {
          transform: `rotateZ(${x}deg)`
        }), O += 1, o && (O += 4, O === "0014" && (O = 5)), this._minutes.textContent = this._setHourOrMinute(
          O > 59 ? 0 : O
        ), this._toggleClassActive(
          this.minutesArray,
          this._minutes,
          y
        ), this._toggleBackgroundColorCircle(
          `[${q}]`
        )), t.keyCode === z && (x -= L, h.addStyle(this._hand, {
          transform: `rotateZ(${x}deg)`
        }), o ? O -= 5 : O -= 1, O === -1 ? O = 59 : O === -5 && (O = 55), this._minutes.textContent = this._setHourOrMinute(O), this._toggleClassActive(
          this.minutesArray,
          this._minutes,
          y
        ), this._toggleBackgroundColorCircle(
          `[${q}]`
        ));
    });
  }
  _setActiveClassToTipsOnOpen(t, ...e) {
    if (!this._isInvalidTimeFormat)
      if (this._options.format24) {
        const i = d.find(
          `[${X}]`,
          this._modal
        ), n = d.find(
          `[${ht}]`,
          this._modal
        );
        this._addActiveClassToTip(i, t), this._addActiveClassToTip(n, t);
      } else {
        [...e].filter((n) => (n.toLowerCase() === "pm" ? (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, "")) : n.toLowerCase() === "am" ? (h.addClass(this._AM, this._classes.opacity), this._AM.setAttribute(H, "")) : (h.removeClass(this._AM, this._classes.opacity), h.removeClass(this._PM, this._classes.opacity), this._AM.removeAttribute(H), this._PM.removeAttribute(H)), n));
        const i = d.find(
          `[${X}]`,
          this._modal
        );
        this._addActiveClassToTip(i, t);
      }
  }
  _setTipsAndTimesDependOnInputValue(t, e) {
    const { inline: i, format12: n } = this._options;
    if (this._isInvalidTimeFormat)
      this._hour.textContent = "12", this._minutes.textContent = "00", i || h.addStyle(this._hand, {
        transform: "rotateZ(0deg)"
      }), n && (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, ""));
    else {
      const o = t > 12 ? t * 30 - 360 : t * 30;
      this._hour.textContent = t, this._minutes.textContent = e, i || (h.addStyle(this._hand, {
        transform: `rotateZ(${o}deg)`
      }), h.addStyle(this._circle, {
        backgroundColor: "#1976d2"
      }), (Number(t) > 12 || t === "00") && h.addStyle(this._hand, {
        height: "21.5%"
      }));
    }
  }
  _listenToToggleKeydown() {
    c.on(
      this._element,
      "keydown",
      `[data-te-toggle='${this.toggleElement}']`,
      (t) => {
        t.keyCode === it && (t.preventDefault(), c.trigger(this.elementToggle, "click"));
      }
    );
  }
  _handleOpen() {
    const t = this._getContainer();
    K.on(
      this._element,
      "click",
      `[data-te-toggle='${this.toggleElement}']`,
      (e) => {
        if (this._options === null)
          return;
        const i = h.getDataAttribute(this.input, "toggle") !== null ? 200 : 0;
        setTimeout(() => {
          h.addStyle(this.elementToggle, {
            pointerEvents: "none"
          }), this.elementToggle.blur();
          let n;
          R(this.input)[0] === "" ? n = ["12", "00", "PM"] : n = R(this.input);
          const { modalID: o, inline: r, format12: a } = this._options, [l, p, u] = n, _ = $("div");
          if ((Number(l) > 12 || l === "00") && (this._isInner = !0), this.input.blur(), e.target.blur(), _.innerHTML = rg(this._options, this._classes), h.addClass(_, this._classes.modal), _.setAttribute(cl, ""), _.setAttribute("role", "dialog"), _.setAttribute("tabIndex", "-1"), _.setAttribute("id", o), r ? (this._popper = se(this.input, _, {
            placement: "bottom-start"
          }), t.appendChild(_)) : (t.appendChild(_), this._scrollBar.hide()), this._getDomElements(), this._animations ? this._toggleBackdropAnimation() : h.addClass(this._wrapper, this._classes.opacity), this._setActiveClassToTipsOnOpen(l, p, u), this._appendTimes(), this._setActiveClassToTipsOnOpen(l, p, u), this._setTipsAndTimesDependOnInputValue(l, p), this.input.value === "") {
            const f = d.find(
              `[${X}]`,
              this._modal
            );
            a && (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, "")), this._hour.textContent = "12", this._minutes.textContent = "00", this._addActiveClassToTip(
              f,
              Number(this._hour.textContent)
            );
          }
          if (this._handleSwitchTimeMode(), this._handleOkButton(), this._handleClose(), r)
            this._handleHoverInlineBtn(), this._handleDocumentClickInline(), this._handleInlineClicks();
          else {
            this._handleSwitchHourMinute(), this._handleClockClick(), this._handleKeyboard();
            const f = document.querySelector(
              `${Ts}[${H}]`
            );
            h.addClass(f, this._classes.opacity), h.addStyle(this._hour, {
              pointerEvents: "none"
            }), h.addStyle(this._minutes, {
              pointerEvents: ""
            });
          }
          this._focusTrap = new zi(this._wrapper, {
            event: "keydown",
            condition: ({ key: f }) => f === "Tab"
          }), this._focusTrap.trap();
        }, i);
      }
    );
  }
  _handleInlineClicks() {
    let t, e;
    const i = (g) => {
      let m = g;
      return m > 59 ? m = 0 : m < 0 && (m = 59), m;
    }, n = (g) => {
      let m = g;
      return this._options.format24 ? (m > 24 ? m = 1 : m < 0 && (m = 23), m > 23 && (m = 0)) : (m > 12 ? m = 1 : m < 1 && (m = 12), m > 12 && (m = 1)), m;
    }, o = (g) => {
      const m = n(g);
      this._hour.textContent = this._setHourOrMinute(m);
    }, r = (g) => {
      const m = i(g);
      this._minutes.textContent = this._setHourOrMinute(m);
    }, a = () => {
      t = n(t) + 1, o(t);
    }, l = () => {
      e = i(e) + 1, r(e);
    }, p = () => {
      t = n(t) - 1, o(t);
    }, u = () => {
      e = i(e) - 1, r(e);
    }, _ = () => {
      clearInterval(this._interval), clearTimeout(this._timeoutInterval);
    }, f = (g) => {
      _(), this._timeoutInterval = setTimeout(() => {
        this._interval = setInterval(g, 100);
      }, 500);
    };
    K.on(
      this._modal,
      "click mousedown mouseup touchstart touchend contextmenu",
      `[${ao}], [${lo}]`,
      (g) => {
        t = Number(this._hour.textContent), e = Number(this._minutes.textContent);
        const { target: m, type: b } = g, v = b === "mousedown" || b === "touchstart";
        m.closest(`[${ao}]`) ? m.closest(`[${ao}]`).parentNode.hasAttribute(rl) ? v ? f(a) : b === "mouseup" || b === "touchend" || b === "contextmenu" ? _() : a() : v ? f(l) : b === "mouseup" || b === "touchend" || b === "contextmenu" ? _() : l() : m.closest(`[${lo}]`) && (m.closest(`[${lo}]`).parentNode.hasAttribute(rl) ? v ? f(p) : b === "mouseup" || b === "touchend" ? _() : p() : v ? f(u) : b === "mouseup" || b === "touchend" ? _() : u());
      }
    ), c.on(window, vs, (g) => {
      const m = g.code, b = document.activeElement.hasAttribute(Cs), v = document.activeElement.hasAttribute(
        uo
      ), T = document.activeElement === document.body;
      switch (t = Number(this._hour.textContent), e = Number(this._minutes.textContent), m) {
        case "ArrowUp":
          g.preventDefault(), T || b ? (this._hour.focus(), a()) : v && l();
          break;
        case "ArrowDown":
          g.preventDefault(), T || b ? (this._hour.focus(), p()) : v && u();
          break;
      }
    });
  }
  _handleClose() {
    c.on(
      this._modal,
      "click",
      `[${ho}], [${oo}], [${ol}]`,
      ({ target: t }) => {
        const { closeModalOnBackdropClick: e } = this._options, i = () => {
          var n;
          h.addStyle(this.elementToggle, {
            pointerEvents: "auto"
          }), this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), (n = this._focusTrap) == null || n.disable(), this._focusTrap = null, this.elementToggle ? this.elementToggle.focus() : this.input && this.input.focus();
        };
        if (t.hasAttribute(ol)) {
          this._toggleAmPm("PM"), this.input.value = "", this.input.removeAttribute(H);
          let n;
          R(this.input)[0] === "" ? n = ["12", "00", "PM"] : n = R(this.input);
          const [o, r, a] = n;
          this._setTipsAndTimesDependOnInputValue("12", "00"), this._setActiveClassToTipsOnOpen(o, r, a), this._hour.click();
        } else
          (t.hasAttribute(oo) || t.hasAttribute(ro) || t.hasAttribute(ho) && e) && i();
      }
    );
  }
  showValueInput() {
    return this.input.value;
  }
  _handleOkButton() {
    K.on(
      this._modal,
      "click",
      `[${ro}]`,
      () => {
        let { maxTime: t, minTime: e } = this._options;
        const {
          format12: i,
          format24: n,
          readOnly: o,
          focusInputAfterApprove: r,
          disablePast: a,
          disableFuture: l
        } = this._options, p = this._document.querySelector(
          `${Es}[${H}]`
        ), u = `${this._hour.textContent}:${this._minutes.textContent}`, _ = Number(this._hour.textContent), f = _ === 12 && i ? 0 : _, g = Number(this._minutes.textContent);
        e = Gt(e, a, i), t = qt(t, l, i);
        let [m, b, v] = R(
          t,
          !1
        ), [T, y, C] = R(
          e,
          !1
        );
        T = T === "12" && i ? "00" : T, m = m === "12" && i ? "00" : m;
        const E = f < Number(T), w = f > Number(m);
        let k = !0;
        p && (k = v === p.textContent);
        let D = !0;
        p && (D = C === p.textContent);
        const O = g > b && f === Number(m), x = g < y && f === Number(T);
        if (this.input.setAttribute(H, ""), h.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), t !== "") {
          if (k && (w || O))
            return;
          if (v === "AM" && p.textContent === "PM")
            return;
        }
        e !== "" && (D && (E || x) || C === "PM" && p.textContent === "AM") || cg(
          this._options,
          this.input,
          this._hour.textContent
        ) !== void 0 && (this._isInvalidTimeFormat && this.input.removeAttribute(co), !o && r && this.input.focus(), h.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), n ? this.input.value = u : p === null ? this.input.value = `${u} PM` : this.input.value = `${u} ${p.textContent}`, this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), c.trigger(this.input, "input.te.timepicker"), c.trigger(this.input, "input"));
      }
    );
  }
  _handleHoverInlineBtn() {
    K.on(
      this._modal,
      "mouseover mouseleave",
      `[${Tg}]`,
      ({ type: t, target: e }) => {
        const i = d.find(
          `[${bg}]`,
          this._modal
        ), n = d.find(
          `[${vg}]`,
          this._modal
        ), o = (l, p) => l.forEach((u) => {
          if (p) {
            h.addClass(u, this._classes.opacity), u.setAttribute(H, "");
            return;
          }
          h.removeClass(u, this._classes.opacity), u.removeAttribute(H);
        }), a = e.hasAttribute(Cs) ? i : n;
        o(a, t === "mouseover");
      }
    );
  }
  _handleDocumentClickInline() {
    c.on(document, qa, ({ target: t }) => {
      if (this._modal && !this._modal.contains(t) && !t.hasAttribute(gg)) {
        if (clearInterval(this._interval), h.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), this._removeModal(), !this._animations)
          return;
        this._toggleBackdropAnimation(!0);
      }
    });
  }
  _handleSwitchHourMinute() {
    lg(
      "click",
      Ts,
      this._classes
    ), c.on(
      this._modal,
      "click",
      Ts,
      () => {
        const { format24: t } = this._options, e = d.find(
          Ts,
          this._modal
        ), i = d.find(
          `[${q}]`,
          this._modal
        ), n = d.find(
          `[${X}]`,
          this._modal
        ), o = d.find(
          `[${ht}]`,
          this._modal
        ), r = Number(this._hour.textContent), a = Number(this._minutes.textContent), l = (p, u) => {
          n.forEach((f) => f.remove()), i.forEach((f) => f.remove()), h.addClass(this._hand, this._classes.transform), setTimeout(() => {
            h.removeClass(this._hand, this._classes.transform);
          }, 401), this._getAppendClock(p, `[${ue}]`, u);
          const _ = () => {
            const f = d.find(
              `[${X}]`,
              this._modal
            ), g = d.find(
              `[${q}]`,
              this._modal
            );
            this._addActiveClassToTip(f, r), this._addActiveClassToTip(g, a);
          };
          if (!t)
            setTimeout(() => {
              _();
            }, 401);
          else {
            const f = d.find(
              `[${ht}]`,
              this._modal
            );
            setTimeout(() => {
              this._addActiveClassToTip(f, r), _();
            }, 401);
          }
        };
        e.forEach((p) => {
          p.hasAttribute(H) && (p.hasAttribute(uo) ? (h.addClass(this._hand, this._classes.transform), h.addStyle(this._hand, {
            transform: `rotateZ(${this._minutes.textContent * 6}deg)`,
            height: "calc(40% + 1px)"
          }), t && o.length > 0 && o.forEach((u) => u.remove()), l(
            this.minutesArray,
            q
          ), this._hour.style.pointerEvents = "", this._minutes.style.pointerEvents = "none") : p.hasAttribute(Cs) && (h.addStyle(this._hand, {
            transform: `rotateZ(${this._hour.textContent * 30}deg)`
          }), Number(this._hour.textContent) > 12 ? (h.addStyle(this._hand, {
            transform: `rotateZ(${this._hour.textContent * 30 - 360}deg)`,
            height: "21.5%"
          }), Number(this._hour.textContent) > 12 && h.addStyle(this._hand, {
            height: "21.5%"
          })) : h.addStyle(this._hand, {
            height: "calc(40% + 1px)"
          }), t && this._getAppendClock(
            this.innerHours,
            `[${mi}]`,
            ht
          ), o.length > 0 && o.forEach((u) => u.remove()), l(
            this.hoursArray,
            X
          ), h.addStyle(this._hour, {
            pointerEvents: "none"
          }), h.addStyle(this._minutes, {
            pointerEvents: ""
          })));
        });
      }
    );
  }
  _handleDisablingTipsMaxTime(t, e, i, n) {
    if (!this._options.maxTime && !this._options.disableFuture)
      return;
    const o = d.find(
      `[${X}]`
    ), r = d.find(
      `[${ht}]`
    ), a = d.find(
      `[${q}]`
    );
    if (!e || e === t) {
      Ua(
        r,
        n,
        this._classes,
        this._options.format12
      ), Ua(
        o,
        n,
        this._classes,
        this._options.format12
      ), hg(
        a,
        i,
        n,
        this._hour.textContent,
        this._classes,
        this._options.format12
      );
      return;
    }
    e === "AM" && t === "PM" && (o.forEach((l) => {
      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(jt, "");
    }), a.forEach((l) => {
      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(jt, "");
    }));
  }
  _handleDisablingTipsMinTime(t, e, i, n) {
    if (!this._options.minTime && !this._options.disablePast)
      return;
    const o = d.find(
      `[${X}]`
    ), r = d.find(
      `[${ht}]`
    ), a = d.find(
      `[${q}]`
    );
    !e || e === t ? (Xa(
      o,
      n,
      this._classes,
      this._options.format12
    ), Xa(
      r,
      n,
      this._classes,
      this._options.format12
    ), dg(
      a,
      i,
      n,
      this._hour.textContent,
      this._classes,
      this._options.format12
    )) : e === "PM" && t === "AM" && (o.forEach((l) => {
      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(jt, "");
    }), a.forEach((l) => {
      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(jt, "");
    }));
  }
  _handleSwitchTimeMode() {
    c.on(
      document,
      "click",
      Es,
      ({ target: t }) => {
        let { maxTime: e, minTime: i } = this._options;
        const { disablePast: n, disableFuture: o, format12: r } = this._options;
        i = Gt(i, n, r), e = qt(e, o, r);
        const [a, l, p] = R(
          e,
          !1
        ), [u, _, f] = R(
          i,
          !1
        ), g = d.find(
          `[${X}]`
        ), m = d.find(
          `[${q}]`
        );
        (() => {
          g.forEach((v) => {
            h.removeClass(v, this._classes.tipsDisabled), v.removeAttribute(jt);
          }), m.forEach((v) => {
            h.removeClass(v, this._classes.tipsDisabled), v.removeAttribute(jt);
          });
        })(), this._handleDisablingTipsMinTime(
          t.textContent,
          f,
          _,
          u
        ), this._handleDisablingTipsMaxTime(
          t.textContent,
          p,
          l,
          a
        ), this._toggleAmPm(t.textContent), t.hasAttribute(H) || (d.find(
          Es
        ).forEach((T) => {
          T.hasAttribute(H) && (h.removeClass(T, this._classes.opacity), T.removeAttribute(H));
        }), h.addClass(t, this._classes.opacity), t.setAttribute(H, ""));
      }
    );
  }
  _handleClockClick() {
    let { maxTime: t, minTime: e } = this._options;
    const { disablePast: i, disableFuture: n, format12: o } = this._options;
    e = Gt(e, i, o), t = qt(t, n, o);
    const r = R(t, !1)[2], a = R(e, !1)[2], l = R(t, !1)[0], p = R(e, !1)[0], u = d.findOne(
      `[${al}]`
    );
    K.on(
      document,
      `${Za} ${Qa} ${Ja} ${tl} ${el} ${nl} ${il} ${sl}`,
      "",
      (_) => {
        bs() || _.preventDefault();
        const { type: f, target: g } = _, { closeModalOnMinutesClick: m, switchHoursToMinutesOnClick: b } = this._options, v = d.findOne(
          `[${q}]`,
          this._modal
        ) !== null, T = d.findOne(
          `[${X}]`,
          this._modal
        ) !== null, y = d.findOne(
          `[${ht}]`,
          this._modal
        ) !== null, C = d.find(
          `[${q}]`,
          this._modal
        ), E = za(_, u), w = u.offsetWidth / 2;
        let k = Math.atan2(E.y - w, E.x - w);
        if (bs()) {
          const L = za(_, u, !0);
          k = Math.atan2(L.y - w, L.x - w);
        }
        let D = null, O = null, x = null;
        if (f === "mousedown" || f === "mousemove" || f === "touchmove" || f === "touchstart")
          (f === "mousedown" || f === "touchstart" || f === "touchmove") && (this._hasTargetInnerClass(g) || g.hasAttribute(al) || g.hasAttribute(ue) || g.hasAttribute(q) || g.hasAttribute(X) || g.hasAttribute(_o) || g.hasAttribute(po) || g.hasAttribute(ll) || g.hasAttribute(As)) && (this._isMouseMove = !0, bs() && _.touches && (D = _.touches[0].clientX, O = _.touches[0].clientY, x = document.elementFromPoint(D, O)));
        else if (f === "mouseup" || f === "touchend") {
          if (this._isMouseMove = !1, this._hasTargetInnerClass(g) || g.hasAttribute(ue) || g.hasAttribute(X) || g.hasAttribute(_o) || g.hasAttribute(po) || g.hasAttribute(ll) || g.hasAttribute(As)) {
            if ((T || y) && b) {
              const L = Number(this._hour.textContent) > l || Number(this._hour.textContent) < p;
              if (this._options.format24 && l !== "" && p !== "" && L)
                return;
              if (this._options.format24 && p !== "" && Number(this._hour.textContent) < p)
                return;
            }
            c.trigger(this._minutes, "click");
          }
          if (v && m) {
            const L = d.findOne(
              `[${ro}]`,
              this._modal
            );
            c.trigger(L, "click");
          }
        }
        if (v) {
          let L;
          const S = Math.trunc(k * 180 / Math.PI) + 90, { degrees: N, minute: P } = this._makeMinutesDegrees(S, L);
          if (this._handlerMaxMinMinutesOptions(N, P) === void 0)
            return;
          const { degrees: ot, minute: rt } = this._handlerMaxMinMinutesOptions(N, P);
          if (this._isMouseMove) {
            if (h.addStyle(this._hand, {
              transform: `rotateZ(${ot}deg)`
            }), rt === void 0)
              return;
            const G = () => rt >= 10 || rt === "00" ? rt : `0${rt}`;
            this._minutes.textContent = G(), this._toggleClassActive(
              this.minutesArray,
              this._minutes,
              C
            ), this._toggleBackgroundColorCircle(
              `[${q}]`
            ), this._objWithDataOnChange.degreesMinutes = ot, this._objWithDataOnChange.minutes = rt;
          }
        }
        if (T || y) {
          let L, S = Math.trunc(k * 180 / Math.PI) + 90;
          if (S = Math.round(S / 30) * 30, h.addStyle(this._circle, {
            backgroundColor: "#1976d2"
          }), this._makeHourDegrees(g, S, L) === void 0)
            return;
          const N = () => {
            if (bs() && S && x) {
              const { degrees: P, hour: ot } = this._makeHourDegrees(x, S, L);
              return this._handleMoveHand(
                x,
                ot,
                P
              );
            } else {
              const { degrees: P, hour: ot } = this._makeHourDegrees(g, S, L);
              return this._handleMoveHand(g, ot, P);
            }
          };
          this._objWithDataOnChange.degreesHours = S, this._handlerMaxMinHoursOptions(
            S,
            l,
            p,
            r,
            a,
            _
          ) && N();
        }
        _.stopPropagation();
      }
    );
  }
  _hasTargetInnerClass(t) {
    return t.hasAttribute(mi) || t.hasAttribute(ht) || t.hasAttribute(ys);
  }
  _handleMoveHand(t, e, i) {
    const n = d.find(
      `[${X}]`,
      this._modal
    ), o = d.find(
      `[${ht}]`,
      this._modal
    );
    this._isMouseMove && (this._hasTargetInnerClass(t) ? h.addStyle(this._hand, {
      height: "21.5%"
    }) : h.addStyle(this._hand, {
      height: "calc(40% + 1px)"
    }), h.addStyle(this._hand, {
      transform: `rotateZ(${i}deg)`
    }), this._hour.textContent = e >= 10 || e === "00" ? e : `0${e}`, this._toggleClassActive(this.hoursArray, this._hour, n), this._toggleClassActive(this.innerHours, this._hour, o), this._objWithDataOnChange.hour = e >= 10 || e === "00" ? e : `0${e}`);
  }
  _handlerMaxMinMinutesOptions(t, e) {
    let { maxTime: i, minTime: n } = this._options;
    const { format12: o, increment: r, disablePast: a, disableFuture: l } = this._options;
    n = Gt(n, a, o), i = qt(i, l, o);
    const p = R(i, !1)[1], u = R(n, !1)[1], _ = R(i, !1)[0], f = R(n, !1)[0], g = f === "12" && o ? "0" : f, m = _ === "12" && o ? "0" : _, b = R(i, !1)[2], v = R(n, !1)[2], T = p !== "" ? p * 6 : "", y = u !== "" ? u * 6 : "", C = Number(this._hour.textContent), E = C === 12 && o ? 0 : C;
    if (!b && !v) {
      if (i !== "" && n !== "") {
        if (Number(m) === E && t > T || Number(g) === E && t < y)
          return t;
      } else if (n !== "" && E <= Number(g)) {
        if (t <= y - 6)
          return t;
      } else if (i !== "" && E >= Number(m) && t >= T + 6)
        return t;
    } else {
      if (n !== "") {
        if (v === "PM" && this._isAmEnabled)
          return;
        if (v === "PM" && this._isPmEnabled) {
          if (E < Number(g))
            return;
          if (E <= Number(g) && t <= y - 6)
            return t;
        } else if (v === "AM" && this._isAmEnabled) {
          if (E < Number(g))
            return;
          if (E <= Number(g) && t <= y - 6)
            return t;
        }
      }
      if (i !== "") {
        if (b === "AM" && this._isPmEnabled)
          return;
        if (b === "PM" && this._isPmEnabled) {
          if (E >= Number(m) && t >= T + 6)
            return t;
        } else if (b === "AM" && this._isAmEnabled && E >= Number(m) && t >= T + 6)
          return t;
      }
    }
    return r && (t = Math.round(t / 30) * 30), t < 0 ? t = 360 + t : t >= 360 && (t = 0), {
      degrees: t,
      minute: e
    };
  }
  _removeModal() {
    this._animations ? setTimeout(() => {
      this._removeModalElements(), this._scrollBar.reset();
    }, 300) : (this._removeModalElements(), this._scrollBar.reset()), K.off(
      this._document,
      `${qa} ${vs} ${Za} ${Qa} ${Ja} ${tl} ${el} ${nl} ${il} ${sl}`
    ), c.off(window, vs);
  }
  _removeModalElements() {
    this._modal && this._modal.remove();
  }
  _toggleBackdropAnimation(t = !1) {
    t ? this._wrapper.classList.add("animate-[fade-out_350ms_ease-in-out]") : (this._wrapper.classList.add("animate-[fade-in_350ms_ease-in-out]"), this._options.inline || h.addClass(this._clock, this._classes.clockAnimation)), setTimeout(() => {
      this._wrapper.classList.remove(
        "animate-[fade-out_350ms_ease-in-out]",
        "animate-[fade-in_350ms_ease-in-out]"
      );
    }, 351);
  }
  _addActiveClassToTip(t, e) {
    t.forEach((i) => {
      Number(i.textContent) === Number(e) && (h.addClass(i, this._classes.tipsActive), i.setAttribute(H, ""));
    });
  }
  _setHourOrMinute(t) {
    return t < 10 ? `0${t}` : t;
  }
  _appendTimes() {
    const { format24: t } = this._options;
    if (t) {
      this._getAppendClock(
        this.hoursArray,
        `[${ue}]`,
        X
      ), this._getAppendClock(
        this.innerHours,
        `[${mi}]`,
        ht
      );
      return;
    }
    this._getAppendClock(
      this.hoursArray,
      `[${ue}]`,
      X
    );
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...wg,
      ...e,
      ...t
    }, I(Bi, t, kg), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...xg,
      ...e,
      ...t
    }, I(Bi, t, Og), t;
  }
  _getContainer() {
    return d.findOne(this._options.container);
  }
  _getValidate(t) {
    const { format24: e, format12: i, appendValidationInfo: n } = this._options;
    K.on(this.input, t, ({ target: o }) => {
      if (this._options === null || this.input.value === "")
        return;
      const r = /^(0?[1-9]|1[012])(:[0-5]\d) [APap][mM]$/, a = /^([01]\d|2[0-3])(:[0-5]\d)$/, l = r.test(o.value);
      if (a.test(o.value) !== !0 && e || l !== !0 && i) {
        n && this.input.setAttribute(co, ""), h.addStyle(o, { marginBottom: 0 }), this._isInvalidTimeFormat = !0;
        return;
      }
      this.input.removeAttribute(co), this._isInvalidTimeFormat = !1;
      const u = d.findOne(
        `[${Cg}]`
      );
      u !== null && u.remove();
    });
  }
  // Static
  static getInstance(t) {
    return A.getData(t, Js);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Ig = {
  threshold: 10,
  direction: "all"
};
let Dg = class {
  constructor(t, e) {
    this._element = t, this._startPosition = null, this._options = {
      ...Ig,
      ...e
    };
  }
  handleTouchStart(t) {
    this._startPosition = this._getCoordinates(t);
  }
  handleTouchMove(t) {
    if (!this._startPosition)
      return;
    const e = this._getCoordinates(t), i = {
      x: e.x - this._startPosition.x,
      y: e.y - this._startPosition.y
    }, n = this._getDirection(i);
    if (this._options.direction === "all") {
      if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)
        return;
      const r = n.y.value > n.x.value ? n.y.direction : n.x.direction;
      c.trigger(this._element, `swipe${r}`), c.trigger(this._element, "swipe", { direction: r }), this._startPosition = null;
      return;
    }
    const o = this._options.direction === "left" || this._options === "right" ? "x" : "y";
    n[o].direction === this._options.direction && n[o].value > this._options.threshold && (c.trigger(this._element, `swipe${n[o].direction}`), this._startPosition = null);
  }
  handleTouchEnd() {
    this._startPosition = null;
  }
  _getCoordinates(t) {
    const [e] = t.touches;
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  _getDirection(t) {
    return {
      x: {
        direction: t.x < 0 ? "left" : "right",
        value: Math.abs(t.x)
      },
      y: {
        direction: t.y < 0 ? "up" : "down",
        value: Math.abs(t.y)
      }
    };
  }
}, $g = class {
  constructor(t, e = "swipe", i = {}) {
    this._element = t, this._event = e, this.swipe = new Dg(t, i), this._touchStartHandler = this._handleTouchStart.bind(this), this._touchMoveHandler = this._handleTouchMove.bind(this), this._touchEndHandler = this._handleTouchEnd.bind(this);
  }
  dispose() {
    this._element.removeEventListener("touchstart", this._touchStartHandler), this._element.removeEventListener("touchmove", this._touchMoveHandler), window.removeEventListener("touchend", this._touchEndHandler);
  }
  init() {
    this._element.addEventListener(
      "touchstart",
      (t) => this._handleTouchStart(t)
    ), this._element.addEventListener(
      "touchmove",
      (t) => this._handleTouchMove(t)
    ), window.addEventListener("touchend", (t) => this._handleTouchEnd(t));
  }
  _handleTouchStart(t) {
    this[this._event].handleTouchStart(t);
  }
  _handleTouchMove(t) {
    this[this._event].handleTouchMove(t);
  }
  _handleTouchEnd(t) {
    this[this._event].handleTouchEnd(t);
  }
};
const hl = "sidenav", ws = "te.sidenav", Lg = "data-te-sidenav-rotate-icon-ref", fo = "[data-te-sidenav-toggle-ref]", Ng = "[data-te-collapse-init]", Mg = '[data-te-sidenav-slim="true"]', Rg = '[data-te-sidenav-slim="false"]', Pg = "[data-te-sidenav-menu-ref]", Le = "[data-te-sidenav-collapse-ref]", gi = "[data-te-sidenav-link-ref]", Bg = W() ? 100 : -100, Hg = W() ? -100 : 100, Vg = {
  sidenavAccordion: "(boolean)",
  sidenavBackdrop: "(boolean)",
  sidenavBackdropClass: "(null|string)",
  sidenavCloseOnEsc: "(boolean)",
  sidenavColor: "(string)",
  sidenavContent: "(null|string)",
  sidenavExpandable: "(boolean)",
  sidenavExpandOnHover: "(boolean)",
  sidenavFocusTrap: "(boolean)",
  sidenavHidden: "(boolean)",
  sidenavMode: "(string)",
  sidenavModeBreakpointOver: "(null|string|number)",
  sidenavModeBreakpointSide: "(null|string|number)",
  sidenavModeBreakpointPush: "(null|string|number)",
  sidenavBreakpointSm: "(number)",
  sidenavBreakpointMd: "(number)",
  sidenavBreakpointLg: "(number)",
  sidenavBreakpointXl: "(number)",
  sidenavBreakpoint2xl: "(number)",
  sidenavScrollContainer: "(null|string)",
  sidenavSlim: "(boolean)",
  sidenavSlimCollapsed: "(boolean)",
  sidenavSlimWidth: "(number)",
  sidenavPosition: "(string)",
  sidenavRight: "(boolean)",
  sidenavTransitionDuration: "(number)",
  sidenavWidth: "(number)"
}, Wg = {
  sidenavAccordion: !1,
  sidenavBackdrop: !0,
  sidenavBackdropClass: null,
  sidenavCloseOnEsc: !0,
  sidenavColor: "primary",
  sidenavContent: null,
  sidenavExpandable: !0,
  sidenavExpandOnHover: !1,
  sidenavFocusTrap: !0,
  sidenavHidden: !0,
  sidenavMode: "over",
  sidenavModeBreakpointOver: null,
  sidenavModeBreakpointSide: null,
  sidenavModeBreakpointPush: null,
  sidenavBreakpointSm: 640,
  sidenavBreakpointMd: 768,
  sidenavBreakpointLg: 1024,
  sidenavBreakpointXl: 1280,
  sidenavBreakpoint2xl: 1536,
  sidenavScrollContainer: null,
  sidenavSlim: !1,
  sidenavSlimCollapsed: !1,
  sidenavSlimWidth: 77,
  sidenavPosition: "fixed",
  sidenavRight: !1,
  sidenavTransitionDuration: 300,
  sidenavWidth: 240
};
class Ci {
  constructor(t, e = {}) {
    wt(this, "_addBackdropOnInit", () => {
      this._options.sidenavHidden || (this._backdrop.show(), c.off(this._element, "transitionend", this._addBackdropOnInit));
    });
    this._element = t, this._options = e, this._ID = et(""), this._content = null, this._initialContentStyle = null, this._slimCollapsed = !1, this._activeNode = null, this._tempSlim = !1, this._backdrop = this._initializeBackDrop(), this._focusTrap = null, this._perfectScrollbar = null, this._touch = null, this._setModeFromBreakpoints(), this.escHandler = (i) => {
      i.keyCode === we && this.toggler && Mt(this.toggler) && (this._update(!1), c.off(window, "keydown", this.escHandler));
    }, this.hashHandler = () => {
      this._setActiveElements();
    }, t && (A.setData(t, ws, this), this._setup()), this.options.sidenavBackdrop && !this.options.sidenavHidden && this.options.sidenavMode === "over" && c.on(this._element, "transitionend", this._addBackdropOnInit), this._didInit = !1, this._init();
  }
  // Getters
  static get NAME() {
    return hl;
  }
  get container() {
    if (this.options.sidenavPosition === "fixed")
      return d.findOne("body");
    const t = (e) => !e.parentNode || e.parentNode === document ? e : e.parentNode.style.position === "relative" || e.parentNode.classList.contains("relative") ? e.parentNode : t(e.parentNode);
    return t(this._element);
  }
  get isVisible() {
    let t = 0, e = window.innerWidth;
    if (this.options.sidenavPosition !== "fixed") {
      const n = this.container.getBoundingClientRect();
      t = n.x, e = n.x + n.width;
    }
    const { x: i } = this._element.getBoundingClientRect();
    if (this.options.sidenavRight && !W() || !this.options.sidenavRight && W()) {
      let n = 0;
      if (this.container.scrollHeight > this.container.clientHeight && (n = this.container.offsetWidth - this.container.clientWidth), this.container.tagName === "BODY") {
        const o = document.documentElement.clientWidth;
        n = Math.abs(window.innerWidth - o);
      }
      return Math.abs(i + n - e) > 10;
    }
    return Math.abs(i - t) < 10;
  }
  get links() {
    return d.find(gi, this._element);
  }
  get navigation() {
    return d.find(Pg, this._element);
  }
  get options() {
    const t = {
      ...Wg,
      ...h.getDataAttributes(this._element),
      ...this._options
    };
    return I(hl, t, Vg), t;
  }
  get sidenavStyle() {
    return {
      width: `${this.width}px`,
      height: this.options.sidenavPosition === "fixed" ? "100vh" : "100%",
      position: this.options.sidenavPosition,
      transition: `all ${this.transitionDuration} linear`
    };
  }
  get toggler() {
    return d.find(fo).find(
      (e) => {
        const i = h.getDataAttribute(e, "target");
        return d.findOne(i) === this._element;
      }
    );
  }
  get transitionDuration() {
    return `${this.options.sidenavTransitionDuration / 1e3}s`;
  }
  get translation() {
    return this.options.sidenavRight ? Hg : Bg;
  }
  get width() {
    return this._slimCollapsed ? this.options.sidenavSlimWidth : this.options.sidenavWidth;
  }
  get isBackdropVisible() {
    return !!this._backdrop._element;
  }
  // Public
  changeMode(t) {
    this._setMode(t);
  }
  dispose() {
    c.off(window, "keydown", this.escHandler), this.options.sidenavBackdrop && this._backdrop.dispose(), c.off(window, "hashchange", this.hashHandler), this._touch.dispose(), A.removeData(this._element, ws), this._element = null;
  }
  hide() {
    this._emitEvents(!1), this._update(!1), this._options.sidenavBackdrop && this.isBackdropVisible && this._backdrop.hide();
  }
  show() {
    this._emitEvents(!0), this._update(!0), this._options.sidenavBackdrop && this._options.sidenavMode === "over" && this._backdrop.show();
  }
  toggle() {
    this._emitEvents(!this.isVisible), this._update(!this.isVisible);
  }
  toggleSlim() {
    this._setSlim(!this._slimCollapsed);
  }
  update(t) {
    this._options = t, this._setup();
  }
  getBreakpoint(t) {
    return this._transformBreakpointValuesToObject()[t];
  }
  // Private
  _init() {
    this._didInit || (c.on(
      document,
      "click",
      fo,
      Ci.toggleSidenav()
    ), this._didInit = !0);
  }
  _transformBreakpointValuesToObject() {
    return {
      sm: this.options.sidenavBreakpointSm,
      md: this.options.sidenavBreakpointMd,
      lg: this.options.sidenavBreakpointLg,
      xl: this.options.sidenavBreakpointXl,
      "2xl": this.options.sidenavBreakpoint2xl
    };
  }
  _setModeFromBreakpoints() {
    const t = window.innerWidth, e = this._transformBreakpointValuesToObject();
    if (t === void 0 || !e)
      return;
    const i = typeof this.options.sidenavModeBreakpointOver == "number" ? t - this.options.sidenavModeBreakpointOver : t - e[this.options.sidenavModeBreakpointOver], n = typeof this.options.sidenavModeBreakpointSide == "number" ? t - this.options.sidenavModeBreakpointSide : t - e[this.options.sidenavModeBreakpointSide], o = typeof this.options.sidenavModeBreakpointPush == "number" ? t - this.options.sidenavModeBreakpointPush : t - e[this.options.sidenavModeBreakpointPush], r = (l, p) => l - p < 0 ? -1 : p - l < 0 ? 1 : 0, a = [i, n, o].filter((l) => l != null && l >= 0).sort(r)[0];
    i > 0 && i === a ? (this._options.sidenavMode = "over", this._options.sidenavHidden = !0) : n > 0 && n === a ? this._options.sidenavMode = "side" : o > 0 && o === a && (this._options.sidenavMode = "push");
  }
  _collapseItems() {
    this.navigation.forEach((t) => {
      d.find(Le, t).forEach((i) => {
        Qt.getInstance(i).hide();
      });
    });
  }
  _getOffsetValue(t, { index: e, property: i, offsets: n }) {
    const o = this._getPxValue(
      this._initialContentStyle[e][n[i].property]
    ), r = t ? n[i].value : 0;
    return o + r;
  }
  _getProperty(...t) {
    return t.map((e, i) => i === 0 ? e : e[0].toUpperCase().concat(e.slice(1))).join("");
  }
  _getPxValue(t) {
    return t ? parseFloat(t) : 0;
  }
  _handleSwipe(t, e) {
    e && this._slimCollapsed && this.options.sidenavSlim && this.options.sidenavExpandable ? this.toggleSlim() : e || (this._slimCollapsed || !this.options.sidenavSlim || !this.options.sidenavExpandable ? this.toggler && Mt(this.toggler) && this.toggle() : this.toggleSlim());
  }
  _isActive(t, e) {
    return e ? e === t : t.attributes.href ? new URL(t, window.location.href).href === window.location.href : !1;
  }
  _isAllToBeCollapsed() {
    return d.find(
      Ng,
      this._element
    ).filter(
      (i) => i.getAttribute("aria-expanded") === "true"
    ).length === 0;
  }
  _isAllCollapsed() {
    return d.find(Le, this._element).filter(
      (t) => Mt(t)
    ).length === 0;
  }
  _initializeBackDrop() {
    if (!this.options.sidenavBackdrop)
      return;
    const t = this.options.sidenavBackdropClass ? this.options.sidenavBackdropClass.split(" ") : this.options.sidenavPosition ? [
      "opacity-50",
      "transition-all",
      "duration-300",
      "ease-in-out",
      this.options.sidenavPosition,
      "top-0",
      "left-0",
      "z-50",
      "bg-black/10",
      "dark:bg-black-60",
      "w-full",
      "h-full",
      this._element.id
    ] : null;
    return new Cr({
      isVisible: this.options.sidenavBackdrop,
      isAnimated: !0,
      rootElement: this._element.parentNode,
      backdropClasses: t,
      clickCallback: () => this.hide()
    });
  }
  _updateBackdrop(t) {
    if (this.options.sidenavMode === "over") {
      t ? this._backdrop.show() : this.isBackdropVisible && this._backdrop.hide();
      return;
    }
    this.isBackdropVisible && this._backdrop.hide();
  }
  _setup() {
    this._setupTouch(), this.options.sidenavFocusTrap && this._setupFocusTrap(), this._setupCollapse(), this.options.sidenavSlim && this._setupSlim(), this._setupInitialStyling(), this._setupScrolling(), this.options.sidenavContent && this._setupContent(), this._setupActiveState(), this._setupRippleEffect(), this.options.sidenavHidden || this._updateOffsets(!0, !0), this.options.sidenavMode === "over" && this._setTabindex(!0);
  }
  _setupActiveState() {
    this._setActiveElements(), this.links.forEach((t) => {
      c.on(t, "click", () => this._setActiveElements(t)), c.on(t, "keydown", (e) => {
        e.keyCode === it && this._setActiveElements(t);
      });
    }), c.on(window, "hashchange", this.hashHandler);
  }
  _setupCollapse() {
    this.navigation.forEach((t, e) => {
      d.find(Le, t).forEach(
        (n, o) => this._setupCollapseList({ list: n, index: o, menu: t, menuIndex: e })
      );
    });
  }
  _generateCollpaseID(t, e) {
    return `sidenav-collapse-${this._ID}-${e}-${t}`;
  }
  _setupCollapseList({ list: t, index: e, menu: i, menuIndex: n }) {
    const o = this._generateCollpaseID(e, n);
    t.setAttribute("id", o), t.setAttribute("data-te-collapse-item", "");
    const [r] = d.prev(t, gi);
    h.setDataAttribute(r, "collapse-init", ""), r.setAttribute("href", `#${o}`), r.setAttribute("role", "button");
    const a = Qt.getInstance(t) || new Qt(t, {
      toggle: !1,
      parent: this.options.sidenavAccordion ? i : t
    });
    (t.dataset.teSidenavStateShow === "" || t.dataset.teCollapseShow === "") && this._rotateArrow(r, !1), c.on(r, "click", (l) => {
      this._toggleCategory(l, a, t), this._tempSlim && this._isAllToBeCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    }), c.on(
      t,
      "show.te.collapse",
      () => this._rotateArrow(r, !1)
    ), c.on(
      t,
      "hide.te.collapse",
      () => this._rotateArrow(r, !0)
    ), c.on(t, "shown.te.collapse", () => {
      this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    }), c.on(t, "hidden.te.collapse", () => {
      this._tempSlim && this._isAllCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    });
  }
  _setupContent() {
    this._content = d.find(this.options.sidenavContent), this._content.forEach((t) => {
      const e = [
        "!p",
        "!m",
        "!px",
        "!pl",
        "!pr",
        "!mx",
        "!ml",
        "!mr",
        "!-p",
        "!-m",
        "!-px",
        "!-pl",
        "!-pr",
        "!-mx",
        "!-ml",
        "!-mr"
      ];
      [...t.classList].filter(
        (n) => e.findIndex((o) => n.includes(o)) >= 0
      ).forEach((n) => t.classList.remove(n));
    }), this._initialContentStyle = this._content.map((t) => {
      const { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r } = window.getComputedStyle(t);
      return { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r };
    });
  }
  _setupFocusTrap() {
    this._focusTrap = new zi(
      this._element,
      {
        event: "keydown",
        condition: (t) => t.keyCode === ke,
        onlyVisible: !0
      },
      this.toggler
    );
  }
  _setupInitialStyling() {
    this._setColor(), h.style(this._element, this.sidenavStyle);
  }
  _setupScrolling() {
    let t = this._element;
    if (this.options.sidenavScrollContainer) {
      t = d.findOne(
        this.options.sidenavScrollContainer,
        this._element
      );
      const i = fd(t.parentNode.children).filter(
        (n) => n !== t
      ).reduce((n, o) => n + o.clientHeight, 0);
      h.style(t, {
        maxHeight: `calc(100% - ${i}px)`,
        position: "relative"
      });
    }
    this._perfectScrollbar = new Bh(t, {
      suppressScrollX: !0,
      handlers: ["click-rail", "drag-thumb", "wheel", "touch"]
    });
  }
  _setupSlim() {
    this._slimCollapsed = this.options.sidenavSlimCollapsed, this._toggleSlimDisplay(this._slimCollapsed), this.options.sidenavExpandOnHover && (this._element.addEventListener("mouseenter", () => {
      this._slimCollapsed && this._setSlim(!1);
    }), this._element.addEventListener("mouseleave", () => {
      this._slimCollapsed || this._setSlim(!0);
    }));
  }
  _setupRippleEffect() {
    this.links.forEach((t) => {
      let e = ei.getInstance(t), i = this.options.sidenavColor;
      if (e && e._options.sidenavColor !== this.options.sidenavColor)
        e.dispose();
      else if (e)
        return;
      (localStorage.theme === "dark" || !("theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) && (i = "white"), e = new ei(t, { rippleColor: i });
    });
  }
  _setupTouch() {
    this._touch = new $g(this._element, "swipe", { threshold: 20 }), this._touch.init(), c.on(
      this._element,
      "swipeleft",
      (t) => this._handleSwipe(t, this.options.sidenavRight)
    ), c.on(
      this._element,
      "swiperight",
      (t) => this._handleSwipe(t, !this.options.sidenavRight)
    );
  }
  _setActive(t, e) {
    t.setAttribute("data-te-sidebar-state-active", ""), this._activeNode && t.removeAttribute("data-te-sidebar-state-active"), this._activeNode = t;
    const [i] = d.parents(
      this._activeNode,
      Le
    );
    if (!i) {
      this._setActiveCategory();
      return;
    }
    const [n] = d.prev(i, gi);
    this._setActiveCategory(n), !e && !this._slimCollapsed && Qt.getInstance(i).show();
  }
  _setActiveCategory(t) {
    this.navigation.forEach((e) => {
      d.find(Le, e).forEach((n) => {
        const [o] = d.prev(n, gi);
        o !== t ? o.removeAttribute("data-te-sidenav-state-active") : o.setAttribute("data-te-sidenav-state-active", "");
      });
    });
  }
  _setActiveElements(t) {
    this.navigation.forEach((e) => {
      d.find(gi, e).filter((n) => d.next(n, Le).length === 0).forEach((n) => {
        this._isActive(n, t) && n !== this._activeNode && this._setActive(n, t);
      });
    }), t && this._updateFocus(this.isVisible);
  }
  _setColor() {
    const t = [
      "primary",
      "secondary",
      "success",
      "info",
      "warning",
      "danger",
      "light",
      "dark"
    ], { sidenavColor: e } = this.options, i = t.includes(e) ? e : "primary";
    t.forEach((n) => {
      this._element.classList.remove(`sidenav-${n}`);
    }), h.addClass(this._element, `sidenav-${i}`);
  }
  _setContentOffsets(t, e, i) {
    this._content.forEach((n, o) => {
      const r = this._getOffsetValue(t, {
        index: o,
        property: "padding",
        offsets: e
      }), a = this._getOffsetValue(t, {
        index: o,
        property: "margin",
        offsets: e
      }), l = {};
      if (i || (l.transition = `all ${this.transitionDuration} linear`), l[e.padding.property] = `${r}px`, l[e.margin.property] = `${a}px`, h.style(n, l), !!t) {
        if (i) {
          h.style(n, {
            transition: this._initialContentStyle[o].transition
          });
          return;
        }
        c.on(n, "transitionend", () => {
          h.style(n, {
            transition: this._initialContentStyle[o].transition
          });
        });
      }
    });
  }
  _setMode(t) {
    this.options.sidenavMode !== t && (this._options.sidenavMode = t, this._update(this.isVisible));
  }
  _setSlim(t) {
    const e = t ? ["collapse", "collapsed"] : ["expand", "expanded"];
    this._triggerEvents(...e), t && this._collapseItems(), this._slimCollapsed = t, this._toggleSlimDisplay(t), h.style(this._element, { width: `${this.width}px` }), this._updateOffsets(this.isVisible);
  }
  _setTabindex(t) {
    this.links.forEach((e) => {
      e.tabIndex = t ? 0 : -1;
    });
  }
  _emitEvents(t) {
    const e = t ? ["show", "shown"] : ["hide", "hidden"];
    this._triggerEvents(...e);
  }
  _rotateArrow(t, e) {
    const [i] = d.children(t, `[${Lg}]`);
    i && (e ? h.removeClass(i, "rotate-180") : h.addClass(i, "rotate-180"));
  }
  _toggleCategory(t, e) {
    t.preventDefault(), e.toggle(), this._slimCollapsed && this.options.sidenavExpandable && (this._tempSlim = !0, this._setSlim(!1));
  }
  _toggleSlimDisplay(t) {
    const e = d.find(
      Mg,
      this._element
    ), i = d.find(
      Rg,
      this._element
    ), n = () => {
      e.forEach((o) => {
        h.style(o, {
          display: this._slimCollapsed ? "unset" : "none"
        });
      }), i.forEach((o) => {
        h.style(o, {
          display: this._slimCollapsed ? "none" : "unset"
        });
      });
    };
    t ? setTimeout(
      () => n(),
      this.options.sidenavTransitionDuration
    ) : n();
  }
  async _triggerEvents(t, e) {
    c.trigger(this._element, `${t}.te.sidenav`), e && await setTimeout(() => {
      c.trigger(this._element, `${e}.te.sidenav`);
    }, this.options.sidenavTransitionDuration + 5);
  }
  _isiPhone() {
    return /iPhone|iPod/i.test(navigator.userAgent);
  }
  _update(t) {
    t && this._isiPhone() && h.addClass(this._element, "ps--scrolling-y"), this.toggler && this._updateTogglerAria(t), this._updateDisplay(t), this.options.sidenavBackdrop && this._updateBackdrop(t), this._updateOffsets(t), t && this.options.sidenavCloseOnEsc && this.options.sidenavMode !== "side" && c.on(window, "keydown", this.escHandler), this.options.sidenavFocusTrap && this._updateFocus(t);
  }
  _updateDisplay(t) {
    const e = t ? 0 : this.translation;
    h.style(this._element, {
      transform: `translateX(${e}%)`
    });
  }
  _updateFocus(t) {
    if (this._setTabindex(t), this.options.sidenavMode === "over" && this.options.sidenavFocusTrap) {
      if (t) {
        this._focusTrap.trap();
        return;
      }
      this._focusTrap.disable();
    }
    this._focusTrap.disable();
  }
  _updateOffsets(t, e = !1) {
    const [i, n] = this.options.sidenavRight ? ["right", "left"] : ["left", "right"], o = {
      property: this._getProperty("padding", i),
      value: this.options.sidenavMode === "over" ? 0 : this.width
    }, r = {
      property: this._getProperty("margin", n),
      value: this.options.sidenavMode === "push" ? -1 * this.width : 0
    };
    c.trigger(this._element, "update.te.sidenav", {
      margin: r,
      padding: o
    }), this._content && (this._content.className = "", this._setContentOffsets(t, { padding: o, margin: r }, e));
  }
  _updateTogglerAria(t) {
    this.toggler.setAttribute("aria-expanded", t);
  }
  // Static
  static toggleSidenav() {
    return function(t) {
      const e = d.closest(t.target, fo), i = h.getDataAttributes(e).target;
      d.find(i).forEach((n) => {
        (Ci.getInstance(n) || new Ci(n)).toggle();
      });
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, ws);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new Ci(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, ws);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Zo = "stepper", tn = "te.stepper", ai = `.${tn}`, Ui = `data-te-${Zo}`, Ai = "horizontal", Ot = "vertical", Fg = `onChangeStep${ai}`, Yg = `onChangedStep${ai}`, jg = {
  stepperType: "string",
  stepperLinear: "boolean",
  stepperNoEditable: "boolean",
  stepperActive: "string",
  stepperCompleted: "string",
  stepperInvalid: "string",
  stepperDisabled: "string",
  stepperVerticalBreakpoint: "number",
  stepperMobileBreakpoint: "number",
  stepperMobileBarBreakpoint: "number",
  stepperAnimationDuration: "number",
  slideInLeftAnimation: "string",
  slideOutLeftAnimation: "string",
  slideInRightAnimation: "string",
  slideOutRightAnimation: "string"
}, Kg = {
  stepperType: Ai,
  stepperLinear: !1,
  stepperNoEditable: !1,
  stepperActive: "",
  stepperCompleted: "",
  stepperInvalid: "",
  stepperDisabled: "",
  stepperVerticalBreakpoint: 0,
  stepperMobileBreakpoint: 0,
  stepperMobileBarBreakpoint: 4,
  stepperAnimationDuration: 800,
  slideInLeftAnimation: "animate-[slide-in-left_0.8s_both]",
  slideOutLeftAnimation: "animate-[slide-out-left_0.8s_both]",
  slideInRightAnimation: "animate-[slide-in-right_0.8s_both]",
  slideOutRightAnimation: "animate-[slide-out-right_0.8s_both]"
}, dl = `mousedown${ai}`, ul = `keydown${ai}`, zg = `keyup${ai}`, pl = `resize${ai}`, Kt = `[${Ui}-step-ref]`, Z = `[${Ui}-head-ref]`, _l = `[${Ui}-head-text-ref]`, ks = `[${Ui}-head-icon-ref]`, Q = `[${Ui}-content-ref]`;
class UA {
  constructor(t, e) {
    this._element = t, this._options = this._getConfig(e), this._elementHeight = 0, this._steps = d.find(`${Kt}`, this._element), this._currentView = "", this._activeStepIndex = 0, this._verticalStepperStyles = [], this._timeout = 0, this._element && (A.setData(t, tn, this), this._init());
  }
  // Getters
  static get NAME() {
    return Zo;
  }
  get activeStep() {
    return this._steps[this._activeStepIndex];
  }
  get activeStepIndex() {
    return this._activeStepIndex;
  }
  // Public
  dispose() {
    this._steps.forEach((t) => {
      c.off(t, dl), c.off(t, ul);
    }), c.off(window, pl), A.removeData(this._element, tn), this._element = null;
  }
  changeStep(t) {
    this._toggleStep(t);
  }
  nextStep() {
    this._toggleStep(this._activeStepIndex + 1);
  }
  previousStep() {
    this._toggleStep(this._activeStepIndex - 1);
  }
  // Private
  _init() {
    const t = d.find(`${Kt}`, this._element)[this._activeStepIndex].setAttribute("data-te", "active-step"), e = d.find(
      `${_l}`,
      this._element
    ), i = d.find(
      `${ks}`,
      this._element
    );
    switch (t ? (this._activeStepIndex = this._steps.indexOf(t), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperActive
    ), e[this._activeStepIndex].classList.add("font-medium"), i[this._activeStepIndex].classList.add("!bg-primary-100"), i[this._activeStepIndex].classList.add("!text-primary-700")) : (e[this._activeStepIndex].classList.add("font-medium"), i[this._activeStepIndex].classList.add("!bg-primary-100"), i[this._activeStepIndex].classList.add("!text-primary-700"), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperActive
    )), this._bindMouseDown(), this._bindKeysNavigation(), this._options.stepperType) {
      case Ot:
        this._toggleVertical();
        break;
      default:
        this._toggleHorizontal();
        break;
    }
    (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView(), this._bindResize();
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...Kg,
      ...e,
      ...t
    }, I(Zo, t, jg), t;
  }
  _bindMouseDown() {
    this._steps.forEach((t) => {
      const e = d.findOne(`${Z}`, t);
      c.on(e, dl, (i) => {
        const n = d.parents(i.target, `${Kt}`)[0], o = this._steps.indexOf(n);
        i.preventDefault(), this._toggleStep(o);
      });
    });
  }
  _bindResize() {
    c.on(window, pl, () => {
      this._currentView === Ot && this._setSingleStepHeight(this.activeStep), this._currentView === Ai && this._setHeight(this.activeStep), (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView();
    });
  }
  _toggleStepperView() {
    const t = this._options.stepperVerticalBreakpoint < window.innerWidth, e = this._options.stepperVerticalBreakpoint > window.innerWidth, i = this._options.stepperMobileBreakpoint > window.innerWidth;
    t && this._currentView !== Ai && this._toggleHorizontal(), e && !i && this._currentView !== Ot && (this._steps.forEach((n) => {
      const o = d.findOne(`${Q}`, n);
      this._resetStepperHeight(), this._showElement(o);
    }), this._toggleVertical());
  }
  _toggleStep(t) {
    if (this._activeStepIndex === t)
      return;
    this._options.stepperNoEditable && this._toggleDisabled();
    const e = this._activeStepIndex, i = c.trigger(
      this.activeStep,
      Fg,
      {
        currentStep: this._activeStepIndex,
        nextStep: t
      }
    );
    t > this._activeStepIndex && i.defaultPrevented || (this._showElement(
      d.findOne(`${Q}`, this._steps[t])
    ), this._toggleActive(t), t > this._activeStepIndex && this._toggleCompleted(this._activeStepIndex), this._currentView === Ai ? this._animateHorizontalStep(t) : (this._animateVerticalStep(t), this._setSingleStepHeight(this._steps[t])), this._toggleStepTabIndex(
      d.findOne(`${Z}`, this.activeStep),
      d.findOne(`${Z}`, this._steps[t])
    ), this._activeStepIndex = t, this._steps[this._activeStepIndex].setAttribute("data-te", "active-step"), this._steps.forEach((n, o) => {
      n[this._activeStepIndex] !== o && n.removeAttribute("data-te");
    }), c.trigger(this.activeStep, Yg, {
      currentStep: this._activeStepIndex,
      prevStep: e
    }));
  }
  _resetStepperHeight() {
    this._element.style.height = "";
  }
  _setStepsHeight() {
    this._steps.forEach((t) => {
      const e = d.findOne(`${Q}`, t), i = window.getComputedStyle(e);
      this._verticalStepperStyles.push({
        paddingTop: parseFloat(i.paddingTop),
        paddingBottom: parseFloat(i.paddingBottom)
      });
      const n = e.scrollHeight;
      e.style.height = `${n}px`;
    });
  }
  _setSingleStepHeight(t) {
    const e = d.findOne(`${Q}`, t), i = this.activeStep === t, n = this._steps.indexOf(t);
    let o;
    i ? (e.style.height = "", o = e.scrollHeight) : o = e.scrollHeight + this._verticalStepperStyles[n].paddingTop + this._verticalStepperStyles[n].paddingBottom, e.style.height = `${o}px`;
  }
  _toggleVertical() {
    this._currentView = Ot, this._setStepsHeight(), this._hideInactiveSteps();
  }
  _toggleHorizontal() {
    this._currentView = Ai, this._setHeight(this.activeStep), this._hideInactiveSteps();
  }
  _toggleStepperClass() {
    d.findOne(
      "[data-te-stepper-type]",
      this._element
    ) !== null && this._steps.forEach((e) => {
      d.findOne(`${Q}`, e).classList.remove("!my-0"), d.findOne(`${Q}`, e).classList.remove("!py-0"), d.findOne(`${Q}`, e).classList.remove("!h-0");
    });
  }
  _toggleStepClass(t, e, i) {
    i && this._steps[t].classList[e](i);
  }
  _bindKeysNavigation() {
    this._toggleStepTabIndex(
      !1,
      d.findOne(`${Z}`, this.activeStep)
    ), this._steps.forEach((t) => {
      const e = d.findOne(`${Z}`, t);
      c.on(e, ul, (i) => {
        const n = d.parents(
          i.currentTarget,
          `${Kt}`
        )[0], o = d.next(n, `${Kt}`)[0], r = d.prev(n, `${Kt}`)[0], a = d.findOne(
          `${Z}`,
          n
        ), l = d.findOne(
          `${Z}`,
          this.activeStep
        );
        let p = null, u = null;
        if (o && (p = d.findOne(`${Z}`, o)), r && (u = d.findOne(`${Z}`, r)), i.keyCode === Ke && this._currentView !== Ot && (u ? (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus()) : p && (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus())), i.keyCode === ze && this._currentView !== Ot && (p ? (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus()) : u && (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus())), i.keyCode === z && this._currentView === Ot && (i.preventDefault(), p && (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus())), i.keyCode === U && this._currentView === Ot && (i.preventDefault(), u && (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus())), i.keyCode === Te) {
          const _ = d.findOne(
            `${Z}`,
            this._steps[0]
          );
          this._toggleStepTabIndex(a, _), this._toggleOutlineStyles(a, _), _.focus();
        }
        if (i.keyCode === Ee) {
          const _ = this._steps[this._steps.length - 1], f = d.findOne(`${Z}`, _);
          this._toggleStepTabIndex(a, f), this._toggleOutlineStyles(a, f), f.focus();
        }
        (i.keyCode === it || i.keyCode === Zs) && (i.preventDefault(), this.changeStep(this._steps.indexOf(n))), i.keyCode === ke && (this._toggleStepTabIndex(a, l), this._toggleOutlineStyles(a, !1), l.focus());
      }), c.on(e, zg, (i) => {
        const n = d.parents(
          i.currentTarget,
          `${Kt}`
        )[0], o = d.findOne(
          `${Z}`,
          n
        ), r = d.findOne(
          `${Z}`,
          this.activeStep
        );
        i.keyCode === ke && (this._toggleStepTabIndex(o, r), this._toggleOutlineStyles(!1, r), r.focus());
      });
    });
  }
  _toggleStepTabIndex(t, e) {
    t && t.setAttribute("tabIndex", -1), e && e.setAttribute("tabIndex", 0);
  }
  _toggleOutlineStyles(t, e) {
    t && (t.style.outline = ""), e && (e.style.outline = "revert");
  }
  _toggleDisabled() {
    const t = d.find(`${Z}`, this._element), e = d.find(
      `${ks}`,
      this._element
    );
    t[this._activeStepIndex].classList.add("color-[#858585]"), t[this._activeStepIndex].classList.add("cursor-default"), e[this._activeStepIndex].classList.add("!bg-[#858585]"), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperDisabled
    );
  }
  _toggleActive(t) {
    const e = d.find(
      `${_l}`,
      this._element
    ), i = d.find(
      `${ks}`,
      this._element
    );
    e[t].classList.add("font-medium"), i[t].classList.add("!bg-primary-100"), i[t].classList.add("!text-primary-700"), i[t].classList.remove("!bg-success-100"), i[t].classList.remove("!text-success-700"), e[this._activeStepIndex].classList.remove("font-medium"), i[this._activeStepIndex].classList.remove("!bg-primary-100"), i[this._activeStepIndex].classList.remove(
      "!text-primary-700"
    ), this._toggleStepClass(t, "add", this._options.stepperActive), this._toggleStepClass(
      this._activeStepIndex,
      "remove",
      this._options.stepperActive
    );
  }
  _toggleCompleted(t) {
    const e = d.find(
      `${ks}`,
      this._element
    );
    this._options.stepperNoEditable ? this._steps[t].classList.add("pointer-events-none") : (e[t].classList.add("!bg-success-100"), e[t].classList.add("!text-success-700")), e[t].classList.remove("!bg-danger-100"), e[t].classList.remove("!text-danger-700"), this._toggleStepClass(t, "add", this._options.stepperCompleted), this._toggleStepClass(t, "remove", this._options.stepperInvalid);
  }
  _hideInactiveSteps() {
    this._steps.forEach((t) => {
      if (!t.getAttribute("data-te")) {
        const e = d.findOne(`${Q}`, t);
        e.classList.remove("translate-x-[150%]"), this._hideElement(e);
      }
    });
  }
  _setHeight(t) {
    const e = d.findOne(`${Q}`, t), i = getComputedStyle(e), n = d.findOne(`${Z}`, t), o = getComputedStyle(n), r = e.offsetHeight + parseFloat(i.marginTop) + parseFloat(i.marginBottom), a = n.offsetHeight + parseFloat(o.marginTop) + parseFloat(o.marginBottom);
    this._element.style.height = `${a + r}px`;
  }
  _hideElement(t) {
    !d.parents(
      t,
      `${Kt}`
    )[0].getAttribute("data-te") && this._currentView !== Ot ? t.style.display = "none" : (t.classList.add("!my-0"), t.classList.add("!py-0"), t.classList.add("!h-0"));
  }
  _showElement(t) {
    this._currentView === Ot ? (t.classList.remove("!my-0"), t.classList.remove("!py-0"), t.classList.remove("!h-0")) : t.style.display = "block";
  }
  _animateHorizontalStep(t) {
    clearTimeout(this._timeout), this._clearStepsAnimation();
    const e = t > this._activeStepIndex, i = d.findOne(
      `${Q}`,
      this._steps[t]
    ), n = d.findOne(
      `${Q}`,
      this.activeStep
    );
    let o, r;
    this._steps.forEach((a, l) => {
      const p = d.findOne(`${Q}`, a);
      l !== t && l !== this._activeStepIndex && this._hideElement(p);
    }), e ? (r = this._options.slideOutLeftAnimation, o = this._options.slideInRightAnimation) : (r = this._options.slideOutRightAnimation, o = this._options.slideInLeftAnimation), n.classList.add(r), i.classList.add(o), this._setHeight(this._steps[t]), this._timeout = setTimeout(() => {
      this._hideElement(n), this._clearStepsAnimation();
    }, this._options.stepperAnimationDuration);
  }
  _clearStepsAnimation() {
    this._steps.forEach((t) => {
      d.findOne(`${Q}`, t).classList.remove(
        this._options.slideInLeftAnimation,
        this._options.slideOutLeftAnimation,
        this._options.slideInRightAnimation,
        this._options.slideOutRightAnimation
      );
    });
  }
  _animateVerticalStep(t) {
    const e = d.findOne(
      `${Q}`,
      this._steps[t]
    ), i = d.findOne(
      `${Q}`,
      this.activeStep
    );
    this._hideElement(i), this._showElement(e);
  }
  static getInstance(t) {
    return A.getData(t, tn);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const fl = "data-te-input-state-active", xs = "data-te-input-selected", ml = "data-te-input-multiple-active", gl = "[data-te-form-check-input]";
class bl {
  constructor(t, e, i, n, o, r, a, l, p, u, _) {
    this.id = t, this.nativeOption = e, this.multiple = i, this.value = n, this.label = o, this.selected = r, this.disabled = a, this.hidden = l, this.secondaryText = p, this.groupId = u, this.icon = _, this.node = null, this.active = !1;
  }
  select() {
    this.multiple ? this._selectMultiple() : this._selectSingle();
  }
  _selectSingle() {
    this.selected || (this.node.setAttribute(xs, ""), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0));
  }
  _selectMultiple() {
    if (!this.selected) {
      const t = d.findOne(
        gl,
        this.node
      );
      t.checked = !0, this.node.setAttribute(xs, ""), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0);
    }
  }
  deselect() {
    this.multiple ? this._deselectMultiple() : this._deselectSingle();
  }
  _deselectSingle() {
    this.selected && (this.node.removeAttribute(xs), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1));
  }
  _deselectMultiple() {
    if (this.selected) {
      const t = d.findOne(
        gl,
        this.node
      );
      t.checked = !1, this.node.removeAttribute(xs), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1);
    }
  }
  setNode(t) {
    this.node = t;
  }
  setActiveStyles() {
    if (!this.active) {
      if (this.multiple) {
        this.node.setAttribute(ml, "");
        return;
      }
      this.active = !0, this.node.setAttribute(fl, "");
    }
  }
  removeActiveStyles() {
    this.active && (this.active = !1, this.node.removeAttribute(fl)), this.multiple && this.node.removeAttribute(ml);
  }
}
class Ug {
  constructor(t = !1) {
    this._multiple = t, this._selections = [];
  }
  select(t) {
    this._multiple ? this._selections.push(t) : this._selections = [t];
  }
  deselect(t) {
    if (this._multiple) {
      const e = this._selections.findIndex(
        (i) => t === i
      );
      this._selections.splice(e, 1);
    } else
      this._selections = [];
  }
  clear() {
    this._selections = [];
  }
  get selection() {
    return this._selections[0];
  }
  get selections() {
    return this._selections;
  }
  get label() {
    return this._selections[0] && this.selection.label;
  }
  get labels() {
    return this._selections.map((t) => t.label).join(", ");
  }
  get value() {
    return this.selections[0] && this.selection.value;
  }
  get values() {
    return this._selections.map((t) => t.value);
  }
}
function Qo(s) {
  return s.filter((t) => !t.disabled).every((t) => t.selected);
}
const Xg = "data-te-select-form-outline-ref", Gg = "data-te-select-wrapper-ref", qg = "data-te-select-input-ref", Zg = "data-te-select-clear-btn-ref", Qg = "data-te-select-dropdown-container-ref", Jg = "data-te-select-dropdown-ref", tb = "data-te-select-options-wrapper-ref", eb = "data-te-select-options-list-ref", ib = "data-te-select-input-filter-ref", Eh = "data-te-select-option-ref", sb = "data-te-select-option-all-ref", nb = "data-te-select-option-text-ref", ob = "data-te-form-check-input", rb = "data-te-select-option-group-ref", ab = "data-te-select-option-group-label-ref", Ch = "data-te-select-selected", lb = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
</svg>
`, cb = (s) => {
  s.code === "Tab" || s.code === "Esc" || s.preventDefault();
};
function Os(s, t, e, i, n) {
  t.selectSize === "default" && h.addClass(s, e), t.selectSize === "sm" && h.addClass(s, i), t.selectSize === "lg" && h.addClass(s, n);
}
function hb(s, t, e, i, n) {
  const o = document.createElement("div");
  o.setAttribute("id", s), o.setAttribute(Gg, "");
  const r = $("div");
  r.setAttribute(Xg, ""), h.addClass(r, i.formOutline);
  const a = $("input"), l = t.selectFilter ? "combobox" : "listbox", p = t.multiple ? "true" : "false", u = t.disabled ? "true" : "false";
  a.setAttribute(qg, ""), h.addClass(a, i.selectInput), Os(
    a,
    t,
    i.selectInputSizeDefault,
    i.selectInputSizeSm,
    i.selectInputSizeLg
  ), t.selectFormWhite && h.addClass(a, i.selectInputWhite), a.setAttribute("type", "text"), a.setAttribute("role", l), a.setAttribute("aria-multiselectable", p), a.setAttribute("aria-disabled", u), a.setAttribute("aria-haspopup", "true"), a.setAttribute("aria-expanded", !1), t.tabIndex && a.setAttribute("tabIndex", t.tabIndex), t.disabled && a.setAttribute("disabled", ""), t.selectPlaceholder !== "" && a.setAttribute("placeholder", t.selectPlaceholder), t.selectValidation ? (h.addStyle(a, {
    "pointer-events": "none",
    "caret-color": "transparent"
  }), h.addStyle(r, { cursor: "pointer" })) : a.setAttribute("readonly", "true"), t.selectValidation && (a.setAttribute("required", "true"), a.setAttribute("aria-required", "true"), a.addEventListener("keydown", cb));
  const _ = $("div");
  h.addClass(_, i.selectValidationValid);
  const f = document.createTextNode(
    `${t.selectValidFeedback}`
  );
  _.appendChild(f);
  const g = $("div");
  h.addClass(g, i.selectValidationInvalid);
  const m = document.createTextNode(
    `${t.selectInvalidFeedback}`
  );
  g.appendChild(m);
  const b = $("span");
  b.setAttribute(Zg, ""), h.addClass(b, i.selectClearBtn), Os(
    b,
    t,
    i.selectClearBtnDefault,
    i.selectClearBtnSm,
    i.selectClearBtnLg
  ), t.selectFormWhite && h.addClass(b, i.selectClearBtnWhite);
  const v = document.createTextNode("â");
  b.appendChild(v), b.setAttribute("tabindex", "0");
  const T = $("span");
  return h.addClass(T, i.selectArrow), Os(
    T,
    t,
    i.selectArrowDefault,
    i.selectArrowSm,
    i.selectArrowLg
  ), t.selectFormWhite && h.addClass(T, i.selectArrowWhite), T.innerHTML = n || lb, r.appendChild(a), e && (h.addClass(e, i.selectLabel), Os(
    e,
    t,
    i.selectLabelSizeDefault,
    i.selectLabelSizeSm,
    i.selectLabelSizeLg
  ), t.selectFormWhite && h.addClass(e, i.selectLabelWhite), r.appendChild(e)), t.selectValidation && (r.appendChild(_), r.appendChild(g)), t.selectClearButton && r.appendChild(b), r.appendChild(T), o.appendChild(r), o;
}
function vl(s, t, e, i, n, o, r, a) {
  const l = document.createElement("div");
  l.setAttribute(Qg, ""), h.addClass(l, a.selectDropdownContainer), l.setAttribute("id", `${s}`), l.style.width = `${e}px`;
  const p = document.createElement("div");
  p.setAttribute("tabindex", 0), p.setAttribute(Jg, ""), h.addClass(p, a.dropdown);
  const u = $("div");
  u.setAttribute(tb, ""), h.addClass(u, a.optionsWrapper), h.addClass(u, a.optionsWrapperScrollbar), u.style.maxHeight = `${i}px`;
  const _ = Ah(
    o,
    n,
    t,
    a
  );
  return u.appendChild(_), t.selectFilter && p.appendChild(
    db(t.selectSearchPlaceholder, a)
  ), p.appendChild(u), r && p.appendChild(r), l.appendChild(p), l;
}
function Ah(s, t, e, i) {
  const n = $("div");
  n.setAttribute(eb, ""), h.addClass(n, i.optionsList);
  let o;
  return e.multiple ? o = pb(
    s,
    t,
    e,
    i
  ) : o = ub(s, e, i), o.forEach((r) => {
    n.appendChild(r);
  }), n;
}
function db(s, t) {
  const e = $("div");
  h.addClass(e, t.inputGroup);
  const i = $("input");
  return i.setAttribute(ib, ""), h.addClass(i, t.selectFilterInput), i.placeholder = s, i.setAttribute("role", "searchbox"), i.setAttribute("type", "text"), e.appendChild(i), e;
}
function ub(s, t, e) {
  return yh(s, t, e);
}
function pb(s, t, e, i) {
  let n = null;
  e.selectAll && (n = _b(
    t,
    s,
    e,
    i
  ));
  const o = yh(s, e, i);
  return n ? [n, ...o] : o;
}
function yh(s, t, e) {
  const i = [];
  return s.forEach((n) => {
    if (Object.prototype.hasOwnProperty.call(
      n,
      "options"
    )) {
      const r = bb(n, t, e);
      i.push(r);
    } else
      i.push(wh(n, t, e));
  }), i;
}
function _b(s, t, e, i) {
  const n = Qo(t), o = $("div");
  o.setAttribute(Eh, "");
  const r = i.selectAllOption || i.selectOption;
  return h.addClass(o, r), o.setAttribute(sb, ""), h.addStyle(o, {
    height: `${e.selectOptionHeight}px`
  }), o.setAttribute("role", "option"), o.setAttribute("aria-selected", n), n && o.setAttribute(Ch, ""), o.appendChild(kh(s, e, i)), s.setNode(o), o;
}
function wh(s, t, e) {
  if (s.node)
    return s.node;
  const i = $("div");
  return i.setAttribute(Eh, ""), h.addClass(i, e.selectOption), h.addStyle(i, {
    height: `${t.selectOptionHeight}px`
  }), h.setDataAttribute(i, "id", s.id), i.setAttribute("role", "option"), i.setAttribute("aria-selected", s.selected), i.setAttribute("aria-disabled", s.disabled), s.selected && i.setAttribute(Ch, ""), s.disabled && i.setAttribute("data-te-select-option-disabled", !0), s.hidden && h.addClass(i, "hidden"), i.appendChild(kh(s, t, e)), s.icon && i.appendChild(gb(s, e)), s.setNode(i), i;
}
function kh(s, t, e) {
  const i = $("span");
  i.setAttribute(nb, ""), h.addClass(i, e.selectOptionText);
  const n = document.createTextNode(s.label);
  return t.multiple && i.appendChild(mb(s, e)), i.appendChild(n), (s.secondaryText || typeof s.secondaryText == "number") && i.appendChild(
    fb(s.secondaryText, e)
  ), i;
}
function fb(s, t) {
  const e = $("span");
  h.addClass(e, t.selectOptionSecondaryText);
  const i = document.createTextNode(s);
  return e.appendChild(i), e;
}
function mb(s, t) {
  const e = $("input");
  e.setAttribute("type", "checkbox"), h.addClass(e, t.formCheckInput), e.setAttribute(ob, "");
  const i = $("label");
  return s.selected && e.setAttribute("checked", !0), s.disabled && e.setAttribute("disabled", !0), e.appendChild(i), e;
}
function gb(s, t) {
  const e = $("span"), i = $("img");
  return h.addClass(i, t.selectOptionIcon), i.src = s.icon, e.appendChild(i), e;
}
function bb(s, t, e) {
  const i = $("div");
  i.setAttribute(rb, ""), h.addClass(i, e.selectOptionGroup), i.setAttribute("role", "group"), i.setAttribute("id", s.id), s.hidden && h.addClass(i, "hidden");
  const n = $("label");
  return n.setAttribute(ab, ""), h.addClass(n, e.selectOptionGroupLabel), h.addStyle(n, { height: `${t.selectOptionHeight}px` }), n.setAttribute("for", s.id), n.textContent = s.label, i.appendChild(n), s.options.forEach((o) => {
    i.appendChild(wh(o, t, e));
  }), i;
}
function vb(s, t) {
  const e = $("div");
  return e.textContent = s, h.addClass(e, t.selectLabel), h.addClass(e, t.selectFakeValue), e;
}
const mo = "select", yi = "te.select", Xi = `.${yi}`, Tb = `close${Xi}`, Eb = `open${Xi}`, Tl = `optionSelect${Xi}`, El = `optionDeselect${Xi}`, Cb = `valueChange${Xi}`, Ab = "change", Cl = "data-te-select-init", xh = "data-te-select-no-results-ref", Al = "data-te-select-open", J = "data-te-input-state-active", zt = "data-te-input-focused", go = "data-te-input-disabled", yb = "data-te-select-option-group-label-ref", wb = "data-te-select-option-all-ref", bi = "data-te-select-selected", kb = "[data-te-select-label-ref]", yl = "[data-te-select-input-ref]", xb = "[data-te-select-input-filter-ref]", Ob = "[data-te-select-dropdown-ref]", Sb = "[data-te-select-options-wrapper-ref]", wl = "[data-te-select-options-list-ref]", Ib = "[data-te-select-option-ref]", Db = "[data-te-select-clear-btn-ref]", $b = "[data-te-select-custom-content-ref]", Lb = `[${xh}]`, kl = "[data-te-select-form-outline-ref]", Nb = "[data-te-select-toggle]", bo = "[data-te-input-notch-ref]", Mb = {
  selectAutoSelect: !1,
  selectContainer: "body",
  selectClearButton: !1,
  disabled: !1,
  selectDisplayedLabels: 5,
  selectFormWhite: !1,
  multiple: !1,
  selectOptionsSelectedLabel: "options selected",
  selectOptionHeight: 38,
  selectAll: !0,
  selectAllLabel: "Select all",
  selectSearchPlaceholder: "Search...",
  selectSize: "default",
  selectVisibleOptions: 5,
  selectFilter: !1,
  selectFilterDebounce: 300,
  selectNoResultText: "No results",
  selectValidation: !1,
  selectValidFeedback: "Valid",
  selectInvalidFeedback: "Invalid",
  selectPlaceholder: ""
}, Rb = {
  selectAutoSelect: "boolean",
  selectContainer: "string",
  selectClearButton: "boolean",
  disabled: "boolean",
  selectDisplayedLabels: "number",
  selectFormWhite: "boolean",
  multiple: "boolean",
  selectOptionsSelectedLabel: "string",
  selectOptionHeight: "number",
  selectAll: "boolean",
  selectAllLabel: "string",
  selectSearchPlaceholder: "string",
  selectSize: "string",
  selectVisibleOptions: "number",
  selectFilter: "boolean",
  selectFilterDebounce: "number",
  selectNoResultText: "string",
  selectValidation: "boolean",
  selectValidFeedback: "string",
  selectInvalidFeedback: "string",
  selectPlaceholder: "string"
}, Pb = {
  dropdown: "relative outline-none min-w-[100px] m-0 scale-y-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-select-open]:scale-100 data-[te-select-open]:opacity-100 dark:bg-zinc-700",
  formCheckInput: "relative float-left mt-[0.15rem] mr-[8px] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 dark:border-neutral-600 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary dark:checked:border-primary checked:bg-primary dark:checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:ml-[0.25rem] checked:after:-mt-px checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-t-0 checked:after:border-l-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:ml-[0.25rem] checked:focus:after:-mt-px checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-t-0 checked:focus:after:border-l-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent",
  formOutline: "relative",
  initialized: "hidden",
  inputGroup: "flex items-center whitespace-nowrap p-2.5 text-center text-base font-normal leading-[1.6] text-gray-700 dark:bg-zinc-800 dark:text-gray-200 dark:placeholder:text-gray-200",
  noResult: "flex items-center px-4",
  optionsList: "list-none m-0 p-0",
  optionsWrapper: "overflow-y-auto",
  optionsWrapperScrollbar: "[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded",
  selectArrow: "absolute right-3 text-[0.8rem] cursor-pointer peer-focus:text-primary peer-data-[te-input-focused]:text-primary group-data-[te-was-validated]/validation:peer-valid:text-green-600 group-data-[te-was-validated]/validation:peer-invalid:text-[rgb(220,76,100)] w-5 h-5",
  selectArrowWhite: "text-gray-50 peer-focus:!text-white peer-data-[te-input-focused]:!text-white",
  selectArrowDefault: "top-2",
  selectArrowLg: "top-[13px]",
  selectArrowSm: "top-1",
  selectClearBtn: "absolute top-2 right-9 text-black cursor-pointer focus:text-primary outline-none dark:text-gray-200",
  selectClearBtnWhite: "!text-gray-50",
  selectClearBtnDefault: "top-2 text-base",
  selectClearBtnLg: "top-[11px] text-base",
  selectClearBtnSm: "top-1 text-[0.8rem]",
  selectDropdownContainer: "z-[1070]",
  selectFakeValue: "transform-none hidden data-[te-input-state-active]:block",
  selectFilterInput: "relative m-0 block w-full min-w-0 flex-auto rounded border border-solid border-gray-300 bg-transparent bg-clip-padding px-3 py-1.5 text-base font-normal text-gray-700 transition duration-300 ease-in-out motion-reduce:transition-none focus:border-primary focus:text-gray-700 focus:shadow-te-primary focus:outline-none dark:text-gray-200 dark:placeholder:text-gray-200",
  selectInput: "peer block min-h-[auto] w-full rounded border-0 bg-transparent outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0 cursor-pointer data-[te-input-disabled]:bg-[#e9ecef] data-[te-input-disabled]:cursor-default group-data-[te-was-validated]/validation:mb-4 dark:data-[te-input-disabled]:bg-zinc-600",
  selectInputWhite: "!text-gray-50",
  selectInputSizeDefault: "py-[0.32rem] px-3 leading-[1.6]",
  selectInputSizeLg: "py-[0.32rem] px-3 leading-[2.15]",
  selectInputSizeSm: "py-[0.33rem] px-3 text-xs leading-[1.5]",
  selectLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate text-gray-500 transition-all duration-200 ease-out peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200 data-[te-input-state-active]:scale-[0.8] dark:peer-focus:text-primary",
  selectLabelWhite: "!text-gray-50",
  selectLabelSizeDefault: "pt-[0.37rem] leading-[1.6] peer-focus:-translate-y-[0.9rem] peer-data-[te-input-state-active]:-translate-y-[0.9rem] data-[te-input-state-active]:-translate-y-[0.9rem]",
  selectLabelSizeLg: "pt-[0.37rem] leading-[2.15] peer-focus:-translate-y-[1.15rem] peer-data-[te-input-state-active]:-translate-y-[1.15rem] data-[te-input-state-active]:-translate-y-[1.15rem]",
  selectLabelSizeSm: "pt-[0.37rem] text-xs leading-[1.5] peer-focus:-translate-y-[0.75rem] peer-data-[te-input-state-active]:-translate-y-[0.75rem] data-[te-input-state-active]:-translate-y-[0.75rem]",
  selectOption: "flex flex-row items-center justify-between w-full px-4 truncate text-gray-700 bg-transparent select-none cursor-pointer data-[te-input-multiple-active]:bg-black/5 hover:[&:not([data-te-select-option-disabled])]:bg-black/5 data-[te-input-state-active]:bg-black/5 data-[te-select-option-selected]:data-[te-input-state-active]:bg-black/5 data-[te-select-selected]:data-[te-select-option-disabled]:cursor-default data-[te-select-selected]:data-[te-select-option-disabled]:text-gray-400 data-[te-select-selected]:data-[te-select-option-disabled]:bg-transparent data-[te-select-option-selected]:bg-black/[0.02] data-[te-select-option-disabled]:text-gray-400 data-[te-select-option-disabled]:cursor-default group-data-[te-select-option-group-ref]/opt:pl-7 dark:text-gray-200 dark:hover:[&:not([data-te-select-option-disabled])]:bg-white/30 dark:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-selected]:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-disabled]:text-gray-400 dark:data-[te-input-multiple-active]:bg-white/30",
  selectAllOption: "",
  selectOptionGroup: "group/opt",
  selectOptionGroupLabel: "flex flex-row items-center w-full px-4 truncate bg-transparent text-black/50 select-none dark:text-gray-300",
  selectOptionIcon: "w-7 h-7 rounded-full",
  selectOptionSecondaryText: "block text-[0.8rem] text-gray-500 dark:text-gray-300",
  selectOptionText: "group",
  selectValidationValid: "hidden absolute -mt-3 w-auto text-sm text-green-600 cursor-pointer group-data-[te-was-validated]/validation:peer-valid:block",
  selectValidationInvalid: "hidden absolute -mt-3 w-auto text-sm text-[rgb(220,76,100)] cursor-pointer group-data-[te-was-validated]/validation:peer-invalid:block"
}, Bb = {
  dropdown: "string",
  formCheckInput: "string",
  formOutline: "string",
  initialized: "string",
  inputGroup: "string",
  noResult: "string",
  optionsList: "string",
  optionsWrapper: "string",
  optionsWrapperScrollbar: "string",
  selectArrow: "string",
  selectArrowDefault: "string",
  selectArrowLg: "string",
  selectArrowSm: "string",
  selectClearBtn: "string",
  selectClearBtnDefault: "string",
  selectClearBtnLg: "string",
  selectClearBtnSm: "string",
  selectDropdownContainer: "string",
  selectFakeValue: "string",
  selectFilterInput: "string",
  selectInput: "string",
  selectInputSizeDefault: "string",
  selectInputSizeLg: "string",
  selectInputSizeSm: "string",
  selectLabel: "string",
  selectLabelSizeDefault: "string",
  selectLabelSizeLg: "string",
  selectLabelSizeSm: "string",
  selectOption: "string",
  selectAllOption: "string",
  selectOptionGroup: "string",
  selectOptionGroupLabel: "string",
  selectOptionIcon: "string",
  selectOptionSecondaryText: "string",
  selectOptionText: "string"
};
class kr {
  constructor(t, e, i) {
    this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._config.selectPlaceholder && !this._config.multiple && this._addPlaceholderOption(), this._optionsToRender = this._getOptionsToRender(t), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._filteredOptionsList = null, this._selectionModel = new Ug(this.multiple), this._activeOptionIndex = -1, this._activeOption = null, this._wrapperId = et("select-wrapper-"), this._dropdownContainerId = et("select-dropdown-container-"), this._selectAllId = et("select-all-"), this._debounceTimeoutId = null, this._dropdownHeight = this._config.selectOptionHeight * this._config.selectVisibleOptions, this._popper = null, this._input = null, this._label = d.next(this._element, kb)[0], this._notch = null, this._fakeValue = null, this._isFakeValueActive = !1, this._customContent = d.next(
      t,
      $b
    )[0], this._toggleButton = null, this._elementToggle = null, this._wrapper = null, this._inputEl = null, this._dropdownContainer = null, this._container = null, this._selectAllOption = null, this._init(), this._mutationObserver = null, this._isOpen = !1, this._addMutationObserver(), this._element && A.setData(t, yi, this);
  }
  static get NAME() {
    return mo;
  }
  get filterInput() {
    return d.findOne(
      xb,
      this._dropdownContainer
    );
  }
  get dropdown() {
    return d.findOne(Ob, this._dropdownContainer);
  }
  get optionsList() {
    return d.findOne(
      wl,
      this._dropdownContainer
    );
  }
  get optionsWrapper() {
    return d.findOne(
      Sb,
      this._dropdownContainer
    );
  }
  get clearButton() {
    return d.findOne(Db, this._wrapper);
  }
  get options() {
    return this._filteredOptionsList ? this._filteredOptionsList : this._plainOptions;
  }
  get value() {
    return this.multiple ? this._selectionModel.values : this._selectionModel.value;
  }
  get multiple() {
    return this._config.multiple;
  }
  get hasSelectAll() {
    return this.multiple && this._config.selectAll;
  }
  get hasSelection() {
    return this._selectionModel.selection || this._selectionModel.selections.length > 0;
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...Mb,
      ...e,
      ...t
    }, this._element.hasAttribute("multiple") && (t.multiple = !0), this._element.hasAttribute("disabled") && (t.disabled = !0), this._element.tabIndex && (t.tabIndex = this._element.getAttribute("tabIndex")), I(mo, t, Rb), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...Pb,
      ...e,
      ...t
    }, I(mo, t, Bb), t;
  }
  _addPlaceholderOption() {
    const t = new Option("", "", !0, !0);
    t.hidden = !0, t.selected = !0, this._element.prepend(t);
  }
  _getOptionsToRender(t) {
    const e = [];
    return t.childNodes.forEach((n) => {
      if (n.nodeName === "OPTGROUP") {
        const o = {
          id: et("group-"),
          label: n.label,
          disabled: n.hasAttribute("disabled"),
          hidden: n.hasAttribute("hidden"),
          options: []
        };
        n.childNodes.forEach((a) => {
          a.nodeName === "OPTION" && o.options.push(
            this._createOptionObject(a, o)
          );
        }), e.push(o);
      } else
        n.nodeName === "OPTION" && e.push(this._createOptionObject(n));
    }), e;
  }
  _getPlainOptions(t) {
    if (!d.findOne("optgroup", this._element))
      return t;
    const i = [];
    return t.forEach((n) => {
      Object.prototype.hasOwnProperty.call(
        n,
        "options"
      ) ? n.options.forEach((r) => {
        i.push(r);
      }) : i.push(n);
    }), i;
  }
  _createOptionObject(t, e = {}) {
    const i = et("option-"), n = e.id ? e.id : null, o = e.disabled ? e.disabled : !1, r = t.selected || t.hasAttribute(bi), a = t.hasAttribute("disabled") || o, l = t.hasAttribute("hidden") || e && e.hidden, p = this.multiple, u = t.value, _ = t.label, f = h.getDataAttribute(
      t,
      "selectSecondaryText"
    ), g = h.getDataAttribute(t, "select-icon");
    return new bl(
      i,
      t,
      p,
      u,
      _,
      r,
      a,
      l,
      f,
      n,
      g
    );
  }
  _getNavigationOptions() {
    const t = this.options.filter((e) => !e.hidden);
    return this.hasSelectAll ? [this._selectAllOption, ...t] : t;
  }
  _init() {
    this._renderMaterialWrapper(), this._wrapper = d.findOne(`#${this._wrapperId}`), this._input = d.findOne(yl, this._wrapper), this._config.disabled && this._input.setAttribute(go, "");
    const t = this._config.selectContainer;
    t === "body" ? this._container = document.body : this._container = d.findOne(t), this._initOutlineInput(), this._setDefaultSelections(), this._updateInputValue(), this._appendFakeValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._bindComponentEvents(), this.hasSelectAll && (this._selectAllOption = this._createSelectAllOption()), this._dropdownContainer = vl(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent,
      this._classes
    ), this._setFirstActiveOption(), this._listenToFocusChange();
  }
  _renderMaterialWrapper() {
    const t = hb(
      this._wrapperId,
      this._config,
      this._label,
      this._classes,
      this._config.customArrow
    );
    this._element.parentNode.insertBefore(t, this._element), h.addClass(this._element, this._classes.initialized), t.appendChild(this._element);
  }
  _initOutlineInput() {
    const t = d.findOne(
      kl,
      this._wrapper
    );
    new V(
      t,
      {
        inputFormWhite: this._config.selectFormWhite
      },
      this._classes
    ).init(), this._notch = d.findOne(bo, this._wrapper);
  }
  _bindComponentEvents() {
    this._listenToComponentKeydown(), this._listenToWrapperClick(), this._listenToClearBtnClick(), this._listenToClearBtnKeydown();
  }
  _setDefaultSelections() {
    this.options.forEach((t) => {
      t.selected && this._selectionModel.select(t);
    });
  }
  _listenToComponentKeydown() {
    c.on(this._wrapper, "keydown", this._handleKeydown.bind(this));
  }
  _handleKeydown(t) {
    this._isOpen && !this._config.selectFilter ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t);
  }
  _handleOpenKeydown(t) {
    const e = t.keyCode, i = e === we || e === U && t.altKey || e === ke;
    if (e === ke && this._config.selectAutoSelect && !this.multiple && this._handleAutoSelection(this._activeOption), i) {
      this.close(), this._input.focus();
      return;
    }
    switch (e) {
      case z:
        this._setNextOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case U:
        this._setPreviousOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case Te:
        this._setFirstOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case Ee:
        this._setLastOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case it:
        t.preventDefault(), this._activeOption && (this.hasSelectAll && this._activeOptionIndex === 0 ? this._handleSelectAll() : this._handleSelection(this._activeOption));
        return;
      default:
        return;
    }
    t.preventDefault();
  }
  _handleClosedKeydown(t) {
    const e = t.keyCode;
    if (e === it && t.preventDefault(), (e === it || e === z && t.altKey || e === z && this.multiple) && this.open(), this.multiple)
      switch (e) {
        case z:
          this.open();
          break;
        case U:
          this.open();
          break;
        default:
          return;
      }
    else
      switch (e) {
        case z:
          this._setNextOptionActive(), this._handleSelection(this._activeOption);
          break;
        case U:
          this._setPreviousOptionActive(), this._handleSelection(this._activeOption);
          break;
        case Te:
          this._setFirstOptionActive(), this._handleSelection(this._activeOption);
          break;
        case Ee:
          this._setLastOptionActive(), this._handleSelection(this._activeOption);
          break;
        default:
          return;
      }
    t.preventDefault();
  }
  _scrollToOption(t) {
    if (!t)
      return;
    let e;
    const i = this.options.filter((u) => !u.hidden);
    this.hasSelectAll ? e = i.indexOf(t) + 1 : e = i.indexOf(t);
    const n = this._getNumberOfGroupsBeforeOption(e), o = e + n, r = this.optionsWrapper, a = r.offsetHeight, l = this._config.selectOptionHeight, p = r.scrollTop;
    if (e > -1) {
      const u = o * l, _ = u + l > p + a;
      u < p ? r.scrollTop = u : _ ? r.scrollTop = u - a + l : r.scrollTop = p;
    }
  }
  _getNumberOfGroupsBeforeOption(t) {
    const e = this.options.filter((r) => !r.hidden), i = this._optionsToRender.filter((r) => !r.hidden), n = this.hasSelectAll ? t - 1 : t;
    let o = 0;
    for (let r = 0; r <= n; r++)
      e[r].groupId && i[o] && i[o].id && e[r].groupId === i[o].id && o++;
    return o;
  }
  _setNextOptionActive() {
    let t = this._activeOptionIndex + 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t += 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setPreviousOptionActive() {
    let t = this._activeOptionIndex - 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t -= 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setFirstOptionActive() {
    const e = this._getNavigationOptions();
    this._updateActiveOption(e[0], 0);
  }
  _setLastOptionActive() {
    const t = this._getNavigationOptions(), e = t.length - 1;
    this._updateActiveOption(t[e], e);
  }
  _updateActiveOption(t, e) {
    const i = this._activeOption;
    i && i.removeActiveStyles(), t.setActiveStyles(), this._activeOptionIndex = e, this._activeOption = t;
  }
  _listenToWrapperClick() {
    c.on(this._wrapper, "click", () => {
      this.toggle();
    });
  }
  _listenToClearBtnClick() {
    c.on(this.clearButton, "click", (t) => {
      t.preventDefault(), t.stopPropagation(), this._handleClear();
    });
  }
  _listenToClearBtnKeydown() {
    c.on(this.clearButton, "keydown", (t) => {
      t.keyCode === it && (this._handleClear(), t.preventDefault(), t.stopPropagation());
    });
  }
  _handleClear() {
    if (this.multiple)
      this._selectionModel.clear(), this._deselectAllOptions(this.options), this.hasSelectAll && this._updateSelectAllState();
    else {
      const t = this._selectionModel.selection;
      this._selectionModel.clear(), t.deselect();
    }
    this._fakeValue.textContent = "", this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(null), this._emitNativeChangeEvent();
  }
  _listenToOptionsClick() {
    c.on(this.optionsWrapper, "click", (t) => {
      if (t.target.hasAttribute(
        yb
      ))
        return;
      const i = t.target.nodeName === "DIV" ? t.target : d.closest(t.target, Ib);
      if (i.hasAttribute(wb)) {
        this._handleSelectAll();
        return;
      }
      const o = i.dataset.teId, r = this.options.find((a) => a.id === o);
      r && !r.disabled && this._handleSelection(r);
    });
  }
  _handleSelectAll() {
    this._selectAllOption.selected ? (this._deselectAllOptions(this.options), this._selectAllOption.deselect()) : (this._selectAllOptions(this.options), this._selectAllOption.select()), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _selectAllOptions(t) {
    t.forEach((e) => {
      !e.selected && !e.disabled && (this._selectionModel.select(e), e.select());
    });
  }
  _deselectAllOptions(t) {
    t.forEach((e) => {
      e.selected && !e.disabled && (this._selectionModel.deselect(e), e.deselect());
    });
  }
  _handleSelection(t) {
    this.multiple ? (this._handleMultiSelection(t), this.hasSelectAll && this._updateSelectAllState()) : this._handleSingleSelection(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleAutoSelection(t) {
    this._singleOptionSelect(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleSingleSelection(t) {
    this._singleOptionSelect(t), this.close(), this._input.focus();
  }
  _singleOptionSelect(t) {
    const e = this._selectionModel.selections[0];
    e && e !== t && (this._selectionModel.deselect(e), e.deselect(), e.node.setAttribute(bi, !1), c.trigger(this._element, El, {
      value: e.value
    })), (!e || e && t !== e) && (this._selectionModel.select(t), t.select(), t.node.setAttribute(bi, !0), c.trigger(this._element, Tl, {
      value: t.value
    }), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent());
  }
  _handleMultiSelection(t) {
    t.selected ? (this._selectionModel.deselect(t), t.deselect(), t.node.setAttribute(bi, !1), c.trigger(this._element, El, {
      value: t.value
    })) : (this._selectionModel.select(t), t.select(), t.node.setAttribute(bi, !0), c.trigger(this._element, Tl, {
      value: t.value
    })), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _emitValueChangeEvent(t) {
    c.trigger(this._element, Cb, { value: t });
  }
  _emitNativeChangeEvent() {
    c.trigger(this._element, Ab);
  }
  _updateInputValue() {
    const t = this.multiple ? this._selectionModel.labels : this._selectionModel.label;
    let e;
    this.multiple && this._config.selectDisplayedLabels !== -1 && this._selectionModel.selections.length > this._config.selectDisplayedLabels ? e = `${this._selectionModel.selections.length} ${this._config.selectOptionsSelectedLabel}` : e = t, !this.multiple && !this._isSelectionValid(this._selectionModel.selection) ? this._input.value = "" : this._isLabelEmpty(this._selectionModel.selection) ? this._input.value = " " : e ? this._input.value = e : this.multiple || !this._optionsToRender[0] ? this._input.value = "" : this._input.value = this._optionsToRender[0].label;
  }
  _isSelectionValid(t) {
    return !(t && (t.disabled || t.value === ""));
  }
  _isLabelEmpty(t) {
    return !!(t && t.label === "");
  }
  _appendFakeValue() {
    if (!this._selectionModel.selection || this._selectionModel._multiple)
      return;
    const t = this._selectionModel.selection.label;
    this._fakeValue = vb(t, this._classes), d.findOne(
      kl,
      this._wrapper
    ).appendChild(this._fakeValue);
  }
  _updateLabelPosition() {
    const t = this._element.hasAttribute(Cl), e = this._input.value !== "";
    this._label && (t && (e || this._isOpen || this._isFakeValueActive) ? (this._label.setAttribute(J, ""), this._notch.setAttribute(J, "")) : (this._label.removeAttribute(J), this._notch.removeAttribute(J, "")));
  }
  _updateLabelPositionWhileClosing() {
    this._label && (this._input.value !== "" || this._isFakeValueActive ? (this._label.setAttribute(J, ""), this._notch.setAttribute(J, "")) : (this._label.removeAttribute(J), this._notch.removeAttribute(J)));
  }
  _updateFakeLabelPosition() {
    this._fakeValue && (this._input.value === "" && this._fakeValue.innerHTML !== "" && !this._config.selectPlaceholder ? (this._isFakeValueActive = !0, this._fakeValue.setAttribute(J, "")) : (this._isFakeValueActive = !1, this._fakeValue.removeAttribute(J)));
  }
  _updateClearButtonVisibility() {
    if (!this.clearButton)
      return;
    this._selectionModel.selection || this._selectionModel.selections.length > 0 ? h.addStyle(this.clearButton, { display: "block" }) : h.addStyle(this.clearButton, { display: "none" });
  }
  _updateSelectAllState() {
    const t = this._selectAllOption.selected, e = Qo(this.options);
    !e && t ? this._selectAllOption.deselect() : e && !t && this._selectAllOption.select();
  }
  toggle() {
    this._isOpen ? this.close() : this.open();
  }
  open() {
    const t = this._config.disabled, e = c.trigger(this._element, Eb);
    this._isOpen || t || e.defaultPrevented || (this._openDropdown(), this._updateDropdownWidth(), this._setFirstActiveOption(), this._scrollToOption(this._activeOption), this._config.selectFilter && (setTimeout(() => {
      this.filterInput.focus();
    }, 0), this._listenToSelectSearch(), this._listenToDropdownKeydown()), this._listenToOptionsClick(), this._listenToOutsideClick(), this._listenToWindowResize(), this._isOpen = !0, this._updateLabelPosition(), this._setInputActiveStyles());
  }
  _openDropdown() {
    this._popper = se(this._input, this._dropdownContainer, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 1]
          }
        }
      ]
    }), this._container.appendChild(this._dropdownContainer), setTimeout(() => {
      this.dropdown.setAttribute(Al, "");
    }, 0);
  }
  _updateDropdownWidth() {
    const t = this._input.offsetWidth;
    h.addStyle(this._dropdownContainer, { width: `${t}px` });
  }
  _setFirstActiveOption() {
    const t = this._getNavigationOptions(), e = this._activeOption;
    e && e.removeActiveStyles();
    const i = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;
    i ? (this._activeOption = i, i.setActiveStyles(), this._activeOptionIndex = t.findIndex(
      (n) => n === i
    )) : (this._activeOption = null, this._activeOptionIndex = -1);
  }
  _setInputActiveStyles() {
    this._input.setAttribute(zt, ""), d.findOne(bo, this._wrapper).setAttribute(
      zt,
      ""
    );
  }
  _listenToWindowResize() {
    c.on(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleWindowResize() {
    this._dropdownContainer && this._updateDropdownWidth();
  }
  _listenToSelectSearch() {
    this.filterInput.addEventListener("input", (t) => {
      const e = t.target.value, i = this._config.selectFilterDebounce;
      this._debounceFilter(e, i);
    });
  }
  _debounceFilter(t, e) {
    this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {
      this._filterOptions(t);
    }, e);
  }
  _filterOptions(t) {
    const e = [];
    this._optionsToRender.forEach((o) => {
      const r = Object.prototype.hasOwnProperty.call(
        o,
        "options"
      ), a = !r && o.label.toLowerCase().includes(t.toLowerCase()), l = {};
      r && (l.label = o.label, l.options = this._filter(t, o.options), l.options.length > 0 && e.push(l)), a && e.push(o);
    });
    const i = this._config.selectNoResultText !== "", n = e.length !== 0;
    if (n)
      this._updateOptionsListTemplate(e), this._popper.forceUpdate(), this._filteredOptionsList = this._getPlainOptions(e), this.hasSelectAll && this._updateSelectAllState(), this._setFirstActiveOption();
    else if (!n && i) {
      const o = this._getNoResultTemplate();
      this.optionsWrapper.innerHTML = o;
    }
  }
  _updateOptionsListTemplate(t) {
    const e = d.findOne(wl, this._dropdownContainer) || d.findOne(Lb, this._dropdownContainer), i = Ah(
      t,
      this._selectAllOption,
      this._config,
      this._classes
    );
    this.optionsWrapper.removeChild(e), this.optionsWrapper.appendChild(i);
  }
  _getNoResultTemplate() {
    return `<div class="${this._classes.noResult}" ${xh} style="height: ${this._config.selectOptionHeight}px">${this._config.selectNoResultText}</div>`;
  }
  _filter(t, e) {
    const i = t.toLowerCase();
    return e.filter(
      (n) => n.label.toLowerCase().includes(i)
    );
  }
  _listenToDropdownKeydown() {
    c.on(
      this.dropdown,
      "keydown",
      this._handleOpenKeydown.bind(this)
    );
  }
  _listenToOutsideClick() {
    this._outsideClick = this._handleOutSideClick.bind(this), c.on(document, "click", this._outsideClick);
  }
  _listenToFocusChange(t = !0) {
    if (t === !1) {
      c.off(
        this._input,
        "focus",
        () => this._notch.setAttribute(zt, "")
      ), c.off(
        this._input,
        "blur",
        () => this._notch.removeAttribute(zt)
      );
      return;
    }
    c.on(
      this._input,
      "focus",
      () => this._notch.setAttribute(zt, "")
    ), c.on(
      this._input,
      "blur",
      () => this._notch.removeAttribute(zt)
    );
  }
  _handleOutSideClick(t) {
    const e = this._wrapper && this._wrapper.contains(t.target), i = t.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t.target);
    let o;
    this._toggleButton || (this._elementToggle = d.find(Nb)), this._elementToggle && this._elementToggle.forEach((r) => {
      const a = h.getDataAttribute(
        r,
        "select-toggle"
      );
      (a === this._element.id || this._element.classList.contains(a)) && (this._toggleButton = r, o = this._toggleButton.contains(t.target));
    }), !e && !i && !n && !o && this.close();
  }
  close() {
    const t = c.trigger(this._element, Tb), e = cn(
      this._dropdownContainer.children[0]
    );
    !this._isOpen || t.defaultPrevented || (this._config.selectFilter && this.hasSelectAll && (this._resetFilterState(), this._updateOptionsListTemplate(this._optionsToRender), this._config.multiple && this._updateSelectAllState()), this._removeDropdownEvents(), this.dropdown.removeAttribute(Al), setTimeout(() => {
      this._input.removeAttribute(zt), this._input.blur(), d.findOne(bo, this._wrapper).removeAttribute(
        zt
      ), this._label && !this.hasSelection && (this._label.removeAttribute(J), this._notch.setAttribute(J, ""), this._input.removeAttribute(J), this._notch.removeAttribute(J)), this._updateLabelPositionWhileClosing();
    }, 0), setTimeout(() => {
      this._container && this._dropdownContainer.parentNode === this._container && this._container.removeChild(this._dropdownContainer), this._popper.destroy(), this._isOpen = !1, c.off(this.dropdown, "transitionend");
    }, e));
  }
  _resetFilterState() {
    this.filterInput.value = "", this._filteredOptionsList = null;
  }
  _removeDropdownEvents() {
    c.off(document, "click", this._outsideClick), this._config.selectFilter && c.off(this.dropdown, "keydown"), c.off(this.optionsWrapper, "click");
  }
  _addMutationObserver() {
    this._mutationObserver = new MutationObserver(() => {
      this._wrapper && (this._updateSelections(), this._updateDisabledState());
    }), this._observeMutationObserver();
  }
  _updateSelections() {
    this._optionsToRender = this._getOptionsToRender(this._element), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._selectionModel.clear(), this._setDefaultSelections(), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this.hasSelectAll && this._updateSelectAllState();
    const t = this._config.filter && this.filterInput && this.filterInput.value;
    this._isOpen && !t ? (this._updateOptionsListTemplate(this._optionsToRender), this._setFirstActiveOption()) : this._isOpen && t ? (this._filterOptions(this.filterInput.value), this._setFirstActiveOption()) : this._dropdownContainer = vl(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent,
      this._classes
    );
  }
  _updateDisabledState() {
    const t = d.findOne(yl, this._wrapper);
    this._element.hasAttribute("disabled") ? (this._config.disabled = !0, t.setAttribute("disabled", ""), t.setAttribute(go, "")) : (this._config.disabled = !1, t.removeAttribute("disabled"), t.removeAttribute(go));
  }
  _observeMutationObserver() {
    this._mutationObserver && this._mutationObserver.observe(this._element, {
      attributes: !0,
      childList: !0,
      characterData: !0,
      subtree: !0
    });
  }
  _disconnectMutationObserver() {
    this.mutationObserver && (this._mutationObserver.disconnect(), this._mutationObserver = null);
  }
  _createSelectAllOption() {
    const t = this._selectAllId, e = null, i = !0, n = "select-all", o = this._config.selectAllLabel, r = Qo(this.options), a = !1, l = !1, p = null, u = null, _ = null;
    return new bl(
      t,
      e,
      i,
      n,
      o,
      r,
      a,
      l,
      p,
      u,
      _
    );
  }
  dispose() {
    this._removeComponentEvents(), this._destroyMaterialSelect(), this._listenToFocusChange(!1), A.removeData(this._element, yi);
  }
  _removeComponentEvents() {
    c.off(this.input, "click"), c.off(this.wrapper, this._handleKeydown.bind(this)), c.off(this.clearButton, "click"), c.off(this.clearButton, "keydown"), c.off(window, "resize", this._handleWindowResize.bind(this));
  }
  _destroyMaterialSelect() {
    this._isOpen && this.close(), this._destroyMaterialTemplate();
  }
  _destroyMaterialTemplate() {
    const t = this._wrapper.parentNode, e = d.find("label", this._wrapper);
    t.appendChild(this._element), e.forEach((i) => {
      t.appendChild(i);
    }), e.forEach((i) => {
      i.removeAttribute(J);
    }), h.removeClass(this._element, this._classes.initialized), this._element.removeAttribute(Cl), t.removeChild(this._wrapper);
  }
  setValue(t) {
    this.options.filter((i) => i.selected).forEach((i) => i.nativeOption.selected = !1), Array.isArray(t) ? t.forEach((i) => {
      this._selectByValue(i);
    }) : this._selectByValue(t), this._updateSelections(), this._emitValueChangeEvent(this.value);
  }
  _selectByValue(t) {
    const e = this.options.find(
      (i) => i.value === t
    );
    return e ? (e.nativeOption.selected = !0, !0) : !1;
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, yi);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new kr(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, yi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Hb = ({ inputID: s, labelText: t }, e) => `<div data-te-chips-input-wrapper data-te-input-wrapper-init class="${e.chipsInputWrapper}">
      <input
          type="text"
          class="${e.chipsInput}"
          id="${s}"
          placeholder="Example label" />
        <label
          for="${s}"
          class="${e.chipsLabel}"
          >${t}
        </label>
      </div>
    </div>`, Vb = ({ text: s, iconSVG: t }, e) => `<div data-te-chip-init data-te-ripple-init class="${e.chipElement}">
    <span data-te-chip-text>${s}</span> 
      <span data-te-chip-close class="${e.chipCloseIcon}">
        ${t}
      </span>
  </div>`, en = "chip", Wb = `te.${en}`, Oh = "data-te-chip-close", vo = `[${Oh}]`, Fb = "delete.te.chips", Yb = "select.te.chip", jb = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-3 h-3"> <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>', Kb = {
  text: "string",
  closeIcon: "boolean",
  img: "object",
  iconSVG: "string"
}, zb = {
  text: "",
  closeIcon: !1,
  img: { path: "", alt: "" },
  iconSVG: jb
}, Ub = {
  icon: "float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:text-[#8b8b8b] transition-all duration-200 ease-in-out",
  chipElement: "flex justify-between items-center h-[32px] leading-loose py-[5px] px-[12px] mr-4 my-[5px] text-[13px] font-normal text-[#4f4f4f] cursor-pointer bg-[#eceff1] dark:text-white dark:bg-neutral-600 rounded-[16px] transition-[opacity] duration-300 ease-linear [word-wrap: break-word] shadow-none normal-case hover:!shadow-none active:bg-[#cacfd1] inline-block font-medium leading-normal text-[#4f4f4f] text-center no-underline align-middle cursor-pointer select-none border-[.125rem] border-solid border-transparent py-1.5 px-3 text-xs rounded",
  chipCloseIcon: "w-4 float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:fill-[#8b8b8b] dark:fill-gray-400 dark:hover:fill-gray-100 transition-all duration-200 ease-in-out"
}, Xb = {
  icon: "string",
  chipElement: "string",
  chipCloseIcon: "string"
};
class vi {
  constructor(t, e = {}, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i);
  }
  // Getters
  static get NAME() {
    return en;
  }
  // Public
  init() {
    this._appendCloseIcon(), this._handleDelete(), this._handleTextChip(), this._handleClickOnChip();
  }
  dispose() {
    this._element = null, this._options = null, c.off(this._element, "click");
  }
  appendChip() {
    const { text: t, closeIcon: e, iconSVG: i } = this._options;
    return Vb({ text: t, closeIcon: e, iconSVG: i }, this._classes);
  }
  // Private
  _appendCloseIcon(t = this._element) {
    if (!(d.find(vo, this._element).length > 0) && this._options.closeIcon) {
      const e = $("span");
      e.classList = this._classes.icon, e.setAttribute(Oh), e.innerHTML = this._options.iconSVG, t.insertAdjacentElement("beforeend", e);
    }
  }
  _handleClickOnChip() {
    c.on(this._element, "click", (t) => {
      const { textContent: e } = t.target, i = {};
      i.tag = e.trim(), c.trigger(Yb, { event: t, obj: i });
    });
  }
  _handleDelete() {
    d.find(
      vo,
      this._element
    ).length !== 0 && c.on(this._element, "click", vo, () => {
      c.trigger(this._element, Fb), this._element.remove();
    });
  }
  _handleTextChip() {
    this._element.innerText === "" && (this._element.innerText = this._options.text);
  }
  _getConfig(t) {
    const e = {
      ...zb,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(en, e, Kb), e;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...Ub,
      ...e,
      ...t
    }, I(en, t, Xb), t;
  }
  static getInstance(t) {
    return A.getData(t, Wb);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Hi = "chips", Gi = `data-te-${Hi}`, xl = `te.${Hi}`, Gb = `${Gi}-input-init`, bt = `${Gi}-active`, Ol = `${Gi}-initial`, Sh = `${Gi}-placeholder`, qb = `${Gi}-input-wrapper`, Jo = "data-te-chip-init", Ih = "data-te-chip-close", Dh = "data-te-chip-text", Zb = `[${bt}]`, tr = `[${Jo}]`, Qb = `${tr}${Zb}`, To = `[${Ih}]`, Jb = `[${qb}]`, tv = `[${Dh}]`, ev = `[${Sh}]`, iv = "data-te-input-notch-leading-ref", sv = "data-te-input-notch-middle-ref", nv = `[${iv}]`, ov = `[${sv}]`, Ne = "data-te-input-state-active", Eo = "[data-te-input-notch-ref]", rv = "add.te.chips", av = "arrowDown.te.chips", lv = "arrowLeft.te.chips", cv = "arrowRight.te.chips", hv = "arrowUp.te.chips", Sl = "delete.te.chips", Il = "select.te.chips", dv = {
  inputID: "string",
  parentSelector: "string",
  initialValues: "array",
  editable: "boolean",
  labelText: "string",
  inputClasses: "object",
  inputOptions: "object"
}, uv = {
  inputID: et("chips-input-"),
  parentSelector: "",
  initialValues: [{ tag: "init1" }, { tag: "init2" }],
  editable: !1,
  labelText: "Example label",
  inputClasses: {},
  inputOptions: {}
}, pv = {
  opacity: "opacity-0",
  inputWrapperPadding: "p-[5px]",
  transition: "transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]",
  contentEditable: "outline-none !border-[3px] !border-solid !border-[#b2b3b4]",
  chipsInputWrapper: "relative flex items-center flex-wrap transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]",
  chipsInput: "peer block min-h-[auto] w-[150px] rounded border-0 bg-transparent py-[0.32rem] px-3 leading-[1.6] outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0",
  chipsLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate pt-[0.37rem] leading-[1.6] text-gray-500 transition-all duration-200 ease-out peer-focus:-translate-y-[0.9rem] peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:-translate-y-[0.9rem] peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200"
}, _v = {
  opacity: "string",
  inputWrapperPadding: "string",
  transition: "string",
  contentEditable: "string",
  chipsInputWrapper: "string",
  chipsInput: "string",
  chipsLabel: "string"
};
class XA extends vi {
  constructor(e, i = {}, n) {
    super(e, i);
    wt(this, "_handleBlurInput", ({ target: e }) => {
      e.value.length > 0 && this._handleCreateChip(e, e.value), this.allChips.length > 0 ? (e.setAttribute(bt, ""), this.input.setAttribute(Ne, ""), d.findOne(
        Eo,
        this.input.parentNode
      ).setAttribute(Ne, ""), this.chipsInputWrapper.classList.add(
        ...this._classes.inputWrapperPadding.split(" ")
      )) : (e.removeAttribute(bt), this.input.removeAttribute(Ne), d.findOne(
        Eo,
        this.input.parentNode
      ).removeAttribute(Ne), this.chipsInputWrapper.classList.remove(
        ...this._classes.inputWrapperPadding.split(" ")
      )), this.allChips.forEach((i) => i.removeAttribute(bt));
    });
    this._element = e, this._inputInstance = null, this._element && A.setData(e, xl, this), this._options = this._getConfig(i), this._classes = this._getClasses(n), this.numberClicks = 0, this.init();
  }
  // Getters
  static get NAME() {
    return Hi;
  }
  get activeChip() {
    return d.findOne(Qb, this._element);
  }
  get input() {
    return d.findOne("input", this._element);
  }
  get allChips() {
    return d.find(tr, this._element);
  }
  get chipsInputWrapper() {
    return d.findOne(Jb, this._element);
  }
  // Public
  init() {
    this._setChipsClass(), this._appendInputToElement(Sh), this._handleInitialValue(), this._handleInputText(), this._handleKeyboard(), this._handleChipsOnSelect(), this._handleEditable(), this._handleChipsFocus(), this._handleClicksOnChips(), this._inputInstance._getLabelWidth(), this._inputInstance._applyNotch();
  }
  dispose() {
    this._element = null, this._options = null;
  }
  // Private
  _getNotchData() {
    this._notchMiddle = d.findOne(
      ov,
      this._element
    ), this._notchLeading = d.findOne(
      nv,
      this._element
    );
  }
  _setChipsClass() {
    this._element.setAttribute(Gb, "");
  }
  _handleDeleteEvents(e) {
    const [i] = this.allChips.slice(-1);
    if (this.activeChip === null)
      i.remove(), this._handleEvents(e, Sl);
    else {
      const n = this.allChips.findIndex((a) => a === this.activeChip), o = this._handleActiveChipAfterRemove(n), r = [];
      if (this.activeChip === null)
        return;
      this.activeChip.remove(), this._handleEvents(e, Sl), this.numberClicks = n, o.setAttribute(bt, ""), this.allChips.forEach((a) => {
        a.hasAttribute(bt) && (r.push(a), r.length > 1 && this.allChips.forEach((l) => l.remove()));
      });
    }
  }
  _handleUpEvents(e) {
    this.numberClicks += 1, this.numberClicks === this.allChips.length + 1 && (this.numberClicks = 0), this._handleRightKeyboardArrow(this.numberClicks), this._handleEvents(e, cv), this._handleEvents(e, hv);
  }
  _handleDownEvents(e) {
    this.numberClicks -= 1, this.numberClicks <= 0 && (this.numberClicks = this.allChips.length), this._handleLeftKeyboardArrow(this.numberClicks), this._handleEvents(e, lv), this._handleEvents(e, av);
  }
  _keyboardEvents(e) {
    const { target: i, keyCode: n, ctrlKey: o } = e;
    i.value.length > 0 || this.allChips.length === 0 || (n === om || n === rm ? this._handleDeleteEvents(e) : n === ze || n === U ? this._handleUpEvents(e) : n === Ke || n === z ? this._handleDownEvents(e) : n === 65 && o && this._handleAddActiveClass());
  }
  _handleKeyboard() {
    c.on(
      this.input,
      "keydown",
      (e) => this._keyboardEvents(e)
    );
  }
  _handleEditable() {
    const { editable: e } = this._options;
    e && this.allChips.forEach((i) => {
      c.on(i, "dblclick", (n) => {
        const o = d.findOne(To, i);
        i.classList.add(...this._classes.contentEditable.split(" ")), i.contentEditable = !0, i.focus(), setTimeout(() => {
          h.addStyle(o, { display: "none" });
        }, 200), o.classList.add(...this._classes.opacity.split(" ")), n.target.textContent, c.trigger(i, Il, {
          event: n,
          allChips: this.allChips
        });
      }), c.on(document, "click", ({ target: n }) => {
        const o = d.findOne(To, i), r = d.findOne(tv, i), a = n === i, l = i && i.contains(n);
        !a && !l && (i.contentEditable = !1, i.classList.remove(...this._classes.contentEditable.split(" ")), r.textContent !== "" && setTimeout(() => {
          h.addStyle(o, { display: "block" }), o.classList.remove(...this._classes.opacity.split(" "));
        }, 160)), r.textContent === "" && (setTimeout(() => {
          i.classList.add(...this._classes.opacity.split(" "));
        }, 200), setTimeout(() => {
          i.remove();
        }, 300));
      });
    });
  }
  _handleRemoveActiveClass() {
    this.allChips.forEach((e) => e.removeAttribute(bt));
  }
  _handleAddActiveClass() {
    this.allChips.forEach((e) => e.setAttribute(bt, ""));
  }
  _handleRightKeyboardArrow(e) {
    this._handleRemoveActiveClass(), e === 0 && (e = 1), this._handleAddActiveClassWithKebyboard(e);
  }
  _handleLeftKeyboardArrow(e) {
    this._handleRemoveActiveClass(), this._handleAddActiveClassWithKebyboard(e);
  }
  _handleActiveChipAfterRemove(e) {
    const i = e === 0 ? 1 : e - 1;
    return this.allChips[i];
  }
  _handleClicksOnChips() {
    c.on(this._element, "click", () => {
      this.allChips.length === 0 && (this.chipsInputWrapper.classList.remove(
        ...this._classes.inputWrapperPadding.split(" ")
      ), this.input.removeAttribute(bt));
    });
  }
  _handleTextContent() {
    const e = [];
    return this.allChips.forEach((i) => e.push({ tag: i.textContent.trim() })), e;
  }
  _handleEvents(e, i) {
    const n = this._handleTextContent(), o = this.allChips.filter(
      (r) => r.hasAttribute(bt) && r
    );
    c.trigger(this._element, i, {
      event: e,
      allChips: this.allChips,
      arrOfObjects: n,
      active: o,
      activeObj: {
        tag: o.length <= 0 ? "" : o[0].textContent.trim()
      }
    });
  }
  _handleChipsFocus() {
    c.on(this._element, "click", ({ target: { attributes: e } }) => {
      const i = [...e].map((n) => n.name);
      i.includes(Jo) || i.includes(Ih) || i.includes(Dh) || this.input.focus();
    });
  }
  _handleInitialValue() {
    if (this._appendInputToElement(Ol), this._element.hasAttribute(Ol)) {
      const { initialValues: e } = this._options;
      e.forEach(
        ({ tag: i }) => this._handleCreateChip(this.input, i)
      ), d.findOne(
        Eo,
        this.input.parentNode
      ).setAttribute(Ne, ""), this.input.setAttribute(bt, ""), this.input.setAttribute(Ne, "");
    }
    this.allChips.length > 0 && (this.chipsInputWrapper.classList.add(
      ...this._classes.inputWrapperPadding.split(" ")
    ), this.chipsInputWrapper.classList.add(
      ...this._classes.transition.split(" ")
    ));
  }
  _handleKeysInputToElement(e) {
    const { keyCode: i, target: n } = e;
    if (n.hasAttribute(Jo)) {
      const o = d.findOne(To, n);
      i === it && (n.contentEditable = !1, n.classList.remove(...this._classes.contentEditable.split(" ")), n.textContent !== "" ? setTimeout(() => {
        h.addStyle(o, { display: "block" }), o.classList.remove(...this._classes.opacity.split(" "));
      }, 160) : n.textContent === "" && (setTimeout(() => {
        n.classList.add(...this._classes.opacity.split(" "));
      }, 200), setTimeout(() => {
        n.remove();
      }, 300)));
      return;
    }
    if (i === it) {
      if (n.value === "")
        return;
      this._handleCreateChip(n, n.value), this._handleRemoveActiveClass(), this.numberClicks = this.allChips.length + 1, this._handleEvents(e, rv);
    }
    this.allChips.length > 0 ? (this.chipsInputWrapper.classList.add(
      ...this._classes.inputWrapperPadding.split(" ")
    ), this.chipsInputWrapper.classList.add(
      ...this._classes.transition.split(" ")
    )) : this.chipsInputWrapper.classList.remove(
      ...this._classes.inputWrapperPadding.split(" ")
    );
  }
  _handleInputText() {
    const e = d.findOne(
      ev,
      this._element
    );
    c.on(
      this._element,
      "keyup",
      e,
      (i) => this._handleKeysInputToElement(i)
    ), c.on(this.input, "blur", (i) => this._handleBlurInput(i));
  }
  _appendInputToElement(e) {
    if (!this._element.hasAttribute(e))
      return;
    const i = Hb(this._options, this._classes);
    this._element.insertAdjacentHTML("beforeend", i);
    const n = d.findOne(
      "[data-te-chips-input-wrapper]",
      this._element
    );
    this._inputInstance = new V(
      n,
      this._options.inputOptions,
      this._options.inputClasses
    );
  }
  _handleCreateChip(e, i) {
    const n = $("div"), o = vi.getInstance(n), r = new vi(o, { text: i }, this._classes);
    this._options.parentSelector !== "" ? document.querySelector(this._options.parentSelector).insertAdjacentHTML("beforeend", r.appendChip()) : e.insertAdjacentHTML("beforebegin", r.appendChip()), e.value = "", d.find(tr).forEach((a) => {
      let l = vi.getInstance(a);
      return l || (l = new vi(a, {}, this._classes)), l.init();
    }), this._handleEditable();
  }
  _handleChipsOnSelect() {
    this.allChips.forEach((e) => {
      c.on(this._element, "click", (i) => {
        c.trigger(e, Il, {
          event: i,
          allChips: this.allChips
        });
      });
    });
  }
  _handleAddActiveClassWithKebyboard(e) {
    let i;
    this.allChips[e - 1] === void 0 ? i = this.allChips[e - 2] : i = this.allChips[e - 1], i.setAttribute(bt);
  }
  _getConfig(e) {
    const i = {
      ...uv,
      ...h.getDataAttributes(this._element),
      ...e
    };
    return I(Hi, i, dv), i;
  }
  _getClasses(e) {
    const i = h.getDataClassAttributes(this._element);
    return e = {
      ...pv,
      ...i,
      ...e
    }, I(Hi, e, _v), e;
  }
  static getInstance(e) {
    return A.getData(e, xl);
  }
  static getOrCreateInstance(e, i = {}) {
    return this.getInstance(e) || new this(e, typeof i == "object" ? i : null);
  }
}
const Ut = {
  plugins: {
    legend: {
      labels: {
        color: "rgb(102,102,102)"
      }
    }
  }
}, wi = {
  line: {
    options: {
      ...Ut,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.0)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bar: {
    options: {
      ...Ut,
      backgroundColor: "rgb(59, 112, 202)",
      borderWidth: 0,
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !0,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  pie: {
    options: {
      ...Ut,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  doughnut: {
    options: {
      ...Ut,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  polarArea: {
    options: {
      ...Ut,
      elements: {
        arc: { backgroundColor: "rgba(59, 112, 202, 0.5)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  radar: {
    options: {
      ...Ut,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  scatter: {
    options: {
      ...Ut,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bubble: {
    options: {
      ...Ut,
      elements: {
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      scales: {
        x: {
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  }
};
var fv = function(t) {
  return mv(t) && !gv(t);
};
function mv(s) {
  return !!s && typeof s == "object";
}
function gv(s) {
  var t = Object.prototype.toString.call(s);
  return t === "[object RegExp]" || t === "[object Date]" || Tv(s);
}
var bv = typeof Symbol == "function" && Symbol.for, vv = bv ? Symbol.for("react.element") : 60103;
function Tv(s) {
  return s.$$typeof === vv;
}
function Ev(s) {
  return Array.isArray(s) ? [] : {};
}
function Yi(s, t) {
  return t.clone !== !1 && t.isMergeableObject(s) ? ii(Ev(s), s, t) : s;
}
function Cv(s, t, e) {
  return s.concat(t).map(function(i) {
    return Yi(i, e);
  });
}
function Av(s, t) {
  if (!t.customMerge)
    return ii;
  var e = t.customMerge(s);
  return typeof e == "function" ? e : ii;
}
function yv(s) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(s).filter(function(t) {
    return Object.propertyIsEnumerable.call(s, t);
  }) : [];
}
function Dl(s) {
  return Object.keys(s).concat(yv(s));
}
function $h(s, t) {
  try {
    return t in s;
  } catch {
    return !1;
  }
}
function wv(s, t) {
  return $h(s, t) && !(Object.hasOwnProperty.call(s, t) && Object.propertyIsEnumerable.call(s, t));
}
function kv(s, t, e) {
  var i = {};
  return e.isMergeableObject(s) && Dl(s).forEach(function(n) {
    i[n] = Yi(s[n], e);
  }), Dl(t).forEach(function(n) {
    wv(s, n) || ($h(s, n) && e.isMergeableObject(t[n]) ? i[n] = Av(n, e)(s[n], t[n], e) : i[n] = Yi(t[n], e));
  }), i;
}
function ii(s, t, e) {
  e = e || {}, e.arrayMerge = e.arrayMerge || Cv, e.isMergeableObject = e.isMergeableObject || fv, e.cloneUnlessOtherwiseSpecified = Yi;
  var i = Array.isArray(t), n = Array.isArray(s), o = i === n;
  return o ? i ? e.arrayMerge(s, t, e) : kv(s, t, e) : Yi(t, e);
}
ii.all = function(t, e) {
  if (!Array.isArray(t))
    throw new Error("first argument should be an array");
  return t.reduce(function(i, n) {
    return ii(i, n, e);
  }, {});
};
var xv = ii, er = xv;
const $l = "chart", Ss = "te.chart", Ov = "chart", Co = (s, t, e) => {
  const i = (n, o, r) => {
    const a = n.slice();
    return o.forEach((l, p) => {
      typeof a[p] > "u" ? a[p] = r.cloneUnlessOtherwiseSpecified(
        l,
        r
      ) : r.isMergeableObject(l) ? a[p] = er(n[p], l, r) : n.indexOf(l) === -1 && a.push(l);
    }), a;
  };
  return er(e[t], s, {
    arrayMerge: i
  });
}, Sv = {
  darkTicksColor: "#fff",
  darkLabelColor: "#fff",
  darkGridLinesColor: "#555",
  darkmodeOff: "undefined",
  darkMode: null,
  darkBgColor: "#262626",
  darkBgColorLight: "#fff",
  options: null
}, Iv = {
  darkTicksColor: "string",
  darkLabelColor: "string",
  darkGridLinesColor: "string",
  darkmodeOff: "(string|null)",
  darkMode: "(string|null)",
  darkBgColor: "string",
  darkBgColorLight: "string",
  options: "(object|null)"
};
class Lh {
  constructor(t, e, i = {}, n = {}) {
    this._waitForCharts(t, e, i, n);
  }
  async _getChartjs() {
    const {
      Chart: t,
      ArcElement: e,
      LineElement: i,
      BarElement: n,
      PointElement: o,
      BarController: r,
      BubbleController: a,
      DoughnutController: l,
      LineController: p,
      PieController: u,
      PolarAreaController: _,
      RadarController: f,
      ScatterController: g,
      CategoryScale: m,
      LinearScale: b,
      LogarithmicScale: v,
      RadialLinearScale: T,
      TimeScale: y,
      TimeSeriesScale: C,
      Decimation: E,
      Filler: w,
      Legend: k,
      Title: D,
      Tooltip: O,
      SubTitle: x
    } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_tw-elements_dist_js_chart_es_js").then(__webpack_require__.bind(__webpack_require__, /*! ./chart.es.js */ "./node_modules/tw-elements/dist/js/chart.es.js")).then((L) => L.f);
    return t.register(
      e,
      i,
      n,
      o,
      r,
      a,
      l,
      p,
      u,
      _,
      f,
      g,
      m,
      b,
      v,
      T,
      y,
      C,
      E,
      w,
      k,
      D,
      O,
      x
    ), t;
  }
  async _getChartDataLabels() {
    return await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_tw-elements_dist_js_chart_es_js"), __webpack_require__.e("vendors-node_modules_tw-elements_dist_js_chartjs-plugin-datalabels_es_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ./chartjs-plugin-datalabels.es.js */ "./node_modules/tw-elements/dist/js/chartjs-plugin-datalabels.es.js"));
  }
  async _waitForCharts(t, e, i = {}, n = {}) {
    if (this._Chartjs = await this._getChartjs(), this._ChartDataLabels = await this._getChartDataLabels(), this._element = t, this._data = e, this._options = i, this._type = e.type, this._canvas = null, this._chart = null, this._darkOptions = this._getDarkConfig(n), this._darkModeClassContainer = document.querySelector("html"), this._prevConfig = null, this._observer = null, this._element && (A.setData(t, Ss, this), h.addClass(this._element, Ov), this._chartConstructor()), this._darkOptions.darkmodeOff !== null) {
      const o = this._darkOptions.darkMode === "dark" ? "dark" : this._darkOptions.darkMode === "light" ? "light" : this.systemColorMode;
      this._handleMode(o), this._observer = new MutationObserver(this._observerCallback.bind(this)), this._observer.observe(this._darkModeClassContainer, {
        attributes: !0
      });
    }
  }
  // Getters
  static get NAME() {
    return $l;
  }
  get systemColorMode() {
    return localStorage.theme || (this._darkModeClassContainer.classList.contains("dark") ? "dark" : "light");
  }
  // Public
  dispose() {
    this._observer.disconnect(), A.removeData(this._element, Ss), this._element = null;
  }
  update(t, e) {
    t && (this._data = { ...this._data, ...t }, this._chart.data = this._data);
    const i = Object.prototype.hasOwnProperty.call(
      e,
      "options"
    ) ? e : { options: { ...e } };
    this._options = er(this._options, i), this._chart.options = Co(
      this._options,
      this._type,
      wi
    ).options, this._chart.update();
  }
  setTheme(t) {
    t !== "dark" && t !== "light" || !this._data || this._handleMode(t);
  }
  // Private
  _getDarkConfig(t) {
    let e = {};
    const i = h.getDataAttributes(this._element);
    Object.keys(i).forEach(
      (p) => p.startsWith("dark") && (e[p] = i[p])
    ), e = {
      ...Sv,
      ...e
    };
    const n = {
      y: {
        ticks: {
          color: e.darkTicksColor
        },
        grid: {
          color: e.darkGridLinesColor
        }
      },
      x: {
        ticks: {
          color: e.darkTicksColor
        },
        grid: {
          color: e.darkGridLinesColor
        }
      }
    }, o = {
      r: {
        ticks: {
          color: e.darkTicksColor,
          backdropColor: e.darkBgColor
        },
        grid: {
          color: e.darkGridLinesColor
        },
        pointLabels: {
          color: e.darkTicksColor
        }
      }
    }, l = {
      scales: ["pie", "doughnut", "polarArea", "radar"].includes(this._type) ? ["polarArea", "radar"].includes(this._type) ? o : {} : n,
      plugins: {
        legend: {
          labels: {
            color: e.darkLabelColor
          }
        }
      }
    };
    return t = {
      ...e,
      options: {
        ...l
      },
      ...t
    }, I($l, t, Iv), t;
  }
  _chartConstructor() {
    if (this._data) {
      this._createCanvas();
      const t = Co(this._options, this._type, wi), e = [];
      t.dataLabelsPlugin && e.push(this._ChartDataLabels.default), this._prevConfig = t, this._chart = new this._Chartjs(this._canvas, {
        ...this._data,
        ...t,
        plugins: e
      });
    }
  }
  _createCanvas() {
    this._canvas || (this._element.nodeName === "CANVAS" ? this._canvas = this._element : (this._canvas = $("canvas"), this._element.appendChild(this._canvas)));
  }
  _handleMode(t) {
    t === "dark" ? (this._changeDatasetBorderColor(), this.update(null, this._darkOptions.options)) : (this._changeDatasetBorderColor(!1), this._prevConfig && this.update(null, this._prevConfig));
  }
  _observerCallback(t) {
    for (const e of t)
      e.type === "attributes" && this._handleMode(this.systemColorMode);
  }
  _changeDatasetBorderColor(t = !0) {
    [...this._data.data.datasets].forEach(
      (e) => ["pie", "doughnut", "polarArea"].includes(this._type) && (e.borderColor = t ? this._darkOptions.darkBgColor : this._darkOptions.darkBgColorLight)
    );
  }
  static jQueryInterface(t, e, i) {
    return this.each(function() {
      let n = A.getData(this, Ss);
      if (!(!n && /dispose/.test(t))) {
        if (!n) {
          const o = e ? Co(e, i, wi) : wi[i];
          n = new Lh(this, {
            ...t,
            ...o
          });
        }
        if (typeof t == "string") {
          if (typeof n[t] > "u")
            throw new TypeError(`No method named "${t}"`);
          n[t](e, i);
        }
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, Ss);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function Nt(s) {
  return getComputedStyle(s);
}
function ct(s, t) {
  for (var e in t) {
    var i = t[e];
    typeof i == "number" && (i = i + "px"), s.style[e] = i;
  }
  return s;
}
function Is(s) {
  var t = document.createElement("div");
  return t.className = s, t;
}
var Ll = typeof Element < "u" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function Jt(s, t) {
  if (!Ll)
    throw new Error("No element matching method supported");
  return Ll.call(s, t);
}
function Ye(s) {
  s.remove ? s.remove() : s.parentNode && s.parentNode.removeChild(s);
}
function Nl(s, t) {
  return Array.prototype.filter.call(
    s.children,
    function(e) {
      return Jt(e, t);
    }
  );
}
var j = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(s) {
      return "ps__thumb-" + s;
    },
    rail: function(s) {
      return "ps__rail-" + s;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(s) {
      return "ps--active-" + s;
    },
    scrolling: function(s) {
      return "ps--scrolling-" + s;
    }
  }
}, Nh = { x: null, y: null };
function Mh(s, t) {
  var e = s.element.classList, i = j.state.scrolling(t);
  e.contains(i) ? clearTimeout(Nh[t]) : e.add(i);
}
function Rh(s, t) {
  Nh[t] = setTimeout(
    function() {
      return s.isAlive && s.element.classList.remove(j.state.scrolling(t));
    },
    s.settings.scrollingThreshold
  );
}
function Dv(s, t) {
  Mh(s, t), Rh(s, t);
}
var qi = function(t) {
  this.element = t, this.handlers = {};
}, Ph = { isEmpty: { configurable: !0 } };
qi.prototype.bind = function(t, e) {
  typeof this.handlers[t] > "u" && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1);
};
qi.prototype.unbind = function(t, e) {
  var i = this;
  this.handlers[t] = this.handlers[t].filter(function(n) {
    return e && n !== e ? !0 : (i.element.removeEventListener(t, n, !1), !1);
  });
};
qi.prototype.unbindAll = function() {
  for (var t in this.handlers)
    this.unbind(t);
};
Ph.isEmpty.get = function() {
  var s = this;
  return Object.keys(this.handlers).every(
    function(t) {
      return s.handlers[t].length === 0;
    }
  );
};
Object.defineProperties(qi.prototype, Ph);
var li = function() {
  this.eventElements = [];
};
li.prototype.eventElement = function(t) {
  var e = this.eventElements.filter(function(i) {
    return i.element === t;
  })[0];
  return e || (e = new qi(t), this.eventElements.push(e)), e;
};
li.prototype.bind = function(t, e, i) {
  this.eventElement(t).bind(e, i);
};
li.prototype.unbind = function(t, e, i) {
  var n = this.eventElement(t);
  n.unbind(e, i), n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1);
};
li.prototype.unbindAll = function() {
  this.eventElements.forEach(function(t) {
    return t.unbindAll();
  }), this.eventElements = [];
};
li.prototype.once = function(t, e, i) {
  var n = this.eventElement(t), o = function(r) {
    n.unbind(e, o), i(r);
  };
  n.bind(e, o);
};
function Ds(s) {
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(s);
  var t = document.createEvent("CustomEvent");
  return t.initCustomEvent(s, !1, !1, void 0), t;
}
function fn(s, t, e, i, n) {
  i === void 0 && (i = !0), n === void 0 && (n = !1);
  var o;
  if (t === "top")
    o = [
      "contentHeight",
      "containerHeight",
      "scrollTop",
      "y",
      "up",
      "down"
    ];
  else if (t === "left")
    o = [
      "contentWidth",
      "containerWidth",
      "scrollLeft",
      "x",
      "left",
      "right"
    ];
  else
    throw new Error("A proper axis should be provided");
  $v(s, e, o, i, n);
}
function $v(s, t, e, i, n) {
  var o = e[0], r = e[1], a = e[2], l = e[3], p = e[4], u = e[5];
  i === void 0 && (i = !0), n === void 0 && (n = !1);
  var _ = s.element;
  s.reach[l] = null, _[a] < 1 && (s.reach[l] = "start"), _[a] > s[o] - s[r] - 1 && (s.reach[l] = "end"), t && (_.dispatchEvent(Ds("ps-scroll-" + l)), t < 0 ? _.dispatchEvent(Ds("ps-scroll-" + p)) : t > 0 && _.dispatchEvent(Ds("ps-scroll-" + u)), i && Dv(s, l)), s.reach[l] && (t || n) && _.dispatchEvent(Ds("ps-" + l + "-reach-" + s.reach[l]));
}
function F(s) {
  return parseInt(s, 10) || 0;
}
function Lv(s) {
  return Jt(s, "input,[contenteditable]") || Jt(s, "select,[contenteditable]") || Jt(s, "textarea,[contenteditable]") || Jt(s, "button,[contenteditable]");
}
function Nv(s) {
  var t = Nt(s);
  return F(t.width) + F(t.paddingLeft) + F(t.paddingRight) + F(t.borderLeftWidth) + F(t.borderRightWidth);
}
var Ve = {
  isWebKit: typeof document < "u" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window < "u" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator < "u" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator < "u" && /Chrome/i.test(navigator && navigator.userAgent)
};
function Ht(s) {
  var t = s.element, e = Math.floor(t.scrollTop), i = t.getBoundingClientRect();
  s.containerWidth = Math.round(i.width), s.containerHeight = Math.round(i.height), s.contentWidth = t.scrollWidth, s.contentHeight = t.scrollHeight, t.contains(s.scrollbarXRail) || (Nl(t, j.element.rail("x")).forEach(
    function(n) {
      return Ye(n);
    }
  ), t.appendChild(s.scrollbarXRail)), t.contains(s.scrollbarYRail) || (Nl(t, j.element.rail("y")).forEach(
    function(n) {
      return Ye(n);
    }
  ), t.appendChild(s.scrollbarYRail)), !s.settings.suppressScrollX && s.containerWidth + s.settings.scrollXMarginOffset < s.contentWidth ? (s.scrollbarXActive = !0, s.railXWidth = s.containerWidth - s.railXMarginWidth, s.railXRatio = s.containerWidth / s.railXWidth, s.scrollbarXWidth = Ml(
    s,
    F(s.railXWidth * s.containerWidth / s.contentWidth)
  ), s.scrollbarXLeft = F(
    (s.negativeScrollAdjustment + t.scrollLeft) * (s.railXWidth - s.scrollbarXWidth) / (s.contentWidth - s.containerWidth)
  )) : s.scrollbarXActive = !1, !s.settings.suppressScrollY && s.containerHeight + s.settings.scrollYMarginOffset < s.contentHeight ? (s.scrollbarYActive = !0, s.railYHeight = s.containerHeight - s.railYMarginHeight, s.railYRatio = s.containerHeight / s.railYHeight, s.scrollbarYHeight = Ml(
    s,
    F(s.railYHeight * s.containerHeight / s.contentHeight)
  ), s.scrollbarYTop = F(
    e * (s.railYHeight - s.scrollbarYHeight) / (s.contentHeight - s.containerHeight)
  )) : s.scrollbarYActive = !1, s.scrollbarXLeft >= s.railXWidth - s.scrollbarXWidth && (s.scrollbarXLeft = s.railXWidth - s.scrollbarXWidth), s.scrollbarYTop >= s.railYHeight - s.scrollbarYHeight && (s.scrollbarYTop = s.railYHeight - s.scrollbarYHeight), Mv(t, s), s.scrollbarXActive ? t.classList.add(j.state.active("x")) : (t.classList.remove(j.state.active("x")), s.scrollbarXWidth = 0, s.scrollbarXLeft = 0, t.scrollLeft = s.isRtl === !0 ? s.contentWidth : 0), s.scrollbarYActive ? t.classList.add(j.state.active("y")) : (t.classList.remove(j.state.active("y")), s.scrollbarYHeight = 0, s.scrollbarYTop = 0, t.scrollTop = 0);
}
function Ml(s, t) {
  return s.settings.minScrollbarLength && (t = Math.max(t, s.settings.minScrollbarLength)), s.settings.maxScrollbarLength && (t = Math.min(t, s.settings.maxScrollbarLength)), t;
}
function Mv(s, t) {
  var e = { width: t.railXWidth }, i = Math.floor(s.scrollTop);
  t.isRtl ? e.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth - t.contentWidth : e.left = s.scrollLeft, t.isScrollbarXUsingBottom ? e.bottom = t.scrollbarXBottom - i : e.top = t.scrollbarXTop + i, ct(t.scrollbarXRail, e);
  var n = { top: i, height: t.railYHeight };
  t.isScrollbarYUsingRight ? t.isRtl ? n.right = t.contentWidth - (t.negativeScrollAdjustment + s.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : n.right = t.scrollbarYRight - s.scrollLeft : t.isRtl ? n.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : n.left = t.scrollbarYLeft + s.scrollLeft, ct(t.scrollbarYRail, n), ct(t.scrollbarX, {
    left: t.scrollbarXLeft,
    width: t.scrollbarXWidth - t.railBorderXWidth
  }), ct(t.scrollbarY, {
    top: t.scrollbarYTop,
    height: t.scrollbarYHeight - t.railBorderYWidth
  });
}
function Rv(s) {
  s.element, s.event.bind(s.scrollbarY, "mousedown", function(t) {
    return t.stopPropagation();
  }), s.event.bind(s.scrollbarYRail, "mousedown", function(t) {
    var e = t.pageY - window.pageYOffset - s.scrollbarYRail.getBoundingClientRect().top, i = e > s.scrollbarYTop ? 1 : -1;
    s.element.scrollTop += i * s.containerHeight, Ht(s), t.stopPropagation();
  }), s.event.bind(s.scrollbarX, "mousedown", function(t) {
    return t.stopPropagation();
  }), s.event.bind(s.scrollbarXRail, "mousedown", function(t) {
    var e = t.pageX - window.pageXOffset - s.scrollbarXRail.getBoundingClientRect().left, i = e > s.scrollbarXLeft ? 1 : -1;
    s.element.scrollLeft += i * s.containerWidth, Ht(s), t.stopPropagation();
  });
}
function Pv(s) {
  Rl(s, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]), Rl(s, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function Rl(s, t) {
  var e = t[0], i = t[1], n = t[2], o = t[3], r = t[4], a = t[5], l = t[6], p = t[7], u = t[8], _ = s.element, f = null, g = null, m = null;
  function b(y) {
    y.touches && y.touches[0] && (y[n] = y.touches[0].pageY), _[l] = f + m * (y[n] - g), Mh(s, p), Ht(s), y.stopPropagation(), y.type.startsWith("touch") && y.changedTouches.length > 1 && y.preventDefault();
  }
  function v() {
    Rh(s, p), s[u].classList.remove(j.state.clicking), s.event.unbind(s.ownerDocument, "mousemove", b);
  }
  function T(y, C) {
    f = _[l], C && y.touches && (y[n] = y.touches[0].pageY), g = y[n], m = (s[i] - s[e]) / (s[o] - s[a]), C ? s.event.bind(s.ownerDocument, "touchmove", b) : (s.event.bind(s.ownerDocument, "mousemove", b), s.event.once(s.ownerDocument, "mouseup", v), y.preventDefault()), s[u].classList.add(j.state.clicking), y.stopPropagation();
  }
  s.event.bind(s[r], "mousedown", function(y) {
    T(y);
  }), s.event.bind(s[r], "touchstart", function(y) {
    T(y, !0);
  });
}
function Bv(s) {
  var t = s.element, e = function() {
    return Jt(t, ":hover");
  }, i = function() {
    return Jt(s.scrollbarX, ":focus") || Jt(s.scrollbarY, ":focus");
  };
  function n(o, r) {
    var a = Math.floor(t.scrollTop);
    if (o === 0) {
      if (!s.scrollbarYActive)
        return !1;
      if (a === 0 && r > 0 || a >= s.contentHeight - s.containerHeight && r < 0)
        return !s.settings.wheelPropagation;
    }
    var l = t.scrollLeft;
    if (r === 0) {
      if (!s.scrollbarXActive)
        return !1;
      if (l === 0 && o < 0 || l >= s.contentWidth - s.containerWidth && o > 0)
        return !s.settings.wheelPropagation;
    }
    return !0;
  }
  s.event.bind(s.ownerDocument, "keydown", function(o) {
    if (!(o.isDefaultPrevented && o.isDefaultPrevented() || o.defaultPrevented) && !(!e() && !i())) {
      var r = document.activeElement ? document.activeElement : s.ownerDocument.activeElement;
      if (r) {
        if (r.tagName === "IFRAME")
          r = r.contentDocument.activeElement;
        else
          for (; r.shadowRoot; )
            r = r.shadowRoot.activeElement;
        if (Lv(r))
          return;
      }
      var a = 0, l = 0;
      switch (o.which) {
        case 37:
          o.metaKey ? a = -s.contentWidth : o.altKey ? a = -s.containerWidth : a = -30;
          break;
        case 38:
          o.metaKey ? l = s.contentHeight : o.altKey ? l = s.containerHeight : l = 30;
          break;
        case 39:
          o.metaKey ? a = s.contentWidth : o.altKey ? a = s.containerWidth : a = 30;
          break;
        case 40:
          o.metaKey ? l = -s.contentHeight : o.altKey ? l = -s.containerHeight : l = -30;
          break;
        case 32:
          o.shiftKey ? l = s.containerHeight : l = -s.containerHeight;
          break;
        case 33:
          l = s.containerHeight;
          break;
        case 34:
          l = -s.containerHeight;
          break;
        case 36:
          l = s.contentHeight;
          break;
        case 35:
          l = -s.contentHeight;
          break;
        default:
          return;
      }
      s.settings.suppressScrollX && a !== 0 || s.settings.suppressScrollY && l !== 0 || (t.scrollTop -= l, t.scrollLeft += a, Ht(s), n(a, l) && o.preventDefault());
    }
  });
}
function Hv(s) {
  var t = s.element;
  function e(r, a) {
    var l = Math.floor(t.scrollTop), p = t.scrollTop === 0, u = l + t.offsetHeight === t.scrollHeight, _ = t.scrollLeft === 0, f = t.scrollLeft + t.offsetWidth === t.scrollWidth, g;
    return Math.abs(a) > Math.abs(r) ? g = p || u : g = _ || f, g ? !s.settings.wheelPropagation : !0;
  }
  function i(r) {
    var a = r.deltaX, l = -1 * r.deltaY;
    return (typeof a > "u" || typeof l > "u") && (a = -1 * r.wheelDeltaX / 6, l = r.wheelDeltaY / 6), r.deltaMode && r.deltaMode === 1 && (a *= 10, l *= 10), a !== a && l !== l && (a = 0, l = r.wheelDelta), r.shiftKey ? [-l, -a] : [a, l];
  }
  function n(r, a, l) {
    if (!Ve.isWebKit && t.querySelector("select:focus"))
      return !0;
    if (!t.contains(r))
      return !1;
    for (var p = r; p && p !== t; ) {
      if (p.classList.contains(j.element.consuming))
        return !0;
      var u = Nt(p);
      if (l && u.overflowY.match(/(scroll|auto)/)) {
        var _ = p.scrollHeight - p.clientHeight;
        if (_ > 0 && (p.scrollTop > 0 && l < 0 || p.scrollTop < _ && l > 0))
          return !0;
      }
      if (a && u.overflowX.match(/(scroll|auto)/)) {
        var f = p.scrollWidth - p.clientWidth;
        if (f > 0 && (p.scrollLeft > 0 && a < 0 || p.scrollLeft < f && a > 0))
          return !0;
      }
      p = p.parentNode;
    }
    return !1;
  }
  function o(r) {
    var a = i(r), l = a[0], p = a[1];
    if (!n(r.target, l, p)) {
      var u = !1;
      s.settings.useBothWheelAxes ? s.scrollbarYActive && !s.scrollbarXActive ? (p ? t.scrollTop -= p * s.settings.wheelSpeed : t.scrollTop += l * s.settings.wheelSpeed, u = !0) : s.scrollbarXActive && !s.scrollbarYActive && (l ? t.scrollLeft += l * s.settings.wheelSpeed : t.scrollLeft -= p * s.settings.wheelSpeed, u = !0) : (t.scrollTop -= p * s.settings.wheelSpeed, t.scrollLeft += l * s.settings.wheelSpeed), Ht(s), u = u || e(l, p), u && !r.ctrlKey && (r.stopPropagation(), r.preventDefault());
    }
  }
  typeof window.onwheel < "u" ? s.event.bind(t, "wheel", o) : typeof window.onmousewheel < "u" && s.event.bind(t, "mousewheel", o);
}
function Vv(s) {
  if (!Ve.supportsTouch && !Ve.supportsIePointer)
    return;
  var t = s.element;
  function e(m, b) {
    var v = Math.floor(t.scrollTop), T = t.scrollLeft, y = Math.abs(m), C = Math.abs(b);
    if (C > y) {
      if (b < 0 && v === s.contentHeight - s.containerHeight || b > 0 && v === 0)
        return window.scrollY === 0 && b > 0 && Ve.isChrome;
    } else if (y > C && (m < 0 && T === s.contentWidth - s.containerWidth || m > 0 && T === 0))
      return !0;
    return !0;
  }
  function i(m, b) {
    t.scrollTop -= b, t.scrollLeft -= m, Ht(s);
  }
  var n = {}, o = 0, r = {}, a = null;
  function l(m) {
    return m.targetTouches ? m.targetTouches[0] : m;
  }
  function p(m) {
    return m.pointerType && m.pointerType === "pen" && m.buttons === 0 ? !1 : !!(m.targetTouches && m.targetTouches.length === 1 || m.pointerType && m.pointerType !== "mouse" && m.pointerType !== m.MSPOINTER_TYPE_MOUSE);
  }
  function u(m) {
    if (p(m)) {
      var b = l(m);
      n.pageX = b.pageX, n.pageY = b.pageY, o = (/* @__PURE__ */ new Date()).getTime(), a !== null && clearInterval(a);
    }
  }
  function _(m, b, v) {
    if (!t.contains(m))
      return !1;
    for (var T = m; T && T !== t; ) {
      if (T.classList.contains(j.element.consuming))
        return !0;
      var y = Nt(T);
      if (v && y.overflowY.match(/(scroll|auto)/)) {
        var C = T.scrollHeight - T.clientHeight;
        if (C > 0 && (T.scrollTop > 0 && v < 0 || T.scrollTop < C && v > 0))
          return !0;
      }
      if (b && y.overflowX.match(/(scroll|auto)/)) {
        var E = T.scrollWidth - T.clientWidth;
        if (E > 0 && (T.scrollLeft > 0 && b < 0 || T.scrollLeft < E && b > 0))
          return !0;
      }
      T = T.parentNode;
    }
    return !1;
  }
  function f(m) {
    if (p(m)) {
      var b = l(m), v = { pageX: b.pageX, pageY: b.pageY }, T = v.pageX - n.pageX, y = v.pageY - n.pageY;
      if (_(m.target, T, y))
        return;
      i(T, y), n = v;
      var C = (/* @__PURE__ */ new Date()).getTime(), E = C - o;
      E > 0 && (r.x = T / E, r.y = y / E, o = C), e(T, y) && m.preventDefault();
    }
  }
  function g() {
    s.settings.swipeEasing && (clearInterval(a), a = setInterval(function() {
      if (s.isInitialized) {
        clearInterval(a);
        return;
      }
      if (!r.x && !r.y) {
        clearInterval(a);
        return;
      }
      if (Math.abs(r.x) < 0.01 && Math.abs(r.y) < 0.01) {
        clearInterval(a);
        return;
      }
      if (!s.element) {
        clearInterval(a);
        return;
      }
      i(r.x * 30, r.y * 30), r.x *= 0.8, r.y *= 0.8;
    }, 10));
  }
  Ve.supportsTouch ? (s.event.bind(t, "touchstart", u), s.event.bind(t, "touchmove", f), s.event.bind(t, "touchend", g)) : Ve.supportsIePointer && (window.PointerEvent ? (s.event.bind(t, "pointerdown", u), s.event.bind(t, "pointermove", f), s.event.bind(t, "pointerup", g)) : window.MSPointerEvent && (s.event.bind(t, "MSPointerDown", u), s.event.bind(t, "MSPointerMove", f), s.event.bind(t, "MSPointerUp", g)));
}
var Wv = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: !1,
    suppressScrollY: !1,
    swipeEasing: !0,
    useBothWheelAxes: !1,
    wheelPropagation: !0,
    wheelSpeed: 1
  };
}, Fv = {
  "click-rail": Rv,
  "drag-thumb": Pv,
  keyboard: Bv,
  wheel: Hv,
  touch: Vv
}, Zi = function(t, e) {
  var i = this;
  if (e === void 0 && (e = {}), typeof t == "string" && (t = document.querySelector(t)), !t || !t.nodeName)
    throw new Error("no element is specified to initialize PerfectScrollbar");
  this.element = t, t.classList.add(j.main), this.settings = Wv();
  for (var n in e)
    this.settings[n] = e[n];
  this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
  var o = function() {
    return t.classList.add(j.state.focus);
  }, r = function() {
    return t.classList.remove(j.state.focus);
  };
  this.isRtl = Nt(t).direction === "rtl", this.isRtl === !0 && t.classList.add(j.rtl), this.isNegativeScroll = function() {
    var p = t.scrollLeft, u = null;
    return t.scrollLeft = -1, u = t.scrollLeft < 0, t.scrollLeft = p, u;
  }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new li(), this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = Is(j.element.rail("x")), t.appendChild(this.scrollbarXRail), this.scrollbarX = Is(j.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", o), this.event.bind(this.scrollbarX, "blur", r), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
  var a = Nt(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(a.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = F(a.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = F(a.borderLeftWidth) + F(a.borderRightWidth), ct(this.scrollbarXRail, { display: "block" }), this.railXMarginWidth = F(a.marginLeft) + F(a.marginRight), ct(this.scrollbarXRail, { display: "" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = Is(j.element.rail("y")), t.appendChild(this.scrollbarYRail), this.scrollbarY = Is(j.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", o), this.event.bind(this.scrollbarY, "blur", r), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
  var l = Nt(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(l.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = F(l.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? Nv(this.scrollbarY) : null, this.railBorderYWidth = F(l.borderTopWidth) + F(l.borderBottomWidth), ct(this.scrollbarYRail, { display: "block" }), this.railYMarginHeight = F(l.marginTop) + F(l.marginBottom), ct(this.scrollbarYRail, { display: "" }), this.railYHeight = null, this.railYRatio = null, this.reach = {
    x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  }, this.isAlive = !0, this.settings.handlers.forEach(function(p) {
    return Fv[p](i);
  }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, "scroll", function(p) {
    return i.onScroll(p);
  }), Ht(this);
};
Zi.prototype.update = function() {
  this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, ct(this.scrollbarXRail, { display: "block" }), ct(this.scrollbarYRail, { display: "block" }), this.railXMarginWidth = F(Nt(this.scrollbarXRail).marginLeft) + F(Nt(this.scrollbarXRail).marginRight), this.railYMarginHeight = F(Nt(this.scrollbarYRail).marginTop) + F(Nt(this.scrollbarYRail).marginBottom), ct(this.scrollbarXRail, { display: "none" }), ct(this.scrollbarYRail, { display: "none" }), Ht(this), fn(this, "top", 0, !1, !0), fn(this, "left", 0, !1, !0), ct(this.scrollbarXRail, { display: "" }), ct(this.scrollbarYRail, { display: "" }));
};
Zi.prototype.onScroll = function(t) {
  this.isAlive && (Ht(this), fn(this, "top", this.element.scrollTop - this.lastScrollTop), fn(
    this,
    "left",
    this.element.scrollLeft - this.lastScrollLeft
  ), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
};
Zi.prototype.destroy = function() {
  this.isAlive && (this.event.unbindAll(), Ye(this.scrollbarX), Ye(this.scrollbarY), Ye(this.scrollbarXRail), Ye(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);
};
Zi.prototype.removePsClasses = function() {
  this.element.className = this.element.className.split(" ").filter(function(t) {
    return !t.match(/^ps([-_].+|)$/);
  }).join(" ");
};
const Ao = "perfectScrollbar", Yv = "perfect-scrollbar", $s = "te.perfectScrollbar", St = "te", It = "ps", yo = [
  { te: `scrollX.${St}.${It}`, ps: "ps-scroll-x" },
  { te: `scrollY.${St}.${It}`, ps: "ps-scroll-y" },
  { te: `scrollUp.${St}.${It}`, ps: "ps-scroll-up" },
  { te: `scrollDown.${St}.${It}`, ps: "ps-scroll-down" },
  { te: `scrollLeft.${St}.${It}`, ps: "ps-scroll-left" },
  { te: `scrollRight.${St}.${It}`, ps: "ps-scroll-right" },
  { te: `scrollXEnd.${St}.${It}`, ps: "ps-x-reach-end" },
  { te: `scrollYEnd.${St}.${It}`, ps: "ps-y-reach-end" },
  { te: `scrollXStart.${St}.${It}`, ps: "ps-x-reach-start" },
  { te: `scrollYStart.${St}.${It}`, ps: "ps-y-reach-start" }
], jv = {
  handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
  wheelSpeed: 1,
  wheelPropagation: !0,
  swipeEasing: !0,
  minScrollbarLength: null,
  maxScrollbarLength: null,
  scrollingThreshold: 1e3,
  useBothWheelAxes: !1,
  suppressScrollX: !1,
  suppressScrollY: !1,
  scrollXMarginOffset: 0,
  scrollYMarginOffset: 0,
  positionRight: !0
}, Kv = {
  handlers: "(string|array)",
  wheelSpeed: "number",
  wheelPropagation: "boolean",
  swipeEasing: "boolean",
  minScrollbarLength: "(number|null)",
  maxScrollbarLength: "(number|null)",
  scrollingThreshold: "number",
  useBothWheelAxes: "boolean",
  suppressScrollX: "boolean",
  suppressScrollY: "boolean",
  scrollXMarginOffset: "number",
  scrollYMarginOffset: "number",
  positionRight: "boolean"
}, zv = {
  ps: "group/ps overflow-hidden [overflow-anchor:none] touch-none",
  railX: "group/x absolute bottom-0 h-[0.9375rem] hidden opacity-0 transition-[background-color,_opacity] duration-200 ease-linear motion-reduce:transition-none z-[1035] group-[&.ps--active-x]/ps:block group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-x]/ps:opacity-60 hover:!opacity-90 focus:!opacity-90 [&.ps--clicking]:!opacity-90 outline-none",
  railXColors: "group-[&.ps--active-x]/ps:bg-transparent hover:!bg-[#eee] focus:!bg-[#eee] [&.ps--clicking]:!bg-[#eee] dark:hover:!bg-[#555] dark:focus:!bg-[#555] dark:[&.ps--clicking]:!bg-[#555]",
  railXThumb: "absolute bottom-0.5 rounded-md h-1.5 group-focus/ps:opacity-100 group-active/ps:opacity-100 [transition:background-color_.2s_linear,_height_.2s_ease-in-out] group-hover/x:h-[11px] group-focus/x:h-[0.6875rem] group-[&.ps--clicking]/x:bg-[#999] group-[&.ps--clicking]/x:h-[11px] outline-none",
  railXThumbColors: "bg-[#aaa] group-hover/x:bg-[#999] group-focus/x:bg-[#999]",
  railY: "group/y absolute right-0 w-[0.9375rem] hidden opacity-0 transition-[background-color,_opacity] duration-200 ease-linear motion-reduce:transition-none z-[1035] group-[&.ps--active-y]/ps:block group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-y]/ps:opacity-60 hover:!opacity-90 focus:!opacity-90 [&.ps--clicking]:!opacity-90 outline-none",
  railYColors: "group-[&.ps--active-y]/ps:bg-transparent hover:!bg-[#eee] focus:!bg-[#eee] [&.ps--clicking]:!bg-[#eee] dark:hover:!bg-[#555] dark:focus:!bg-[#555] dark:[&.ps--clicking]:!bg-[#555]",
  railYThumb: "absolute right-0.5 rounded-md w-1.5 group-focus/ps:opacity-100 group-active/ps:opacity-100 [transition:background-color_.2s_linear,_width_.2s_ease-in-out,_opacity] group-hover/y:w-[11px] group-focus/y:w-[0.6875rem] group-[&.ps--clicking]/y:w-[11px] outline-none",
  railYThumbColors: "bg-[#aaa] group-hover/y:bg-[#999] group-focus/y:bg-[#999] group-[&.ps--clicking]/y:bg-[#999]"
}, Uv = {
  ps: "string",
  railX: "string",
  railXColors: "string",
  railXThumb: "string",
  railXThumbColors: "string",
  railY: "string",
  railYColors: "string",
  railYThumb: "string",
  railYThumbColors: "string"
};
class xr {
  constructor(t, e = {}, i = {}) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this.perfectScrollbar = null, this._observer = null, this._psClasses = [
      {
        ps: "ps__rail-x",
        te: this._classes.railX,
        teColor: this._classes.railXColors
      },
      {
        ps: "ps__rail-y",
        te: this._classes.railY,
        teColor: this._classes.railYColors
      },
      {
        ps: "ps__thumb-x",
        te: this._classes.railXThumb,
        teColor: this._classes.railXThumbColors
      },
      {
        ps: "ps__thumb-y",
        te: this._classes.railYThumb,
        teColor: this._classes.railYThumbColors
      }
    ], this._element && (A.setData(t, $s, this), h.addClass(this._element, Yv)), this.init();
  }
  // Getters
  static get NAME() {
    return Ao;
  }
  get railX() {
    return d.findOne(".ps__rail-x", this._element);
  }
  get railY() {
    return d.findOne(".ps__rail-y", this._element);
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return e.handlers !== void 0 && (e.handlers = e.handlers.split(" ")), t = {
      ...jv,
      ...e,
      ...t
    }, I(Ao, t, Kv), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...zv,
      ...e,
      ...t
    }, I(Ao, t, Uv), t;
  }
  // Public
  dispose() {
    this._options.positionRight && this._observer.disconnect(), A.removeData(this._element, $s), this._element = null, this._dataAttrOptions = null, this._options = null, this.perfectScrollbar.destroy(), this.removeEvent(yo), this.perfectScrollbar = null;
  }
  init() {
    if (this.perfectScrollbar = new Zi(this._element, this._options), this._addPerfectScrollbarStyles(), this._updateScrollPosition(), this.perfectScrollbar.update(), this._initEvents(yo), this._options.positionRight) {
      this._observer = new ResizeObserver(() => {
        setTimeout(() => {
          this._updateScrollPosition();
        }, 100);
      });
      const t = {
        attributes: !0,
        attributeFilter: ["class", "className"]
      };
      this._observer.observe(this._element, t);
    }
  }
  _updateScrollPosition() {
    const t = getComputedStyle(this._element).getPropertyValue("height"), e = getComputedStyle(this._element).getPropertyValue("width");
    this.railX && (this.railX.style.transform = `translateY(calc(-100% + ${this._canTransform(t) ? t : "0px"}))`), this.railY && (this.railY.style.transform = `translateX(calc(-100% + ${this._canTransform(e) ? e : "0px"}))`);
  }
  _canTransform(t) {
    return t && t.includes("px");
  }
  update() {
    return this.perfectScrollbar.update();
  }
  _initEvents(t = []) {
    t.forEach(
      ({ ps: e, te: i }) => c.on(
        this._element,
        e,
        (n) => c.trigger(this._element, i, { e: n })
      )
    );
  }
  _addPerfectScrollbarStyles() {
    this._psClasses.forEach((t) => {
      const e = d.findOne(`.${t.ps}`, this._element);
      h.addClass(e, t.te), h.addClass(e, t.teColor);
    }), h.addClass(this._element, this._classes.ps), h.removeClass(this._element, "ps");
  }
  removeEvent(t) {
    let e = [];
    typeof t == "string" && (e = yo.filter(({ te: i }) => i === t)), e.forEach(({ ps: i, te: n }) => {
      c.off(this._element, i), c.off(this._element, n);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      let e = A.getData(this, $s);
      const i = typeof t == "object" && t;
      if (!(!e && /dispose|hide/.test(t)) && (e || (e = new xr(this, i)), typeof t == "string")) {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, $s);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Bh = xr, Xv = "data-te-datatable-select-ref", Gv = "data-te-datatable-pagination-nav-ref", qv = "data-te-datatable-pagination-right-ref", Zv = "data-te-datatable-pagination-left-ref", Qv = "data-te-datatable-pagination-start-ref", Jv = "data-te-datatable-pagination-end-ref", tT = ({
  text: s,
  entries: t,
  entriesOptions: e,
  fullPagination: i,
  rowsText: n,
  allText: o,
  paginationStartIconTemplate: r,
  paginationLeftIconTemplate: a,
  paginationRightIconTemplate: l,
  paginationEndIconTemplate: p,
  classes: u
}, _, f) => {
  const g = e.map((m) => m === "All" ? `<option value="${m}" ${m === t ? "selected" : ""}>${o}</option>` : `<option value="${m}" ${m === t ? "selected" : ""}>${m}</option>`).join(`
`);
  return `
<div class="${u.pagination} ${f ? `${u.paginationBordered}` : ""} ${u.borderColor} ${u.color}">
  <div class="${u.selectItemsWrapper}">  
    <p class="${u.paginationRowsText} ${_ ? `${u.loadingPaginationRowsText}` : ""}">${n}</p>
    <div class="${u.selectWrapper} ${_ ? `${u.loadingPaginationSelectWrapper}` : ""}">
      <select name="entries"
        ${_ ? "disabled" : ""} class="select" ${Xv}>
        ${g}
      </select>
    </div>
  </div>
  <div class="${u.paginationNav} ${_ ? `${u.loadingPaginationNav}` : ""}" ${Gv}>
  ${s}
  </div>
  <div class="${u.paginationButtonsWrapper}">
    ${i ? `<button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationStartButton}" ${Qv}>
           ${r}
          </button>` : ""}
    <button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationLeftButton}" ${Zv}>
      ${a}
  </button>
    <button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationRightButton}" ${qv}>
      ${l}
  </button>
    ${i ? `<button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationEndButton}" ${Jv}>
           ${p}
          </button>` : ""}
  </div>
</div>
`;
}, eT = "data-te-datatable-sort-icon-ref", iT = "data-te-datatable-header-checkbox-ref", sT = (s, t, e, i, n, o, r, a) => {
  const l = e ? `
  <th scope="col">
    <div class="${a.checkboxHeaderWrapper}">
      <input
        class="${a.checkboxHeader}"
        type="checkbox"
        value=""
        ${iT}
        />
    </div>
  </th>
  ` : '<th scope="col"></th>', p = s.map((u, _) => {
    const f = u.fixed ? s.filter((g, m) => g.fixed === u.fixed && m < _).reduce((g, m) => g + m.width, 0) : null;
    return `<th class="${a.column} ${i ? `${a.tableBordered}` : ""} ${a.borderColor} ${n ? `${a.sm}` : ""} ${u.fixed ? `${a.fixedHeader} ${a.color}` : ""} ${o ? `${a.loadingColumn}` : ""}" style="${u.fixed ? `${u.fixed === "right" ? "right" : "left"}: ${f}px;` : ""}" scope="col">${u.sort ? `<div class="${a.sortIconWrapper}"><span class="${a.sortIcon} ${o ? "invisible" : ""}" data-te-sort="${u.field}" ${eT}>${r}</span>` : ""} <span class="${u.sort ? "" : "pl-[18px]"}">${u.label}</span></div></th>`;
  });
  return [t ? l : "", ...p].join(`
`);
}, nT = "data-te-datatable-row-ref", oT = "data-te-datatable-row-checkbox-ref", rT = "data-te-datatable-cell-ref", aT = ({
  rows: s,
  columns: t,
  noFoundMessage: e,
  edit: i,
  selectable: n,
  loading: o,
  bordered: r,
  borderless: a,
  striped: l,
  hover: p,
  sm: u,
  classes: _
}) => {
  const f = s.map((g) => {
    const m = `
      <td data-te-field="checkbox" class="${r ? `${_.tableBordered} ${_.borderColor}` : ""}">
        <div class="${_.checkboxRowWrapper}">
          <input
            class="${_.checkboxRow}"
            type="checkbox"
            value=""
            data-te-row-index="${g.rowIndex}"  ${oT}/>
        </div>
      </td>`, b = t.map((v, T) => {
      const y = {};
      if (v.width && (y["min-width"] = `${v.width - 1}px`, y["max-width"] = `${v.width}px`, y.width = `${v.width}px`), v.fixed) {
        const E = t.filter((w, k) => w.fixed === v.fixed && k < T).reduce((w, k) => w + k.width, 0);
        y[v.fixed === "right" ? "right" : "left"] = `${E}px`;
      }
      return `<td style="${Object.keys(y).map((E) => `${E}: ${y[E]}`).join("; ")}" class="${_.rowItem} ${_.borderColor} ${i ? `${_.edit}` : ""} ${r ? `${_.tableBordered}` : ""} ${u ? `${_.sm}` : ""} ${v.fixed ? `${_.fixedHeader} ${_.color}` : ""}" ${rT} data-te-field="${v.field}" ${i && 'contenteditable="true"'}>${g[v.field]}</td>`;
    }).join("");
    return `<tr scope="row" class="${_.row} ${_.borderColor} ${_.rowAnimation} ${l ? `${_.striped}` : ""} ${a ? `${_.borderless}` : ""} ${p ? `${_.hoverRow}` : ""}" data-te-index="${g.rowIndex}" ${nT}>${n ? m : ""}${b}</tr>`;
  });
  return s.length > 0 || o ? f.join(`
`) : `<tr class="${_.noFoundMessageWrapper} ${_.borderColor}"><td class="${_.noFoundMessage}">${e}</td></tr>`;
}, lT = "data-te-datatable-inner-ref", cT = "data-te-datatable-header-ref", Pl = ({
  columns: s,
  rows: t,
  noFoundMessage: e,
  edit: i,
  multi: n,
  selectable: o,
  loading: r,
  loadingMessage: a,
  pagination: l,
  bordered: p,
  borderless: u,
  striped: _,
  hover: f,
  fixedHeader: g,
  sm: m,
  sortIconTemplate: b,
  classes: v
}) => {
  const T = aT({
    rows: t,
    columns: s,
    noFoundMessage: e,
    edit: i,
    loading: r,
    selectable: o,
    bordered: p,
    borderless: u,
    striped: _,
    hover: f,
    sm: m,
    classes: v
  }), y = sT(
    s,
    o,
    n,
    p,
    m,
    r,
    b,
    v
  );
  return { table: `
<div class="${v.color}" ${lT}>
  <table class="${v.table}">
    <thead class="${v.tableHeader} ${p ? `${v.tableBordered}` : ""} ${u ? `${v.borderless}` : ""} ${v.borderColor}" ${cT}>
      <tr>
        ${y}
      </tr>
    </thead>
    <tbody class="${g ? `${v.fixedHeaderBody}` : ""}">
      ${r ? "" : T}
    </tbody>
  </table>
</div>
${r ? `
  <div class="${v.loadingItemsWrapper}">
    <div class="${v.loadingProgressBarWrapper}">
      <div class="${v.loadingProgressBar}"></div>
    </div>
  </div>
<p class="${v.loadingMessage}">${a}</p>
` : ""}
${l.enable ? tT(l, r, p) : ""}
  `, rows: T, column: y };
}, hT = ({ rows: s, field: t, order: e }) => s.sort((n, o) => {
  let r = n[t], a = o[t];
  return typeof r == "string" && (r = r.toLowerCase()), typeof a == "string" && (a = a.toLowerCase()), r < a ? e === "desc" ? 1 : -1 : r > a ? e === "desc" ? -1 : 1 : 0;
}), dT = (s, t, e) => {
  if (!t)
    return s;
  const i = (n) => {
    const o = document.createElement("div");
    return o.innerHTML = n, n = o.textContent || o.innerText || "", n.toString().toLowerCase().match(t.toLowerCase());
  };
  return s.filter((n) => {
    if (e && typeof e == "string")
      return i(n[e]);
    let o = Object.values(n);
    return e && Array.isArray(e) && (o = Object.keys(n).filter((r) => e.includes(r)).map((r) => n[r])), o.filter((r) => i(r)).length > 0;
  });
}, Bl = ({ rows: s, entries: t, activePage: e }) => {
  const i = e * t;
  return s.slice(i, i + Number(t));
}, Vi = "datatable", gt = `data-te-${Vi}`, ki = `te.${Vi}`, An = `.${ki}`, uT = `[${gt}-inner-ref]`, wo = `[${gt}-cell-ref]`, pT = `[${gt}-header-ref]`, _T = `[${gt}-header-checkbox-ref]`, fT = `[${gt}-pagination-right-ref]`, mT = `[${gt}-pagination-left-ref]`, gT = `[${gt}-pagination-start-ref]`, bT = `[${gt}-pagination-end-ref]`, vT = `[${gt}-pagination-nav-ref]`, TT = `[${gt}-select-ref]`, ko = `[${gt}-sort-icon-ref]`, Ti = `[${gt}-row-ref]`, xo = `[${gt}-row-checkbox-ref]`, ET = `selectRows${An}`, Hl = `render${An}`, CT = `rowClick${An}`, AT = `update${An}`, yT = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 10.5L12 3m0 0l7.5 7.5M12 3v18" />
</svg>`, wT = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M18.75 19.5l-7.5-7.5 7.5-7.5m-6 15L5.25 12l7.5-7.5" />
</svg>`, kT = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
</svg>`, xT = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
</svg>`, OT = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M11.25 4.5l7.5 7.5-7.5 7.5m-6-15l7.5 7.5-7.5 7.5"/>
</svg>`, ST = "border-neutral-200 dark:border-neutral-500", IT = "border-none", DT = "relative float-left -ml-[1.5rem] mr-[6px] mt-[0.15rem] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:-mt-px checked:after:ml-[0.25rem] checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-l-0 checked:after:border-t-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:-mt-px checked:focus:after:ml-[0.25rem] checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-l-0 checked:focus:after:border-t-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent dark:border-neutral-600 dark:checked:border-primary dark:checked:bg-primary dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:border-neutral-400", $T = "mb-[0.125rem] min-h-[1.5rem] pl-[1.5rem] ml-3 flex items-center", LT = "relative float-left -ml-[1.5rem] mr-[6px] mt-[0.15rem] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:-mt-px checked:after:ml-[0.25rem] checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-l-0 checked:after:border-t-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:-mt-px checked:focus:after:ml-[0.25rem] checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-l-0 checked:focus:after:border-t-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent dark:border-neutral-600 dark:checked:border-primary dark:checked:bg-primary dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:border-neutral-400", NT = "mb-[0.125rem] min-h-[1.5rem] pl-[1.5rem] ml-3 flex items-center", MT = "bg-white dark:bg-neutral-800", RT = "py-4 pl-1 text-clip overflow-hidden text-[#212529] dark:text-white", PT = "focus:outline-none", BT = "sticky top-0 z-30", HT = "sticky z-10 bg-inherit", VT = "hover:bg-neutral-100 dark:hover:bg-neutral-700", WT = "pointer-events-none cursor-none text-neutral-400 dark:text-neutral-300", FT = "h-[2px] relative w-full overflow-hidden", YT = "text-center text-neutral-500 font-ligh text-sm my-4 dark:text-neutral-400", jT = "text-neutral-500 dark:text-neutral-300", KT = "text-neutral-500 dark:text-neutral-300", zT = "pointer-events-none cursor-none", UT = "h-full w-[45%] bg-primary-400 dark:bg-primary-600", XT = "h-full animate-[progress_3s_ease-in-out_infinite]", GT = "pl-2 py-3 font-light text-sm dark:text-neutral-300", qT = "border-b", ZT = "flex md:flex-row justify-end items-center py-2 space-x-4 text-sm flex-col leading-[1.6]", QT = "border border-t-0", JT = "order-1 my-3 md:order-none md:my-0 md:pr-1", tE = "inline-block rounded p-2.5 text-xs font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", eE = "inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", iE = "font-normal order-2 mb-3 md:order-none md:mb-0", sE = "inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", nE = "font-light", oE = "inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", rE = "border-b", aE = "transition ease-in-out duration-300 motion-reduce:transition-none", lE = "whitespace-nowrap text-clip overflow-auto px-[1.4rem] py-4", cE = "relative", hE = "!bg-neutral-100 dark:!bg-neutral-600", dE = "flex items-center space-x-4 order-3 md:order-none", uE = "w-[70px]", pE = "!py-2", _E = "w-[15px] h-[10px] origin-bottom font-black mr-1 opacity-0 text-neutral-500 group-hover:opacity-100 transition hover:ease-in-out transform ease-linear duration-300 motion-reduce:transition-none dark:text-neutral-400", fE = "flex flex-row group", mE = "[&:nth-child(odd)]:bg-neutral-50 [&:nth-child(odd)]:dark:bg-neutral-700", gE = "border", bE = "border-b font-normal px-[1.4rem]", vE = "text-left text-sm font-light w-full leading-[1.6]", TE = {
  bordered: "boolean",
  borderless: "boolean",
  clickableRows: "boolean",
  defaultValue: "string",
  edit: "boolean",
  entries: "(number|string)",
  entriesOptions: "array",
  fullPagination: "boolean",
  hover: "boolean",
  loading: "boolean",
  loadingMessage: "string",
  maxWidth: "(null|number|string)",
  maxHeight: "(null|number|string)",
  multi: "boolean",
  noFoundMessage: "string",
  pagination: "boolean",
  selectable: "boolean",
  sm: "boolean",
  sortField: "(null|string)",
  sortOrder: "string",
  fixedHeader: "boolean",
  striped: "boolean",
  rowsText: "string",
  ofText: "string",
  allText: "string",
  forceSort: "boolean",
  sortIconTemplate: "string",
  paginationStartIconTemplate: "string",
  paginationEndIconTemplate: "string",
  paginationLeftIconTemplate: "string",
  paginationRightIconTemplate: "string"
}, EE = {
  bordered: !1,
  borderless: !1,
  clickableRows: !1,
  defaultValue: "-",
  edit: !1,
  entries: 10,
  entriesOptions: [10, 25, 50, 200],
  fixedHeader: !1,
  fullPagination: !1,
  hover: !1,
  loading: !1,
  loadingMessage: "Loading results...",
  maxWidth: null,
  maxHeight: null,
  multi: !1,
  noFoundMessage: "No matching results found",
  pagination: !0,
  selectable: !1,
  sm: !1,
  sortField: null,
  sortOrder: "asc",
  striped: !1,
  rowsText: "Rows per page:",
  ofText: "of",
  allText: "All",
  forceSort: !1,
  sortIconTemplate: yT,
  paginationStartIconTemplate: wT,
  paginationEndIconTemplate: OT,
  paginationLeftIconTemplate: kT,
  paginationRightIconTemplate: xT
}, CE = {
  label: "string",
  field: "string",
  fixed: "(boolean|string)",
  format: "(function|null)",
  width: "(number|null)",
  sort: "boolean",
  columnIndex: "number"
}, AE = {
  label: "",
  field: "",
  fixed: !1,
  format: null,
  width: null,
  sort: !0,
  columnIndex: 0
}, yE = {
  table: vE,
  tableHeader: bE,
  column: RT,
  pagination: ZT,
  selectWrapper: uE,
  scroll: cE,
  tableBordered: gE,
  paginationBordered: QT,
  borderless: IT,
  checkboxRowWrapper: NT,
  checkboxRow: LT,
  checkboxHeaderWrapper: $T,
  checkboxHeader: DT,
  row: rE,
  rowItem: lE,
  striped: mE,
  sortIconWrapper: fE,
  sortIcon: _E,
  paginationRowsText: nE,
  paginationNav: iE,
  paginationButtonsWrapper: JT,
  hoverRow: VT,
  borderColor: ST,
  color: MT,
  fixedHeader: BT,
  fixedHeaderBody: HT,
  selectableRow: hE,
  rowAnimation: aE,
  sm: pE,
  edit: PT,
  selectItemsWrapper: dE,
  paginationStartButton: oE,
  paginationLeftButton: eE,
  paginationRightButton: sE,
  paginationEndButton: tE,
  loadingItemsWrapper: FT,
  loadingProgressBarWrapper: XT,
  loadingProgressBar: UT,
  loadingMessage: YT,
  loadingPaginationRowsText: KT,
  loadingPaginationSelectWrapper: zT,
  loadingPaginationNav: jT,
  loadingColumn: WT,
  noFoundMessageWrapper: qT,
  noFoundMessage: GT
}, wE = {
  table: "string",
  tableHeader: "string",
  column: "string",
  pagination: "string",
  selectWrapper: "string",
  scroll: "string",
  tableBordered: "string",
  paginationBordered: "string",
  borderless: "string",
  checkboxRowWrapper: "string",
  checkboxRow: "string",
  checkboxHeaderWrapper: "string",
  checkboxHeader: "string",
  row: "string",
  rowItem: "string",
  striped: "string",
  sortIconWrapper: "string",
  sortIcon: "string",
  paginationRowsText: "string",
  paginationNav: "string",
  paginationButtonsWrapper: "string",
  hoverRow: "string",
  borderColor: "string",
  color: "string",
  fixedHeader: "string",
  fixedHeaderBody: "string",
  selectableRow: "string",
  rowAnimation: "string",
  sm: "string",
  edit: "string",
  selectItemsWrapper: "string",
  paginationStartButton: "string",
  paginationLeftButton: "string",
  paginationRightButton: "string",
  paginationEndButton: "string",
  loadingItemsWrapper: "string",
  loadingProgressBarWrapper: "string",
  loadingProgressBar: "string",
  loadingMessage: "string",
  loadingPaginationRowsText: "string",
  loadingPaginationSelectWrapper: "string",
  loadingPaginationNav: "string",
  loadingColumn: "string",
  noFoundMessageWrapper: "string",
  noFoundMessage: "string"
};
class Hh {
  constructor(t, e = {}, i = {}, n = {}) {
    this._element = t, this._options = this._getOptions(i), this._classes = this._getClasses(n), this._sortReverse = !1, this._activePage = 0, this._search = "", this._searchColumn = null, this._paginationLeft = null, this._paginationRight = null, this._paginationStart = null, this._paginationEnd = null, this._select = null, this._selectInstance = null, this._selected = [], this._checkboxes = null, this._headerCheckbox = null, this._rows = this._getRows(e.rows), this._columns = this._getColumns(e.columns), this._element && (A.setData(t, ki, this), this._perfectScrollbar = null, this._setup());
  }
  // Getters
  static get NAME() {
    return Vi;
  }
  get columns() {
    return this._columns.map((t, e) => {
      let i = {
        ...AE,
        field: `field_${e}`,
        columnIndex: e
      };
      return typeof t == "string" ? i.label = t : typeof t == "object" && (i = {
        ...i,
        ...t
      }), I("column", i, CE), i;
    });
  }
  get rows() {
    return this._rows.map((t, e) => {
      const i = {
        rowIndex: e
      };
      return Array.isArray(t) ? this.columns.forEach((n, o) => {
        t[o] === 0 ? i[n.field] = t[o] : i[n.field] = t[o] || this._options.defaultValue;
      }) : typeof t == "object" && this.columns.forEach((n) => {
        t[n.field] === 0 ? i[n.field] = t[n.field] : i[n.field] = t[n.field] || this._options.defaultValue;
      }), i;
    });
  }
  get searchResult() {
    return dT(this.rows, this._search, this._searchColumn);
  }
  get computedRows() {
    let t = [...this.searchResult];
    return this._options.sortOrder && (t = hT({
      rows: t,
      field: this._options.sortField,
      order: this._options.sortOrder
    })), this._options.pagination && (this._options.entries === "All" ? t = Bl({
      rows: t,
      entries: t.length,
      activePage: this._activePage
    }) : t = Bl({
      rows: t,
      entries: this._options.entries,
      activePage: this._activePage
    })), t;
  }
  get pages() {
    return this._options.entries === "All" ? 1 : Math.ceil(this.searchResult.length / this._options.entries);
  }
  get navigationText() {
    const t = this._activePage * this._options.entries;
    return this.searchResult.length === 0 ? `0 ${this._options.ofText} 0` : this._options.entries === "All" ? `1 - ${this.searchResult.length} ${this._options.ofText} ${this.searchResult.length}` : `${t + 1} - ${this.computedRows.length + t} ${this._options.ofText} ${this.searchResult.length}`;
  }
  get tableOptions() {
    return {
      classes: this._classes,
      columns: this.columns,
      rows: this.computedRows,
      noFoundMessage: this._options.noFoundMessage,
      edit: this._options.edit,
      loading: this._options.loading,
      loaderClass: this._options.loaderClass,
      loadingMessage: this._options.loadingMessage,
      selectable: this._options.selectable,
      multi: this._options.multi,
      bordered: this._options.bordered,
      borderless: this._options.borderless,
      striped: this._options.striped,
      hover: this._options.hover,
      fixedHeader: this._options.fixedHeader,
      sm: this._options.sm,
      sortIconTemplate: this._options.sortIconTemplate,
      pagination: {
        enable: this._options.pagination,
        text: this.navigationText,
        entries: this._options.entries,
        entriesOptions: this._options.entriesOptions,
        fullPagination: this._options.fullPagination,
        rowsText: this._options.rowsText,
        ofText: this._options.ofText,
        allText: this._options.allText,
        paginationStartIconTemplate: this._options.paginationStartIconTemplate,
        paginationLeftIconTemplate: this._options.paginationLeftIconTemplate,
        paginationRightIconTemplate: this._options.paginationRightIconTemplate,
        paginationEndIconTemplate: this._options.paginationEndIconTemplate,
        classes: this._classes
      },
      forceSort: this._options.forceSort
    };
  }
  // Public
  update(t, e = {}) {
    t && t.rows && (this._rows = t.rows), t && t.columns && (this._columns = t.columns), this._clearClassList(e), this._options = this._getOptions({ ...this._options, ...e }), this._setup(), this._performSort();
  }
  dispose() {
    this._selectInstance && this._selectInstance.dispose(), A.removeData(this._element, ki), this._removeEventListeners(), this._perfectScrollbar.destroy(), this._element = null;
  }
  search(t, e) {
    this._search = t, this._searchColumn = e, this._activePage = 0, this._options.pagination && this._toggleDisableState(), this._renderRows(), this._options.maxHeight && (this._perfectScrollbar.element.scrollTop = 0, this._perfectScrollbar.update());
  }
  sort(t, e = "asc") {
    this._options.sortOrder = e, typeof t == "string" ? this._options.sortField = this.columns.find(
      (n) => n.label === t
    ).field : this._options.sortField = t.field;
    const i = d.findOne(
      `[data-te-sort="${this._options.sortField}"]`,
      this._element
    );
    this._activePage = 0, this._toggleDisableState(), this._renderRows(), this._setActiveSortIcon(i);
  }
  setActivePage(t) {
    t < this.pages && this._changeActivePage(t);
  }
  // Private
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...yE,
      ...e,
      ...t
    }, I(Vi, t, wE), t;
  }
  _changeActivePage(t) {
    this._activePage = t, this._toggleDisableState(), this._renderRows();
  }
  _clearClassList(t) {
    ["hover", "bordered", "borderless", "sm", "striped"].forEach((e) => {
      this._options[e] && !t[e] && h.removeDataAttribute(`data-te-${e}`);
    });
  }
  _emitSelectEvent() {
    c.trigger(this._element, ET, {
      selectedRows: this.rows.filter(
        (t) => this._selected.indexOf(t.rowIndex) !== -1
      ),
      selectedIndexes: this._selected,
      allSelected: this._selected.length === this.rows.length
    });
  }
  _getRows(t = []) {
    const e = d.findOne("tbody", this._element);
    return e ? [...d.find("tr", e).map((n) => d.find("td", n).map((o) => o.innerHTML)), ...t] : t;
  }
  _getColumns(t = []) {
    const e = d.findOne("thead", this._element);
    if (!e)
      return t;
    const i = d.findOne("tr", e);
    return [...d.find("th", i).map((o) => ({
      label: o.innerHTML,
      ...h.getDataAttributes(o)
    })), ...t];
  }
  _getCSSValue(t) {
    return typeof t == "string" ? t : `${t}px`;
  }
  _getOptions(t) {
    const e = {
      ...EE,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(Vi, e, TE), e;
  }
  _setActiveRows() {
    d.find(Ti, this._element).forEach((t) => {
      this._selected.includes(h.getDataAttribute(t, "index")) ? h.addClass(t, `active ${this._classes.selectableRow}`) : h.removeClass(t, `active ${this._classes.selectableRow}`);
    });
  }
  _setEntries(t) {
    this._options = this._getOptions({
      ...this._options,
      entries: t.target.value
    }), this._activePage > this.pages - 1 && (this._activePage = this.pages - 1), this._toggleDisableState(), this._renderRows();
  }
  _setSelected() {
    d.find(xo, this._element).forEach(
      (t) => {
        const e = h.getDataAttribute(t, "rowIndex");
        t.checked = this._selected.includes(e);
      }
    ), this._setActiveRows();
  }
  _setActiveSortIcon(t) {
    d.find(ko, this._element).forEach((e) => {
      const i = this._options.sortOrder === "desc" && e === t ? 180 : 0;
      h.style(e, {
        transform: `rotate(${i}deg)`
      }), e === t && this._options.sortOrder ? h.addClass(e, "opacity-100") : h.removeClass(e, "opacity-100");
    });
  }
  _setup() {
    this._renderTable(), this._options.pagination && this._setupPagination(), this._options.edit && this._setupEditable(), this._options.clickableRows && this._setupClickableRows(), this._options.selectable && this._setupSelectable(), this._setupScroll(), this._setupSort();
  }
  _setupClickableRows() {
    d.find(Ti, this._element).forEach((t) => {
      const e = h.getDataAttribute(t, "index");
      h.addClass(t, "cursor-pointer"), c.on(t, "click", (i) => {
        d.matches(i.target, xo) || c.trigger(this._element, CT, {
          index: e,
          row: this.rows[e]
        });
      });
    });
  }
  _setupEditable() {
    d.find(Ti, this._element).forEach((t) => {
      const e = h.getDataAttribute(t, "index");
      d.find(wo, t).forEach((i) => {
        c.on(i, "input", (n) => this._updateRow(n, e));
      });
    });
  }
  _setupScroll() {
    const t = d.findOne(uT, this._element), e = {};
    if (this._options.maxHeight && (e.maxHeight = this._getCSSValue(this._options.maxHeight)), this._options.maxWidth) {
      const i = this._getCSSValue(this._options.maxWidth);
      e.maxWidth = i, h.style(this._element, { maxWidth: i });
    }
    if (h.style(t, e), h.addClass(t, `${this._classes.scroll}`), this._options.fixedHeader) {
      let i = d.find(pT, this._element);
      this._options.selectable && (i = i.filter((n, o) => (h.addClass(
        n,
        `${this._classes.fixedHeader} ${this._classes.color}`
      ), o !== 0))), i.forEach((n, o) => {
        h.addClass(
          n,
          `${this._classes.fixedHeader} ${this._classes.color}`
        ), this.columns[o].fixed && h.addClass(n, "!z-40");
      });
    }
    this._perfectScrollbar = new Bh(t);
  }
  _setupSort() {
    d.find(ko, this._element).forEach((t) => {
      const e = h.getDataAttribute(t, "sort"), [i] = d.parents(t, "th");
      if (this.columns.sort)
        h.addClass(i, "cursor-pointer");
      else
        return;
      e === this._options.sortField && this._setActiveSortIcon(t), c.on(i, "click", () => {
        this._options.sortField === e && this._options.sortOrder === "asc" ? this._options.sortOrder = "desc" : this._options.sortField === e && this._options.sortOrder === "desc" ? this._options.sortOrder = this._options.forceSort ? "asc" : null : this._options.sortOrder = "asc", this._options.sortField = e, this._activePage = 0, this._performSort(), this._setActiveSortIcon(t);
      });
    });
  }
  _performSort() {
    this._toggleDisableState(), this._renderRows();
  }
  _setupSelectable() {
    this._checkboxes = d.find(xo, this._element), this._headerCheckbox = d.findOne(
      _T,
      this._element
    ), c.on(
      this._headerCheckbox,
      "input",
      (t) => this._toggleSelectAll(t)
    ), this._checkboxes.forEach((t) => {
      const e = h.getDataAttribute(t, "rowIndex");
      c.on(
        t,
        "input",
        (i) => this._toggleSelectRow(i, e)
      );
    });
  }
  _setupPagination() {
    this._paginationRight = d.findOne(
      fT,
      this._element
    ), this._paginationLeft = d.findOne(
      mT,
      this._element
    ), c.on(
      this._paginationRight,
      "click",
      () => this._changeActivePage(this._activePage + 1)
    ), c.on(
      this._paginationLeft,
      "click",
      () => this._changeActivePage(this._activePage - 1)
    ), this._options.fullPagination && (this._paginationStart = d.findOne(
      gT,
      this._element
    ), this._paginationEnd = d.findOne(
      bT,
      this._element
    ), c.on(
      this._paginationStart,
      "click",
      () => this._changeActivePage(0)
    ), c.on(
      this._paginationEnd,
      "click",
      () => this._changeActivePage(this.pages - 1)
    )), this._toggleDisableState(), this._setupPaginationSelect();
  }
  _setupPaginationSelect() {
    this._select = d.findOne(TT, this._element), this._selectInstance = new kr(this._select), c.on(
      this._select,
      "valueChange.te.select",
      (t) => this._setEntries(t)
    );
  }
  _removeEventListeners() {
    this._options.pagination && (c.off(this._paginationRight, "click"), c.off(this._paginationLeft, "click"), c.off(this._select, "valueChange.te.select"), this._options.fullPagination && (c.off(this._paginationStart, "click"), c.off(this._paginationEnd, "click"))), this._options.edit && d.find(wo, this._element).forEach((t) => {
      c.off(t, "input");
    }), this._options.clickableRows && d.find(Ti, this._element).forEach((t) => {
      c.off(t, "click");
    }), d.find(ko, this._element).forEach((t) => {
      const [e] = d.parents(t, "th");
      c.off(e, "click");
    }), this._options.selectable && (c.off(this._headerCheckbox, "input"), this._checkboxes.forEach((t) => {
      c.off(t, "input");
    }));
  }
  _renderTable() {
    this._element.innerHTML = Pl(this.tableOptions).table, this._formatCells(), c.trigger(this._element, Hl);
  }
  _renderRows() {
    const t = d.findOne("tbody", this._element);
    if (this._options.pagination) {
      const e = d.findOne(
        vT,
        this._element
      );
      e.innerText = this.navigationText;
    }
    t.innerHTML = Pl(this.tableOptions).rows, this._formatCells(), this._options.edit && this._setupEditable(), this._options.selectable && (this._setupSelectable(), this._setSelected()), this._options.clickableRows && this._setupClickableRows(), c.trigger(this._element, Hl);
  }
  _formatCells() {
    d.find(Ti, this._element).forEach((e) => {
      const i = h.getDataAttribute(e, "index");
      d.find(wo, e).forEach((o) => {
        const r = h.getDataAttribute(o, "field"), a = this.columns.find((l) => l.field === r);
        a && a.format !== null && a.format(o, this.rows[i][r]);
      });
    });
  }
  _toggleDisableState() {
    this._options.pagination !== !1 && (this._activePage === 0 || this._options.loading ? (this._paginationLeft.setAttribute("disabled", ""), this._options.fullPagination && this._paginationStart.setAttribute("disabled", "")) : (this._paginationLeft.removeAttribute("disabled"), this._options.fullPagination && this._paginationStart.removeAttribute("disabled")), this._activePage === this.pages - 1 || this._options.loading || this.pages === 0 ? (this._paginationRight.setAttribute("disabled", ""), this._options.fullPagination && this._paginationEnd.setAttribute("disabled", "")) : (this._paginationRight.removeAttribute("disabled"), this._options.fullPagination && this._paginationEnd.removeAttribute("disabled")));
  }
  _toggleSelectAll(t) {
    t.target.checked ? this._selected = this.rows.map((e) => e.rowIndex) : this._selected = [], this._setSelected(), this._emitSelectEvent();
  }
  _toggleSelectRow(t, e) {
    t.target.checked ? this._options.multi && !this._selected.includes(e) ? this._selected = [...this._selected, e] : (this._selected = [e], this._checkboxes.forEach((i) => {
      i !== t.target && (i.checked = !1);
    })) : this._selected = this._selected.filter((i) => i !== e), this._options.multi && !t.target.checked && (this._headerCheckbox.checked = !1), this._setActiveRows(), this._emitSelectEvent();
  }
  _updateRow(t, e) {
    const i = h.getDataAttribute(t.target, "field"), n = t.target.textContent, o = this._rows[e];
    if (Array.isArray(o)) {
      const a = this.columns.find((l) => l.field === i).columnIndex;
      o[a] = n;
    } else
      o[i] = n;
    c.trigger(this._element, AT, {
      rows: this._rows,
      columns: this._columns
    });
  }
  static jQueryInterface(t, e, i) {
    return this.each(function() {
      let n = A.getData(this, ki);
      const o = typeof t == "object" && t;
      if (!(!n && /dispose/.test(t)) && (n || (n = new Hh(this, o, e)), typeof t == "string")) {
        if (typeof n[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        n[t](e, i);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, ki);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Vl = "rating", sn = "te.rating", kE = "data-te-rating-init", xE = "[data-te-rating-icon-ref]", ci = `.${sn}`, OE = "ArrowLeft", SE = "ArrowRight", IE = {
  tooltip: "string",
  value: "(string|number)",
  readonly: "boolean",
  after: "string",
  before: "string",
  dynamic: "boolean",
  active: "string"
}, DE = {
  tooltip: "top",
  value: "",
  readonly: !1,
  after: "",
  before: "",
  dynamic: !1,
  active: "fill-current"
}, Wl = `onSelect${ci}`, $E = `onHover${ci}`, Fl = `keyup${ci}`, Yl = `focusout${ci}`, jl = `keydown${ci}`, Kl = `mousedown${ci}`;
class GA {
  constructor(t, e) {
    this._element = t, this._icons = d.find(xE, this._element), this._options = this._getConfig(e), this._index = -1, this._savedIndex = null, this._originalClassList = [], this._originalIcons = [], this._fn = {}, this._tooltips = [], this._element && (A.setData(t, sn, this), this._init());
  }
  // Getters
  static get NAME() {
    return Vl;
  }
  dispose() {
    A.removeData(this._element, sn), this._options.readonly || (c.off(this._element, Fl), c.off(this._element, Yl), c.off(this._element, jl), this._element.removeEventListener("mouseleave", this._fn.mouseleave), this._icons.forEach((t, e) => {
      c.off(t, Kl), t.removeEventListener("mouseenter", this._fn.mouseenter[e]), h.removeClass(t, "cursor-pointer");
    }), this._tooltips.forEach((t) => {
      t._element.removeAttribute(kE), t.dispose();
    }), this._icons.forEach((t) => t.removeAttribute("tabIndex"))), this._element = null;
  }
  // Private
  _init() {
    this._options.readonly || (this._bindMouseEnter(), this._bindMouseLeave(), this._bindMouseDown(), this._bindKeyDown(), this._bindKeyUp(), this._bindFocusLost(), this._icons.forEach((t) => {
      h.addClass(t, "cursor-pointer");
    })), this._options.dynamic && (this._saveOriginalClassList(), this._saveOriginalIcons()), this._setCustomText(), this._setToolTips(), this._options.value && (this._index = this._options.value - 1, this._updateRating(this._index));
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...DE,
      ...e,
      ...t
    }, I(Vl, t, IE), t;
  }
  _bindMouseEnter() {
    this._fn.mouseenter = [], this._icons.forEach((t, e) => {
      t.addEventListener(
        "mouseenter",
        // this._fn.mouseenter[i] is needed to create reference and unpin events after call dispose
        // prettier-ignore
        this._fn.mouseenter[e] = (i) => {
          this._index = this._icons.indexOf(i.target), this._updateRating(this._index), this._triggerEvents(t, $E);
        }
      );
    });
  }
  _bindMouseLeave() {
    this._element.addEventListener(
      "mouseleave",
      // this._fn.mouseleave is needed to create reference and unpin events after call dispose
      // prettier-ignore
      this._fn.mouseleave = () => {
        this._savedIndex !== null ? (this._updateRating(this._savedIndex), this._index = this._savedIndex) : this._options.value ? (this._updateRating(this._options.value - 1), this._index = this._options.value - 1) : (this._index = -1, this._clearRating());
      }
    );
  }
  _bindMouseDown() {
    this._icons.forEach((t) => {
      c.on(t, Kl, () => {
        this._setElementOutline("none"), this._savedIndex = this._index, this._triggerEvents(t, Wl);
      });
    });
  }
  _bindKeyDown() {
    this._element.tabIndex = 0, c.on(
      this._element,
      jl,
      (t) => this._updateAfterKeyDown(t)
    );
  }
  _bindKeyUp() {
    c.on(
      this._element,
      Fl,
      () => this._setElementOutline("auto")
    );
  }
  _bindFocusLost() {
    c.on(
      this._element,
      Yl,
      () => this._setElementOutline("none")
    );
  }
  _setElementOutline(t) {
    this._element.style.outline = t;
  }
  _triggerEvents(t, e) {
    c.trigger(t, e, {
      value: this._index + 1
    });
  }
  _updateAfterKeyDown(t) {
    const e = this._icons.length - 1, i = this._index;
    t.key === SE && this._index < e && (this._index += 1), t.key === OE && this._index > -1 && (this._index -= 1), i !== this._index && (this._savedIndex = this._index, this._updateRating(this._savedIndex), this._triggerEvents(this._icons[this._savedIndex], Wl));
  }
  _updateRating(t) {
    this._clearRating(), this._options.dynamic && this._restoreOriginalIcon(t), this._icons.forEach((e, i) => {
      i <= t && h.addClass(e.querySelector("svg"), this._options.active);
    });
  }
  _clearRating() {
    this._icons.forEach((t, e) => {
      const i = t.querySelector("svg");
      this._options.dynamic && (t.classList = this._originalClassList[e], i.innerHTML = this._originalIcons[e]), h.removeClass(i, this._options.active);
    });
  }
  _setToolTips() {
    this._icons.forEach((t, e) => {
      const i = h.getDataAttribute(t, "toggle");
      t.title && !i && (h.setDataAttribute(t, "toggle", "tooltip"), this._tooltips[e] = new ri(t, {
        placement: this._options.tooltip
      }));
    });
  }
  _setCustomText() {
    this._icons.forEach((t) => {
      const e = h.getDataAttribute(t, "after"), i = h.getDataAttribute(t, "before");
      e && t.insertAdjacentHTML("afterEnd", e), i && t.insertAdjacentHTML("beforeBegin", i);
    });
  }
  _saveOriginalClassList() {
    this._icons.forEach((t) => {
      const e = t.classList.value;
      this._originalClassList.push(e);
    });
  }
  _saveOriginalIcons() {
    this._icons.forEach((t) => {
      const e = t.querySelector("svg").innerHTML;
      this._originalIcons.push(e);
    });
  }
  _restoreOriginalIcon(t) {
    const e = this._originalClassList[t], i = this._originalIcons[t];
    this._icons.forEach((n, o) => {
      if (o <= t) {
        const r = n.querySelector("svg");
        r.innerHTML = i, n.classList = e;
      }
    });
  }
  // Static
  static getInstance(t) {
    return A.getData(t, sn);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Oo = "popconfirm", xi = "te.popconfirm", Vh = `.${xi}`, LE = `cancel${Vh}`, NE = `confirm${Vh}`, ME = "[data-te-popconfirm-body]", So = "data-te-popconfirm-popover", RE = "data-te-popconfirm-modal", zl = "data-te-popconfirm-backdrop", PE = {
  popconfirmMode: "string",
  message: "string",
  cancelText: "(null|string)",
  okText: "(null|string)",
  popconfirmIconTemplate: "string",
  cancelLabel: "(null|string)",
  confirmLabel: "(null|string)",
  position: "(null|string)"
}, BE = {
  popconfirmMode: "inline",
  message: "Are you sure?",
  cancelText: "Cancel",
  okText: "OK",
  popconfirmIconTemplate: "",
  cancelLabel: "Cancel",
  confirmLabel: "Confirm",
  position: "bottom"
}, HE = {
  backdrop: "string",
  body: "string",
  btnCancel: "string",
  btnConfirm: "string",
  btnsContainer: "string",
  fade: "string",
  icon: "string",
  message: "string",
  messageText: "string",
  modal: "string",
  popover: "string"
}, VE = {
  backdrop: "h-full w-full z-[1070] fixed top-0 left-0 bg-[#00000066] flex justify-center items-center",
  body: "p-[1rem] bg-white rounded-[0.5rem] opacity-0 dark:bg-neutral-700",
  btnCancel: "inline-block rounded bg-primary-100 px-4 pb-[5px] pt-[6px] text-xs font-medium uppercase leading-normal text-primary-700 transition duration-150 ease-in-out hover:bg-primary-accent-100 focus:bg-primary-accent-100 focus:outline-none focus:ring-0 active:bg-primary-accent-200",
  btnConfirm: "inline-block rounded bg-primary px-4 pb-[5px] pt-[6px] text-xs font-medium uppercase leading-normal text-white shadow-[0_4px_9px_-4px_#3b71ca] transition duration-150 ease-in-out hover:bg-primary-600 hover:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] focus:bg-primary-600 focus:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] focus:outline-none focus:ring-0 active:bg-primary-700 active:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] dark:shadow-[0_4px_9px_-4px_rgba(59,113,202,0.5)] dark:hover:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)] dark:focus:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)] dark:active:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)]",
  btnsContainer: "flex justify-end space-x-2",
  fade: "transition-opacity duration-[150ms] ease-linear",
  icon: "pr-2",
  message: "flex mb-3",
  messageText: "text-neutral-600 dark:text-white",
  modal: "absolute w-[300px] z-[1080] shadow-sm rounded-[0.5rem]",
  popover: "w-[300px] border-0 rounded-[0.5rem] z-[1080] shadow-sm"
};
class Wh {
  constructor(t, e, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._popper = null, this._cancelButton = "", this._confirmButton = "", this._isOpen = !1, this._uid = this._element.id ? `popconfirm-${this._element.id}` : et("popconfirm-"), t && A.setData(t, xi, this), this._clickHandler = this.open.bind(this), c.on(this._element, "click", this._clickHandler);
  }
  // Getters
  static get NAME() {
    return Oo;
  }
  get container() {
    return d.findOne(`#${this._uid}`);
  }
  get popconfirmBody() {
    return d.findOne(
      ME,
      this.container
    );
  }
  // Public
  dispose() {
    (this._isOpen || this.container !== null) && this.close(), A.removeData(this._element, xi), c.off(this._element, "click", this._clickHandler), this._element = null;
  }
  open() {
    this._isOpen || (this._options.popconfirmMode === "inline" ? this._openPopover(this._getPopoverTemplate()) : this._openModal(this._getModalTemplate()), this._handleCancelButtonClick(), this._handleConfirmButtonClick(), this._listenToEscapeKey(), this._listenToOutsideClick());
  }
  close() {
    if (this._isOpen) {
      if (this._popper !== null || d.findOne(`[${So}]`) !== null)
        c.on(
          this.popconfirmBody,
          "transitionend",
          this._handlePopconfirmTransitionEnd.bind(this)
        ), h.removeClass(this.popconfirmBody, "opacity-100");
      else {
        const t = d.findOne(
          `[${zl}]`
        );
        h.removeClass(this.popconfirmBody, "opacity-100"), document.body.removeChild(t), this._isOpen = !1;
      }
      c.off(document, "click", this._handleOutsideClick.bind(this)), c.off(document, "keydown", this._handleEscapeKey.bind(this));
    }
  }
  _handlePopconfirmTransitionEnd(t) {
    if (t.target !== this.popconfirmBody)
      return;
    const e = d.findOne(
      `[${So}]`
    );
    c.off(this.popconfirmBody, "transitionend"), this._isOpen && t && t.propertyName === "opacity" && (this._popper.destroy(), e && document.body.removeChild(e), this._isOpen = !1);
  }
  // Private
  _getPopoverTemplate() {
    const t = $("div"), e = this._getPopconfirmTemplate();
    return t.setAttribute(So, ""), h.addClass(t, this._classes.popover), t.id = this._uid, t.innerHTML = e, t;
  }
  _getModalTemplate() {
    const t = $("div"), e = this._getPopconfirmTemplate();
    return t.setAttribute(RE, ""), h.addClass(t, `${this._classes.modal}`), t.id = this._uid, t.innerHTML = e, t;
  }
  _getPopconfirmTemplate() {
    return `<div data-te-popconfirm-body class="${this._classes.body}">
      <p class="${this._classes.message}">
      ${this._options.popconfirmIconTemplate ? `<span class="${this._classes.icon}">${this._options.popconfirmIconTemplate}</span>` : ""}
      <span class="${this._classes.messageText}">${this._options.message}</span>
      </p>
      <div class="${this._classes.btnsContainer}">
      ${this._options.cancelText ? `<button type="button" data-te-ripple-init data-te-ripple-color="light" id="popconfirm-button-cancel" aria-label="${this._options.cancelLabel}"
        class="${this._classes.btnCancel}">${this._options.cancelText}</button>` : ""}
      <button type="button" data-te-ripple-init data-te-ripple-color="light" id="popconfirm-button-confirm"
      aria-label="${this._options.confirmLabel}"
      class="${this._classes.btnConfirm}">${this._options.okText ? this._options.okText : "Ok"}</button>
      </div>
    </div>`;
  }
  _getConfig(t) {
    return t = {
      ...BE,
      ...h.getDataAttributes(this._element),
      ...t
    }, I(Oo, t, PE), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...VE,
      ...e,
      ...t
    }, I(Oo, t, HE), t;
  }
  _openPopover(t) {
    this._popper = se(this._element, t, {
      placement: this._translatePositionValue(),
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 5]
          }
        }
      ]
    }), document.body.appendChild(t), setTimeout(() => {
      h.addClass(
        this.popconfirmBody,
        `${this._classes.fade} opacity-100`
      ), this._isOpen = !0;
    }, 0);
  }
  _openModal(t) {
    const e = $("div");
    e.setAttribute(zl, ""), h.addClass(e, this._classes.backdrop), document.body.appendChild(e), e.appendChild(t), h.addClass(this.popconfirmBody, "opacity-100"), this._isOpen = !0;
  }
  _handleCancelButtonClick() {
    const t = this.container;
    this._cancelButton = d.findOne(
      "#popconfirm-button-cancel",
      t
    ), ei.getOrCreateInstance(this._cancelButton, { rippleColor: "light" }), this._cancelButton !== null && c.on(this._cancelButton, "click", () => {
      this.close(), c.trigger(this._element, LE);
    });
  }
  _handleConfirmButtonClick() {
    const t = this.container;
    this._confirmButton = d.findOne(
      "#popconfirm-button-confirm",
      t
    ), ei.getOrCreateInstance(this._confirmButton, { rippleColor: "light" }), c.on(this._confirmButton, "click", () => {
      this.close(), c.trigger(this._element, NE);
    });
  }
  _listenToEscapeKey() {
    c.on(document, "keydown", this._handleEscapeKey.bind(this));
  }
  _handleEscapeKey(t) {
    t.keyCode === we && this.close();
  }
  _listenToOutsideClick() {
    c.on(document, "click", this._handleOutsideClick.bind(this));
  }
  _handleOutsideClick(t) {
    const e = this.container, i = t.target === e, n = e && e.contains(t.target), o = t.target === this._element, r = this._element && this._element.contains(t.target);
    !i && !n && !o && !r && this.close();
  }
  _translatePositionValue() {
    switch (this._options.position) {
      case "top left":
        return "top-end";
      case "top":
        return "top";
      case "top right":
        return "top-start";
      case "bottom left":
        return "bottom-end";
      case "bottom":
        return "bottom";
      case "bottom right":
        return "bottom-start";
      case "left":
        return "left";
      case "left top":
        return "left-end";
      case "left bottom":
        return "left-start";
      case "right":
        return "right";
      case "right top":
        return "right-end";
      case "right bottom":
        return "right-start";
      case void 0:
        return "bottom";
      default:
        return "bottom";
    }
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      const i = A.getData(this, xi), n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t))) {
        if (!i)
          return new Wh(this, n);
        if (typeof t == "string") {
          if (typeof i[t] > "u")
            throw new TypeError(`No method named "${t}"`);
          i[t](e);
        }
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, xi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Io = "lightbox", Oi = "te.lightbox", WE = `.${Oi}`, FE = ".data-api", Me = `click${WE}${FE}`, Fh = "[data-te-lightbox-init]", YE = `${Fh} img:not([data-te-lightbox-disabled])`, Ul = "data-te-lightbox-caption", jE = "data-te-lightbox-disabled", Dt = "data-te-lightbox-active", KE = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 12h-15m0 0l6.75 6.75M4.5 12l6.75-6.75" />
</svg>
`, zE = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12h15m0 0l-6.75-6.75M19.5 12l-6.75 6.75" />
</svg>
`, UE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
</svg>
`, XE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5l5.25 5.25" />
</svg>
`, GE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6" />
</svg>
`, qE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
<path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM13.5 10.5h-6" />
</svg>
`, ZE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
</svg>
`, QE = {
  container: "string",
  zoomLevel: "(number|string)",
  prevIconTemplate: "string",
  nextIconTemplate: "string",
  showFullscreenIconTemplate: "string",
  hideFullscreenIconTemplate: "string",
  zoomInIconTemplate: "string",
  closeIconTemplate: "string",
  zoomOutIconTemplate: "string",
  spinnerContent: "string"
}, JE = {
  container: "body",
  zoomLevel: 1,
  prevIconTemplate: KE,
  nextIconTemplate: zE,
  showFullscreenIconTemplate: UE,
  hideFullscreenIconTemplate: XE,
  zoomInIconTemplate: GE,
  zoomOutIconTemplate: qE,
  closeIconTemplate: ZE,
  spinnerContent: "Loading..."
}, t0 = {
  caption: "text-white text-ellipsis overflow-hidden whitespace-nowrap mx-[10px] text-center",
  captionWrapper: "fixed left-0 bottom-0 w-full h-[50px] flex justify-center items-center",
  closeBtn: "border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  fullscreenBtn: "border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  gallery: "invisible fixed left-0 top-0 w-full h-full z-[1100] pointer-events-none opacity-0 bg-[#000000e6] transition-all duration-[400ms] motion-reduce:transition-none",
  galleryContent: "fixed top-[50px] left-[50px] w-[calc(100%-100px)] h-[calc(100%-100px)]",
  galleryCounter: "flex justify-center items-center px-[10px] mb-0 h-full text-[#b3b3b3]",
  img: "absolute left-0 top-0 w-full max-h-full h-auto cursor-pointer pointer-events-auto",
  imgWrapper: "absolute top-0 left-0 w-full h-full opacity-0 transform scale-[0.25] transition-all duration-[400ms] ease-out pointer-events-none motion-reduce:transition-none motion-reduce:transform-none",
  leftTools: "float-left h-full",
  loader: "fixed left-0 top-0 z-[2] w-full h-full text-neutral-50 opacity-1 flex justify-center items-center pointer-events-none transition-opacity duration-[1000ms] motion-reduce:transition-none",
  nextBtn: "border-none bg-transparent w-full h-[50px] flex justify-center items-center text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  nextBtnWrapper: "fixed right-0 top-0 w-[50px] h-full flex justify-center items-center transition-opacity duration-[400ms] motion-reduce:transition-none",
  prevBtn: "border-none bg-transparent w-full h-[50px] flex justify-center items-center text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  prevBtnWrapper: "fixed left-0 top-0 w-[50px] h-full flex justify-center items-center transition-opacity duration-[400ms] motion-reduce:transition-none",
  rightTools: "float-right",
  spinner: "inline-block h-8 w-8 animate-[spinner-grow_0.75s_linear_infinite] rounded-full bg-current align-[-0.125em] motion-reduce:animate-[spinner-grow_1.5s_linear_infinite]",
  spinnerContent: "!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]",
  toolbar: "absolute top-0 left-0 w-full h-[50px] z-20 transition-opacity duration-[400ms] motion-reduce:transition-none",
  vertical: "h-full max-h-full w-auto",
  zoomBtn: "border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none"
}, e0 = {
  caption: "string",
  captionWrapper: "string",
  closeBtn: "string",
  fullscreenBtn: "string",
  gallery: "string",
  galleryContent: "string",
  galleryCounter: "string",
  img: "string",
  imgWrapper: "string",
  leftTools: "string",
  loader: "string",
  nextBtn: "string",
  nextBtnWrapper: "string",
  prevBtn: "string",
  prevBtnWrapper: "string",
  rightTools: "string",
  spinner: "string",
  spinnerContent: "string",
  toolbar: "string",
  vertical: "string",
  zoomBtn: "string"
};
class nn {
  constructor(t, e = {}, i) {
    this._element = t, this._options = e, this._classes = this._getClasses(i), this._getContainer(), this._id = `lightbox-${Math.random().toString(36).substr(2, 9)}`, this._activeImg = 0, this._images = [], this._zoom = 1, this._gallery = null, this._galleryToolbar = null, this._galleryContent = null, this._loader = null, this._imgCounter = null, this._animating = !1, this._fullscreen = !1, this._zoomBtn = null, this._fullscreenBtn = null, this._toolsToggleTimer = 0, this._mousedown = !1, this._mousedownPositionX = 0, this._mousedownPositionY = 0, this._originalPositionX = 0, this._originalPositionY = 0, this._positionX = 0, this._positionY = 0, this._zoomTimer = 0, this._tapCounter = 0, this._tapTime = 0, this._rightArrow = null, this._leftArrowWrapper = null, this._rightArrowWrapper = null, this._initiated = !1, this._multitouch = !1, this._touchZoomPosition = [], this._element && (A.setData(t, Oi, this), this.init());
  }
  // Getters
  static get NAME() {
    return Io;
  }
  get activeImg() {
    return this._activeImg;
  }
  get currentImg() {
    return d.findOne(
      `[${Dt}]`,
      this._galleryContent
    );
  }
  get options() {
    const t = {
      ...JE,
      ...h.getDataAttributes(this._element),
      ...this._options
    };
    return I(Io, t, QE), t;
  }
  // Public
  init() {
    this._initiated || (this._appendTemplate(), this._initiated = !0);
  }
  open(t = 0) {
    this._getImages(), this._setActiveImg(t), this._sortImages(), this._triggerEvents("open", "opened"), this._loadImages().then((e) => {
      this._resizeImages(e), this._toggleTemplate(), this._addEvents(), this._focusFullscreenBtn();
    });
  }
  close() {
    this.reset(), this._removeEvents(), this._toggleTemplate(), this._triggerEvents("close", "closed");
  }
  slide(t = "right") {
    this._animating === !0 || this._images.length <= 1 || (this._triggerEvents("slide", "slided"), this._beforeSlideEvents(), t === "right" && this._slideHorizontally(t), t === "left" && this._slideHorizontally(t), t === "first" && this._slideToTarget(t), t === "last" && this._slideToTarget(t), this._afterSlideEvents());
  }
  zoomIn() {
    this._zoom >= 3 || (this._triggerEvents("zoomIn", "zoomedIn"), this._zoom += parseFloat(this.options.zoomLevel), h.style(this.currentImg.parentNode, {
      transform: `scale(${this._zoom})`
    }), this._updateZoomBtn());
  }
  zoomOut() {
    this._zoom <= 1 || (this._triggerEvents("zoomOut", "zoomedOut"), this._zoom -= parseFloat(this.options.zoomLevel), h.style(this.currentImg.parentNode, {
      transform: `scale(${this._zoom})`
    }), this._updateZoomBtn(), this._updateImgPosition());
  }
  toggleFullscreen() {
    this._fullscreen === !1 ? (this._fullscreenBtn.setAttribute(Dt, ""), this._fullscreenBtn.innerHTML = this.options.hideFullscreenIconTemplate, this._gallery.requestFullscreen && this._gallery.requestFullscreen(), this._fullscreen = !0) : (this._fullscreenBtn.removeAttribute(Dt), document.exitFullscreen && document.exitFullscreen(), this._fullscreen = !1);
  }
  reset() {
    this._restoreDefaultFullscreen(), this._restoreDefaultPosition(), this._restoreDefaultZoom(), clearTimeout(this._toolsToggleTimer), clearTimeout(this._doubleTapTimer);
  }
  dispose() {
    c.off(
      document,
      Me,
      YE,
      this.toggle
    ), this._galleryContent && this._removeEvents(), this._gallery && this._gallery.remove(), A.removeData(this._element, Oi), this._element = null;
  }
  // Private
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...t0,
      ...e,
      ...t
    }, I(Io, t, e0), t;
  }
  _getImages() {
    const e = d.find("img", this._element).filter(
      (i) => !i.hasAttribute(jE)
    );
    this._images = e;
  }
  _getContainer() {
    this._container = d.findOne(this.options.container);
  }
  _setActiveImg(t) {
    this._activeImg = typeof t == "number" ? t : this._images.indexOf(t.target);
  }
  _appendTemplate() {
    this._gallery = $("div"), h.addClass(this._gallery, `${this._classes.gallery}`), this._element.dataset.id = this._id, this._gallery.id = this._id, this._appendLoader(), this._appendToolbar(), this._appendContent(), this._appendArrows(), this._appendCaption(), this._container.append(this._gallery);
  }
  _appendToolbar() {
    this._galleryToolbar = $("div"), this._imgCounter = $("p"), this._fullscreenBtn = $("button"), this._zoomBtn = $("button");
    const t = $("button"), e = $("div"), i = $("div");
    h.addClass(this._galleryToolbar, `${this._classes.toolbar}`), h.addClass(this._imgCounter, `${this._classes.galleryCounter}`), h.addClass(this._fullscreenBtn, `${this._classes.fullscreenBtn}`), h.addClass(this._zoomBtn, `${this._classes.zoomInBtn}`), h.addClass(this._zoomBtn, this._classes.zoomBtn), h.addClass(e, `${this._classes.leftTools}`), h.addClass(i, `${this._classes.rightTools}`), h.addClass(t, `${this._classes.closeBtn}`), this._fullscreenBtn.innerHTML = this.options.showFullscreenIconTemplate, t.innerHTML = this.options.closeIconTemplate, this._zoomBtn.innerHTML = this.options.zoomInIconTemplate, this._fullscreenBtn.setAttribute("aria-label", "Toggle fullscreen"), this._zoomBtn.setAttribute("aria-label", "Zoom in"), t.setAttribute("aria-label", "Close"), c.on(
      this._fullscreenBtn,
      Me,
      () => this.toggleFullscreen()
    ), c.on(
      this._zoomBtn,
      Me,
      () => this._toggleZoom()
    ), c.on(t, Me, () => this.close()), e.append(this._imgCounter), i.append(this._fullscreenBtn), i.append(this._zoomBtn), i.append(t), this._galleryToolbar.append(e), this._galleryToolbar.append(i), this._gallery.append(this._galleryToolbar);
  }
  _appendContent() {
    this._galleryContent = $("div"), h.addClass(
      this._galleryContent,
      `${this._classes.galleryContent}`
    ), this._gallery.append(this._galleryContent);
  }
  _appendLoader() {
    this._loader = $("div");
    const t = $("div"), e = $("span");
    h.addClass(this._loader, `${this._classes.loader}`), h.addClass(t, `${this._classes.spinner}`), h.addClass(e, `${this._classes.spinnerContent}`), t.setAttribute("role", "status"), e.innerHTML = this.options.spinnerContent, t.append(e), this._loader.append(t), this._gallery.append(this._loader);
  }
  _appendArrows() {
    this._leftArrowWrapper = $("div"), h.addClass(
      this._leftArrowWrapper,
      `${this._classes.prevBtnWrapper}`
    );
    const t = $("button");
    t.setAttribute("aria-label", "Previous"), h.addClass(t, `${this._classes.prevBtn}`), c.on(t, Me, () => this.slide("left")), this._leftArrowWrapper.append(t), this._rightArrowWrapper = $("div"), h.addClass(
      this._rightArrowWrapper,
      `${this._classes.nextBtnWrapper}`
    ), this._rightArrow = $("button"), this._rightArrow.setAttribute("aria-label", "Next"), h.addClass(this._rightArrow, `${this._classes.nextBtn}`), c.on(this._rightArrow, Me, () => this.slide()), this._rightArrowWrapper.append(this._rightArrow), this._rightArrow.innerHTML = this.options.nextIconTemplate, t.innerHTML = this.options.prevIconTemplate, this._getImages(), !(this._images.length <= 1) && (this._gallery.append(this._leftArrowWrapper), this._gallery.append(this._rightArrowWrapper));
  }
  _appendCaption() {
    const t = $("div"), e = $("p");
    e.setAttribute(Ul, ""), h.addClass(t, `${this._classes.captionWrapper}`), h.addClass(e, `${this._classes.caption}`), t.append(e), this._gallery.append(t);
  }
  _sortImages() {
    for (let t = 0; t < this._activeImg; t++)
      this._images.push(this._images.shift());
  }
  async _loadImages() {
    const t = [], e = [];
    this._galleryContent.innerHTML = "";
    let i = 0;
    return this._images.forEach((n, o) => {
      t.push(
        new Promise((r) => {
          const a = new Image(), l = $("div");
          h.addClass(l, `${this._classes.imgWrapper}`), h.addClass(a, `${this._classes.img}`), this._addImgStyles(a, l, i, o, n), l.append(a), this._galleryContent.append(l), a.onload = r, a.src = n.dataset.teImg || n.src, e.push(a), i += 100;
        })
      );
    }), await Promise.all(t), e;
  }
  _addImgStyles(t, e, i, n, o) {
    t.alt = o.alt, t.draggable = !1, h.style(e, {
      position: "absolute",
      left: `${i}%`,
      top: 0
    }), (o.dataset.teCaption || o.dataset.teCaption === "") && (t.dataset.caption = o.dataset.teCaption), i === 0 ? (o.width < o.height && h.addClass(t, `${this._classes.vertical}`), h.style(e, { opacity: 1 }), t.setAttribute(Dt, "")) : t.removeAttribute(Dt), n === this._images.length - 1 && this._images.length > 1 && h.style(e, { left: "-100%" });
  }
  _resizeImages(t) {
    t.forEach((e) => {
      this._calculateImgSize(e);
    });
  }
  _calculateImgSize(t) {
    t.width >= t.height ? (t.style.width = "100%", t.style.maxWidth = "100%", t.style.height = "auto", t.style.top = `${(t.parentNode.offsetHeight - t.height) / 2}px`, t.style.left = 0) : (t.style.height = "100%", t.style.maxHeight = "100%", t.style.width = "auto", t.style.left = `${(t.parentNode.offsetWidth - t.width) / 2}px`, t.style.top = 0), t.width >= t.parentNode.offsetWidth && (t.style.width = `${t.parentNode.offsetWidth}px`, t.style.height = "auto", t.style.left = 0, t.style.top = `${(t.parentNode.offsetHeight - t.height) / 2}px`), t.height >= t.parentNode.offsetHeight && (t.style.height = `${t.parentNode.offsetHeight}px`, t.style.width = "auto", t.style.top = 0, t.style.left = `${(t.parentNode.offsetWidth - t.width) / 2}px`), this._positionX = parseFloat(t.style.left) || 0, this._positionY = parseFloat(t.style.top) || 0;
  }
  _onResize() {
    this._images = d.find("img", this._galleryContent), this._images.forEach((t) => {
      this._calculateImgSize(t);
    });
  }
  _onFullscreenChange() {
    (document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement) === void 0 && (this._fullscreen = !1, this._fullscreenBtn.innerHTML = this.options.showFullscreenIconTemplate, this._fullscreenBtn.removeAttribute(Dt));
  }
  _beforeSlideEvents() {
    this._animationStart(), this._restoreDefaultZoom(), this._restoreDefaultPosition(), this._resetDoubleTap();
  }
  _slideHorizontally(t) {
    this._images = d.find("img", this._galleryContent), this._images.forEach((e) => {
      let i;
      t === "right" ? (i = parseInt(e.parentNode.style.left, 10) - 100, i < -100 && (i = (this._images.length - 2) * 100)) : (i = parseInt(e.parentNode.style.left, 10) + 100, i === (this._images.length - 1) * 100 && (i = -100)), this._slideImg(e, i);
    }), this._updateActiveImg(t);
  }
  _slideImg(t, e) {
    e === 0 ? (t.setAttribute(Dt, ""), h.style(t.parentNode, { opacity: 1, transform: "scale(1)" })) : (t.removeAttribute(Dt), h.style(t.parentNode, {
      opacity: 0,
      transform: "scale(0.25)"
    })), t.parentNode.style.left = `${e}%`;
  }
  _slideToTarget(t) {
    t === "first" && this._activeImg === 0 || t === "last" && this._activeImg === this._images.length - 1 || (this.reset(), this._removeEvents(), this._showLoader(), this._getImages(), this._activeImg = t === "first" ? 0 : this._images.length - 1, this._sortImages(), h.style(this.currentImg.parentNode, {
      transform: "scale(0.25)",
      opacity: 0
    }), setTimeout(() => {
      this._loadImages().then((e) => {
        this._resizeImages(e), this._addEvents(), this._updateCaption(), this._hideLoader(), setTimeout(() => {
          h.style(this.currentImg.parentNode, {
            transform: "scale(1)",
            opacity: 1
          });
        }, 10);
      });
    }, 400));
  }
  _updateActiveImg(t) {
    t === "right" && (this._activeImg === this._images.length - 1 ? this._activeImg = 0 : this._activeImg++), t === "left" && (this._activeImg === 0 ? this._activeImg = this._images.length - 1 : this._activeImg--);
  }
  _afterSlideEvents() {
    this._updateCounter(), this._updateCaption();
  }
  _updateCounter() {
    this._images.length <= 1 || setTimeout(() => {
      this._imgCounter.innerHTML = `${this._activeImg + 1} / ${this._images.length}`;
    }, 200);
  }
  _updateCaption() {
    setTimeout(() => {
      let t = this.currentImg.alt;
      (this.currentImg.dataset.caption || this.currentImg.dataset.caption === "") && (t = this.currentImg.dataset.caption), d.findOne(
        `[${Ul}]`,
        this._gallery
      ).innerHTML = t;
    }, 200);
  }
  _toggleTemplate() {
    this._gallery.style.visibility === "visible" ? (h.style(this.currentImg.parentNode, {
      transform: "scale(0.25)"
    }), setTimeout(() => {
      this._hideGallery(), this._enableScroll(), this._showLoader();
    }, 100)) : (this._showGallery(), this._disableScroll(), this._updateCounter(), this._updateCaption(), this._setToolsToggleTimout(), this._hideLoader());
  }
  _showLoader() {
    h.style(this._loader, { opacity: 1 });
  }
  _hideLoader() {
    h.style(this._loader, { opacity: 0 });
  }
  _hideGallery() {
    h.style(this._gallery, {
      opacity: 0,
      pointerEvents: "none",
      visibility: "hidden"
    });
  }
  _showGallery() {
    h.style(this._gallery, {
      opacity: 1,
      pointerEvents: "initial",
      visibility: "visible"
    }), setTimeout(() => {
      h.style(this.currentImg.parentNode, { transform: "scale(1)" });
    }, 50);
  }
  _toggleZoom() {
    this._zoom !== 1 ? this.zoomOut() : this.zoomIn();
  }
  _updateZoomBtn() {
    this._zoom > 1 ? (this._zoomBtn.setAttribute(Dt, ""), this._zoomBtn.setAttribute("aria-label", "Zoom out"), this._zoomBtn.innerHTML = this.options.zoomOutIconTemplate) : (this._zoomBtn.removeAttribute(Dt), this._zoomBtn.setAttribute("aria-label", "Zoom in"), this._zoomBtn.innerHTML = this.options.zoomInIconTemplate);
  }
  _updateImgPosition() {
    this._zoom === 1 && this._restoreDefaultPosition();
  }
  _addEvents() {
    const t = d.find("img", this._galleryContent);
    this._onWindowTouchmove = this._onWindowTouchmove.bind(this), this._onWindowTouchstart = this._onWindowTouchstart.bind(this), this._onImgMousedown = this._onMousedown.bind(this), this._onImgMousemove = this._onMousemove.bind(this), this._onImgWheel = this._onZoom.bind(this), this._onImgMouseup = this._onMouseup.bind(this), this._onImgTouchend = this._onTouchend.bind(this), this._onImgDoubleClick = this._onDoubleClick.bind(this), this._onWindowResize = this._onResize.bind(this), this._onWindowFullscreenChange = this._onFullscreenChange.bind(this), this._onAnyImgAction = this._resetToolsToggler.bind(this), this._onGalleryClick = this._onBackdropClick.bind(this), this._onKeyupEvent = this._onKeyup.bind(this), this._onRightArrowKeydownEvent = this._onRightArrowKeydown.bind(this), this._onFullscreenBtnKeydownEvent = this._onFullscreenBtnKeydown.bind(this), t.forEach((e) => {
      c.on(e, "mousedown", this._onImgMousedown, {
        passive: !0
      }), c.on(e, "touchstart", this._onImgMousedown, {
        passive: !0
      }), c.on(e, "mousemove", this._onImgMousemove, {
        passive: !0
      }), c.on(e, "touchmove", this._onImgMousemove, {
        passive: !0
      }), c.on(e, "wheel", this._onImgWheel, { passive: !0 }), c.on(e, "dblclick", this._onImgDoubleClick, {
        passive: !0
      });
    }), document.addEventListener("touchmove", this._onWindowTouchmove, {
      passive: !1
    }), c.on(window, "touchstart", this._onWindowTouchstart), c.on(window, "mouseup", this._onImgMouseup), c.on(window, "touchend", this._onImgTouchend), c.on(window, "resize", this._onWindowResize), c.on(window, "orientationchange", this._onWindowResize), c.on(window, "keyup", this._onKeyupEvent), c.on(window, "fullscreenchange", this._onWindowFullscreenChange), c.on(this._gallery, "mousemove", this._onAnyImgAction), c.on(this._gallery, "click", this._onGalleryClick), c.on(
      this._rightArrow,
      "keydown",
      this._onRightArrowKeydownEvent
    ), c.on(
      this._fullscreenBtn,
      "keydown",
      this._onFullscreenBtnKeydownEvent
    );
  }
  _removeEvents() {
    d.find("img", this._galleryContent).forEach((e) => {
      c.off(e, "mousedown", this._onImgMousedown), c.off(e, "touchstart", this._onImgMousedown), c.off(e, "mousemove", this._onImgMousemove), c.off(e, "touchmove", this._onImgMousemove), c.off(e, "wheel", this._onImgWheel), c.off(e, "dblclick", this._onImgDoubleClick);
    }), document.removeEventListener("touchmove", this._onWindowTouchmove, {
      passive: !1
    }), c.off(window, "touchstart", this._onWindowTouchstart), c.off(window, "mouseup", this._onImgMouseup), c.off(window, "touchend", this._onImgTouchend), c.off(window, "resize", this._onWindowResize), c.off(window, "orientationchange", this._onWindowResize), c.off(window, "keyup", this._onKeyupEvent), c.off(
      window,
      "fullscreenchange",
      this._onWindowFullscreenChange
    ), c.off(this._gallery, "mousemove", this._onAnyImgAction), c.off(this._gallery, "click", this._onGalleryClick), c.off(
      this._rightArrow,
      "keydown",
      this._onRightArrowKeydownEvent
    ), c.off(
      this._fullscreenBtn,
      "keydown",
      this._onFullscreenBtnKeydownEvent
    );
  }
  _onMousedown(t) {
    const e = t.touches, i = e ? e[0].clientX : t.clientX, n = e ? e[0].clientY : t.clientY;
    this._originalPositionX = parseFloat(this.currentImg.style.left) || 0, this._originalPositionY = parseFloat(this.currentImg.style.top) || 0, this._positionX = this._originalPositionX, this._positionY = this._originalPositionY, this._mousedownPositionX = i * (1 / this._zoom) - this._positionX, this._mousedownPositionY = n * (1 / this._zoom) - this._positionY, this._mousedown = !0, t.type === "touchstart" && t.touches.length > 1 && (this._multitouch = !0, this._touchZoomPosition = t.touches);
  }
  _onMousemove(t) {
    if (!this._mousedown)
      return;
    const e = t.touches, i = e ? e[0].clientX : t.clientX, n = e ? e[0].clientY : t.clientY;
    if (e && this._resetToolsToggler(), !this._multitouch)
      if (this._zoom !== 1)
        this._positionX = i * (1 / this._zoom) - this._mousedownPositionX, this._positionY = n * (1 / this._zoom) - this._mousedownPositionY, h.style(this.currentImg, {
          left: `${this._positionX}px`,
          top: `${this._positionY}px`
        });
      else {
        if (this._images.length <= 1)
          return;
        this._positionX = i * (1 / this._zoom) - this._mousedownPositionX, h.style(this.currentImg, { left: `${this._positionX}px` });
      }
  }
  _onMouseup(t) {
    this._mousedown = !1, this._moveImg(t.target);
  }
  _onTouchend(t) {
    this._mousedown = !1, this._multitouch ? t.targetTouches.length === 0 && (this._multitouch = !1, this._touchZoomPosition = []) : this._multitouch || (this._checkDoubleTap(t), this._moveImg(t.target));
  }
  _calculateTouchZoom(t) {
    const e = Math.hypot(
      this._touchZoomPosition[1].pageX - this._touchZoomPosition[0].pageX,
      this._touchZoomPosition[1].pageY - this._touchZoomPosition[0].pageY
    ), i = Math.hypot(
      t.touches[1].pageX - t.touches[0].pageX,
      t.touches[1].pageY - t.touches[0].pageY
    ), n = Math.abs(e - i), o = t.view.screen.width;
    n > o * 0.03 && (e <= i ? this.zoomIn() : this.zoomOut(), this._touchZoomPosition = t.touches);
  }
  _onWindowTouchstart(t) {
    t.touches.length > 1 && (this._multitouch = !0, this._touchZoomPosition = t.touches);
  }
  _onWindowTouchmove(t) {
    t.preventDefault(), t.type === "touchmove" && t.targetTouches.length > 1 && this._calculateTouchZoom(t);
  }
  _onRightArrowKeydown(t) {
    switch (t.keyCode) {
      case 9:
        if (t.shiftKey)
          break;
        t.preventDefault(), this._focusFullscreenBtn();
        break;
    }
  }
  _onFullscreenBtnKeydown(t) {
    switch (t.keyCode) {
      case 9:
        if (!t.shiftKey)
          break;
        t.preventDefault(), this._focusRightArrow();
        break;
    }
  }
  _onKeyup(t) {
    switch (this._resetToolsToggler(), t.keyCode) {
      case 39:
        this.slide();
        break;
      case 37:
        this.slide("left");
        break;
      case 27:
        this.close();
        break;
      case 36:
        this.slide("first");
        break;
      case 35:
        this.slide("last");
        break;
      case 38:
        this.zoomIn();
        break;
      case 40:
        this.zoomOut();
        break;
    }
  }
  _focusFullscreenBtn() {
    setTimeout(() => {
      this._fullscreenBtn.focus();
    }, 100);
  }
  _focusRightArrow() {
    this._rightArrow.focus();
  }
  _moveImg(t) {
    if (this._multitouch || this._zoom !== 1 || t !== this.currentImg || this._images.length <= 1)
      return;
    const e = this._positionX - this._originalPositionX;
    e > 0 ? this.slide("left") : e < 0 && this.slide();
  }
  _checkDoubleTap(t) {
    clearTimeout(this._doubleTapTimer);
    const i = (/* @__PURE__ */ new Date()).getTime() - this._tapTime;
    this._tapCounter > 0 && i < 500 ? (this._onDoubleClick(t), this._doubleTapTimer = setTimeout(() => {
      this._tapTime = (/* @__PURE__ */ new Date()).getTime(), this._tapCounter = 0;
    }, 300)) : (this._tapCounter++, this._tapTime = (/* @__PURE__ */ new Date()).getTime());
  }
  _resetDoubleTap() {
    this._tapTime = 0, this._tapCounter = 0, clearTimeout(this._doubleTapTimer);
  }
  _onDoubleClick(t) {
    this._multitouch || (t.touches || this._setNewPositionOnZoomIn(t), this._zoom !== 1 ? this._restoreDefaultZoom() : this.zoomIn());
  }
  _onZoom(t) {
    if (t.deltaY > 0)
      this.zoomOut();
    else {
      if (this._zoom >= 3)
        return;
      this._setNewPositionOnZoomIn(t), this.zoomIn();
    }
  }
  _onBackdropClick(t) {
    this._resetToolsToggler(), t.target.tagName === "DIV" && this.close();
  }
  _setNewPositionOnZoomIn(t) {
    clearTimeout(this._zoomTimer), this._positionX = window.innerWidth / 2 - t.offsetX - 50, this._positionY = window.innerHeight / 2 - t.offsetY - 50, this.currentImg.style.transition = "all 0.5s ease-out", this.currentImg.style.left = `${this._positionX}px`, this.currentImg.style.top = `${this._positionY}px`, this._zoomTimer = setTimeout(() => {
      this.currentImg.style.transition = "none";
    }, 500);
  }
  _resetToolsToggler() {
    this._showTools(), clearTimeout(this._toolsToggleTimer), this._setToolsToggleTimout();
  }
  _setToolsToggleTimout() {
    this._toolsToggleTimer = setTimeout(() => {
      this._hideTools(), clearTimeout(this._toolsToggleTimer);
    }, 4e3);
  }
  _hideTools() {
    h.style(this._galleryToolbar, { opacity: 0 }), h.style(this._leftArrowWrapper, { opacity: 0 }), h.style(this._rightArrowWrapper, { opacity: 0 });
  }
  _showTools() {
    h.style(this._galleryToolbar, { opacity: 1 }), h.style(this._leftArrowWrapper, { opacity: 1 }), h.style(this._rightArrowWrapper, { opacity: 1 });
  }
  _disableScroll() {
    h.addClass(document.body, "overflow-y-hidden relative"), document.documentElement.scrollHeight > document.documentElement.clientHeight && h.addClass(document.body, "md:pr-[17px]");
  }
  _enableScroll() {
    setTimeout(() => {
      h.removeClass(document.body, "overflow-y-hidden relative"), h.removeClass(document.body, "md:pr-[17px]");
    }, 300);
  }
  _animationStart() {
    this._animating = !0, setTimeout(() => {
      this._animating = !1;
    }, 400);
  }
  _restoreDefaultZoom() {
    this._zoom !== 1 && (this._zoom = 1, h.style(this.currentImg.parentNode, {
      transform: `scale(${this._zoom})`
    }), this._updateZoomBtn(), this._updateImgPosition());
  }
  _restoreDefaultFullscreen() {
    this._fullscreen && this.toggleFullscreen();
  }
  _restoreDefaultPosition() {
    clearTimeout(this._zoomTimer);
    const t = this.currentImg;
    h.style(this.currentImg.parentNode, { left: 0, top: 0 }), h.style(this.currentImg, {
      transition: "all 0.5s ease-out",
      left: 0,
      top: 0
    }), this._calculateImgSize(t), setTimeout(() => {
      h.style(this.currentImg, { transition: "none" });
    }, 500);
  }
  async _triggerEvents(t, e) {
    c.trigger(this._element, `${t}.te.lightbox`), e && await setTimeout(() => {
      c.trigger(this._element, `${e}.te.lightbox`);
    }, 505);
  }
  static getInstance(t) {
    return A.getData(t, Oi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static toggle() {
    return function(t) {
      const e = d.closest(
        t.target,
        `${Fh}`
      );
      (nn.getInstance(e) || new nn(e)).open(t);
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, Oi);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new nn(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
}
const i0 = {
  isRequired: "This is required",
  isEmail: "Please enter a valid email address",
  isLongerThan: "This field must be longer than {length} characters",
  isShorterThan: "This field must be shorter than {length} characters",
  isChecked: "This is required",
  isPhone: "Please enter a valid phone number",
  isNumber: "Expected value with type Number",
  isString: "Expected value with type String",
  isBoolean: "Expected value with type Boolean",
  isDate: "Please enter a valid date",
  is12hFormat: "Please enter a valid time in 12h format",
  is24hFormat: "Please enter a valid time in 24h format"
}, s0 = {
  isRequired: (s, t) => (s == null ? void 0 : s.trim()) ? !0 : t,
  isEmail: (s, t) => /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(s) ? !0 : t,
  isLongerThan: (s, t, e) => s.length > e ? !0 : t.replace("{length}", e),
  isShorterThan: (s, t, e) => s.length < e ? !0 : t.replace("{length}", e),
  isChecked: (s) => s ? !0 : "This is required",
  isPhone: (s, t) => s.length === 9 ? !0 : t,
  isNumber: (s, t) => s && !isNaN(Number(s)) ? !0 : t,
  isString: (s, t) => typeof s == "string" ? !0 : t,
  isBoolean: (s, t) => typeof s == "boolean" ? !0 : t,
  isDate: (s, t) => {
    const e = /^([0-9]{1,2})\/([0-9]{1,2})\/([0-9]{4})$/;
    return s.match(e) ? !0 : t;
  },
  is12hFormat: (s, t) => {
    const e = /^(0?[1-9]|1[0-2]):[0-5][0-9] [APap][mM]$/;
    return s.match(e) ? !0 : t;
  },
  is24hFormat: (s, t) => {
    const e = /^(?:[01]\d|2[0-3]):[0-5][0-9]$/;
    return s.match(e) ? !0 : t;
  }
}, Do = "validation", ir = "te.validation", yn = `.${ir}`, Yh = "data-te-validate", Ls = "data-te-validated", Ns = "data-te-validation-state", Ms = "data-te-validation-feedback", $o = "data-te-valid-feedback", Rs = "data-te-invalid-feedback", Xl = "data-te-validation-ruleset", n0 = "data-te-submit-btn-ref", o0 = `[${Yh}]`, r0 = "[data-te-input-notch-ref] div", a0 = `[${n0}]`, l0 = `validated${yn}`, c0 = `valid${yn}`, h0 = `invalid${yn}`, d0 = `changed${yn}`, u0 = {
  validFeedback: "string",
  invalidFeedback: "string",
  disableFeedback: "boolean",
  customRules: "object",
  customErrorMessages: "object",
  activeValidation: "boolean",
  submitCallback: "(function|null)"
}, Gl = {
  validFeedback: "Looks good!",
  invalidFeedback: "Something is wrong!",
  disableFeedback: !1,
  customRules: {},
  customErrorMessages: {},
  activeValidation: !1,
  submitCallback: null
}, p0 = {
  // default notch
  notchLeadingValid: "border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[-1px_0_0_#14a44d,_0_1px_0_0_#14a44d,_0_-1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]",
  notchMiddleValid: "border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[0_1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]",
  notchTrailingValid: "border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[1px_0_0_#14a44d,_0_-1px_0_0_#14a44d,_0_1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]",
  notchLeadingInvalid: "border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[-1px_0_0_#dc4c64,_0_1px_0_0_#dc4c64,_0_-1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]",
  notchMiddleInvalid: "border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[0_1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]",
  notchTrailingInvalid: "border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[1px_0_0_#dc4c64,_0_-1px_0_0_#dc4c64,_0_1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]",
  // basic inputs
  basicInputValid: "!border-[#14a44d] focus:!border-[#14a44d] focus:!shadow-[inset_0_0_0_1px_#14a44d]",
  basicInputInvalid: "!border-[#dc4c64] focus:!border-[#dc4c64] focus:!shadow-[inset_0_0_0_1px_#dc4c64]",
  // checkbox
  checkboxValid: "checked:!border-[#14a44d] checked:!bg-[#14a44d] checked:after:!bg-[#14a44d]",
  checkboxInvalid: "checked:!border-[#dc4c64] checked:!bg-[#dc4c64] checked:after:!bg-[#dc4c64]",
  radioValid: "checked:!border-[#14a44d] checked:after:!bg-[#14a44d]",
  radioInvalid: "checked:!border-[#dc4c64] checked:after:!bg-[#dc4c64]",
  // labels
  labelValid: "!text-[#14a44d]",
  labelInvalid: "!text-[#dc4c64]",
  // feedback
  validFeedback: "absolute top-full left-0 m-1 w-auto text-sm text-[#14a44d] animate-[fade-in_0.3s_both]",
  invalidFeedback: "absolute top-full left-0 m-1 w-auto text-sm text-[#dc4c64] animate-[fade-in_0.3s_both]",
  // element validated
  elementValidated: "mb-8"
}, _0 = {
  notchLeadingValid: "string",
  notchMiddleValid: "string",
  notchTrailingValid: "string",
  notchLeadingInvalid: "string",
  notchMiddleInvalid: "string",
  notchTrailingInvalid: "string",
  basicInputValid: "string",
  basicInputInvalid: "string",
  checkboxValid: "string",
  checkboxInvalid: "string",
  radioValid: "string",
  radioInvalid: "string",
  labelValid: "string",
  labelInvalid: "string",
  validFeedback: "string",
  invalidFeedback: "string",
  elementValidated: "string"
};
class jh extends ft {
  constructor(t, e, i) {
    super(t), this._element = t, this._element && A.setData(t, ir, this), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._isValid = !0, this._shouldApplyInputEvents = !0, this._submitCallback = null, this._errorMessages = {
      ...i0,
      ...this._config.customErrorMessages
    }, this._validationElements = this._getValidationElements(), this._validationElements.forEach(({ element: n, input: o }) => {
      this._createFeedbackWrapper(n, o);
    }), this._validationObserver = this._watchForValidationChanges(), this._validationObserver.observe(this._element, { attributes: !0 }), this._submitButton = null, this._handleSubmitButton(), this._validationResult = [];
  }
  // Getters
  static get DefaultType() {
    return u0;
  }
  static get Default() {
    return Gl;
  }
  static get NAME() {
    return Do;
  }
  // Public
  dispose() {
    var t;
    (t = this._validationObserver) == null || t.disconnect(), this._validationObserver = null, this._submitCallback = null, this._element.removeAttribute(Ls), this._removeInputEvents(), this._removeValidationTraces(), this._validationResult = [], this._submitButton && c.off(this._submitButton, "click"), this._config.activeValidation && (this._validationElements.forEach((e) => {
      const { input: i } = e;
      c.off(i, "input");
    }), this._shouldApplyInputEvents = !0);
  }
  // Private
  _removeValidationTraces() {
    this._removeFeedbackWrapper(), this._validationElements.forEach(({ element: t, classes: e, initialHTML: i }) => {
      t.className = e, t.innerHTML = i, t.removeAttribute(Ns), t.removeAttribute(Rs), t.removeAttribute($o);
    }), this._validationElements = [];
  }
  _getValidationElements() {
    return d.find(
      o0,
      this._element
    ).map((e) => {
      const i = d.findOne("input", e) || d.findOne("textarea", e), n = d.findOne("select", e);
      return {
        id: i.name || i.id || (n == null ? void 0 : n.name) || et("validation-"),
        element: e,
        type: e.getAttribute(Yh),
        input: i,
        validFeedback: e.getAttribute($o),
        invalidFeedback: e.getAttribute(Rs),
        classes: e.className,
        initialHTML: e.innerHTML,
        ruleset: e.getAttribute(Xl)
      };
    });
  }
  _createFeedbackWrapper(t, e) {
    if (t.querySelectorAll(`[${Ms}]`).length > 0)
      return;
    const i = document.createElement("span");
    i.setAttribute(Ms, ""), e.parentNode.appendChild(i);
  }
  _removeFeedbackWrapper() {
    d.find(
      `[${Ms}]`,
      this._element
    ).forEach((e) => {
      e.remove();
    });
  }
  _watchForValidationChanges() {
    return new MutationObserver((e) => {
      e.forEach((i) => {
        const { attributeName: n } = i;
        n === Ls && (this._handleValidation(), this._config.activeValidation && this._shouldApplyInputEvents && this._applyInputEvents());
      });
    });
  }
  _handleValidation() {
    this._element.getAttribute(Ls) && (this._validationResult = [], this._isValid = !0, this._validationElements.forEach(
      (t) => this._validateSingleElement(t)
    ), this._emitEvents(this._isValid), this._submitCallback && this._submitCallback(this._isValid));
  }
  _validateSingleElement(t) {
    var p;
    const { element: e, type: i, input: n, ruleset: o, id: r } = t;
    o && this._validateByRuleset(t);
    const a = e.getAttribute(Ns);
    if (a !== "valid" && a !== "invalid")
      return;
    const l = a.replace(
      a.charAt(0),
      a.charAt(0).toUpperCase()
    );
    i === "input" && this._restyleNotches(e, l), i === "basic" && this._restyleBasicInputs(n, l), (i === "checkbox" || i === "radio") && this._restyleCheckboxes(n, l, i), this._restyleLabels(e, l), a === "invalid" && (this._isValid = !1), this._config.disableFeedback || this._applyFeedback(e, a), c.trigger(this._element, d0, {
      value: {
        name: r,
        result: a,
        validation: (p = this._validationResult[r]) == null ? void 0 : p.validation
      }
    });
  }
  _validateByRuleset({ element: t, type: e, invalidFeedback: i, input: n, id: o }) {
    const r = this._getRuleset(t);
    if (!r.length)
      return;
    const a = e === "checkbox" || e === "radio" ? n.checked : n.value;
    let l = "", p = [];
    for (const u of r) {
      const _ = u.callback(
        a,
        this._errorMessages[u.name] || this._config.invalidFeedback,
        u.parameter
      );
      p.push({
        result: _ === !0,
        name: u.name,
        fullName: u.fullName
      }), typeof _ == "string" && !l && (l = _);
    }
    if (this._validationResult[o] = { element: t, validation: p }, !l) {
      t.setAttribute(Ns, "valid");
      return;
    }
    t.setAttribute(Ns, "invalid"), i || t.setAttribute(Rs, l);
  }
  _handleInputChange(t) {
    this._validateSingleElement(t);
  }
  _getRuleset(t) {
    const i = t.getAttribute(Xl).split("|");
    let n = [];
    const o = {
      ...s0,
      ...this._config.customRules
    };
    return i.forEach((r) => {
      const a = this._getRuleData(r, o);
      a.callback ? n.push(a) : console.warn(`Rule ${r} does not exist`);
    }), n;
  }
  _getRuleData(t, e) {
    const i = t.split("(");
    return {
      callback: e[i[0]],
      parameter: i[1] ? i[1].split(")")[0] : null,
      name: i[0],
      fullName: t
    };
  }
  _applyFeedback(t, e) {
    const i = d.findOne(
      `[${Ms}]`,
      t
    ), n = t.getAttribute($o) || this._config.validFeedback, o = t.getAttribute(Rs) || this._config.invalidFeedback;
    h.addClass(t, this._classes.elementValidated), i.textContent = e === "valid" ? n : o, i.className = this._classes[e === "valid" ? "validFeedback" : "invalidFeedback"];
  }
  _restyleCheckboxes(t, e, i) {
    h.removeClass(t, this._classes.checkboxValid), h.removeClass(t, this._classes.checkboxInvalid), h.addClass(t, this._classes[`${i}${e}`]);
  }
  _restyleBasicInputs(t, e) {
    h.removeClass(t, this._classes.basicInputValid), h.removeClass(t, this._classes.basicInputInvalid), h.addClass(t, this._classes[`basicInput${e}`]);
  }
  _restyleNotches(t, e) {
    d.find(r0, t).forEach((n, o) => {
      let r = o === 0 ? "notchLeading" : o === 1 ? "notchMiddle" : "notchTrailing";
      n.className = "", h.addClass(n, ph[r]), r += e, h.addClass(n, this._classes[r]);
    });
  }
  _restyleLabels(t, e) {
    const i = d.find("label", t);
    i.length && i.forEach((n) => {
      h.removeClass(n, this._classes.labelValid), h.removeClass(n, this._classes.labelInvalid), h.addClass(n, this._classes[`label${e}`]);
    });
  }
  _emitEvents(t) {
    if (c.trigger(this._element, l0), t) {
      c.trigger(this._element, c0, {
        value: this._validationResult
      });
      return;
    }
    c.trigger(this._element, h0, {
      value: this._validationResult
    });
  }
  _applyInputEvents() {
    this._validationElements.forEach((t) => {
      const { input: e, element: i } = t;
      c.on(
        e,
        "input",
        () => this._handleInputChange(t)
      ), c.on(
        i,
        "valueChange.te.select",
        () => this._delayedInputChange(t)
      ), c.on(
        i,
        "itemSelect.te.autocomplete",
        () => this._delayedInputChange(t)
      );
    }), this._shouldApplyInputEvents = !1;
  }
  _removeInputEvents() {
    this._validationElements.forEach((t) => {
      const { input: e, element: i } = t;
      c.off(
        e,
        "input",
        () => this._handleInputChange(t)
      ), c.off(
        i,
        "valueChange.te.select",
        () => this._delayedInputChange(t)
      ), c.off(
        i,
        "itemSelect.te.autocomplete",
        () => this._delayedInputChange(t)
      );
    });
  }
  _delayedInputChange(t) {
    setTimeout(() => {
      this._handleInputChange(t);
    }, 10);
  }
  _handleSubmitButton() {
    this._submitButton = d.findOne(
      a0,
      this._element
    ), this._submitButton && c.on(
      this._submitButton,
      "click",
      (t) => this._handleSubmitButtonClick(t)
    );
  }
  _handleSubmitButtonClick(t) {
    if (this._element.setAttribute(Ls, !0), this._config.submitCallback) {
      this._submitCallback = (e) => this._config.submitCallback(t, e);
      return;
    }
  }
  _getConfig(t) {
    return t = {
      ...Gl,
      ...h.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, I(Do, t, this.constructor.DefaultType), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...p0,
      ...e,
      ...t
    }, I(Do, t, _0), t;
  }
  // Static
  static getInstance(t) {
    return A.getData(t, ir);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static jQueryInterface(t) {
    return this.each(function() {
      const e = jh.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
class Qi {
  _getCoordinates(t) {
    const [e] = t.touches;
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  _getDirection({ x: t, y: e }) {
    return {
      x: {
        direction: t < 0 ? "left" : "right",
        value: Math.abs(t)
      },
      y: {
        direction: e < 0 ? "up" : "down",
        value: Math.abs(e)
      }
    };
  }
  _getOrigin({ x: t, y: e }, { x: i, y: n }) {
    return {
      x: t - i,
      y: e - n
    };
  }
  _getDistanceBetweenTwoPoints(t, e, i, n) {
    return Math.hypot(e - t, n - i);
  }
  _getMidPoint({ x1: t, x2: e, y1: i, y2: n }) {
    return {
      x: (t + e) / 2,
      y: (i + n) / 2
    };
  }
  _getVectorLength({ x1: t, x2: e, y1: i, y2: n }) {
    return Math.sqrt((e - t) ** 2 + (n - i) ** 2);
  }
  _getRightMostTouch(t) {
    let e = null;
    const i = Number.MIN_VALUE;
    return t.forEach((n) => {
      n.clientX > i && (e = n);
    }), e;
  }
  _getAngle(t, e, i, n) {
    return Math.atan2(n - e, i - t);
  }
  _getAngularDistance(t, e) {
    return e - t;
  }
  _getCenterXY({ x1: t, x2: e, y1: i, y2: n }) {
    return {
      x: t + (e - t) / 2,
      y: i + (n - i) / 2
    };
  }
  _getPinchTouchOrigin(t) {
    const [e, i] = t, n = {
      x1: e.clientX,
      x2: i.clientX,
      y1: e.clientY,
      y2: i.clientY
    };
    return [this._getVectorLength(n), this._getCenterXY(n)];
  }
  _getPosition({ x1: t, x2: e, y1: i, y2: n }) {
    return { x1: t, x2: e, y1: i, y2: n };
  }
}
const Lo = "press", f0 = "pressup", m0 = {
  time: "number",
  pointers: "number"
}, g0 = {
  time: 250,
  pointers: 1
};
class b0 extends Qi {
  constructor(t, e = {}) {
    super(), this._element = t, this._options = this._getConfig(e), this._timer = null;
  }
  // Getters
  static get NAME() {
    return Lo;
  }
  handleTouchStart(t) {
    const { time: e, pointers: i } = this._options;
    t.touches.length === i && (this._timer = setTimeout(() => {
      c.trigger(this._element, Lo, { touch: t, time: e }), c.trigger(this._element, f0, { touch: t });
    }, e));
  }
  handleTouchEnd() {
    clearTimeout(this._timer);
  }
  _getConfig(t) {
    const e = {
      ...g0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(Lo, e, m0), e;
  }
}
const v0 = "swipe", T0 = {
  threshold: "number",
  direction: "string"
}, E0 = {
  threshold: 10,
  direction: "all"
};
class C0 {
  constructor(t, e) {
    this._element = t, this._startPosition = null, this._options = this._getConfig(e);
  }
  handleTouchStart(t) {
    this._startPosition = this._getCoordinates(t);
  }
  handleTouchMove(t) {
    if (!this._startPosition)
      return;
    const e = this._getCoordinates(t), i = {
      x: e.x - this._startPosition.x,
      y: e.y - this._startPosition.y
    }, n = this._getDirection(i);
    if (this._options.direction === "all") {
      if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)
        return;
      const r = n.y.value > n.x.value ? n.y.direction : n.x.direction;
      c.trigger(this._element, `swipe${r}`, { touch: t }), c.trigger(this._element, "swipe", { touch: t, direction: r }), this._startPosition = null;
      return;
    }
    const o = this._options.direction === "left" || this._options === "right" ? "x" : "y";
    n[o].direction === this._options.direction && n[o].value > this._options.threshold && (c.trigger(this._element, `swipe${n[o].direction}`, {
      touch: t
    }), this._startPosition = null);
  }
  handleTouchEnd() {
    this._startPosition = null;
  }
  _getCoordinates(t) {
    const [e] = t.touches;
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  _getDirection(t) {
    return {
      x: {
        direction: t.x < 0 ? "left" : "right",
        value: Math.abs(t.x)
      },
      y: {
        direction: t.y < 0 ? "up" : "down",
        value: Math.abs(t.y)
      }
    };
  }
  _getConfig(t) {
    const e = {
      ...E0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(v0, e, T0), e;
  }
}
const Zt = "pan", A0 = `${Zt}start`, y0 = `${Zt}end`, w0 = `${Zt}move`, k0 = "left", x0 = "right", O0 = {
  threshold: "number",
  direction: "string",
  pointers: "number"
}, S0 = {
  threshold: 20,
  direction: "all",
  pointers: 1
};
class I0 extends Qi {
  constructor(t, e = {}) {
    super(), this._element = t, this._options = this._getConfig(e), this._startTouch = null;
  }
  // Getters
  static get NAME() {
    return Zt;
  }
  handleTouchStart(t) {
    this._startTouch = this._getCoordinates(t), this._movedTouch = t, c.trigger(this._element, A0, { touch: t });
  }
  handleTouchMove(t) {
    t.type === "touchmove" && t.preventDefault();
    const { threshold: e, direction: i } = this._options, n = this._getCoordinates(t), o = this._getCoordinates(this._movedTouch), r = this._getOrigin(n, this._startTouch), a = this._getOrigin(n, o), l = this._getDirection(r), p = this._getDirection(a), { x: u, y: _ } = l;
    if (i === "all" && (_.value > e || u.value > e)) {
      const g = _.value > u.value ? _.direction : u.direction;
      c.trigger(this._element, `${Zt}${g}`, { touch: t }), c.trigger(this._element, Zt, {
        ...a,
        touch: t
      });
    }
    const f = i === k0 || i === x0 ? "x" : "y";
    p[f].direction === i && l[f].value > e && c.trigger(this._element, `${Zt}${i}`, {
      touch: t,
      [f]: n[f] - o[f]
    }), this._movedTouch = t, c.trigger(this._element, w0, { touch: t });
  }
  handleTouchEnd(t) {
    t.type === "touchend" && t.preventDefault(), this._movedTouch = null, this._startTouch = null, c.trigger(this._element, y0, { touch: t });
  }
  _getConfig(t) {
    const e = {
      ...S0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(Zt, e, O0), e;
  }
}
const Ue = "pinch", D0 = `${Ue}end`, $0 = `${Ue}start`, L0 = `${Ue}move`, N0 = {
  threshold: "number",
  pointers: "number"
}, M0 = {
  threshold: 10,
  pointers: 2
};
class R0 extends Qi {
  constructor(t, e = {}) {
    super(), this._element = t, this._options = this._getConfig(e), this._startTouch = null, this._origin = null, this._touch = null, this._math = null, this._ratio = null;
  }
  // Getters
  static get NAME() {
    return Ue;
  }
  get isNumber() {
    return typeof this._startTouch == "number" && typeof this._touch == "number" && // eslint-disable-next-line no-restricted-globals
    !isNaN(this._startTouch) && // eslint-disable-next-line no-restricted-globals
    !isNaN(this._touch);
  }
  handleTouchStart(t) {
    if (t.touches.length !== this._options.pointers)
      return;
    t.type === "touchstart" && t.preventDefault();
    const [e, i] = this._getPinchTouchOrigin(t.touches);
    this._touch = e, this._origin = i, this._startTouch = this._touch, c.trigger(this._element, $0, {
      touch: t,
      ratio: this._ratio,
      origin: this._origin
    });
  }
  handleTouchMove(t) {
    const { threshold: e, pointers: i } = this._options;
    t.touches.length === i && (t.type === "touchmove" && t.preventDefault(), this._touch = this._getPinchTouchOrigin(t.touches)[0], this._ratio = this._touch / this._startTouch, this.isNumber && (this._origin.x > e || this._origin.y > e) && (this._startTouch = this._touch, c.trigger(this._element, Ue, {
      touch: t,
      ratio: this._ratio,
      origin: this._origin
    }), c.trigger(this._element, L0, {
      touch: t,
      ratio: this._ratio,
      origin: this._origin
    })));
  }
  handleTouchEnd(t) {
    this.isNumber && (this._startTouch = null, c.trigger(this._element, D0, {
      touch: t,
      ratio: this._ratio,
      origin: this._origin
    }));
  }
  _getConfig(t) {
    const e = {
      ...M0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(Ue, e, N0), e;
  }
}
const No = "tap", P0 = {
  interval: "number",
  time: "number",
  taps: "number",
  pointers: "number"
}, B0 = {
  interval: 500,
  time: 250,
  taps: 1,
  pointers: 1
};
class H0 extends Qi {
  constructor(t, e) {
    super(), this._element = t, this._options = this._getConfig(e), this._timer = null, this._tapCount = 0;
  }
  // Getters
  static get NAME() {
    return No;
  }
  handleTouchStart(t) {
    const { x: e, y: i } = this._getCoordinates(t), { interval: n, taps: o, pointers: r } = this._options;
    return t.touches.length === r && (this._tapCount += 1, this._tapCount === 1 && (this._timer = setTimeout(() => {
      this._tapCount = 0;
    }, n)), this._tapCount === o && (clearTimeout(this._timer), this._tapCount = 0, c.trigger(this._element, No, {
      touch: t,
      origin: {
        x: e,
        y: i
      }
    }))), t;
  }
  handleTouchEnd() {
  }
  handleTouchMove() {
  }
  _getConfig(t) {
    const e = {
      ...B0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(No, e, P0), e;
  }
}
const Wi = "rotate", V0 = `${Wi}end`, W0 = `${Wi}start`, F0 = {
  angle: "number",
  pointers: "number"
}, Y0 = {
  angle: 0,
  pointers: 2
};
class j0 extends Qi {
  constructor(t, e) {
    super(), this._element = t, this._options = this._getConfig(e), this._origin = {};
  }
  // Getters
  static get NAME() {
    return Wi;
  }
  handleTouchStart(t) {
    t.type === "touchstart" && t.preventDefault(), !(t.touches.length < 2) && (this._startTouch = t, this._origin = {}, c.trigger(this._element, W0, { touch: t }));
  }
  handleTouchMove(t) {
    t.type === "touchmove" && t.preventDefault();
    let e, i;
    const n = t.touches;
    if (n.length === 1 && this._options.pointers === 1) {
      const { left: o, top: r, width: a, height: l } = this._element.getBoundingClientRect();
      e = {
        x: o + a / 2,
        y: r + l / 2
      }, i = n[0];
    } else if (t.touches.length === 2 && this._options.pointers === 2) {
      const [o, r] = t.touches, a = {
        x1: r.clientX,
        x2: o.clientX,
        y1: r.clientY,
        y2: o.clientY
      };
      e = this._getMidPoint(a), i = this._getRightMostTouch(t.touches);
    } else
      return;
    this.currentAngle = this._getAngle(
      e.x,
      e.y,
      i.clientX,
      i.clientY
    ), this._origin.initialAngle ? (this._origin.change = this._getAngularDistance(
      this._origin.previousAngle,
      this.currentAngle
    ), this._origin.distance += this._origin.change) : (this._origin.initialAngle = this._origin.previousAngle = this.currentAngle, this._origin.distance = this._origin.change = 0), this._origin.previousAngle = this.currentAngle, this.rotate = {
      currentAngle: this.currentAngle,
      distance: this._origin.distance,
      change: this._origin.change
    }, c.trigger(this._element, Wi, { ...this.rotate, touch: t });
  }
  handleTouchEnd(t) {
    t.type === "touchend" && t.preventDefault(), this._origin = {}, c.trigger(this._element, V0, { touch: t });
  }
  _getConfig(t) {
    const e = {
      ...Y0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(Wi, e, F0), e;
  }
}
const sr = "touch", Mo = `te.${sr}`, K0 = {
  event: "string"
}, z0 = {
  event: "swipe"
};
class Kh {
  constructor(t, e = {}) {
    this._element = t, this._options = this._getConfig(e), this._event = this._options.event, this.swipe = this._event === "swipe" ? new C0(t, e) : null, this.press = this._event === "press" ? new b0(t, e) : null, this.pan = this._event === "pan" ? new I0(t, e) : null, this.pinch = this._event === "pinch" ? new R0(t, e) : null, this.tap = this._event === "tap" ? new H0(t, e) : null, this.rotate = this._event === "rotate" ? new j0(t, e) : null, this._touchStartHandler = (i) => this._handleTouchStart(i), this._touchMoveHandler = (i) => this._handleTouchMove(i), this._touchEndHandler = (i) => this._handleTouchEnd(i), c.on(this._element, "touchstart", this._touchStartHandler), c.on(this._element, "touchmove", this._touchMoveHandler), c.on(this._element, "touchend", this._touchEndHandler), this._element && A.setData(t, Mo, this);
  }
  // Getters
  static get NAME() {
    return sr;
  }
  dispose() {
    c.off(this._element, "touchstart", this._touchStartHandler), c.off(this._element, "touchmove", this._touchMoveHandler), c.off(this._element, "touchend", this._touchEndHandler), this.swipe = null, this.press = null, this.pan = null, this.pinch = null, this.tap = null, this.rotate = null;
  }
  _getConfig(t) {
    const e = {
      ...z0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(sr, e, K0), e;
  }
  _handleTouchStart(t) {
    this[this._event].handleTouchStart(t);
  }
  _handleTouchMove(t) {
    this[this._event].handleTouchMove && this[this._event].handleTouchMove(t);
  }
  _handleTouchEnd(t) {
    this[this._event].handleTouchEnd(t);
  }
  static jQueryInterface(t) {
    return this.each(function() {
      let e = A.getData(this, Mo);
      const i = typeof t == "object" && t;
      if (!(!e && /dispose/.test(t)) && (e || (e = new Kh(this, i)), typeof t == "string")) {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        return e[t];
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, Mo);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const nr = "smoothScroll", Si = `te.${nr}`, Or = `.${Si}`, U0 = {
  container: "string",
  offset: "number",
  easing: "string",
  duration: "number"
}, X0 = {
  container: "body",
  offset: 0,
  easing: "linear",
  duration: 500
}, G0 = `scrollStart${Or}`, q0 = `scrollEnd${Or}`, Z0 = `scrollCancel${Or}`;
class zh {
  constructor(t, e = {}) {
    this._element = t, this._options = this._getConfig(e), this._href = this._element.getAttribute("href"), this.isCancel = !1, this._element && (A.setData(t, Si, this), this._setup());
  }
  // getters
  static get NAME() {
    return nr;
  }
  get isWindow() {
    return this._options.container === "body";
  }
  get containerToScroll() {
    return this.isWindow ? document.documentElement : d.findOne(
      this._options.container,
      document.documentElement
    );
  }
  get elFromHrefExist() {
    return !!d.findOne(this._href, this.containerToScroll);
  }
  get offsetFromEl() {
    const t = this.containerToScroll.scrollTop, e = d.findOne(this._href, this.containerToScroll);
    if (this.isWindow)
      return h.offset(e).top - this._options.offset + t;
    const i = e.getBoundingClientRect().y, n = this.containerToScroll.getBoundingClientRect().y;
    return i - n - this._options.offset + t;
  }
  get easingFunction() {
    const t = this._options.easing, e = `_motion${t[0].toUpperCase()}${t.slice(1)}`;
    return this[e] ? this[e] : this._motionLinear;
  }
  // public
  dispose() {
    c.off(this._element, "click", this._handleClick), A.removeData(this._element, Si), this._element = null;
  }
  cancelScroll() {
    this.isCancel = !0;
  }
  // private
  _getConfig(t) {
    const e = {
      ...X0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(nr, e, U0), e;
  }
  _inViewport() {
    if (this.isWindow)
      return !0;
    const t = this.containerToScroll.getBoundingClientRect();
    return t.top >= 0 && t.bottom <= (window.innerHeight || document.documentElement.clientHeight);
  }
  _setup() {
    const t = typeof this._href < "u", e = this._href.includes("#");
    t && e && this.elFromHrefExist && (this._scrollOnClickEvent(), this._preventNativeScroll());
  }
  _scrollOnClickEvent() {
    c.on(this._element, "click", (t) => {
      this._handleClick(t);
    });
  }
  _handleClick(t) {
    t.preventDefault(), this.isCancel = !1, c.trigger(this._element, G0);
    const e = this.containerToScroll, i = this.containerToScroll.scrollTop, n = this.offsetFromEl, o = 0, r = 1 / this._options.duration, a = 4.25, l = this.easingFunction;
    this._inViewport() ? this._scrollOnNextTick(
      e,
      i,
      n,
      o,
      r,
      a,
      l
    ) : (this._scrollOnNextTick(
      document.documentElement,
      document.documentElement.scrollTop,
      this.containerToScroll.offsetTop,
      o,
      r,
      a,
      l
    ), setTimeout(() => {
      this._scrollOnNextTick(
        e,
        i,
        n,
        o,
        r,
        a,
        l
      ), this.isCancel = !1;
    }, this._options.duration));
  }
  _scrollOnNextTick(t, e, i, n, o, r, a) {
    const l = n < 0, p = n > 1, u = o <= 0;
    if (l || p || u || this.isCancel) {
      if (this.isCancel) {
        this.isInViewport && (this.isCancel = !1), c.trigger(this._element, Z0);
        return;
      }
      c.trigger(this._element, q0), t.scrollTop = i;
      return;
    }
    t.scrollTo({
      top: e - (e - i) * a(n)
    }), n += o * r, setTimeout(() => {
      this._scrollOnNextTick(
        t,
        e,
        i,
        n,
        o,
        r,
        a
      );
    });
  }
  _preventDefault(t) {
    t.preventDefault();
  }
  _preventNativeScroll() {
    let t = !1;
    try {
      window.addEventListener(
        "test",
        null,
        Object.defineProperty({}, "passive", {
          get: () => t = !0
        })
      );
    } catch (n) {
      this._scrollError = n;
    }
    const e = t ? { passive: !1 } : !1, i = "onwheel" in $("div") ? "wheel" : "mousewheel";
    this.isWindow && (this._deleteScrollOnStart(e, i), this._addScrollOnEnd(e, i), this._addScrollOnCancel(e, i));
  }
  _deleteScrollOnStart(t, e) {
    c.on(this._element, "scrollStart.te.smoothScroll", () => {
      window.addEventListener(e, this._preventDefault, t), window.addEventListener("touchmove", this._preventDefault, t);
    });
  }
  _addScrollOnEnd(t, e) {
    c.on(this._element, "scrollEnd.te.smoothScroll", () => {
      window.removeEventListener(e, this._preventDefault, t), window.removeEventListener("touchmove", this._preventDefault, t);
    });
  }
  _addScrollOnCancel(t, e) {
    c.on(this._element, "scrollCancel.te.smoothScroll", () => {
      window.removeEventListener(e, this._preventDefault, t), window.removeEventListener("touchmove", this._preventDefault, t);
    });
  }
  // Motions
  // Linear
  _motionLinear(t) {
    return t;
  }
  // Ease-In
  _motionEaseInQuad(t) {
    return t * t;
  }
  _motionEaseInCubic(t) {
    return t * t * t;
  }
  _motionEaseInQuart(t) {
    return t * t * t * t;
  }
  _motionEaseInQuint(t) {
    return t * t * t * t * t;
  }
  // Ease-In-Out
  _motionEaseInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }
  _motionEaseInOutCubic(t) {
    return t /= 0.5, t < 1 ? t * t * t / 2 : (t -= 2, (t * t * t + 2) / 2);
  }
  _motionEaseInOutQuart(t) {
    return t /= 0.5, t < 1 ? 0.5 * t * t * t * t : (t -= 2, -(t * t * t * t - 2) / 2);
  }
  _motionEaseInOutQuint(t) {
    return t /= 0.5, t < 1 ? t * t * t * t * t / 2 : (t -= 2, (t * t * t * t * t + 2) / 2);
  }
  // Ease-Out
  _motionEaseOutQuad(t) {
    return -t * (t - 2);
  }
  _motionEaseOutCubic(t) {
    return t--, t * t * t + 1;
  }
  _motionEaseOutQuart(t) {
    return t--, -(t * t * t * t - 1);
  }
  _motionEaseOutQuint(t) {
    return t--, t * t * t * t * t + 1;
  }
  // static
  static getInstance(t) {
    return A.getData(t, Si);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static jQueryInterface(t) {
    return this.each(function() {
      let e = A.getData(this, Si);
      const i = typeof t == "object" && t;
      if (e || (e = new zh(this, i)), typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const ql = "lazyLoad", Ps = "te.lazyLoad", Q0 = "[data-te-lazy-load-init]", Zl = "data-te-lazy-load", J0 = "onLoad.te.lazy", tC = "onError.te.lazy", Ql = ["img", "video"], eC = {
  lazySrc: "(string|null)",
  lazyDelay: "number",
  lazyAnimation: "string",
  lazyOffset: "number",
  lazyPlaceholder: "(string|undefined)",
  lazyError: "(string|undefined)"
}, iC = {
  lazySrc: null,
  lazyDelay: 500,
  lazyAnimation: "[fade-in_1s_ease-in-out]",
  lazyOffset: 0
};
class or {
  constructor(t, e) {
    this._element = t, this._element && A.setData(t, Ps, this), this._options = this._getConfig(e), this.scrollHandler = this._scrollHandler.bind(this), this.errorHandler = this._setElementError.bind(this), this._childrenInstances = null, this._init();
  }
  // Getters
  static get NAME() {
    return ql;
  }
  get offsetValues() {
    return this._element.getBoundingClientRect();
  }
  get inViewport() {
    if (this.parent) {
      const t = this.parent.getBoundingClientRect();
      return t.y > 0 && t.y < window.innerHeight && this.offsetValues.y >= t.y && this.offsetValues.y <= t.y + t.height && this.offsetValues.y <= window.innerHeight;
    }
    return this.offsetValues.top + this._options.lazyOffset <= window.innerHeight && this.offsetValues.bottom >= 0;
  }
  get parent() {
    const [t] = d.parents(
      this._element,
      Q0
    );
    return t;
  }
  get node() {
    return this._element.nodeName;
  }
  get isContainer() {
    return !d.matches(this._element, Ql);
  }
  // Public
  dispose() {
    A.removeData(this._element, Ps), this._animation && (this._animation.dispose(), this._animation = null), this._element = null, this._childrenInstances && this._childrenInstances.forEach((t) => t.dispose());
  }
  // Private
  _init() {
    if (this._element.setAttribute(Zl, ""), this.isContainer) {
      this._setupContainer();
      return;
    }
    this._setupElement();
  }
  _setupElement() {
    c.one(this._element, "error", this.errorHandler), this._options.lazyPlaceholder && this._setPlaceholder(), this._animation = new wr(this._element, {
      animation: `${this._options.lazyAnimation}`,
      animationStart: "onLoad"
    }), c.one(this._element, "load", () => this._scrollHandler()), this.parent && c.on(this.parent, "scroll", this.scrollHandler), c.on(window, "scroll", this.scrollHandler);
  }
  _scrollHandler() {
    this.inViewport && (this._timeout = setTimeout(() => {
      this._setSrc(), this._element.removeAttribute(Zl), this._removeAttrs(), this._animation.init();
    }, this._options.lazyDelay), this.parent && c.off(this.parent, "scroll", this.scrollHandler), c.off(window, "scroll", this.scrollHandler));
  }
  _setElementError() {
    !this._options.lazyError || this._element.src === this._options.lazyError ? this._element.alt = "404 not found" : this._element.setAttribute("src", this._options.lazyError), c.trigger(this._element, tC);
  }
  _setSrc() {
    this._element.setAttribute("src", this._options.lazySrc), c.trigger(this._element, J0);
  }
  _setPlaceholder() {
    this.node === "IMG" ? this._element.setAttribute("src", this._options.lazyPlaceholder) : this.node === "VIDEO" && this._element.setAttribute("poster", this._options.lazyPlaceholder);
  }
  _removeAttrs() {
    ["src", "delay", "animation", "placeholder", "offset", "error"].forEach(
      (t) => {
        h.removeDataAttribute(this._element, `lazy-${t}`);
      }
    );
  }
  _setupContainer() {
    this._childrenInstances = d.children(
      this._element,
      Ql
    ).map((t) => new or(t, this._options));
  }
  _getConfig(t) {
    const e = {
      ...iC,
      ...t,
      ...h.getDataAttributes(this._element)
    };
    return I(ql, e, eC), e;
  }
  // Static
  static getInstance(t) {
    return A.getData(t, Ps);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static jQueryInterface(t) {
    return this.each(function() {
      let e = A.getData(this, Ps);
      const i = typeof t == "object" && t;
      if (e || (e = new or(this, i)), typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const Jl = "clipboard", Ii = "te.clipboard", sC = `.${Ii}`, nC = {
  clipboardTarget: null
}, oC = {
  clipboardTarget: "null|string"
}, rC = `copy${sC}`;
class Uh {
  constructor(t, e = {}) {
    this._element = t, this._options = e, this._element && (A.setData(t, Ii, this), this._initCopy = this._initCopy.bind(this), this._setup());
  }
  // Getters
  static get NAME() {
    return Jl;
  }
  get options() {
    const t = {
      ...nC,
      ...h.getDataAttributes(this._element),
      ...this._options
    };
    return I(Jl, t, oC), t;
  }
  get clipboardTarget() {
    return d.findOne(this.options.clipboardTarget);
  }
  get copyText() {
    const t = this.clipboardTarget.hasAttribute(
      "data-te-clipboard-text"
    ), e = this.clipboardTarget.value, i = this.clipboardTarget.textContent;
    return t ? this.clipboardTarget.getAttribute("data-te-clipboard-text") : e || i;
  }
  // Public
  dispose() {
    c.off(this._element, "click", this._initCopy), A.removeData(this._element, Ii), this._element = null;
  }
  // Private
  _setup() {
    c.on(this._element, "click", this._initCopy);
  }
  _initCopy() {
    const t = this._createNewInput();
    document.body.appendChild(t), this._selectInput(t), c.trigger(this._element, rC, {
      copyText: this.copyText
    }), t.remove();
  }
  _createNewInput() {
    const t = this.clipboardTarget.tagName === "TEXTAREA" ? "textarea" : "input", e = $(t);
    return e.value = this.copyText, h.addClass(e, "-left-[9999px] absolute"), e;
  }
  _selectInput(t) {
    t.select(), t.focus(), t.setSelectionRange(0, 99999), document.execCommand("copy");
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      let e = A.getData(this, Ii);
      const i = typeof t == "object" && t;
      if (e || (e = new Uh(this, i)), typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, Ii);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const rr = "infiniteScroll", Bs = `te.${rr}`, aC = {
  infiniteDirection: "y"
}, lC = {
  infiniteDirection: "string"
};
class Xh {
  constructor(t, e) {
    this._element = t, this._element && A.setData(t, Bs, this), this._options = this._getConfig(e), this.scrollHandler = this._scrollHandler.bind(this), this._init();
  }
  // Getters
  static get NAME() {
    return rr;
  }
  get rect() {
    return this._element.getBoundingClientRect();
  }
  get condition() {
    return this._element === window ? Math.abs(
      window.scrollY + window.innerHeight - document.documentElement.scrollHeight
    ) < 1 : this._options.infiniteDirection === "x" ? this.rect.width + this._element.scrollLeft + 10 >= this._element.scrollWidth : Math.ceil(this.rect.height + this._element.scrollTop) >= this._element.scrollHeight;
  }
  // Public
  dispose() {
    c.off(this._element, "scroll", this.scrollHandler), A.removeData(this._element, Bs), this._element = null;
  }
  // Private
  _init() {
    c.on(this._element, "scroll", () => this._scrollHandler());
  }
  _scrollHandler() {
    this.condition && c.trigger(this._element, "complete.te.infiniteScroll"), c.off(this._element, "scroll", this.scrollHandler);
  }
  _getConfig(t) {
    const e = {
      ...aC,
      ...this._element !== window ? h.getDataAttributes(this._element) : {},
      ...t
    };
    return I(rr, e, lC), e;
  }
  // Static
  static getInstance(t) {
    return A.getData(t, Bs);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static jQueryInterface(t) {
    return this.each(function() {
      let e = A.getData(this, Bs);
      const i = typeof t == "object" && t;
      if (e || (e = new Xh(this, i)), typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
function cC({ backdropID: s }, t) {
  const e = $("div");
  return h.addClass(
    e,
    `${t.backdrop} ${t.backdropColor}`
  ), e.id = s, e;
}
const Fi = "loadingManagement", Hs = `te.${Fi}`, hC = "[data-te-loading-icon-ref]", dC = "[data-te-loading-text-ref]", uC = `show.te.${Fi}`, pC = {
  backdrop: "(null|boolean)",
  backdropID: "(null|string|number)",
  delay: "(null|number)",
  loader: "(null|string|number)",
  parentSelector: "(null|string)",
  loadingIcon: "boolean",
  loadingText: "boolean",
  scroll: "boolean"
}, _C = {
  backdrop: !0,
  backdropID: null,
  delay: 0,
  loader: "",
  parentSelector: null,
  scroll: !0,
  loadingText: !0,
  loadingIcon: !0
}, fC = {
  loadingSpinner: "absolute top-[50%] left-[50%] -translate-x-[50%] -translate-y-[50%] flex flex-col justify-center items-center z-40",
  spinnerColor: "text-primary dark:text-primary-400",
  backdrop: "w-full h-full fixed top-0 left-0 bottom-0 right-0 z-30",
  backdropColor: "bg-[rgba(0,0,0,0.4)]"
}, mC = {
  loadingSpinner: "string",
  spinnerColor: "string",
  backdrop: "string",
  backdropColor: "string"
};
class Gh {
  constructor(t, e = {}, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._element && A.setData(t, Hs, this), this._backdropElement = null, this._parentElement = d.findOne(this._options.parentSelector), this._loadingIcon = d.findOne(
      hC,
      this._element
    ), this._loadingText = d.findOne(
      dC,
      this._element
    ), this.init();
  }
  // Getters
  static get NAME() {
    return Fi;
  }
  // Public
  init() {
    const t = this._loadingIcon.cloneNode(!0), e = this._loadingText.cloneNode(!0);
    this._removeElementsOnStart(), setTimeout(() => {
      h.addClass(
        this._element,
        `${this._classes.loadingSpinner} ${this._classes.spinnerColor}`
      ), this._setBackdrop(), this._setLoadingIcon(t), this._setLoadingText(e), this._setScrollOption(), c.trigger(this._element, uC);
    }, this._options.delay);
  }
  dispose() {
    A.removeData(this._element, Hs), h.removeClass(
      this._element,
      `${this._classes.loadingSpinner} ${this._classes.spinnerColor}`
    );
    const t = this._options.delay;
    setTimeout(() => {
      this._removeBackdrop(), this._backdropElement = null, this._element = null, this._options = null;
    }, t);
  }
  // Private
  _setBackdrop() {
    const { backdrop: t } = this._options;
    t && (this._backdropElement = cC(this._options, this._classes), this._parentElement !== null ? (h.addClass(this._element, "absolute"), h.addClass(this._parentElement, "relative"), h.addClass(this._backdropElement, "absolute"), this._parentElement.appendChild(this._backdropElement)) : (h.addClass(this._element, "!fixed"), document.body.appendChild(this._backdropElement), document.body.appendChild(this._element)));
  }
  _removeBackdrop() {
    const { backdrop: t } = this._options;
    t && (this._parentElement !== null ? (h.removeClass(this._element, "absolute"), h.removeClass(this._parentElement, "relative"), this._backdropElement.remove()) : (this._backdropElement.remove(), this._element.remove()));
  }
  _setLoadingIcon(t) {
    if (!this._options.loadingIcon) {
      t.remove();
      return;
    }
    this._element.appendChild(t), t.id = this._options.loader;
  }
  _setLoadingText(t) {
    if (!this._options.loadingText) {
      t.remove();
      return;
    }
    this._element.appendChild(t);
  }
  _removeElementsOnStart() {
    this._element !== null && (this._loadingIcon.remove(), this._loadingText.remove());
  }
  _setScrollOption() {
    if (this._options.scroll) {
      if (this._parentElement === null) {
        h.addClass(document.body, "overflow-auto");
        return;
      }
      h.addClass(this._parentElement, "overflow-auto");
    } else {
      if (this._parentElement === null) {
        h.addClass(document.body, "overflow-hidden");
        return;
      }
      h.addClass(this._parentElement, "overflow-hidden");
    }
  }
  _getConfig(t) {
    const e = {
      ..._C,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(Fi, e, pC), e;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...fC,
      ...e,
      ...t
    }, I(Fi, t, mC), t;
  }
  // Static
  static getInstance(t) {
    return A.getData(t, Hs);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static jQueryInterface(t) {
    return this.each(function() {
      let e = A.getData(this, Hs);
      const i = typeof t == "object" && t;
      if (e || (e = new Gh(this, i)), typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const gC = (s) => {
  const t = /^(0?[1-9]|1[012])(:[0-5]\d) [APap][mM]$/, e = /^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/;
  return s.match(t) || s.match(e);
}, bC = (s) => s && Object.prototype.toString.call(s) === "[object Date]" && !isNaN(s), vC = (s) => s.getMonth(), TC = (s) => s.getFullYear(), EC = (s) => s.match(/[^(dmy)]{1,}/g), CC = (s, t, e, i) => {
  let n;
  e[0] !== e[1] ? n = e[0] + e[1] : n = e[0];
  const o = new RegExp(`[${n}]`), r = s.split(o), a = t.split(o), l = t.indexOf("mmm") !== -1, p = [];
  for (let b = 0; b < a.length; b++)
    a[b].indexOf("yy") !== -1 && (p[0] = { value: r[b], format: a[b] }), a[b].indexOf("m") !== -1 && (p[1] = { value: r[b], format: a[b] }), a[b].indexOf("d") !== -1 && a[b].length <= 2 && (p[2] = { value: r[b], format: a[b] });
  let u;
  t.indexOf("mmmm") !== -1 ? u = i.monthsFull : u = i.monthsShort;
  const _ = Number(p[0].value), f = l ? AC(p[1].value, u) : Number(p[1].value) - 1, g = Number(p[2].value);
  return Ct(_, f, g);
}, AC = (s, t) => t.findIndex((e) => e === s), yC = (s, t, e) => `
  <button type="button" class="${e.pickerIcon}" data-te-datepicker-toggle-button-ref>
    ${s}
  </button>
  <button type="button" class="${e.pickerIcon}" data-te-timepicker-toggle-button-ref>
    ${t}
  </button>
`, wC = (s, t) => `
  <button type="button" class="${t.toggleButton}" data-te-date-timepicker-toggle-ref>
    ${s} 
  </button>
`, on = "datetimepicker", Di = `te.${on}`, Sr = `.${Di}`, qh = "data-te-datepicker-init", Zh = "data-te-timepicker-init", kC = "data-te-datepicker-header", xC = "data-te-datepicker-cancel-button-ref", OC = "data-te-datepicker-ok-button-ref", Ro = "data-te-timepicker-wrapper", tc = "data-te-timepicker-cancel", SC = "data-te-timepicker-submit", IC = "data-te-timepicker-clear", ec = "data-te-buttons-timepicker", DC = "data-te-date-timepicker-toggle-ref", $C = "data-te-datepicker-toggle-button-ref", LC = "data-te-timepicker-toggle-button-ref", NC = `[${Zh}]`, MC = `[${qh}]`, RC = `[${DC}]`, PC = `[${LC}]`, BC = "[data-te-input-notch-ref]", HC = "[data-te-date-timepicker-toggle-ref]", VC = "[data-te-timepicker-elements-wrapper]", WC = "[data-te-timepicker-clock-wrapper]", FC = `open${Sr}`, YC = `close${Sr}`, jC = `datetimeChange${Sr}`, ic = "close.te.datepicker", sc = "input.te.timepicker", Re = $("div"), nc = {
  inline: !1,
  toggleButton: !0,
  container: "body",
  disabled: !1,
  disablePast: !1,
  disableFuture: !1,
  defaultTime: "",
  defaultDate: "",
  timepicker: {},
  datepicker: {},
  showFormat: !1,
  dateTimepickerToggleIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
  <path fill-rule="evenodd" d="M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z" clip-rule="evenodd" />
  </svg>`,
  datepickerToggleIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
  <path fill-rule="evenodd" d="M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z" clip-rule="evenodd" />
  </svg>`,
  timepickerToggleIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>`
}, KC = {
  inline: "boolean",
  toggleButton: "boolean",
  container: "string",
  disabled: "boolean",
  disablePast: "boolean",
  disableFuture: "boolean",
  defaultTime: "(string|date|number)",
  defaultDate: "(string|date|number)",
  timepicker: "object",
  datepicker: "object",
  showFormat: "boolean",
  dateTimepickerToggleIconTemplate: "string",
  datepickerToggleIconTemplate: "string",
  timepickerToggleIconTemplate: "string"
}, zC = {
  toggleButton: "flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-0.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200",
  pickerIcon: "[&>svg]:w-6 [&>svg]:h-6 [&>svg]:mx-auto [&>svg]:pointer-events-none w-1/2 px-1.5 py-[1px] rounded-[10px] min-h-[40px] cursor-pointer outline-none border-none text-white hover:bg-primary-600 dark:hover:bg-neutral-600",
  buttonsContainer: "flex justify-evenly items-end bg-primary dark:bg-zinc-800 dark:data-[te-buttons-timepicker]:bg-zinc-700",
  timepicker: {},
  datepicker: {}
}, UC = {
  toggleButton: "string",
  pickerIcon: "string",
  buttonsContainer: "string",
  timepicker: "object",
  datepicker: "object"
};
class Qh {
  constructor(t, e, i) {
    this._element = t, this._input = d.findOne("input", this._element), this._options = this._getConfig(e), this._classes = this._getClasses(i), this._timepicker = null, this._datepicker = null, this._dateValue = this._options.defaultDate ? this._options.defaultDate : "", this._timeValue = this._options.defaultTime ? this._options.defaultTime : "", this._isInvalidTimeFormat = !1, this._format = this._options.datepicker.format ? this._options.datepicker.format : "dd/mm/yyyy", this._cancel = !1, this._scrollBar = new ti(), this._element && A.setData(t, Di, this), this._init();
  }
  // Getters
  static get NAME() {
    return on;
  }
  get toggleButton() {
    return d.findOne(RC, this._element);
  }
  get notch() {
    return d.findOne(BC, this._element);
  }
  dispose() {
    c.off(this._element, "click", this._openDatePicker), c.off(this._input, "input", this._handleInput), c.off(this._element, "click"), A.removeData(this._element, Di), this._removeTimePicker(), this._removeDatepicker(), this.toggleButton.remove(), this._options = nc, this._timepicker = null, this._datepicker = null, this._dateValue = null, this._timeValue = null, this._isInvalidTimeFormat = null;
  }
  update(t = {}) {
    const e = this._getConfig({ ...this._options, ...t });
    this.dispose(), this._options = e, this._init();
  }
  // Private
  _init() {
    this._addDatepicker(), this._addTimePicker(), this._appendToggleButton(), this._listenToToggleClick(), this._listenToUserInput(), this._disableInput(), this._setInitialDefaultInput(), this._applyFormatPlaceholder(), this._options.disablePast && this._handleTimepickerDisablePast(), this._options.disableFuture && this._handleTimepickerDisableFuture();
  }
  _removeDatepicker() {
    const t = this._element.querySelector(MC);
    t && t.remove();
  }
  _addDatepicker() {
    const t = $("div");
    t.id = this._element.id ? `datepicker-${this._element.id}` : et("datepicker-");
    const e = '<input type="text">';
    t.innerHTML = e, t.setAttribute(qh, ""), this._element.appendChild(t), h.addClass(t, "hidden");
    let i = {
      ...this._options.datepicker,
      container: this._options.container,
      disablePast: this._options.disablePast,
      disableFuture: this._options.disableFuture
    };
    (this._options.inline || this._options.datepicker.inline) && (i = { ...i, inline: !0 }), this._datepicker = new og(t, i, {
      ...this._classes.datepicker
    }), this._datepicker._input.value = this._dateValue;
  }
  _removeTimePicker() {
    const t = this._element.querySelector(NC);
    t && (t.remove(), this._scrollBar.reset());
  }
  _addTimePicker() {
    const t = $("div");
    t.id = this._element.id ? `timepicker-${this._element.id}` : et("timepicker-");
    const e = '<input type="text">';
    t.innerHTML = e, t.setAttribute(Zh, ""), this._element.appendChild(t), h.addClass(t, "hidden");
    let i = {
      ...this._options.timepicker,
      container: this._options.container
    };
    (this._options.inline || this._options.timepicker.inline) && (i = { ...i, inline: !0 }), this._timepicker = new Sg(t, i, {
      ...this._classes.timepicker
    }), this._timepicker.input.value = this._timeValue;
  }
  _addIconButtons() {
    if (h.addClass(Re, this._classes.buttonsContainer), Re.innerHTML = yC(
      this._options.datepickerToggleIconTemplate,
      this._options.timepickerToggleIconTemplate,
      this._classes
    ), Re.removeAttribute(ec), !(this._options.inline || this._options.datepicker.inline)) {
      if (this._scrollBar.hide(), this._datepicker._isOpen)
        d.findOne(
          `[${kC}]`,
          document.body
        ).appendChild(Re);
      else if (this._timepicker._modal && !this._options.timepicker.inline) {
        const t = d.findOne(
          VC,
          document.body
        ), e = d.findOne(
          WC,
          document.body
        );
        Re.setAttribute(ec, ""), t.insertBefore(Re, e);
      }
    }
  }
  _enableOrDisableToggleButton() {
    this._options.disabled ? (this.toggleButton.disabled = !0, h.addClass(this.toggleButton, "pointer-events-none")) : (this.toggleButton.disabled = !1, h.removeClass(this.toggleButton, "pointer-events-none"));
  }
  _appendToggleButton() {
    this._options.toggleButton && (this._element.insertAdjacentHTML(
      "beforeend",
      wC(
        this._options.dateTimepickerToggleIconTemplate,
        this._classes
      )
    ), this._enableOrDisableToggleButton());
  }
  _applyFormatPlaceholder() {
    this._options.showFormat && (this._input.placeholder = this._format);
  }
  _listenToCancelClick() {
    const t = d.findOne(
      `[${xC}]`,
      document.body
    );
    c.one(t, "mousedown", () => {
      this._cancel = !0, this._scrollBar.reset(), c.off(t, "mousedown");
    });
  }
  _listenToToggleClick() {
    c.on(this._element, "click", HC, (t) => {
      t.preventDefault(), this._openDatePicker();
    });
  }
  _listenToUserInput() {
    c.on(this._input, "input", (t) => {
      this._handleInput(t.target.value);
    });
  }
  _disableInput() {
    this._options.disabled && (this._input.disabled = "true");
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...nc,
      ...e,
      ...t
    }, I(on, t, KC), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...zC,
      ...e,
      ...t
    }, I(on, t, UC), t;
  }
  _handleInput(t) {
    const e = t.split(", "), i = EC(this._format), n = e[0], o = e[1] || "", r = CC(
      n,
      this._format,
      i,
      this._datepicker._options
    );
    e.length === 2 && (bC(r) && gC(o) ? (this._dateValue = n, this._timeValue = o, this._datepicker._input.value = this._dateValue, this._datepicker._activeDate = this._dateValue, this._datepicker._selectedYear = TC(r), this._datepicker._selectedMonth = vC(r), this._datepicker._headerDate = r, this._timepicker.input.value = this._timeValue, this._timepicker._isInvalidTimeFormat = !1) : (this._datepicker._activeDate = /* @__PURE__ */ new Date(), this._datepicker._selectedDate = null, this._datepicker._selectedMonth = null, this._datepicker._selectedYear = null, this._datepicker._headerDate = null, this._datepicker._headerMonth = null, this._datepicker._headerYear = null, this._timepicker._isInvalidTimeFormat = !0));
  }
  _openDatePicker() {
    if (c.trigger(this._element, FC).defaultPrevented)
      return;
    this._datepicker.open(), this._options.inline || this._scrollBar.hide(), (this._options.inline || this._options.datepicker.inline) && this._openDropdownDate(), this._addIconButtons(), this._listenToCancelClick(), this._options.inline && this._datepicker._isOpen && h.addClass(this.toggleButton, "pointer-events-none"), c.one(this._datepicker._element, ic, () => {
      if (this._dateValue = this._datepicker._input.value, this._updateInputValue(), this._cancel) {
        this._cancel = !1;
        return;
      }
      let i = !1;
      c.on(this._datepicker.container, "click", (n) => {
        !this._datepicker._selectedDate && n.target.hasAttribute(OC) || i || (this._openTimePicker(), i = !0, setTimeout(() => {
          i = !1;
        }, 500));
      }), setTimeout(() => {
        d.findOne(
          `[${Ro}]`,
          document.body
        ) || this._scrollBar.reset();
      }, 10), this._options.inline && h.removeClass(this.toggleButton, "pointer-events-none");
    });
    const e = d.findOne(
      PC,
      document.body
    );
    c.on(e, "click", () => {
      this._datepicker.close(), this._scrollBar.hide(), c.trigger(this._datepicker._element, ic);
    });
  }
  _handleTimepickerDisablePast() {
    const t = /* @__PURE__ */ new Date();
    t.setHours(0, 0, 0, 0), c.on(
      this._datepicker._element,
      "dateChange.te.datepicker",
      () => {
        this._datepicker._selectedDate.getTime() === t.getTime() ? this._timepicker.update({ disablePast: !0 }) : this._timepicker.update({ disablePast: !1 });
      }
    );
  }
  _handleTimepickerDisableFuture() {
    const t = /* @__PURE__ */ new Date();
    t.setHours(0, 0, 0, 0), c.on(
      this._datepicker._element,
      "dateChange.te.datepicker",
      () => {
        this._datepicker._selectedDate.getTime() === t.getTime() ? this._timepicker.update({ disableFuture: !0 }) : this._timepicker.update({ disableFuture: !1 });
      }
    );
  }
  _handleEscapeKey() {
    c.one(document.body, "keyup", () => {
      setTimeout(() => {
        d.findOne(
          `[${Ro}]`,
          document.body
        ) || this._scrollBar.reset();
      }, 250);
    });
  }
  _handleCancelButton() {
    const t = d.findOne(
      `[${tc}]`,
      document.body
    );
    c.one(t, "mousedown", () => {
      this._scrollBar.reset();
    });
  }
  _openDropdownDate() {
    const t = this._datepicker._popper;
    t.state.elements.reference = this._input, this._scrollBar.reset();
  }
  _openTimePicker() {
    c.trigger(this._timepicker.elementToggle, "click"), setTimeout(() => {
      if (this._addIconButtons(), (this._options.inline || this._options.timepicker.inline) && this._openDropdownTime(), this._timepicker._modal) {
        const t = d.findOne(
          `[${tc}]`,
          document.body
        );
        this._handleEscapeKey(), this._handleCancelButton(), c.on(this._timepicker._modal, "click", (e) => {
          (e.target.hasAttribute(Ro) || e.target.hasAttribute(SC)) && setTimeout(() => {
            this._scrollBar.reset();
          }, 200), e.target.hasAttribute(IC) && c.trigger(
            this._timepicker._element,
            sc
          ), e.target.hasAttribute($C) && (c.trigger(t, "click"), setTimeout(() => {
            this._openDatePicker(), this._scrollBar.hide();
          }, 200));
        });
      }
    }), c.one(this._timepicker._element, sc, () => {
      this._timeValue = this._timepicker.input.value, this._updateInputValue(), c.trigger(this._element, YC);
    });
  }
  _openDropdownTime() {
    const t = this._timepicker._popper;
    t.state.elements.reference = this._input, t.update(), this._scrollBar.reset();
  }
  _setInitialDefaultInput() {
    (this._options.defaultDate || this._options.defaultTime) && this._updateInputValue();
  }
  _updateInputValue() {
    this._timeValue && this._dateValue && (this._input.value = `${this._dateValue}, ${this._timeValue}`, c.trigger(
      this._element,
      jC,
      { value: this._input.value }
    ).defaultPrevented) || (c.trigger(this._input, "focus"), this.notch && this.notch.removeAttribute("data-te-input-focused"));
  }
  // static
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, Di);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new Qh(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, Di);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const rn = "sticky", $i = `te.${rn}`, Jh = `.${$i}`, XC = `active${Jh}`, GC = `inactive${Jh}`, qC = {
  stickyAnimationSticky: "",
  stickyAnimationUnsticky: "",
  stickyBoundary: !1,
  stickyDelay: 0,
  stickyDirection: "down",
  stickyMedia: 0,
  stickyOffset: 0,
  stickyPosition: "top",
  stickyZIndex: 100
}, ZC = {
  stickyAnimationSticky: "string",
  stickyAnimationUnsticky: "string",
  stickyBoundary: "(boolean|string)",
  stickyDelay: "number",
  stickyDirection: "string",
  stickyMedia: "number",
  stickyOffset: "number",
  stickyPosition: "string",
  stickyZIndex: "(string|number)"
}, QC = {
  stickyActive: ""
}, JC = {
  stickyActive: "string"
};
class td {
  constructor(t, e, i) {
    this._element = t, this._hiddenElement = null, this._elementPositionStyles = {}, this._scrollDirection = "", this._isSticked = !1, this._elementOffsetTop = null, this._scrollTop = 0, this._pushPoint = "", this._manuallyDeactivated = !1, this._element && (this._options = this._getConfig(e), this._classes = this._getClasses(i), A.setData(t, $i, this), this._init());
  }
  // Getters
  static get NAME() {
    return rn;
  }
  // Public
  dispose() {
    const { stickyAnimationUnsticky: t } = this._options;
    let { animationDuration: e } = getComputedStyle(this._element);
    e = t !== "" ? parseFloat(e) * 1e3 : 0, this._disableSticky(), setTimeout(() => {
      A.removeData(this._element, $i), this._element = null, this._options = null, this._hiddenElement = null, this._elementPositionStyles = null, this._scrollDirection = null, this._isSticked = null, this._elementOffsetTop = null, this._scrollTop = null, this._pushPoint = null, this._manuallyDeactivated = null;
    }, e);
  }
  active() {
    this._isSticked || (this._createHiddenElement(), this._enableSticky(), this._changeBoundaryPosition(), this._isSticked = !0, this._manuallyDeactivated = !1);
  }
  inactive() {
    this._isSticked && (this._disableSticky(), this._isSticked = !1, this._manuallyDeactivated = !0);
  }
  // Private
  _init() {
    this._userActivityListener();
  }
  _userActivityListener() {
    c.on(window, "resize", () => {
      this._updateElementPosition(), this._updateElementOffset();
    }), c.on(window, "scroll", () => {
      if (!this._element || window.innerWidth <= this._options.stickyMedia || this._manuallyDeactivated)
        return;
      const t = document.documentElement, { stickyDirection: e } = this._options, i = window.pageYOffset || t.scrollTop;
      this._updateElementOffset(), this._updatePushPoint(), this._updateScrollDirection(i), this._clearInProgressAnimations();
      const n = [this._scrollDirection, "both"].includes(
        e
      ), o = this._pushPoint <= i, r = o && !this._isSticked && n, a = (!o || !n) && this._isSticked;
      r && (this._createHiddenElement(), this._enableSticky(), this._changeBoundaryPosition(), this._isSticked = !0), a && (this._disableSticky(), this._isSticked = !1), this._isSticked && (this._updatePosition({ styles: this._elementPositionStyles }), this._changeBoundaryPosition()), this._scrollTop = i <= 0 ? 0 : i;
    });
  }
  _updatePushPoint() {
    this._options.stickyPosition === "top" ? this._pushPoint = this._elementOffsetTop - this._options.stickyDelay : this._pushPoint = this._elementOffsetTop + this._element.height - document.body.scrollHeight + this._options.stickyDelay;
  }
  _updateElementOffset() {
    this._hiddenElement ? this._elementOffsetTop = this._hiddenElement.offsetTop : this._elementOffsetTop = this._element.offsetTop, this._options.stickyAnimationUnsticky && (this._elementOffsetTop += this._element.height || 0);
  }
  _updateElementPosition() {
    if (this._hiddenElement) {
      const { left: t } = this._hiddenElement.getBoundingClientRect();
      this._elementPositionStyles = {
        left: `${t}px`
      };
    } else
      this._elementPositionStyles = {};
    this._setStyle(this._element, this._elementPositionStyles);
  }
  _updateScrollDirection(t) {
    t > this._scrollTop ? this._scrollDirection = "down" : this._scrollDirection = "up";
  }
  _clearInProgressAnimations() {
    const t = this._scrollDirection === "up", e = this._element.classList.contains(
      this._options.stickyAnimationUnsticky
    ), i = window.scrollY <= this._elementOffsetTop - this._element.height;
    t && e && i && (this._removeUnstickyAnimation(), this._resetStyles(), this._removeHiddenElement());
  }
  _enableSticky() {
    const {
      stickyAnimationSticky: t,
      stickyAnimationUnsticky: e,
      stickyOffset: i,
      stickyPosition: n,
      stickyZIndex: o
    } = this._options, { height: r, left: a, width: l } = this._element.getBoundingClientRect();
    t !== "" && this._toggleClass(
      t,
      e,
      this._element
    ), this._toggleClass(this._classes.stickyActive, "", this._element), this._setStyle(this._element, {
      top: n === "top" && `${0 + i}px`,
      bottom: n === "bottom" && `${0 + i}px`,
      height: `${r}px`,
      width: `${l}px`,
      left: `${a}px`,
      zIndex: `${o}`,
      position: "fixed"
    }), this._hiddenElement.hidden = !1, c.trigger(this._element, XC);
  }
  _changeBoundaryPosition() {
    const { stickyPosition: t, stickyBoundary: e, stickyOffset: i } = this._options, { height: n } = this._element.getBoundingClientRect(), o = {
      height: this._element.parentElement.getBoundingClientRect().height,
      ...this._getOffset(this._element.parentElement)
    };
    let r;
    const a = d.findOne(e);
    a ? r = this._getOffset(a).top - n - i : r = o.height + o[t] - n - i;
    const l = t === "top", p = t === "bottom", u = e, _ = r < 0, f = r > o.height - n;
    let g;
    l && (_ && u ? g = { top: `${i + r}px` } : g = { top: `${i + 0}px` }), p && (_ && u ? g = { bottom: `${i + r}px` } : f && u ? g = { bottom: `${i + o.bottom}px` } : g = { bottom: `${i + 0}px` }), this._setStyle(this._element, g);
  }
  _disableSticky() {
    const { stickyAnimationUnsticky: t, stickyAnimationSticky: e } = this._options;
    let { animationDuration: i } = getComputedStyle(this._element);
    i = t !== "" ? parseFloat(i) * 1e3 : 0, this._options.stickyAnimationUnsticky !== "" && this._toggleClass(
      t,
      e,
      this._element
    ), setTimeout(() => {
      this._element.classList.contains(e) || (this._removeUnstickyAnimation(), this._resetStyles(), this._removeHiddenElement(), this._toggleClass("", this._classes.stickyActive, this._element), c.trigger(this._element, GC));
    }, i);
  }
  _createHiddenElement() {
    this._hiddenElement || (this._hiddenElement = this._copyElement(this._element));
  }
  _removeHiddenElement() {
    this._hiddenElement && (this._hiddenElement.remove(), this._hiddenElement = null);
  }
  _removeUnstickyAnimation() {
    this._toggleClass("", this._options.stickyAnimationUnsticky, this._element);
  }
  _resetStyles() {
    this._setStyle(this._element, {
      top: null,
      bottom: null,
      position: null,
      left: null,
      zIndex: null,
      width: null,
      height: null
    });
  }
  _updatePosition({ styles: t }) {
    this._setStyle(this._element, t);
  }
  _toggleClass(t, e, i) {
    t && h.addClass(i, t), e && h.removeClass(i, e);
  }
  _getOffset(t) {
    const e = h.offset(t), i = t.getBoundingClientRect(), n = e.left === 0 && e.top === 0 ? 0 : window.innerHeight - i.bottom;
    return {
      ...e,
      bottom: n
    };
  }
  _copyElement(t) {
    const { height: e, width: i } = t.getBoundingClientRect(), n = t.cloneNode(!1);
    return n.hidden = !0, this._setStyle(n, {
      height: `${e}px`,
      width: `${i}px`,
      opacity: "0"
    }), t.parentElement.insertBefore(n, t), n;
  }
  _getConfig(t = {}) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...qC,
      ...e,
      ...t
    }, I(rn, t, ZC), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...QC,
      ...e,
      ...t
    }, I(rn, t, JC), t;
  }
  _setStyle(t, e) {
    Object.keys(e).forEach((i) => {
      t.style[i] = e[i];
    });
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, $i);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose|hide/.test(t)) && (i || (i = new td(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, $i);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const tA = "data-te-autocomplete-dropdown-ref", eA = "data-te-autocomplete-items-list-ref", iA = "data-te-autocomplete-item-ref", sA = "data-te-autocomplete-loader-ref";
function nA(s, t) {
  const { id: e, items: i, width: n, options: o } = s, r = $("div");
  h.addClass(r, t.dropdownContainer), h.addStyle(r, { width: `${n}px` }), r.setAttribute("id", e);
  const a = $("div");
  a.setAttribute(tA, ""), h.addClass(a, t.dropdown);
  const l = $("ul"), p = o.listHeight;
  l.setAttribute(eA, ""), h.addClass(l, t.autocompleteList), h.addClass(l, t.scrollbar), h.addStyle(l, { maxHeight: `${p}px` }), l.setAttribute("role", "listbox");
  const u = ed(i, o);
  return l.innerHTML = u, a.appendChild(l), r.appendChild(a), r;
}
function ed(s = [], t, e) {
  const i = t.displayValue, n = t.itemContent;
  return `
    ${s.map((o, r) => {
    const a = typeof n == "function" ? pn(n(o), sh, null) : i(o);
    return `<li data-te-index="${r}" role="option" class="${e}" ${iA} >${a}</li>`;
  }).join("")}
  `;
}
function oA(s) {
  const t = $("div");
  t.setAttribute(sA, ""), h.addClass(t, s.autocompleteLoader), h.addClass(t, s.spinnerIcon), t.setAttribute("role", "status");
  const e = '<span class="absolute -m-px h-px w-px overflow-hidden whitespace-nowrap border-0 p-0 [clip:rect(0,0,0,0)]">Loading...</span>';
  return t.innerHTML = e, t;
}
function rA(s, t) {
  return `<li class="${t.autocompleteItem}">${s}</li>`;
}
const Po = "autocomplete", Li = "te.autocomplete", Pe = "data-te-input-state-active", Bo = "data-te-autocomplete-item-active", oc = "data-te-input-focused", rc = "data-te-autocomplete-state-open", aA = "data-te-autocomplete-custom-content-ref", lA = "[data-te-autocomplete-dropdown-ref]", Vs = "[data-te-autocomplete-items-list-ref]", ac = "[data-te-autocomplete-item-ref]", cA = "[data-te-autocomplete-loader-ref]", hA = `[${aA}]`, dA = "[data-te-input-notch-ref]", wn = `.${Li}`, uA = `close${wn}`, pA = `open${wn}`, lc = `itemSelect${wn}`, _A = `update${wn}`, fA = {
  autoSelect: !1,
  container: "body",
  customContent: "",
  debounce: 300,
  displayValue: (s) => s,
  filter: null,
  itemContent: null,
  listHeight: 190,
  loaderCloseDelay: 300,
  noResults: "No results found",
  threshold: 0
}, mA = {
  autoSelect: "boolean",
  container: "string",
  customContent: "string",
  debounce: "number",
  displayValue: "function",
  filter: "(null|function)",
  itemContent: "(null|function)",
  listHeight: "number",
  loaderCloseDelay: "number",
  noResults: "string",
  threshold: "number"
}, gA = {
  autocompleteItem: "flex flex-row items-center justify-between w-full px-4 py-[0.4375rem] truncate text-gray-700 bg-transparent select-none cursor-pointer hover:[&:not([data-te-autocomplete-option-disabled])]:bg-black/5 data-[te-autocomplete-item-active]:bg-black/5 data-[data-te-autocomplete-option-disabled]:text-gray-400 data-[data-te-autocomplete-option-disabled]:cursor-default dark:text-gray-200 dark:hover:[&:not([data-te-autocomplete-option-disabled])]:bg-white/30 dark:data-[te-autocomplete-item-active]:bg-white/30",
  autocompleteList: "list-none m-0 p-0 overflow-y-auto",
  autocompleteLoader: "absolute right-1 top-2 w-[1.4rem] h-[1.4rem] border-[0.15em]",
  dropdown: "relative outline-none min-w-[100px] m-0 scale-y-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-autocomplete-state-open]:scale-y-100 data-[te-autocomplete-state-open]:opacity-100 dark:bg-zinc-700",
  dropdownContainer: "z-[1070]",
  scrollbar: "[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded",
  spinnerIcon: "inline-block h-8 w-8 animate-spin rounded-full border-4 border-solid border-current border-r-transparent align-[-0.125em] motion-reduce:animate-[spin_1.5s_linear_infinite]"
}, bA = {
  autocompleteItem: "string",
  autocompleteList: "string",
  autocompleteLoader: "string",
  dropdown: "string",
  dropdownContainer: "string",
  scrollbar: "string",
  spinnerIcon: "string"
};
class id {
  constructor(t, e, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._getContainer(), this._input = d.findOne("input", t), this._notch = d.findOne(dA, t), this._customContent = d.findOne(
      hA,
      t
    ), this._loader = oA(this._classes), this._popper = null, this._debounceTimeoutId = null, this._loaderTimeout = null, this._activeItemIndex = -1, this._activeItem = null, this._filteredResults = null, this._lastQueryValue = null, this._canOpenOnFocus = !0, this._isOpen = !1, this._outsideClickHandler = this._handleOutsideClick.bind(this), this._inputFocusHandler = this._handleInputFocus.bind(this), this._userInputHandler = this._handleUserInput.bind(this), this._keydownHandler = this._handleKeydown.bind(this), t && A.setData(t, Li, this), this._init();
  }
  static get NAME() {
    return Po;
  }
  get filter() {
    return this._options.filter;
  }
  get dropdown() {
    return d.findOne(lA, this._dropdownContainer);
  }
  get items() {
    return d.find(ac, this._dropdownContainer);
  }
  get itemsList() {
    return d.findOne(Vs, this._dropdownContainer);
  }
  initSearch(t) {
    this._filterResults(t);
  }
  _getContainer() {
    this._container = d.findOne(this._options.container);
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...fA,
      ...e,
      ...t
    }, I(Po, t, mA), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...gA,
      ...e,
      ...t
    }, I(Po, t, bA), t;
  }
  _init() {
    this._initDropdown(), this._updateInputState(), this._setInputAriaAttributes(), this._listenToInputFocus(), this._listenToUserInput(), this._listenToKeydown();
  }
  _initDropdown() {
    this._dropdownContainerId = this._element.id ? `autocomplete-dropdown-${this._element.id}` : et("autocomplete-dropdown-");
    const t = {
      id: this._dropdownContainerId,
      items: [],
      width: this._input.offsetWidth,
      options: this._options
    };
    if (this._dropdownContainer = nA(t, this._classes), this._options.customContent !== "") {
      const e = this._options.customContent, i = pn(
        e,
        sh,
        null
      );
      this.dropdown.insertAdjacentHTML("beforeend", i);
    }
  }
  _setInputAriaAttributes() {
    this._input.setAttribute("role", "combobox"), this._input.setAttribute("aria-expanded", !1), this._input.setAttribute("aria-owns", this._dropdownContainerId), this._input.setAttribute("aria-haspopup", !0), this._input.setAttribute("autocomplete", "off");
  }
  _updateInputState() {
    var t, e;
    this._input.value !== "" || this._isOpen ? (this._input.setAttribute(Pe, ""), (t = this._notch) == null || t.setAttribute(Pe, "")) : (this._input.removeAttribute(Pe), (e = this._notch) == null || e.removeAttribute(Pe));
  }
  _listenToInputFocus() {
    c.on(this._input, "focus", this._inputFocusHandler);
  }
  _handleInputFocus(t) {
    const { value: e } = t.target, i = this._options.threshold;
    if (!this._canOpenOnFocus) {
      this._canOpenOnFocus = !0;
      return;
    }
    e.length < i || (this._lastQueryValue !== e ? this._filterResults(e) : this.open());
  }
  _listenToWindowResize() {
    c.on(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleWindowResize() {
    this._dropdownContainer && this._updateDropdownWidth();
  }
  _updateDropdownWidth() {
    const t = this._input.offsetWidth;
    h.addStyle(this._dropdownContainer, { width: `${t}px` });
  }
  _listenToUserInput() {
    c.on(this._input, "input", this._userInputHandler);
  }
  _handleUserInput(t) {
    const { value: e } = t.target, i = this._options.threshold, n = this._options.debounce;
    if (this.filter) {
      if (e.length < i) {
        this._isOpen && this.close();
        return;
      }
      this._debounceFilter(e, n);
    }
  }
  _debounceFilter(t, e) {
    this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {
      this._filterResults(t);
    }, e);
  }
  _filterResults(t) {
    this._lastQueryValue = t;
    const e = this.filter(t);
    this._isPromise(e) ? this._asyncUpdateResults(e) : this._updateResults(e);
  }
  _isPromise(t) {
    return !!t && typeof t.then == "function";
  }
  _asyncUpdateResults(t) {
    this._resetActiveItem(), this._showLoader(), t.then((e) => {
      this._updateResults(e), this._loaderTimeout = setTimeout(() => {
        this._hideLoader(), this._loaderTimeout = null;
      }, this._options.loaderCloseDelay);
    });
  }
  _resetActiveItem() {
    const t = this._activeItem;
    t && (t.removeAttribute(Bo), this._activeItem = null, this._activeItemIndex = -1);
  }
  _showLoader() {
    this._element.appendChild(this._loader);
  }
  _hideLoader() {
    d.findOne(cA, this._element) && this._element.removeChild(this._loader);
  }
  _updateResults(t) {
    this._resetActiveItem(), this._filteredResults = t, c.trigger(this._element, _A, { results: t });
    const e = d.findOne(
      Vs,
      this._dropdownContainer
    ), i = ed(
      t,
      this._options,
      this._classes.autocompleteItem
    ), n = rA(
      this._options.noResults,
      this._classes
    );
    t.length === 0 && this._options.noResults !== "" ? e.innerHTML = n : e.innerHTML = i, this._isOpen || this.open(), this._popper && this._popper.forceUpdate();
  }
  _listenToKeydown() {
    c.on(this._element, "keydown", this._keydownHandler);
  }
  _handleKeydown(t) {
    this._isOpen ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t);
  }
  _handleOpenKeydown(t) {
    const e = t.keyCode;
    if (e === ke && this._options.autoSelect && this._selectActiveItem(), e === we || e === U && t.altKey) {
      this.close(), this._input.focus();
      return;
    }
    if (e === we || e === U && t.altKey || e === ke) {
      this.close(), this._input.focus();
      return;
    }
    switch (e) {
      case z:
        this._setActiveItem(this._activeItemIndex + 1), this._scrollToItem(this._activeItem);
        break;
      case U:
        this._setActiveItem(this._activeItemIndex - 1), this._scrollToItem(this._activeItem);
        break;
      case Te:
        this._activeItemIndex > -1 ? (this._setActiveItem(0), this._scrollToItem(this._activeItem)) : this._input.setSelectionRange(0, 0);
        break;
      case Ee:
        if (this._activeItemIndex > -1)
          this._setActiveItem(this.items.length - 1), this._scrollToItem(this._activeItem);
        else {
          const n = this._input.value.length;
          this._input.setSelectionRange(n, n);
        }
        break;
      case it:
        if (t.preventDefault(), this._activeItemIndex > -1) {
          const n = this._filteredResults[this._activeItemIndex];
          this._handleSelection(n);
        }
        return;
      default:
        return;
    }
    t.preventDefault();
  }
  _setActiveItem(t) {
    const e = this.items;
    e[t] && this._updateActiveItem(e[t], t);
  }
  _updateActiveItem(t, e) {
    const i = this._activeItem;
    i && i.removeAttribute(Bo), t.setAttribute(Bo, ""), this._activeItemIndex = e, this._activeItem = t;
  }
  _scrollToItem(t) {
    if (!t)
      return;
    const e = this.itemsList, i = e.offsetHeight, n = this.items.indexOf(t), o = t.offsetHeight, r = e.scrollTop;
    if (n > -1) {
      const a = n * o, l = a + o > r + i;
      a < r ? e.scrollTop = a : l ? e.scrollTop = a - i + o : e.scrollTop = r;
    }
  }
  _handleClosedKeydown(t) {
    t.key === "Enter" && t.preventDefault();
    const e = t.keyCode;
    (e === it || e === z || e === z) && this.open();
  }
  open() {
    this._lastQueryValue === null && this._filterResults("");
    const t = c.trigger(this._element, pA);
    this._isOpen || t.defaultPrevented || (this._updateDropdownWidth(), this._listenToWindowResize(), this._popper = se(this._element, this._dropdownContainer, {
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 1]
          }
        }
      ]
    }), this._container.appendChild(this._dropdownContainer), this._listenToOutsideClick(), this._listenToItemsClick(), setTimeout(() => {
      this.dropdown.setAttribute(rc, ""), this._isOpen = !0, this._setInputActiveStyles(), this._updateInputState();
    }, 0));
  }
  _listenToOutsideClick() {
    c.on(document, "click", this._outsideClickHandler);
  }
  _handleOutsideClick(t) {
    const e = this._input === t.target, i = t.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t.target);
    !e && !i && !n && this.close();
  }
  _listenToItemsClick() {
    const t = d.findOne(
      Vs,
      this._dropdownContainer
    );
    c.on(t, "click", this._handleItemsClick.bind(this));
  }
  _handleItemsClick(t) {
    const e = d.closest(t.target, ac), i = h.getDataAttribute(e, "index"), n = this._filteredResults[i];
    this._handleSelection(n);
  }
  _selectActiveItem() {
    const t = this._filteredResults[this._activeItemIndex];
    if (!t)
      return;
    const e = this._options.displayValue(t);
    c.trigger(this._element, lc, {
      value: t
    }).defaultPrevented || setTimeout(() => {
      this._canOpenOnFocus = !1, this._updateInputValue(e), this._updateInputState();
    }, 0);
  }
  _handleSelection(t) {
    const e = this._options.displayValue(t), i = c.trigger(this._element, lc, {
      value: t
    });
    t !== void 0 && (i.defaultPrevented || setTimeout(() => {
      this._canOpenOnFocus = !1, this._updateInputValue(e), this._updateInputState(), this._input.focus(), this.close();
    }, 0));
  }
  _updateInputValue(t) {
    this._input.value = t;
  }
  _setInputActiveStyles() {
    this._input.setAttribute(oc, "");
  }
  close() {
    var e;
    const t = c.trigger(this._element, uA);
    !this._isOpen || t.defaultPrevented || (this._resetActiveItem(), this._removeDropdownEvents(), this.dropdown.removeAttribute(rc), c.on(
      this.dropdown,
      "transitionend",
      this._handleDropdownTransitionEnd.bind(this)
    ), this._input.removeAttribute(oc), this._input.value || (this._input.removeAttribute(Pe), (e = this._notch) == null || e.removeAttribute(Pe)));
  }
  _removeDropdownEvents() {
    const t = d.findOne(
      Vs,
      this._dropdownContainer
    );
    c.off(t, "click"), c.off(document, "click", this._outsideClickHandler), c.off(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleDropdownTransitionEnd(t) {
    this._isOpen && t && t.propertyName === "opacity" && (this._popper.destroy(), this._dropdownContainer && this._container.removeChild(this._dropdownContainer), this._isOpen = !1, c.off(this.dropdown, "transitionend"), this._canOpenOnFocus = !0);
  }
  dispose() {
    this._isOpen && this.close(), this._removeInputAndElementEvents(), this._dropdownContainer.remove(), A.removeData(this._element, Li);
  }
  _removeInputAndElementEvents() {
    c.off(this._input, "focus", this._inputFocusHandler), c.off(this._input, "input", this._userInputHandler), c.off(this._element, "keydown", this._keydownHandler);
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, Li);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new id(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, Li);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const vA = (s, t) => `<div class="${s.connectContainer}" ${t}>
  <div class="${s.connect}"></div>
  </div>`, TA = (s, t) => `<div class="${s.hand}" ${t}>
    <span></span>
  </div>`, EA = (s, t) => `
    <span class="${s.tooltip}" ${t}>
      <span class="${s.tooltipValue}"></span>
    </span>
    `, pe = (s) => s.type === "touchmove" ? s.touches[0].clientX : s.clientX, an = "multiRangeSlider", ln = `te.${an}`, CA = `.${ln}`, cc = `valueChanged${CA}`, _e = "data-te-active", hc = "data-te-multi-range-slider-hand-ref", dc = "data-te-multi-range-slider-connect-ref", uc = "data-te-multi-range-slider-tooltip-ref", AA = {
  max: "number",
  min: "number",
  numberOfRanges: "number",
  startValues: "(array|string)",
  step: "(string|null|number)",
  tooltip: "boolean"
}, yA = {
  max: 100,
  min: 0,
  numberOfRanges: 2,
  startValues: [0, 100],
  step: null,
  tooltip: !1
}, wA = {
  connect: "z-10 h-full w-full bg-[#eee] will-change-transform dark:bg-[#4f4f4f]",
  connectContainer: "relative border-[1px] border-[#eee] z-0 h-full w-full overflow-hidden dark:border-[#4f4f4f]",
  container: "apperance-none relative m-auto w-full cursor-pointer h-1 border-0 bg-transparent p-0 focus:outline-none dark:border-[#4f4f4f]",
  hand: "apperance-none absolute top-[50%] border-0 -mt-1 h-4 w-4 cursor-pointer rounded-[50%] border-0 bg-primary transition-colors ease-in-out will-change-transform active:bg-[#c4d4ef] active:z-60",
  tooltip: "absolute -top-[18px] origin-[50%_50%] -translate-x-[6px] -rotate-45 scale-0 rounded-bl-none rounded-br-2xl rounded-tl-2xl rounded-tr-2xl bg-primary text-white transition-all duration-[200ms] data-[te-active]:-top-[38px] data-[te-active]:scale-100",
  tooltipValue: "block h-[30px] w-[30px] -translate-x-[6px] translate-y-[6px] rotate-45 text-center text-[10px]"
}, kA = {
  container: "string",
  connectContainer: "string",
  connect: "string",
  hand: "string",
  tooltip: "string",
  tooltipValue: "string"
};
class sd extends ft {
  constructor(t, e, i) {
    super(t), this._options = this._getConfig(e), this._mousemove = !1, this._classes = this._getClasses(i), this._maxTranslation = null, this._minTranslation = null, this._currentStepValue = null, this._canChangeStep = !1, this.init();
  }
  // Getters
  static get NAME() {
    return an;
  }
  get hands() {
    return d.find(`[${hc}]`, this._element);
  }
  get connect() {
    return d.findOne(`[${dc}]`, this._element);
  }
  get leftConnectRect() {
    return this.connect.getBoundingClientRect().left;
  }
  get handActive() {
    return d.findOne(`[${_e}]`);
  }
  get activeTooltipValue() {
    return d.find(`[${uc}]`).filter(
      (n) => n.hasAttribute(_e)
    )[0].children[0];
  }
  // Public
  init() {
    this._setContainerClasses(), this._setRangeConnectsElement(), this._setRangeHandleElements(), this._setMaxAndMinTranslation(), this._setTransofrmationOnStart(), this._handleClickEventOnHand(), this._handleEndMoveEventDocument(), this._handleClickOnRange(), this._setTooltipToHand();
  }
  dispose() {
    A.removeData(this._element, ln), this._options = null, this._mousemove = null, this._maxTranslation = null, this._minTranslation = null, this._currentStepValue = null, this._canChangeStep = null, this.hands.forEach((t) => {
      K.off(t, "mousedown touchstart"), K.off(t, "mouseup touchend");
    }), K.off(document, "mousemove touchmove"), K.off(document, "mouseup touchend"), K.off(this.connect, "mousedown touchstart");
  }
  // Private
  _setMaxAndMinTranslation() {
    this._maxTranslation = this.connect.offsetWidth - this.hands[0].offsetWidth / 2, this._minTranslation = this.connect.offsetLeft - this.hands[0].offsetWidth / 2;
  }
  _setTransofrmationOnStart() {
    const { max: t, min: e } = this._options;
    let { startValues: i } = this._options;
    typeof i == "string" && (i = JSON.parse(i.replace(/'/g, '"'))), i.length === 0 ? this.hands.forEach((n) => {
      h.setDataAttribute(
        n,
        "translation",
        Math.round(this._minTranslation)
      ), h.addStyle(n, {
        transform: `translate(${this._minTranslation}px,-25%)`
      });
    }) : this.hands.forEach((n, o) => {
      if (i[o] > t || i[o] < e)
        return;
      if (i[o] === void 0) {
        h.setDataAttribute(
          n,
          "translation",
          Math.round(this._maxTranslation)
        ), h.addStyle(n, {
          transform: `translate(${this._maxTranslation}px,-25%)`,
          zIndex: this.hands.length - o
        });
        return;
      }
      const a = (i[o] - e) / (t - e) * this.connect.offsetWidth - n.offsetWidth / 2;
      h.setDataAttribute(
        n,
        "translation",
        Math.round(a)
      ), h.addStyle(n, {
        transform: `translate(${a}px,-25%)`,
        zIndex: this.hands.length - o
      });
    });
  }
  _handleOutOfMaxRangeValue(t, e) {
    this._updateHand(t, this._maxTranslation), this._options.tooltip && (this.activeTooltipValue.innerText = e);
  }
  _handleOutOfMinRangeValue(t, e) {
    this._updateHand(t, this._minTranslation), this._options.tooltip && (this.activeTooltipValue.innerText = e);
  }
  _handleNormalMove(t, e, i) {
    this._updateHand(t, e), this._options.tooltip && (this.activeTooltipValue.innerText = Math.round(i));
  }
  _handleClickEventOnHand() {
    const { max: t, min: e, step: i } = this._options;
    this.hands.forEach((n) => {
      K.on(n, "mousedown touchstart", (o) => {
        if (this._mousemove = !0, n.setAttribute(_e, ""), this._options.tooltip && n.children[1].setAttribute(_e, ""), this._handleMoveEvent(n), this._handleEndMoveEvent(n, o), !this._canChangeStep && i !== null)
          return;
        const r = pe(o) - this.leftConnectRect - n.offsetWidth / 2, a = (pe(o) - this.leftConnectRect) / (this.connect.offsetWidth / (t - e)) % (t - e);
        r >= this._maxTranslation ? this._handleOutOfMaxRangeValue(n, t) : r <= this._minTranslation ? this._handleOutOfMinRangeValue(n, e) : this._handleNormalMove(n, r, a);
      });
    });
  }
  _setContainerClasses() {
    h.addClass(this._element, this._classes.container);
  }
  _setRangeConnectsElement() {
    this._element.insertAdjacentHTML(
      "afterbegin",
      vA(
        {
          connectContainer: this._classes.connectContainer,
          connect: this._classes.connect
        },
        dc
      )
    );
  }
  _setRangeHandleElements() {
    for (let t = 0; t < this._options.numberOfRanges; t++)
      this._element.insertAdjacentHTML(
        "beforeend",
        TA({ hand: this._classes.hand }, hc)
      );
    this.hands.forEach((t, e) => {
      t.setAttribute("aria-orientation", "horizontal"), t.setAttribute("role", "slider"), h.setDataAttribute(t, "handle", e);
    });
  }
  _setTooltipToHand() {
    this._options.tooltip && this.hands.forEach((t) => t.insertAdjacentHTML(
      "beforeend",
      EA(
        {
          tooltip: this._classes.tooltip,
          tooltipValue: this._classes.tooltipValue
        },
        uc
      )
    ));
  }
  _handleMoveEvent(t) {
    const { tooltip: e, step: i } = this._options;
    K.on(document, "mousemove touchmove", (n) => {
      n.type === "mousemove" && n.preventDefault();
      const { max: o, min: r, numberOfRanges: a } = this._options;
      if (t.hasAttribute(_e)) {
        const l = (pe(n) - this.leftConnectRect) / this.connect.offsetWidth * o;
        let p = (pe(n) - this.leftConnectRect) / (this.connect.offsetWidth / (o - r)) % (o - r) + r;
        if ((this._currentStepValue === Math.round(p) || Math.round(p) % i !== 0) && i !== null) {
          this._canChangeStep = !1;
          return;
        }
        this._canChangeStep = !0;
        let u = pe(n) - this.leftConnectRect - t.offsetWidth / 2;
        const _ = h.getDataAttribute(
          this.handActive,
          "handle"
        ), f = h.getDataAttribute(
          this.handActive,
          "translation"
        );
        if (p < r)
          u = r - t.offsetWidth / 2, p = r;
        else if (l >= o)
          return;
        const g = this.hands.map(
          (m) => h.getDataAttribute(m, "translation")
        );
        if (a < 2)
          Math.round(p) % i === 0 && i !== null ? (this._currentStepValue = Math.round(p), h.addStyle(t, {
            transform: `translate(${u}px,-25%)`
          }), e && (this.activeTooltipValue.innerText = Math.round(p))) : i === null && (h.addStyle(t, {
            transform: `translate(${u}px,-25%)`
          }), e && (this.activeTooltipValue.innerText = Math.round(p))), h.setDataAttribute(t, "translation", u);
        else {
          const m = _ > 0 && _ < a - 1;
          let b = u, v = !1;
          const T = g[_ + 1], y = g[_ - 1];
          _ === 0 && f >= T ? (b = T, v = u <= b) : _ === a - 1 && f <= y ? (b = y, v = u >= b) : m && (f >= T || f <= y) && (b = f >= T ? T : y, v = b === T ? u <= b : u >= b), Math.round(p) % i === 0 && i !== null ? (this._currentStepValue = Math.round(p), h.addStyle(t, {
            transform: `translate(${b}px,-25%)`
          }), e && b === u && this.activeTooltipValue !== null && (this.activeTooltipValue.innerText = Math.round(p))) : i === null && (h.addStyle(t, {
            transform: `translate(${b}px,-25%)`
          }), e && b === u && this.activeTooltipValue !== null && (this.activeTooltipValue.innerText = Math.round(p))), h.setDataAttribute(
            t,
            "translation",
            v ? u : b
          );
        }
        this._canChangeStep && this._handleEventChangeValuesOnRange();
      }
    });
  }
  _handleEventChangeValuesOnRange() {
    const { max: t, min: e, numberOfRanges: i } = this._options, n = (r) => {
      const a = r.getBoundingClientRect().left - this.leftConnectRect + r.offsetWidth / 2;
      let l = a / (this.connect.offsetWidth / (t - e)) % (t - e);
      return a === this.connect.offsetWidth ? l = t : l += e, h.setDataAttribute(r, "value", Math.round(l * 10) / 10), { value: l };
    };
    if (i < 2) {
      const { value: r } = n(this.hands[0]);
      c.trigger(this._element, cc, {
        values: { value: r + e, rounded: Math.round(r + e) }
      });
      return;
    }
    const o = this.hands.map((r) => n(r));
    c.trigger(this._element, cc, {
      values: {
        value: o.map(({ value: r }) => r + e),
        rounded: o.map(({ value: r }) => Math.round(r + e))
      }
    });
  }
  _resetHandState(t, e) {
    c.off(t, e), t.removeAttribute(_e), this._options.tooltip && t.children[1].removeAttribute(_e);
  }
  _handleEndMoveEventDocument() {
    K.on(document, "mouseup touchend", () => {
      this._mousemove && (this.hands.forEach((t) => {
        this._resetHandState(t, "mousemove");
      }), K.off(document, "mousemove touchmove"), this._mousemove = !1);
    });
  }
  _handleEndMoveEvent(t) {
    K.on(t, "mouseup touchend", () => {
      this._resetHandState(t, "mousemove"), K.off(document, "mousemove touchmove"), this._mousemove = !1;
    });
  }
  _handleClickOnRange() {
    this._options.step === null && K.on(this.connect, "mousedown touchstart", (t) => {
      const e = [];
      let i = 0;
      if (this.hands.forEach((n) => {
        this._mousemove = !0;
        const o = pe(t), r = n.offsetWidth, a = h.getDataAttribute(
          n,
          "translation"
        ), l = o - this.leftConnectRect - r / 2;
        this._options.numberOfRanges < 2 ? this._updateHand(n, l) : (e.push(Math.abs(l - a)), e.forEach((p, u) => {
          p < e[i] && (i = u);
        }));
      }), this._options.numberOfRanges >= 2) {
        const n = pe(t) - this.leftConnectRect - this.hands[i].offsetWidth / 2;
        this._updateAdjacentHands(i, n);
      }
      this._handleEventChangeValuesOnRange();
    });
  }
  _updateHand(t, e) {
    h.addStyle(t, {
      transform: `translate(${e}px,-25%)`
    }), h.setDataAttribute(t, "translation", e);
  }
  _updateAdjacentHands(t, e) {
    const i = this.hands[t + 1], n = this.hands[t - 1], o = i ? h.getDataAttribute(i, "translation") : void 0, r = n ? h.getDataAttribute(n, "translation") : void 0;
    i && e > o ? this._updateHand(i, e) : n && e < r ? this._updateHand(n, e) : this._updateHand(this.hands[t], e);
  }
  _getConfig(t) {
    const e = {
      ...yA,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(an, e, AA), e;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...wA,
      ...e,
      ...t
    }, I(an, t, kA), t;
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, ln);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose|hide/.test(t)) && (i || (i = new sd(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, ln);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const xA = (s) => {
  gc(() => {
    const t = mc();
    if (t) {
      const e = s.NAME, i = t.fn[e];
      t.fn[e] = s.jQueryInterface, t.fn[e].Constructor = s, t.fn[e].noConflict = () => (t.fn[e] = i, s.jQueryInterface);
    }
  });
}, OA = (s, t) => {
  c.on(
    document,
    `click.te.${s.NAME}`,
    t,
    function(e) {
      e.preventDefault(), s.getOrCreateInstance(this).toggle();
    }
  );
}, SA = (s, t) => {
  c.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), be(this))
        return;
      s.getOrCreateInstance(this).show();
    }
  );
}, IA = (s, t) => {
  c.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      const i = te(this);
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), be(this))
        return;
      c.one(i, s.EVENT_HIDDEN, () => {
        Mt(this) && this.focus();
      });
      const n = d.findOne(s.OPEN_SELECTOR);
      n && n !== i && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    }
  );
}, DA = (s, t) => {
  c.on(
    document,
    `click.te.${s.NAME}`,
    t,
    (e) => {
      e.preventDefault();
      const i = e.target.closest(t);
      s.getOrCreateInstance(i).toggle();
    }
  );
}, $A = (s, t) => {
  c.on(
    document,
    `click.te.${s.NAME}`,
    t,
    function(e) {
      const i = te(this);
      ["A", "AREA"].includes(this.tagName) && e.preventDefault(), c.one(i, s.EVENT_SHOW, (r) => {
        r.defaultPrevented || c.one(i, s.EVENT_HIDDEN, () => {
          Mt(this) && this.focus();
        });
      });
      const n = d.findOne(
        `[${s.OPEN_SELECTOR}="true"]`
      );
      n && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    }
  );
}, LA = (s, t) => {
  c.one(
    document,
    "mousedown",
    t,
    s.autoInitial(new s())
  );
}, NA = (s, t) => {
  c.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      (e.target.tagName === "A" || e.delegateTarget && e.delegateTarget.tagName === "A") && e.preventDefault();
      const i = lr(this);
      d.find(i).forEach((o) => {
        s.getOrCreateInstance(o, { toggle: !1 }).toggle();
      });
    }
  );
}, MA = (s, t) => {
  [].slice.call(
    document.querySelectorAll(t)
  ).map(function(i) {
    return new s(i);
  });
}, RA = (s, t) => {
  [].slice.call(
    document.querySelectorAll(t)
  ).map(function(i) {
    return new s(i);
  });
}, PA = (s, t) => {
  d.find(t).forEach((e) => {
    new s(e);
  }), c.on(
    document,
    `click.te.${s.NAME}.data-api`,
    `${t} img:not([data-te-lightbox-disabled])`,
    s.toggle()
  );
}, BA = (s, t) => {
  const e = (o) => o[0] === "{" && o[o.length - 1] === "}" || o[0] === "[" && o[o.length - 1] === "]", i = (o) => typeof o != "string" ? o : e(o) ? JSON.parse(o.replace(/'/g, '"')) : o, n = (o) => {
    const r = {};
    return Object.keys(o).forEach((a) => {
      if (a.match(/dataset.*/)) {
        const l = a.slice(7, 8).toLowerCase().concat(a.slice(8));
        r[l] = i(o[a]);
      }
    }), r;
  };
  d.find(t).forEach((o) => {
    if (h.getDataAttribute(o, "chart") !== "bubble" && h.getDataAttribute(o, "chart") !== "scatter") {
      const r = h.getDataAttributes(o), a = {
        data: {
          datasets: [n(r)]
        }
      };
      return r.chart && (a.type = r.chart), r.labels && (a.data.labels = JSON.parse(r.labels.replace(/'/g, '"'))), new s(o, {
        ...a,
        ...wi[a.type]
      });
    }
    return null;
  });
};
class HA {
  constructor() {
    this.inits = [];
  }
  get initialized() {
    return this.inits;
  }
  isInited(t) {
    return this.inits.includes(t);
  }
  add(t) {
    this.isInited(t) || this.inits.push(t);
  }
}
const ar = new HA(), Ni = {
  alert: {
    name: "Alert",
    selector: "[data-te-alert-init]",
    isToggler: !1
  },
  animation: {
    name: "Animate",
    selector: "[data-te-animation-init]",
    isToggler: !1
  },
  carousel: {
    name: "Carousel",
    selector: "[data-te-carousel-init]",
    isToggler: !1
  },
  chips: {
    name: "ChipsInput",
    selector: "[data-te-chips-input-init]",
    isToggler: !1
  },
  chip: {
    name: "Chip",
    selector: "[data-te-chip-init]",
    isToggler: !1,
    onInit: "init"
  },
  datepicker: {
    name: "Datepicker",
    selector: "[data-te-datepicker-init]",
    isToggler: !1
  },
  datetimepicker: {
    name: "Datetimepicker",
    selector: "[data-te-date-timepicker-init]",
    isToggler: !1
  },
  input: {
    name: "Input",
    selector: "[data-te-input-wrapper-init]",
    isToggler: !1
  },
  perfectScrollbar: {
    name: "PerfectScrollbar",
    selector: "[data-te-perfect-scrollbar-init]",
    isToggler: !1
  },
  rating: {
    name: "Rating",
    selector: "[data-te-rating-init]",
    isToggler: !1
  },
  scrollspy: {
    name: "ScrollSpy",
    selector: "[data-te-spy='scroll']",
    isToggler: !1
  },
  select: {
    name: "Select",
    selector: "[data-te-select-init]",
    isToggler: !1
  },
  sidenav: {
    name: "Sidenav",
    selector: "[data-te-sidenav-init]",
    isToggler: !1
  },
  stepper: {
    name: "Stepper",
    selector: "[data-te-stepper-init]",
    isToggler: !1
  },
  timepicker: {
    name: "Timepicker",
    selector: "[data-te-timepicker-init]",
    isToggler: !1
  },
  toast: {
    name: "Toast",
    selector: "[data-te-toast-init]",
    isToggler: !1
  },
  datatable: {
    name: "Datatable",
    selector: "[data-te-datatable-init]"
  },
  popconfirm: {
    name: "Popconfirm",
    selector: "[data-te-toggle='popconfirm']"
  },
  validation: {
    name: "Validation",
    selector: "[data-te-validation-init]"
  },
  smoothScroll: {
    name: "SmoothScroll",
    selector: "a[data-te-smooth-scroll-init]"
  },
  lazyLoad: {
    name: "LazyLoad",
    selector: "[data-te-lazy-load-init]"
  },
  clipboard: {
    name: "Clipboard",
    selector: "[data-te-clipboard-init]"
  },
  infiniteScroll: {
    name: "InfiniteScroll",
    selector: "[data-te-infinite-scroll-init]"
  },
  loadingManagement: {
    name: "LoadingManagement",
    selector: "[data-te-loading-management-init]"
  },
  sticky: {
    name: "Sticky",
    selector: "[data-te-sticky-init]"
  },
  multiRangeSlider: {
    name: "MultiRangeSlider",
    selector: "[data-te-multi-range-slider-init]"
  },
  // advancedInits
  chart: {
    name: "Chart",
    selector: "[data-te-chart]",
    isToggler: !1,
    advanced: BA
  },
  // togglers
  button: {
    name: "Button",
    selector: "[data-te-toggle='button']",
    isToggler: !0,
    callback: DA
  },
  collapse: {
    name: "Collapse",
    selector: "[data-te-collapse-init]",
    isToggler: !0,
    callback: NA
  },
  dropdown: {
    name: "Dropdown",
    selector: "[data-te-dropdown-toggle-ref]",
    isToggler: !0,
    callback: OA
  },
  modal: {
    name: "Modal",
    selector: "[data-te-toggle='modal']",
    isToggler: !0,
    callback: $A
  },
  ripple: {
    name: "Ripple",
    selector: "[data-te-ripple-init]",
    isToggler: !0,
    callback: LA
  },
  offcanvas: {
    name: "Offcanvas",
    selector: "[data-te-offcanvas-toggle]",
    isToggler: !0,
    callback: IA
  },
  tab: {
    name: "Tab",
    selector: "[data-te-toggle='tab'], [data-te-toggle='pill'], [data-te-toggle='list']",
    isToggler: !0,
    callback: SA
  },
  tooltip: {
    name: "Tooltip",
    selector: "[data-te-toggle='tooltip']",
    isToggler: !1,
    callback: MA
  },
  popover: {
    name: "Popover",
    selector: "[data-te-toggle='popover']",
    isToggler: !0,
    callback: RA
  },
  lightbox: {
    name: "Lightbox",
    selector: "[data-te-lightbox-init]",
    isToggler: !0,
    callback: PA
  },
  touch: {
    name: "Touch",
    selector: "[data-te-touch-init]"
  }
}, VA = (s) => Ni[s.NAME] || null, WA = (s, t) => {
  if (!s || !t.allowReinits && ar.isInited(s.NAME))
    return;
  ar.add(s.NAME);
  const e = VA(s), i = (e == null ? void 0 : e.isToggler) || !1;
  if (xA(s), e != null && e.advanced) {
    e == null || e.advanced(s, e == null ? void 0 : e.selector);
    return;
  }
  if (i) {
    e == null || e.callback(s, e == null ? void 0 : e.selector);
    return;
  }
  d.find(e == null ? void 0 : e.selector).forEach((n) => {
    let o = s.getInstance(n);
    o || (o = new s(n), e != null && e.onInit && o[e.onInit]());
  });
}, FA = (s, t) => {
  s.forEach((e) => WA(e, t));
}, YA = {
  allowReinits: !1,
  checkOtherImports: !1
}, qA = (s, t = {}) => {
  t = { ...YA, ...t };
  const e = Object.keys(Ni).map((i) => {
    if (!!document.querySelector(Ni[i].selector)) {
      const o = s[Ni[i].name];
      return !o && !ar.isInited(i) && t.checkOtherImports && console.warn(
        `Please import ${Ni[i].name} from "tw-elements" package and add it to a object parameter inside "initTE" function`
      ), o;
    }
  });
  FA(e, t);
};

//# sourceMappingURL=tw-elements.es.min.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfc3ltZm9ueV9zdGltdWx1cy1icmlkZ2VfZGlzdF9pbmRleF9qcy1ub2RlX21vZHVsZXNfY29yZS1qc19tb2R1bGVzX2VzX2FyLTgyOTFiOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDJDQUEyQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdDQUF3QztBQUM1RTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1CQUFtQjtBQUNqRTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCLEdBQUcsZUFBZTtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGNBQWMsS0FBSyxNQUFNO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0JBQWdCLEdBQUcsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVyxxQkFBcUIsY0FBYyxJQUFJLFdBQVcsR0FBRyxXQUFXLFNBQVMscUJBQXFCLElBQUksV0FBVztBQUN2Syx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsV0FBVztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNELFVBQVUsWUFBWTtBQUN0QjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEVBQUUsSUFBSSxLQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVksS0FBSyxpQkFBaUI7QUFDakQsNkJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJCQUEyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUE4QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJDQUEyQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsc0NBQXNDO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5RUFBeUUscUNBQXFDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0Q0FBNEM7QUFDL0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEJBQTBCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssMEdBQTBHLGNBQWM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU8sV0FBVyxRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsd0NBQXdDO0FBQzNDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHdNQUF3TTtBQUMzTTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBNEQ7QUFDdkU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0QsR0FBRztBQUNwRCxLQUFLLEdBQUcsR0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0MsR0FBRztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsRUFBRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsRUFBRSwrQkFBK0IsRUFBRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0QsR0FBRyxpQ0FBaUMsR0FBRyxFQUFFLEdBQUc7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0ZBQW9GLEdBQUcsZ0JBQWdCLEdBQUcsZUFBZSxHQUFHLGlCQUFpQixHQUFHLDBCQUEwQixHQUFHO0FBQzlLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZUQUE2VCxHQUFHO0FBQ2hVO0FBQ0Esb0ZBQW9GLGtCQUFrQjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEgsR0FBRztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw4Q0FBOEMsR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUIsR0FBRztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9EQUFvRCxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQyxlQUFlLEdBQUcsZUFBZSxHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQixHQUFHLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLGVBQWUsR0FBRyxFQUFFLEdBQUcsZ0JBQWdCLEdBQUcsRUFBRSxHQUFHLDhWQUE4VixHQUFHLEVBQUUsR0FBRyxXQUFXLElBQUk7QUFDMXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSCxHQUFHO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLEVBQUUsb0ZBQW9GLEVBQUU7QUFDeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrT0FBK087QUFDL087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsR0FBRztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsQ0FBQztBQUNELGVBQWUsR0FBRztBQUNsQixtQkFBbUIsR0FBRztBQUN0QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEIsdUJBQXVCLEdBQUc7QUFDMUIsaUJBQWlCLEdBQUc7QUFDcEIscUJBQXFCLEdBQUc7QUFDeEIsdUJBQXVCLEdBQUc7QUFDMUIsMkJBQTJCLEdBQUc7QUFDOUIsMkJBQTJCLEdBQUc7QUFDOUIsQ0FBQyxtR0FBbUcsR0FBRztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QixHQUFHLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEdBQUcsSUFBSSxxQkFBcUI7QUFDdEM7QUFDQSxVQUFVLEdBQUcsSUFBSSxxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLHNDQUFzQyx3QkFBd0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLLElBQUksTUFBTSxFQUFFLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUJBQXFCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhEQUE4RDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBRTtB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QkFBcUIsRUFBRSx3QkFBd0IsRUFBRSxzQkFBc0IsRUFBRSw4QkFBOEIsRUFBRSxzQkFBc0IsRUFBRSx3QkFBd0IsRUFBRSxrQkFBa0IsRUFBRTtBQUN6eEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKLHdDQUF3QyxFQUFFLHdDQUF3QztBQUN6TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILGtCQUFrQixtQ0FBbUMsaUJBQWlCO0FBQ3hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVUsRUFBRSxLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCLElBQUksSUFBSSxpQkFBaUIsZ0NBQWdDLE1BQU0sZ0NBQWdDO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxTQUFTO0FBQ3hFO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxRQUFRLHdOQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpWEFBMkM7QUFDNUQ7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0lBQW9JO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsU0FBUztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsU0FBUyxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQ0FBZ0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QyxHQUFHLGdDQUFnQyxHQUFHLGdDQUFnQyxHQUFHLHdCQUF3QixHQUFHLDJCQUEyQixHQUFHLHFCQUFxQixHQUFHLHVDQUF1QyxHQUFHLGlCQUFpQixHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHO0FBQ3RqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHNCQUFzQiw4Q0FBOEMsMEJBQTBCLEVBQUUsc0JBQXNCLEVBQUUseUJBQXlCLE9BQU8sT0FBTyxJQUFJLDhCQUE4QixFQUFFLHNCQUFzQixFQUFFLHlCQUF5QjtBQUNyUztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixxSkFBcUosd0JBQXdCO0FBQzdLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsRUFBRTtBQUN0RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUNBQXlDLEVBQUU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3Riw0QkFBNEIsZ0NBQWdDLDRCQUE0QjtBQUNoTCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixFQUFFO0FBQy9CLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0Esd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQixFQUFFLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQixFQUFFLG9CQUFvQjtBQUM5RDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSw4R0FBOEcsR0FBRztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsb0JBQW9CLEdBQUc7QUFDaEk7QUFDQTtBQUNBLG9OQUFvTjtBQUNwTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSx3REFBd0QsR0FBRyxpQkFBaUIsR0FBRyxrQkFBa0IsR0FBRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd09BQXdPLGlCQUFpQjtBQUN6UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxHQUFHO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxHQUFHO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsb0JBQW9CO0FBQ3hFO0FBQ0E7QUFDQSxrREFBa0QsbUJBQW1CO0FBQ3JFLGtCQUFrQixzQkFBc0I7QUFDeEMsUUFBUSx1REFBdUQsbUJBQW1CLElBQUkscUNBQXFDO0FBQzNILHFCQUFxQiwwQkFBMEIsSUFBSSxzQkFBc0I7QUFDekU7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hELFFBQVEsK0lBQStJLDBCQUEwQjtBQUNqTCxpQkFBaUIsd0JBQXdCLElBQUkseUJBQXlCO0FBQ3RFO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyxlQUFlLHlCQUF5QixJQUFJLG1EQUFtRDtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsc0JBQXNCO0FBQzFFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxzQkFBc0I7QUFDM0U7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEdBQUcsa0NBQWtDLEdBQUcsRUFBRSxHQUFHLDJDQUEyQyxJQUFJO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixZQUFZO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7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QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjtBQUNsQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUEwQ0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaG90d2lyZWQvc3RpbXVsdXMvZGlzdC9zdGltdWx1cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHN5bWZvbnkvc3RpbXVsdXMtYnJpZGdlL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWZvci1lYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc2V0LWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc2xpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RhdGUtdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4tYWNjZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWlucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2VzLW5vdC1leGNlZWQtc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20tdG9rZW4tbGlzdC1wcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Vudmlyb25tZW50LXVzZXItYWdlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Vudmlyb25tZW50LXY4LXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Vudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lcnJvci1zdGFjay1jbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXJyb3Itc3RhY2staW5zdGFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXJyb3Itc3RhY2staW5zdGFsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Vycm9yLXRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYXBwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1hY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLWNsYXVzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci1kaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWpzb24tcmVwbGFjZXItZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC10aGlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5zdGFsbC1lcnJvci1jYXVzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZGF0YS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWludGVncmFsLW51bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcG9zc2libGUtcHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItY2xvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNyZWF0ZS1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1oZWxwZXItd2l0aG91dC1jbG9zaW5nLW9uLWVhcmx5LWVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMtY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWFrZS1idWlsdC1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWF0aC10cnVuYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbm9ybWFsaXplLXN0cmluZy1hcmd1bWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbm90LWEtcmVnZXhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9udW1iZXItcGFyc2UtaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtdG8tYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29yZGluYXJ5LXRvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3duLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Byb3h5LWFjY2Vzc29yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1mbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWdldC1mbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLXN0aWNreS1oZWxwZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtdW5zdXBwb3J0ZWQtZG90LWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLXVuc3VwcG9ydGVkLW5jZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zYWZlLWdldC1idWlsdC1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2FtZS12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2NoZWR1bGVycy1maXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLXRyaW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N5bWJvbC1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N5bWJvbC1kZWZpbmUtdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zeW1ib2wtcmVnaXN0cnktZGV0ZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90aGlzLW51bWJlci12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90cnktdG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VybC1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1Zy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdmFsaWRhdGUtYXJndW1lbnRzLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2Vhay1tYXAtYmFzaWMtZGV0ZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93aGl0ZXNwYWNlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd3JhcC1lcnJvci1jb25zdHJ1Y3Rvci13aXRoLWNhdXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZXZlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnB1c2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmRhdGUudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmRhdGUudG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZGF0ZS50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5lcnJvci5jYXVzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmVycm9yLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLmJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3IuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5pdGVyYXRvci5ldmVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLml0ZXJhdG9yLmZvci1lYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuanNvbi5zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuaXMtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmVudHJpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktc3ltYm9scy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucGFyc2UtaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QudG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmZyb20tY29kZS1wb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3Vic3RyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmZvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5rZXktZm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLnRvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5pdGVyYXRvci5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5pdGVyYXRvci5ldmVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5pdGVyYXRvci5mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnNldC1pbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5zZXQtdGltZW91dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudXJsLXNlYXJjaC1wYXJhbXMuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudXJsLXNlYXJjaC1wYXJhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3LWVsZW1lbnRzL2Rpc3QvanMvdHctZWxlbWVudHMuZXMubWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5TdGltdWx1cyAzLjIuMVxuQ29weXJpZ2h0IMKpIDIwMjMgQmFzZWNhbXAsIExMQ1xuICovXG5jbGFzcyBFdmVudExpc3RlbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ldmVudFRhcmdldCA9IGV2ZW50VGFyZ2V0O1xuICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcbiAgICAgICAgdGhpcy5ldmVudE9wdGlvbnMgPSBldmVudE9wdGlvbnM7XG4gICAgICAgIHRoaXMudW5vcmRlcmVkQmluZGluZ3MgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcywgdGhpcy5ldmVudE9wdGlvbnMpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudE5hbWUsIHRoaXMsIHRoaXMuZXZlbnRPcHRpb25zKTtcbiAgICB9XG4gICAgYmluZGluZ0Nvbm5lY3RlZChiaW5kaW5nKSB7XG4gICAgICAgIHRoaXMudW5vcmRlcmVkQmluZGluZ3MuYWRkKGJpbmRpbmcpO1xuICAgIH1cbiAgICBiaW5kaW5nRGlzY29ubmVjdGVkKGJpbmRpbmcpIHtcbiAgICAgICAgdGhpcy51bm9yZGVyZWRCaW5kaW5ncy5kZWxldGUoYmluZGluZyk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGV4dGVuZGVkRXZlbnQgPSBleHRlbmRFdmVudChldmVudCk7XG4gICAgICAgIGZvciAoY29uc3QgYmluZGluZyBvZiB0aGlzLmJpbmRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoZXh0ZW5kZWRFdmVudC5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJpbmRpbmcuaGFuZGxlRXZlbnQoZXh0ZW5kZWRFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzQmluZGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVub3JkZXJlZEJpbmRpbmdzLnNpemUgPiAwO1xuICAgIH1cbiAgICBnZXQgYmluZGluZ3MoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudW5vcmRlcmVkQmluZGluZ3MpLnNvcnQoKGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0SW5kZXggPSBsZWZ0LmluZGV4LCByaWdodEluZGV4ID0gcmlnaHQuaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gbGVmdEluZGV4IDwgcmlnaHRJbmRleCA/IC0xIDogbGVmdEluZGV4ID4gcmlnaHRJbmRleCA/IDEgOiAwO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBleHRlbmRFdmVudChldmVudCkge1xuICAgIGlmIChcImltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFwiIGluIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIH0gPSBldmVudDtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZXZlbnQsIHtcbiAgICAgICAgICAgIGltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogZmFsc2UsXG4gICAgICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBEaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhcHBsaWNhdGlvbikge1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uID0gYXBwbGljYXRpb247XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lck1hcHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmZvckVhY2goKGV2ZW50TGlzdGVuZXIpID0+IGV2ZW50TGlzdGVuZXIuY29ubmVjdCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaCgoZXZlbnRMaXN0ZW5lcikgPT4gZXZlbnRMaXN0ZW5lci5kaXNjb25uZWN0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBldmVudExpc3RlbmVycygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5ldmVudExpc3RlbmVyTWFwcy52YWx1ZXMoKSkucmVkdWNlKChsaXN0ZW5lcnMsIG1hcCkgPT4gbGlzdGVuZXJzLmNvbmNhdChBcnJheS5mcm9tKG1hcC52YWx1ZXMoKSkpLCBbXSk7XG4gICAgfVxuICAgIGJpbmRpbmdDb25uZWN0ZWQoYmluZGluZykge1xuICAgICAgICB0aGlzLmZldGNoRXZlbnRMaXN0ZW5lckZvckJpbmRpbmcoYmluZGluZykuYmluZGluZ0Nvbm5lY3RlZChiaW5kaW5nKTtcbiAgICB9XG4gICAgYmluZGluZ0Rpc2Nvbm5lY3RlZChiaW5kaW5nLCBjbGVhckV2ZW50TGlzdGVuZXJzID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5mZXRjaEV2ZW50TGlzdGVuZXJGb3JCaW5kaW5nKGJpbmRpbmcpLmJpbmRpbmdEaXNjb25uZWN0ZWQoYmluZGluZyk7XG4gICAgICAgIGlmIChjbGVhckV2ZW50TGlzdGVuZXJzKVxuICAgICAgICAgICAgdGhpcy5jbGVhckV2ZW50TGlzdGVuZXJzRm9yQmluZGluZyhiaW5kaW5nKTtcbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IsIG1lc3NhZ2UsIGRldGFpbCA9IHt9KSB7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24uaGFuZGxlRXJyb3IoZXJyb3IsIGBFcnJvciAke21lc3NhZ2V9YCwgZGV0YWlsKTtcbiAgICB9XG4gICAgY2xlYXJFdmVudExpc3RlbmVyc0ZvckJpbmRpbmcoYmluZGluZykge1xuICAgICAgICBjb25zdCBldmVudExpc3RlbmVyID0gdGhpcy5mZXRjaEV2ZW50TGlzdGVuZXJGb3JCaW5kaW5nKGJpbmRpbmcpO1xuICAgICAgICBpZiAoIWV2ZW50TGlzdGVuZXIuaGFzQmluZGluZ3MoKSkge1xuICAgICAgICAgICAgZXZlbnRMaXN0ZW5lci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU1hcHBlZEV2ZW50TGlzdGVuZXJGb3IoYmluZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlTWFwcGVkRXZlbnRMaXN0ZW5lckZvcihiaW5kaW5nKSB7XG4gICAgICAgIGNvbnN0IHsgZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zIH0gPSBiaW5kaW5nO1xuICAgICAgICBjb25zdCBldmVudExpc3RlbmVyTWFwID0gdGhpcy5mZXRjaEV2ZW50TGlzdGVuZXJNYXBGb3JFdmVudFRhcmdldChldmVudFRhcmdldCk7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5jYWNoZUtleShldmVudE5hbWUsIGV2ZW50T3B0aW9ucyk7XG4gICAgICAgIGV2ZW50TGlzdGVuZXJNYXAuZGVsZXRlKGNhY2hlS2V5KTtcbiAgICAgICAgaWYgKGV2ZW50TGlzdGVuZXJNYXAuc2l6ZSA9PSAwKVxuICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyTWFwcy5kZWxldGUoZXZlbnRUYXJnZXQpO1xuICAgIH1cbiAgICBmZXRjaEV2ZW50TGlzdGVuZXJGb3JCaW5kaW5nKGJpbmRpbmcpIHtcbiAgICAgICAgY29uc3QgeyBldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMgfSA9IGJpbmRpbmc7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoRXZlbnRMaXN0ZW5lcihldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMpO1xuICAgIH1cbiAgICBmZXRjaEV2ZW50TGlzdGVuZXIoZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJNYXAgPSB0aGlzLmZldGNoRXZlbnRMaXN0ZW5lck1hcEZvckV2ZW50VGFyZ2V0KGV2ZW50VGFyZ2V0KTtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmNhY2hlS2V5KGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zKTtcbiAgICAgICAgbGV0IGV2ZW50TGlzdGVuZXIgPSBldmVudExpc3RlbmVyTWFwLmdldChjYWNoZUtleSk7XG4gICAgICAgIGlmICghZXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZXZlbnRMaXN0ZW5lciA9IHRoaXMuY3JlYXRlRXZlbnRMaXN0ZW5lcihldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMpO1xuICAgICAgICAgICAgZXZlbnRMaXN0ZW5lck1hcC5zZXQoY2FjaGVLZXksIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudExpc3RlbmVyO1xuICAgIH1cbiAgICBjcmVhdGVFdmVudExpc3RlbmVyKGV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGV2ZW50T3B0aW9ucykge1xuICAgICAgICBjb25zdCBldmVudExpc3RlbmVyID0gbmV3IEV2ZW50TGlzdGVuZXIoZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgZXZlbnRMaXN0ZW5lci5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50TGlzdGVuZXI7XG4gICAgfVxuICAgIGZldGNoRXZlbnRMaXN0ZW5lck1hcEZvckV2ZW50VGFyZ2V0KGV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIGxldCBldmVudExpc3RlbmVyTWFwID0gdGhpcy5ldmVudExpc3RlbmVyTWFwcy5nZXQoZXZlbnRUYXJnZXQpO1xuICAgICAgICBpZiAoIWV2ZW50TGlzdGVuZXJNYXApIHtcbiAgICAgICAgICAgIGV2ZW50TGlzdGVuZXJNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJNYXBzLnNldChldmVudFRhcmdldCwgZXZlbnRMaXN0ZW5lck1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50TGlzdGVuZXJNYXA7XG4gICAgfVxuICAgIGNhY2hlS2V5KGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW2V2ZW50TmFtZV07XG4gICAgICAgIE9iamVjdC5rZXlzKGV2ZW50T3B0aW9ucylcbiAgICAgICAgICAgIC5zb3J0KClcbiAgICAgICAgICAgIC5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goYCR7ZXZlbnRPcHRpb25zW2tleV0gPyBcIlwiIDogXCIhXCJ9JHtrZXl9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIjpcIik7XG4gICAgfVxufVxuXG5jb25zdCBkZWZhdWx0QWN0aW9uRGVzY3JpcHRvckZpbHRlcnMgPSB7XG4gICAgc3RvcCh7IGV2ZW50LCB2YWx1ZSB9KSB7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHByZXZlbnQoeyBldmVudCwgdmFsdWUgfSkge1xuICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHNlbGYoeyBldmVudCwgdmFsdWUsIGVsZW1lbnQgfSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50ID09PSBldmVudC50YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuY29uc3QgZGVzY3JpcHRvclBhdHRlcm4gPSAvXig/Oig/OihbXi5dKz8pXFwrKT8oLis/KSg/OlxcLiguKz8pKT8oPzpAKHdpbmRvd3xkb2N1bWVudCkpPy0+KT8oLis/KSg/OiMoW146XSs/KSkoPzo6KC4rKSk/JC87XG5mdW5jdGlvbiBwYXJzZUFjdGlvbkRlc2NyaXB0b3JTdHJpbmcoZGVzY3JpcHRvclN0cmluZykge1xuICAgIGNvbnN0IHNvdXJjZSA9IGRlc2NyaXB0b3JTdHJpbmcudHJpbSgpO1xuICAgIGNvbnN0IG1hdGNoZXMgPSBzb3VyY2UubWF0Y2goZGVzY3JpcHRvclBhdHRlcm4pIHx8IFtdO1xuICAgIGxldCBldmVudE5hbWUgPSBtYXRjaGVzWzJdO1xuICAgIGxldCBrZXlGaWx0ZXIgPSBtYXRjaGVzWzNdO1xuICAgIGlmIChrZXlGaWx0ZXIgJiYgIVtcImtleWRvd25cIiwgXCJrZXl1cFwiLCBcImtleXByZXNzXCJdLmluY2x1ZGVzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgZXZlbnROYW1lICs9IGAuJHtrZXlGaWx0ZXJ9YDtcbiAgICAgICAga2V5RmlsdGVyID0gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnRUYXJnZXQ6IHBhcnNlRXZlbnRUYXJnZXQobWF0Y2hlc1s0XSksXG4gICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgZXZlbnRPcHRpb25zOiBtYXRjaGVzWzddID8gcGFyc2VFdmVudE9wdGlvbnMobWF0Y2hlc1s3XSkgOiB7fSxcbiAgICAgICAgaWRlbnRpZmllcjogbWF0Y2hlc1s1XSxcbiAgICAgICAgbWV0aG9kTmFtZTogbWF0Y2hlc1s2XSxcbiAgICAgICAga2V5RmlsdGVyOiBtYXRjaGVzWzFdIHx8IGtleUZpbHRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VFdmVudFRhcmdldChldmVudFRhcmdldE5hbWUpIHtcbiAgICBpZiAoZXZlbnRUYXJnZXROYW1lID09IFwid2luZG93XCIpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnRUYXJnZXROYW1lID09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VFdmVudE9wdGlvbnMoZXZlbnRPcHRpb25zKSB7XG4gICAgcmV0dXJuIGV2ZW50T3B0aW9uc1xuICAgICAgICAuc3BsaXQoXCI6XCIpXG4gICAgICAgIC5yZWR1Y2UoKG9wdGlvbnMsIHRva2VuKSA9PiBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHsgW3Rva2VuLnJlcGxhY2UoL14hLywgXCJcIildOiAhL14hLy50ZXN0KHRva2VuKSB9KSwge30pO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5RXZlbnRUYXJnZXQoZXZlbnRUYXJnZXQpIHtcbiAgICBpZiAoZXZlbnRUYXJnZXQgPT0gd2luZG93KSB7XG4gICAgICAgIHJldHVybiBcIndpbmRvd1wiO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudFRhcmdldCA9PSBkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gXCJkb2N1bWVudFwiO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2FtZWxpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvKD86W18tXSkoW2EtejAtOV0pL2csIChfLCBjaGFyKSA9PiBjaGFyLnRvVXBwZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gbmFtZXNwYWNlQ2FtZWxpemUodmFsdWUpIHtcbiAgICByZXR1cm4gY2FtZWxpemUodmFsdWUucmVwbGFjZSgvLS0vZywgXCItXCIpLnJlcGxhY2UoL19fL2csIFwiX1wiKSk7XG59XG5mdW5jdGlvbiBjYXBpdGFsaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdmFsdWUuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiBkYXNoZXJpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvKFtBLVpdKS9nLCAoXywgY2hhcikgPT4gYC0ke2NoYXIudG9Mb3dlckNhc2UoKX1gKTtcbn1cbmZ1bmN0aW9uIHRva2VuaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hdGNoKC9bXlxcc10rL2cpIHx8IFtdO1xufVxuXG5mdW5jdGlvbiBpc1NvbWV0aGluZyhvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaGFzUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7XG59XG5cbmNvbnN0IGFsbE1vZGlmaWVycyA9IFtcIm1ldGFcIiwgXCJjdHJsXCIsIFwiYWx0XCIsIFwic2hpZnRcIl07XG5jbGFzcyBBY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGluZGV4LCBkZXNjcmlwdG9yLCBzY2hlbWEpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmV2ZW50VGFyZ2V0ID0gZGVzY3JpcHRvci5ldmVudFRhcmdldCB8fCBlbGVtZW50O1xuICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IGRlc2NyaXB0b3IuZXZlbnROYW1lIHx8IGdldERlZmF1bHRFdmVudE5hbWVGb3JFbGVtZW50KGVsZW1lbnQpIHx8IGVycm9yKFwibWlzc2luZyBldmVudCBuYW1lXCIpO1xuICAgICAgICB0aGlzLmV2ZW50T3B0aW9ucyA9IGRlc2NyaXB0b3IuZXZlbnRPcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBkZXNjcmlwdG9yLmlkZW50aWZpZXIgfHwgZXJyb3IoXCJtaXNzaW5nIGlkZW50aWZpZXJcIik7XG4gICAgICAgIHRoaXMubWV0aG9kTmFtZSA9IGRlc2NyaXB0b3IubWV0aG9kTmFtZSB8fCBlcnJvcihcIm1pc3NpbmcgbWV0aG9kIG5hbWVcIik7XG4gICAgICAgIHRoaXMua2V5RmlsdGVyID0gZGVzY3JpcHRvci5rZXlGaWx0ZXIgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgfVxuICAgIHN0YXRpYyBmb3JUb2tlbih0b2tlbiwgc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh0b2tlbi5lbGVtZW50LCB0b2tlbi5pbmRleCwgcGFyc2VBY3Rpb25EZXNjcmlwdG9yU3RyaW5nKHRva2VuLmNvbnRlbnQpLCBzY2hlbWEpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgZXZlbnRGaWx0ZXIgPSB0aGlzLmtleUZpbHRlciA/IGAuJHt0aGlzLmtleUZpbHRlcn1gIDogXCJcIjtcbiAgICAgICAgY29uc3QgZXZlbnRUYXJnZXQgPSB0aGlzLmV2ZW50VGFyZ2V0TmFtZSA/IGBAJHt0aGlzLmV2ZW50VGFyZ2V0TmFtZX1gIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZXZlbnROYW1lfSR7ZXZlbnRGaWx0ZXJ9JHtldmVudFRhcmdldH0tPiR7dGhpcy5pZGVudGlmaWVyfSMke3RoaXMubWV0aG9kTmFtZX1gO1xuICAgIH1cbiAgICBzaG91bGRJZ25vcmVLZXlib2FyZEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5rZXlGaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJzID0gdGhpcy5rZXlGaWx0ZXIuc3BsaXQoXCIrXCIpO1xuICAgICAgICBpZiAodGhpcy5rZXlGaWx0ZXJEaXNzYXRpc2ZpZWQoZXZlbnQsIGZpbHRlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFuZGFyZEZpbHRlciA9IGZpbHRlcnMuZmlsdGVyKChrZXkpID0+ICFhbGxNb2RpZmllcnMuaW5jbHVkZXMoa2V5KSlbMF07XG4gICAgICAgIGlmICghc3RhbmRhcmRGaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc1Byb3BlcnR5KHRoaXMua2V5TWFwcGluZ3MsIHN0YW5kYXJkRmlsdGVyKSkge1xuICAgICAgICAgICAgZXJyb3IoYGNvbnRhaW5zIHVua25vd24ga2V5IGZpbHRlcjogJHt0aGlzLmtleUZpbHRlcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXBwaW5nc1tzdGFuZGFyZEZpbHRlcl0udG9Mb3dlckNhc2UoKSAhPT0gZXZlbnQua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHNob3VsZElnbm9yZU1vdXNlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleUZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlcnMgPSBbdGhpcy5rZXlGaWx0ZXJdO1xuICAgICAgICBpZiAodGhpcy5rZXlGaWx0ZXJEaXNzYXRpc2ZpZWQoZXZlbnQsIGZpbHRlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBwYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChgXmRhdGEtJHt0aGlzLmlkZW50aWZpZXJ9LSguKyktcGFyYW0kYCwgXCJpXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbmFtZSwgdmFsdWUgfSBvZiBBcnJheS5mcm9tKHRoaXMuZWxlbWVudC5hdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBuYW1lLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2NhbWVsaXplKGtleSldID0gdHlwZWNhc3QodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIGdldCBldmVudFRhcmdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlFdmVudFRhcmdldCh0aGlzLmV2ZW50VGFyZ2V0KTtcbiAgICB9XG4gICAgZ2V0IGtleU1hcHBpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWEua2V5TWFwcGluZ3M7XG4gICAgfVxuICAgIGtleUZpbHRlckRpc3NhdGlzZmllZChldmVudCwgZmlsdGVycykge1xuICAgICAgICBjb25zdCBbbWV0YSwgY3RybCwgYWx0LCBzaGlmdF0gPSBhbGxNb2RpZmllcnMubWFwKChtb2RpZmllcikgPT4gZmlsdGVycy5pbmNsdWRlcyhtb2RpZmllcikpO1xuICAgICAgICByZXR1cm4gZXZlbnQubWV0YUtleSAhPT0gbWV0YSB8fCBldmVudC5jdHJsS2V5ICE9PSBjdHJsIHx8IGV2ZW50LmFsdEtleSAhPT0gYWx0IHx8IGV2ZW50LnNoaWZ0S2V5ICE9PSBzaGlmdDtcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0RXZlbnROYW1lcyA9IHtcbiAgICBhOiAoKSA9PiBcImNsaWNrXCIsXG4gICAgYnV0dG9uOiAoKSA9PiBcImNsaWNrXCIsXG4gICAgZm9ybTogKCkgPT4gXCJzdWJtaXRcIixcbiAgICBkZXRhaWxzOiAoKSA9PiBcInRvZ2dsZVwiLFxuICAgIGlucHV0OiAoZSkgPT4gKGUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PSBcInN1Ym1pdFwiID8gXCJjbGlja1wiIDogXCJpbnB1dFwiKSxcbiAgICBzZWxlY3Q6ICgpID0+IFwiY2hhbmdlXCIsXG4gICAgdGV4dGFyZWE6ICgpID0+IFwiaW5wdXRcIixcbn07XG5mdW5jdGlvbiBnZXREZWZhdWx0RXZlbnROYW1lRm9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3QgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh0YWdOYW1lIGluIGRlZmF1bHRFdmVudE5hbWVzKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RXZlbnROYW1lc1t0YWdOYW1lXShlbGVtZW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gdHlwZWNhc3QodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChvX08pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cblxuY2xhc3MgQmluZGluZyB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uO1xuICAgIH1cbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbi5pbmRleDtcbiAgICB9XG4gICAgZ2V0IGV2ZW50VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb24uZXZlbnRUYXJnZXQ7XG4gICAgfVxuICAgIGdldCBldmVudE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbi5ldmVudE9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmlkZW50aWZpZXI7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbkV2ZW50ID0gdGhpcy5wcmVwYXJlQWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy53aWxsQmVJbnZva2VkQnlFdmVudChldmVudCkgJiYgdGhpcy5hcHBseUV2ZW50TW9kaWZpZXJzKGFjdGlvbkV2ZW50KSkge1xuICAgICAgICAgICAgdGhpcy5pbnZva2VXaXRoRXZlbnQoYWN0aW9uRXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBldmVudE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbi5ldmVudE5hbWU7XG4gICAgfVxuICAgIGdldCBtZXRob2QoKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuY29udHJvbGxlclt0aGlzLm1ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY3Rpb24gXCIke3RoaXMuYWN0aW9ufVwiIHJlZmVyZW5jZXMgdW5kZWZpbmVkIG1ldGhvZCBcIiR7dGhpcy5tZXRob2ROYW1lfVwiYCk7XG4gICAgfVxuICAgIGFwcGx5RXZlbnRNb2RpZmllcnMoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50IH0gPSB0aGlzLmFjdGlvbjtcbiAgICAgICAgY29uc3QgeyBhY3Rpb25EZXNjcmlwdG9yRmlsdGVycyB9ID0gdGhpcy5jb250ZXh0LmFwcGxpY2F0aW9uO1xuICAgICAgICBjb25zdCB7IGNvbnRyb2xsZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHBhc3NlcyA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmV2ZW50T3B0aW9ucykpIHtcbiAgICAgICAgICAgIGlmIChuYW1lIGluIGFjdGlvbkRlc2NyaXB0b3JGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gYWN0aW9uRGVzY3JpcHRvckZpbHRlcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgcGFzc2VzID0gcGFzc2VzICYmIGZpbHRlcih7IG5hbWUsIHZhbHVlLCBldmVudCwgZWxlbWVudCwgY29udHJvbGxlciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXNzZXM7XG4gICAgfVxuICAgIHByZXBhcmVBY3Rpb25FdmVudChldmVudCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihldmVudCwgeyBwYXJhbXM6IHRoaXMuYWN0aW9uLnBhcmFtcyB9KTtcbiAgICB9XG4gICAgaW52b2tlV2l0aEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0LCBjdXJyZW50VGFyZ2V0IH0gPSBldmVudDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMubWV0aG9kLmNhbGwodGhpcy5jb250cm9sbGVyLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQubG9nRGVidWdBY3Rpdml0eSh0aGlzLm1ldGhvZE5hbWUsIHsgZXZlbnQsIHRhcmdldCwgY3VycmVudFRhcmdldCwgYWN0aW9uOiB0aGlzLm1ldGhvZE5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlkZW50aWZpZXIsIGNvbnRyb2xsZXIsIGVsZW1lbnQsIGluZGV4IH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgZGV0YWlsID0geyBpZGVudGlmaWVyLCBjb250cm9sbGVyLCBlbGVtZW50LCBpbmRleCwgZXZlbnQgfTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5oYW5kbGVFcnJvcihlcnJvciwgYGludm9raW5nIGFjdGlvbiBcIiR7dGhpcy5hY3Rpb259XCJgLCBkZXRhaWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpbGxCZUludm9rZWRCeUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50VGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50ICYmIHRoaXMuYWN0aW9uLnNob3VsZElnbm9yZUtleWJvYXJkRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCAmJiB0aGlzLmFjdGlvbi5zaG91bGRJZ25vcmVNb3VzZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQgPT09IGV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudFRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgdGhpcy5lbGVtZW50LmNvbnRhaW5zKGV2ZW50VGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuY29udGFpbnNFbGVtZW50KGV2ZW50VGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmNvbnRhaW5zRWxlbWVudCh0aGlzLmFjdGlvbi5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY29udHJvbGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5jb250cm9sbGVyO1xuICAgIH1cbiAgICBnZXQgbWV0aG9kTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uLm1ldGhvZE5hbWU7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgc2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuc2NvcGU7XG4gICAgfVxufVxuXG5jbGFzcyBFbGVtZW50T2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGRlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlckluaXQgPSB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9O1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB0aGlzLnByb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKSk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuZWxlbWVudCwgdGhpcy5tdXRhdGlvbk9ic2VydmVySW5pdCk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXVzZShjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuZWxlbWVudCwgdGhpcy5tdXRhdGlvbk9ic2VydmVySW5pdCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBuZXcgU2V0KHRoaXMubWF0Y2hFbGVtZW50c0luVHJlZSgpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBBcnJheS5mcm9tKHRoaXMuZWxlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIEFycmF5LmZyb20obWF0Y2hlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc011dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NBdHRyaWJ1dGVDaGFuZ2UobXV0YXRpb24udGFyZ2V0LCBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtdXRhdGlvbi50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1JlbW92ZWROb2RlcyhtdXRhdGlvbi5yZW1vdmVkTm9kZXMpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQWRkZWROb2RlcyhtdXRhdGlvbi5hZGRlZE5vZGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzQXR0cmlidXRlQ2hhbmdlKGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbGVtZW50QXR0cmlidXRlQ2hhbmdlZCAmJiB0aGlzLm1hdGNoRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZWxlbWVudEF0dHJpYnV0ZUNoYW5nZWQoZWxlbWVudCwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzUmVtb3ZlZE5vZGVzKG5vZGVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBBcnJheS5mcm9tKG5vZGVzKSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudEZyb21Ob2RlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NUcmVlKGVsZW1lbnQsIHRoaXMucmVtb3ZlRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc0FkZGVkTm9kZXMobm9kZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIEFycmF5LmZyb20obm9kZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50RnJvbU5vZGUobm9kZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiB0aGlzLmVsZW1lbnRJc0FjdGl2ZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1RyZWUoZWxlbWVudCwgdGhpcy5hZGRFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5tYXRjaEVsZW1lbnQoZWxlbWVudCk7XG4gICAgfVxuICAgIG1hdGNoRWxlbWVudHNJblRyZWUodHJlZSA9IHRoaXMuZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5tYXRjaEVsZW1lbnRzSW5UcmVlKHRyZWUpO1xuICAgIH1cbiAgICBwcm9jZXNzVHJlZSh0cmVlLCBwcm9jZXNzb3IpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMubWF0Y2hFbGVtZW50c0luVHJlZSh0cmVlKSkge1xuICAgICAgICAgICAgcHJvY2Vzc29yLmNhbGwodGhpcywgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudEZyb21Ob2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRJc0FjdGl2ZShlbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50LmlzQ29ubmVjdGVkICE9IHRoaXMuZWxlbWVudC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jb250YWlucyhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnRzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudElzQWN0aXZlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5hZGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuZWxlbWVudE1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbGVtZW50TWF0Y2hlZChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbGVtZW50VW5tYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbGVtZW50VW5tYXRjaGVkKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBBdHRyaWJ1dGVPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgYXR0cmlidXRlTmFtZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLmVsZW1lbnRPYnNlcnZlciA9IG5ldyBFbGVtZW50T2JzZXJ2ZXIoZWxlbWVudCwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50T2JzZXJ2ZXIuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gYFske3RoaXMuYXR0cmlidXRlTmFtZX1dYDtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudE9ic2VydmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIHBhdXNlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudE9ic2VydmVyLnBhdXNlKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50T2JzZXJ2ZXIuc3RvcCgpO1xuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRPYnNlcnZlci5yZWZyZXNoKCk7XG4gICAgfVxuICAgIGdldCBzdGFydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50T2JzZXJ2ZXIuc3RhcnRlZDtcbiAgICB9XG4gICAgbWF0Y2hFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKHRoaXMuYXR0cmlidXRlTmFtZSk7XG4gICAgfVxuICAgIG1hdGNoRWxlbWVudHNJblRyZWUodHJlZSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRoaXMubWF0Y2hFbGVtZW50KHRyZWUpID8gW3RyZWVdIDogW107XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBBcnJheS5mcm9tKHRyZWUucXVlcnlTZWxlY3RvckFsbCh0aGlzLnNlbGVjdG9yKSk7XG4gICAgICAgIHJldHVybiBtYXRjaC5jb25jYXQobWF0Y2hlcyk7XG4gICAgfVxuICAgIGVsZW1lbnRNYXRjaGVkKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuZWxlbWVudE1hdGNoZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZWxlbWVudE1hdGNoZWRBdHRyaWJ1dGUoZWxlbWVudCwgdGhpcy5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50VW5tYXRjaGVkKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuZWxlbWVudFVubWF0Y2hlZEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbGVtZW50VW5tYXRjaGVkQXR0cmlidXRlKGVsZW1lbnQsIHRoaXMuYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudEF0dHJpYnV0ZUNoYW5nZWQoZWxlbWVudCwgYXR0cmlidXRlTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbGVtZW50QXR0cmlidXRlVmFsdWVDaGFuZ2VkICYmIHRoaXMuYXR0cmlidXRlTmFtZSA9PSBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmVsZW1lbnRBdHRyaWJ1dGVWYWx1ZUNoYW5nZWQoZWxlbWVudCwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZChtYXAsIGtleSwgdmFsdWUpIHtcbiAgICBmZXRjaChtYXAsIGtleSkuYWRkKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGRlbChtYXAsIGtleSwgdmFsdWUpIHtcbiAgICBmZXRjaChtYXAsIGtleSkuZGVsZXRlKHZhbHVlKTtcbiAgICBwcnVuZShtYXAsIGtleSk7XG59XG5mdW5jdGlvbiBmZXRjaChtYXAsIGtleSkge1xuICAgIGxldCB2YWx1ZXMgPSBtYXAuZ2V0KGtleSk7XG4gICAgaWYgKCF2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gbmV3IFNldCgpO1xuICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIHBydW5lKG1hcCwga2V5KSB7XG4gICAgY29uc3QgdmFsdWVzID0gbWFwLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZXMgIT0gbnVsbCAmJiB2YWx1ZXMuc2l6ZSA9PSAwKSB7XG4gICAgICAgIG1hcC5kZWxldGUoa2V5KTtcbiAgICB9XG59XG5cbmNsYXNzIE11bHRpbWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNCeUtleSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZ2V0IGtleXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudmFsdWVzQnlLZXkua2V5cygpKTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlcygpIHtcbiAgICAgICAgY29uc3Qgc2V0cyA9IEFycmF5LmZyb20odGhpcy52YWx1ZXNCeUtleS52YWx1ZXMoKSk7XG4gICAgICAgIHJldHVybiBzZXRzLnJlZHVjZSgodmFsdWVzLCBzZXQpID0+IHZhbHVlcy5jb25jYXQoQXJyYXkuZnJvbShzZXQpKSwgW10pO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgY29uc3Qgc2V0cyA9IEFycmF5LmZyb20odGhpcy52YWx1ZXNCeUtleS52YWx1ZXMoKSk7XG4gICAgICAgIHJldHVybiBzZXRzLnJlZHVjZSgoc2l6ZSwgc2V0KSA9PiBzaXplICsgc2V0LnNpemUsIDApO1xuICAgIH1cbiAgICBhZGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBhZGQodGhpcy52YWx1ZXNCeUtleSwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGRlbCh0aGlzLnZhbHVlc0J5S2V5LCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgaGFzKGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy52YWx1ZXNCeUtleS5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyAhPSBudWxsICYmIHZhbHVlcy5oYXModmFsdWUpO1xuICAgIH1cbiAgICBoYXNLZXkoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc0J5S2V5LmhhcyhrZXkpO1xuICAgIH1cbiAgICBoYXNWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBzZXRzID0gQXJyYXkuZnJvbSh0aGlzLnZhbHVlc0J5S2V5LnZhbHVlcygpKTtcbiAgICAgICAgcmV0dXJuIHNldHMuc29tZSgoc2V0KSA9PiBzZXQuaGFzKHZhbHVlKSk7XG4gICAgfVxuICAgIGdldFZhbHVlc0ZvcktleShrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy52YWx1ZXNCeUtleS5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyA/IEFycmF5LmZyb20odmFsdWVzKSA6IFtdO1xuICAgIH1cbiAgICBnZXRLZXlzRm9yVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy52YWx1ZXNCeUtleSlcbiAgICAgICAgICAgIC5maWx0ZXIoKFtfa2V5LCB2YWx1ZXNdKSA9PiB2YWx1ZXMuaGFzKHZhbHVlKSlcbiAgICAgICAgICAgIC5tYXAoKFtrZXksIF92YWx1ZXNdKSA9PiBrZXkpO1xuICAgIH1cbn1cblxuY2xhc3MgSW5kZXhlZE11bHRpbWFwIGV4dGVuZHMgTXVsdGltYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmtleXNCeVZhbHVlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXQgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmtleXNCeVZhbHVlLmtleXMoKSk7XG4gICAgfVxuICAgIGFkZChrZXksIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFkZChrZXksIHZhbHVlKTtcbiAgICAgICAgYWRkKHRoaXMua2V5c0J5VmFsdWUsIHZhbHVlLCBrZXkpO1xuICAgIH1cbiAgICBkZWxldGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5kZWxldGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGRlbCh0aGlzLmtleXNCeVZhbHVlLCB2YWx1ZSwga2V5KTtcbiAgICB9XG4gICAgaGFzVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5c0J5VmFsdWUuaGFzKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0S2V5c0ZvclZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMua2V5c0J5VmFsdWUuZ2V0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNldCA/IEFycmF5LmZyb20oc2V0KSA6IFtdO1xuICAgIH1cbn1cblxuY2xhc3MgU2VsZWN0b3JPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgc2VsZWN0b3IsIGRlbGVnYXRlLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgIHRoaXMuZWxlbWVudE9ic2VydmVyID0gbmV3IEVsZW1lbnRPYnNlcnZlcihlbGVtZW50LCB0aGlzKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLm1hdGNoZXNCeUVsZW1lbnQgPSBuZXcgTXVsdGltYXAoKTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRPYnNlcnZlci5zdGFydGVkO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RvcjtcbiAgICB9XG4gICAgc2V0IHNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50T2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgcGF1c2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5lbGVtZW50T2JzZXJ2ZXIucGF1c2UoY2FsbGJhY2spO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRPYnNlcnZlci5zdG9wKCk7XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudE9ic2VydmVyLnJlZnJlc2goKTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRPYnNlcnZlci5lbGVtZW50O1xuICAgIH1cbiAgICBtYXRjaEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCB7IHNlbGVjdG9yIH0gPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuc2VsZWN0b3JNYXRjaEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcyAmJiB0aGlzLmRlbGVnYXRlLnNlbGVjdG9yTWF0Y2hFbGVtZW50KGVsZW1lbnQsIHRoaXMuZGV0YWlscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaEVsZW1lbnRzSW5UcmVlKHRyZWUpIHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3RvciB9ID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHRoaXMubWF0Y2hFbGVtZW50KHRyZWUpID8gW3RyZWVdIDogW107XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gQXJyYXkuZnJvbSh0cmVlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKS5maWx0ZXIoKG1hdGNoKSA9PiB0aGlzLm1hdGNoRWxlbWVudChtYXRjaCkpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoLmNvbmNhdChtYXRjaGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50TWF0Y2hlZChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0b3IgfSA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rvck1hdGNoZWQoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRVbm1hdGNoZWQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBzZWxlY3RvcnMgPSB0aGlzLm1hdGNoZXNCeUVsZW1lbnQuZ2V0S2V5c0ZvclZhbHVlKGVsZW1lbnQpO1xuICAgICAgICBmb3IgKGNvbnN0IHNlbGVjdG9yIG9mIHNlbGVjdG9ycykge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RvclVubWF0Y2hlZChlbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudEF0dHJpYnV0ZUNoYW5nZWQoZWxlbWVudCwgX2F0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3RvciB9ID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5tYXRjaEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkQmVmb3JlID0gdGhpcy5tYXRjaGVzQnlFbGVtZW50LmhhcyhzZWxlY3RvciwgZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcyAmJiAhbWF0Y2hlZEJlZm9yZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JNYXRjaGVkKGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFtYXRjaGVzICYmIG1hdGNoZWRCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yVW5tYXRjaGVkKGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3Rvck1hdGNoZWQoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZWxlY3Rvck1hdGNoZWQoZWxlbWVudCwgc2VsZWN0b3IsIHRoaXMuZGV0YWlscyk7XG4gICAgICAgIHRoaXMubWF0Y2hlc0J5RWxlbWVudC5hZGQoc2VsZWN0b3IsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBzZWxlY3RvclVubWF0Y2hlZChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnNlbGVjdG9yVW5tYXRjaGVkKGVsZW1lbnQsIHNlbGVjdG9yLCB0aGlzLmRldGFpbHMpO1xuICAgICAgICB0aGlzLm1hdGNoZXNCeUVsZW1lbnQuZGVsZXRlKHNlbGVjdG9yLCBlbGVtZW50KTtcbiAgICB9XG59XG5cbmNsYXNzIFN0cmluZ01hcE9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBkZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0cmluZ01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4gdGhpcy5wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucykpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUgfSk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgb2YgdGhpcy5rbm93bkF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTXV0YXRpb24obXV0YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gbXV0YXRpb24uYXR0cmlidXRlTmFtZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBtdXRhdGlvbi5vbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmcmVzaEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmRlbGVnYXRlLmdldFN0cmluZ01hcEtleUZvckF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RyaW5nTWFwLmhhcyhhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5nTWFwS2V5QWRkZWQoa2V5LCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmluZ01hcC5nZXQoYXR0cmlidXRlTmFtZSkgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmluZ01hcFZhbHVlQ2hhbmdlZCh2YWx1ZSwga2V5LCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5zdHJpbmdNYXAuZ2V0KGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5nTWFwLmRlbGV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5nTWFwS2V5UmVtb3ZlZChrZXksIGF0dHJpYnV0ZU5hbWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5nTWFwLnNldChhdHRyaWJ1dGVOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyaW5nTWFwS2V5QWRkZWQoa2V5LCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLnN0cmluZ01hcEtleUFkZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnN0cmluZ01hcEtleUFkZGVkKGtleSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyaW5nTWFwVmFsdWVDaGFuZ2VkKHZhbHVlLCBrZXksIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLnN0cmluZ01hcFZhbHVlQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zdHJpbmdNYXBWYWx1ZUNoYW5nZWQodmFsdWUsIGtleSwgb2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0cmluZ01hcEtleVJlbW92ZWQoa2V5LCBhdHRyaWJ1dGVOYW1lLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5zdHJpbmdNYXBLZXlSZW1vdmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnN0cmluZ01hcEtleVJlbW92ZWQoa2V5LCBhdHRyaWJ1dGVOYW1lLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGtub3duQXR0cmlidXRlTmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQodGhpcy5jdXJyZW50QXR0cmlidXRlTmFtZXMuY29uY2F0KHRoaXMucmVjb3JkZWRBdHRyaWJ1dGVOYW1lcykpKTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRBdHRyaWJ1dGVOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbGVtZW50LmF0dHJpYnV0ZXMpLm1hcCgoYXR0cmlidXRlKSA9PiBhdHRyaWJ1dGUubmFtZSk7XG4gICAgfVxuICAgIGdldCByZWNvcmRlZEF0dHJpYnV0ZU5hbWVzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnN0cmluZ01hcC5rZXlzKCkpO1xuICAgIH1cbn1cblxuY2xhc3MgVG9rZW5MaXN0T2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGRlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXIgPSBuZXcgQXR0cmlidXRlT2JzZXJ2ZXIoZWxlbWVudCwgYXR0cmlidXRlTmFtZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy50b2tlbnNCeUVsZW1lbnQgPSBuZXcgTXVsdGltYXAoKTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZU9ic2VydmVyLnN0YXJ0ZWQ7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIHBhdXNlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXIucGF1c2UoY2FsbGJhY2spO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZU9ic2VydmVyLnN0b3AoKTtcbiAgICB9XG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVPYnNlcnZlci5yZWZyZXNoKCk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVPYnNlcnZlci5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgYXR0cmlidXRlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXIuYXR0cmlidXRlTmFtZTtcbiAgICB9XG4gICAgZWxlbWVudE1hdGNoZWRBdHRyaWJ1dGUoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnRva2Vuc01hdGNoZWQodGhpcy5yZWFkVG9rZW5zRm9yRWxlbWVudChlbGVtZW50KSk7XG4gICAgfVxuICAgIGVsZW1lbnRBdHRyaWJ1dGVWYWx1ZUNoYW5nZWQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBbdW5tYXRjaGVkVG9rZW5zLCBtYXRjaGVkVG9rZW5zXSA9IHRoaXMucmVmcmVzaFRva2Vuc0ZvckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIHRoaXMudG9rZW5zVW5tYXRjaGVkKHVubWF0Y2hlZFRva2Vucyk7XG4gICAgICAgIHRoaXMudG9rZW5zTWF0Y2hlZChtYXRjaGVkVG9rZW5zKTtcbiAgICB9XG4gICAgZWxlbWVudFVubWF0Y2hlZEF0dHJpYnV0ZShlbGVtZW50KSB7XG4gICAgICAgIHRoaXMudG9rZW5zVW5tYXRjaGVkKHRoaXMudG9rZW5zQnlFbGVtZW50LmdldFZhbHVlc0ZvcktleShlbGVtZW50KSk7XG4gICAgfVxuICAgIHRva2Vuc01hdGNoZWQodG9rZW5zKSB7XG4gICAgICAgIHRva2Vucy5mb3JFYWNoKCh0b2tlbikgPT4gdGhpcy50b2tlbk1hdGNoZWQodG9rZW4pKTtcbiAgICB9XG4gICAgdG9rZW5zVW5tYXRjaGVkKHRva2Vucykge1xuICAgICAgICB0b2tlbnMuZm9yRWFjaCgodG9rZW4pID0+IHRoaXMudG9rZW5Vbm1hdGNoZWQodG9rZW4pKTtcbiAgICB9XG4gICAgdG9rZW5NYXRjaGVkKHRva2VuKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUudG9rZW5NYXRjaGVkKHRva2VuKTtcbiAgICAgICAgdGhpcy50b2tlbnNCeUVsZW1lbnQuYWRkKHRva2VuLmVsZW1lbnQsIHRva2VuKTtcbiAgICB9XG4gICAgdG9rZW5Vbm1hdGNoZWQodG9rZW4pIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS50b2tlblVubWF0Y2hlZCh0b2tlbik7XG4gICAgICAgIHRoaXMudG9rZW5zQnlFbGVtZW50LmRlbGV0ZSh0b2tlbi5lbGVtZW50LCB0b2tlbik7XG4gICAgfVxuICAgIHJlZnJlc2hUb2tlbnNGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNUb2tlbnMgPSB0aGlzLnRva2Vuc0J5RWxlbWVudC5nZXRWYWx1ZXNGb3JLZXkoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUb2tlbnMgPSB0aGlzLnJlYWRUb2tlbnNGb3JFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBmaXJzdERpZmZlcmluZ0luZGV4ID0gemlwKHByZXZpb3VzVG9rZW5zLCBjdXJyZW50VG9rZW5zKS5maW5kSW5kZXgoKFtwcmV2aW91c1Rva2VuLCBjdXJyZW50VG9rZW5dKSA9PiAhdG9rZW5zQXJlRXF1YWwocHJldmlvdXNUb2tlbiwgY3VycmVudFRva2VuKSk7XG4gICAgICAgIGlmIChmaXJzdERpZmZlcmluZ0luZGV4ID09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gW1tdLCBbXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3ByZXZpb3VzVG9rZW5zLnNsaWNlKGZpcnN0RGlmZmVyaW5nSW5kZXgpLCBjdXJyZW50VG9rZW5zLnNsaWNlKGZpcnN0RGlmZmVyaW5nSW5kZXgpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkVG9rZW5zRm9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIGNvbnN0IHRva2VuU3RyaW5nID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkgfHwgXCJcIjtcbiAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5TdHJpbmcodG9rZW5TdHJpbmcsIGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVG9rZW5TdHJpbmcodG9rZW5TdHJpbmcsIGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gdG9rZW5TdHJpbmdcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgICAuZmlsdGVyKChjb250ZW50KSA9PiBjb250ZW50Lmxlbmd0aClcbiAgICAgICAgLm1hcCgoY29udGVudCwgaW5kZXgpID0+ICh7IGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGNvbnRlbnQsIGluZGV4IH0pKTtcbn1cbmZ1bmN0aW9uIHppcChsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KGxlZnQubGVuZ3RoLCByaWdodC5sZW5ndGgpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sIChfLCBpbmRleCkgPT4gW2xlZnRbaW5kZXhdLCByaWdodFtpbmRleF1dKTtcbn1cbmZ1bmN0aW9uIHRva2Vuc0FyZUVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQgJiYgcmlnaHQgJiYgbGVmdC5pbmRleCA9PSByaWdodC5pbmRleCAmJiBsZWZ0LmNvbnRlbnQgPT0gcmlnaHQuY29udGVudDtcbn1cblxuY2xhc3MgVmFsdWVMaXN0T2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGRlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIgPSBuZXcgVG9rZW5MaXN0T2JzZXJ2ZXIoZWxlbWVudCwgYXR0cmlidXRlTmFtZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5wYXJzZVJlc3VsdHNCeVRva2VuID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy52YWx1ZXNCeVRva2VuQnlFbGVtZW50ID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuTGlzdE9ic2VydmVyLnN0YXJ0ZWQ7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnRva2VuTGlzdE9ic2VydmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIuc3RvcCgpO1xuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICB0aGlzLnRva2VuTGlzdE9ic2VydmVyLnJlZnJlc2goKTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuTGlzdE9ic2VydmVyLmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBhdHRyaWJ1dGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbkxpc3RPYnNlcnZlci5hdHRyaWJ1dGVOYW1lO1xuICAgIH1cbiAgICB0b2tlbk1hdGNoZWQodG9rZW4pIHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50IH0gPSB0b2tlbjtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gdGhpcy5mZXRjaFBhcnNlUmVzdWx0Rm9yVG9rZW4odG9rZW4pO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hWYWx1ZXNCeVRva2VuRm9yRWxlbWVudChlbGVtZW50KS5zZXQodG9rZW4sIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZWxlbWVudE1hdGNoZWRWYWx1ZShlbGVtZW50LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9rZW5Vbm1hdGNoZWQodG9rZW4pIHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50IH0gPSB0b2tlbjtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gdGhpcy5mZXRjaFBhcnNlUmVzdWx0Rm9yVG9rZW4odG9rZW4pO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hWYWx1ZXNCeVRva2VuRm9yRWxlbWVudChlbGVtZW50KS5kZWxldGUodG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbGVtZW50VW5tYXRjaGVkVmFsdWUoZWxlbWVudCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZldGNoUGFyc2VSZXN1bHRGb3JUb2tlbih0b2tlbikge1xuICAgICAgICBsZXQgcGFyc2VSZXN1bHQgPSB0aGlzLnBhcnNlUmVzdWx0c0J5VG9rZW4uZ2V0KHRva2VuKTtcbiAgICAgICAgaWYgKCFwYXJzZVJlc3VsdCkge1xuICAgICAgICAgICAgcGFyc2VSZXN1bHQgPSB0aGlzLnBhcnNlVG9rZW4odG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5wYXJzZVJlc3VsdHNCeVRva2VuLnNldCh0b2tlbiwgcGFyc2VSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZVJlc3VsdDtcbiAgICB9XG4gICAgZmV0Y2hWYWx1ZXNCeVRva2VuRm9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGxldCB2YWx1ZXNCeVRva2VuID0gdGhpcy52YWx1ZXNCeVRva2VuQnlFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKCF2YWx1ZXNCeVRva2VuKSB7XG4gICAgICAgICAgICB2YWx1ZXNCeVRva2VuID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXNCeVRva2VuQnlFbGVtZW50LnNldChlbGVtZW50LCB2YWx1ZXNCeVRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzQnlUb2tlbjtcbiAgICB9XG4gICAgcGFyc2VUb2tlbih0b2tlbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmRlbGVnYXRlLnBhcnNlVmFsdWVGb3JUb2tlbih0b2tlbik7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQmluZGluZ09ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBkZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuYmluZGluZ3NCeUFjdGlvbiA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy52YWx1ZUxpc3RPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUxpc3RPYnNlcnZlciA9IG5ldyBWYWx1ZUxpc3RPYnNlcnZlcih0aGlzLmVsZW1lbnQsIHRoaXMuYWN0aW9uQXR0cmlidXRlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVMaXN0T2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZUxpc3RPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUxpc3RPYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy52YWx1ZUxpc3RPYnNlcnZlcjtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbEFjdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5pZGVudGlmaWVyO1xuICAgIH1cbiAgICBnZXQgYWN0aW9uQXR0cmlidXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWEuYWN0aW9uQXR0cmlidXRlO1xuICAgIH1cbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnNjaGVtYTtcbiAgICB9XG4gICAgZ2V0IGJpbmRpbmdzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmJpbmRpbmdzQnlBY3Rpb24udmFsdWVzKCkpO1xuICAgIH1cbiAgICBjb25uZWN0QWN0aW9uKGFjdGlvbikge1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gbmV3IEJpbmRpbmcodGhpcy5jb250ZXh0LCBhY3Rpb24pO1xuICAgICAgICB0aGlzLmJpbmRpbmdzQnlBY3Rpb24uc2V0KGFjdGlvbiwgYmluZGluZyk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuYmluZGluZ0Nvbm5lY3RlZChiaW5kaW5nKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdEFjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IHRoaXMuYmluZGluZ3NCeUFjdGlvbi5nZXQoYWN0aW9uKTtcbiAgICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NCeUFjdGlvbi5kZWxldGUoYWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYmluZGluZ0Rpc2Nvbm5lY3RlZChiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNjb25uZWN0QWxsQWN0aW9ucygpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5ncy5mb3JFYWNoKChiaW5kaW5nKSA9PiB0aGlzLmRlbGVnYXRlLmJpbmRpbmdEaXNjb25uZWN0ZWQoYmluZGluZywgdHJ1ZSkpO1xuICAgICAgICB0aGlzLmJpbmRpbmdzQnlBY3Rpb24uY2xlYXIoKTtcbiAgICB9XG4gICAgcGFyc2VWYWx1ZUZvclRva2VuKHRva2VuKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IEFjdGlvbi5mb3JUb2tlbih0b2tlbiwgdGhpcy5zY2hlbWEpO1xuICAgICAgICBpZiAoYWN0aW9uLmlkZW50aWZpZXIgPT0gdGhpcy5pZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRNYXRjaGVkVmFsdWUoZWxlbWVudCwgYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdEFjdGlvbihhY3Rpb24pO1xuICAgIH1cbiAgICBlbGVtZW50VW5tYXRjaGVkVmFsdWUoZWxlbWVudCwgYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdEFjdGlvbihhY3Rpb24pO1xuICAgIH1cbn1cblxuY2xhc3MgVmFsdWVPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLnN0cmluZ01hcE9ic2VydmVyID0gbmV3IFN0cmluZ01hcE9ic2VydmVyKHRoaXMuZWxlbWVudCwgdGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVEZXNjcmlwdG9yTWFwID0gdGhpcy5jb250cm9sbGVyLnZhbHVlRGVzY3JpcHRvck1hcDtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nTWFwT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgdGhpcy5pbnZva2VDaGFuZ2VkQ2FsbGJhY2tzRm9yRGVmYXVsdFZhbHVlcygpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnN0cmluZ01hcE9ic2VydmVyLnN0b3AoKTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2xsZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuY29udHJvbGxlcjtcbiAgICB9XG4gICAgZ2V0U3RyaW5nTWFwS2V5Rm9yQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgaW4gdGhpcy52YWx1ZURlc2NyaXB0b3JNYXApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlRGVzY3JpcHRvck1hcFthdHRyaWJ1dGVOYW1lXS5uYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0cmluZ01hcEtleUFkZGVkKGtleSwgYXR0cmlidXRlTmFtZSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy52YWx1ZURlc2NyaXB0b3JNYXBbYXR0cmlidXRlTmFtZV07XG4gICAgICAgIGlmICghdGhpcy5oYXNWYWx1ZShrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmludm9rZUNoYW5nZWRDYWxsYmFjayhrZXksIGRlc2NyaXB0b3Iud3JpdGVyKHRoaXMucmVjZWl2ZXJba2V5XSksIGRlc2NyaXB0b3Iud3JpdGVyKGRlc2NyaXB0b3IuZGVmYXVsdFZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyaW5nTWFwVmFsdWVDaGFuZ2VkKHZhbHVlLCBuYW1lLCBvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy52YWx1ZURlc2NyaXB0b3JOYW1lTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb2xkVmFsdWUgPSBkZXNjcmlwdG9yLndyaXRlcihkZXNjcmlwdG9yLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnZva2VDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgc3RyaW5nTWFwS2V5UmVtb3ZlZChrZXksIGF0dHJpYnV0ZU5hbWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLnZhbHVlRGVzY3JpcHRvck5hbWVNYXBba2V5XTtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5pbnZva2VDaGFuZ2VkQ2FsbGJhY2soa2V5LCBkZXNjcmlwdG9yLndyaXRlcih0aGlzLnJlY2VpdmVyW2tleV0pLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmludm9rZUNoYW5nZWRDYWxsYmFjayhrZXksIGRlc2NyaXB0b3Iud3JpdGVyKGRlc2NyaXB0b3IuZGVmYXVsdFZhbHVlKSwgb2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludm9rZUNoYW5nZWRDYWxsYmFja3NGb3JEZWZhdWx0VmFsdWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHsga2V5LCBuYW1lLCBkZWZhdWx0VmFsdWUsIHdyaXRlciB9IG9mIHRoaXMudmFsdWVEZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAhPSB1bmRlZmluZWQgJiYgIXRoaXMuY29udHJvbGxlci5kYXRhLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZva2VDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgd3JpdGVyKGRlZmF1bHRWYWx1ZSksIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW52b2tlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIHJhd1ZhbHVlLCByYXdPbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBjaGFuZ2VkTWV0aG9kTmFtZSA9IGAke25hbWV9Q2hhbmdlZGA7XG4gICAgICAgIGNvbnN0IGNoYW5nZWRNZXRob2QgPSB0aGlzLnJlY2VpdmVyW2NoYW5nZWRNZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2VkTWV0aG9kID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMudmFsdWVEZXNjcmlwdG9yTmFtZU1hcFtuYW1lXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkZXNjcmlwdG9yLnJlYWRlcihyYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IG9sZFZhbHVlID0gcmF3T2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHJhd09sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gZGVzY3JpcHRvci5yZWFkZXIocmF3T2xkVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFuZ2VkTWV0aG9kLmNhbGwodGhpcy5yZWNlaXZlciwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gYFN0aW11bHVzIFZhbHVlIFwiJHt0aGlzLmNvbnRleHQuaWRlbnRpZmllcn0uJHtkZXNjcmlwdG9yLm5hbWV9XCIgLSAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHZhbHVlRGVzY3JpcHRvcnMoKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWVEZXNjcmlwdG9yTWFwIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWVEZXNjcmlwdG9yTWFwKS5tYXAoKGtleSkgPT4gdmFsdWVEZXNjcmlwdG9yTWFwW2tleV0pO1xuICAgIH1cbiAgICBnZXQgdmFsdWVEZXNjcmlwdG9yTmFtZU1hcCgpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy52YWx1ZURlc2NyaXB0b3JNYXApLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMudmFsdWVEZXNjcmlwdG9yTWFwW2tleV07XG4gICAgICAgICAgICBkZXNjcmlwdG9yc1tkZXNjcmlwdG9yLm5hbWVdID0gZGVzY3JpcHRvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgICB9XG4gICAgaGFzVmFsdWUoYXR0cmlidXRlTmFtZSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy52YWx1ZURlc2NyaXB0b3JOYW1lTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICBjb25zdCBoYXNNZXRob2ROYW1lID0gYGhhcyR7Y2FwaXRhbGl6ZShkZXNjcmlwdG9yLm5hbWUpfWA7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVyW2hhc01ldGhvZE5hbWVdO1xuICAgIH1cbn1cblxuY2xhc3MgVGFyZ2V0T2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGRlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy50YXJnZXRzQnlOYW1lID0gbmV3IE11bHRpbWFwKCk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIgPSBuZXcgVG9rZW5MaXN0T2JzZXJ2ZXIodGhpcy5lbGVtZW50LCB0aGlzLmF0dHJpYnV0ZU5hbWUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy50b2tlbkxpc3RPYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnRva2VuTGlzdE9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUYXJnZXRzKCk7XG4gICAgICAgICAgICB0aGlzLnRva2VuTGlzdE9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRva2VuTGlzdE9ic2VydmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRva2VuTWF0Y2hlZCh7IGVsZW1lbnQsIGNvbnRlbnQ6IG5hbWUgfSkge1xuICAgICAgICBpZiAodGhpcy5zY29wZS5jb250YWluc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRhcmdldChlbGVtZW50LCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b2tlblVubWF0Y2hlZCh7IGVsZW1lbnQsIGNvbnRlbnQ6IG5hbWUgfSkge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RUYXJnZXQoZWxlbWVudCwgbmFtZSk7XG4gICAgfVxuICAgIGNvbm5lY3RUYXJnZXQoZWxlbWVudCwgbmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy50YXJnZXRzQnlOYW1lLmhhcyhuYW1lLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRzQnlOYW1lLmFkZChuYW1lLCBlbGVtZW50KTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZSgoKSA9PiB0aGlzLmRlbGVnYXRlLnRhcmdldENvbm5lY3RlZChlbGVtZW50LCBuYW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdFRhcmdldChlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0c0J5TmFtZS5oYXMobmFtZSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0c0J5TmFtZS5kZWxldGUobmFtZSwgZWxlbWVudCk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnRva2VuTGlzdE9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF1c2UoKCkgPT4gdGhpcy5kZWxlZ2F0ZS50YXJnZXREaXNjb25uZWN0ZWQoZWxlbWVudCwgbmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RBbGxUYXJnZXRzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy50YXJnZXRzQnlOYW1lLmtleXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLnRhcmdldHNCeU5hbWUuZ2V0VmFsdWVzRm9yS2V5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0VGFyZ2V0KGVsZW1lbnQsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhdHRyaWJ1dGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gYGRhdGEtJHt0aGlzLmNvbnRleHQuaWRlbnRpZmllcn0tdGFyZ2V0YDtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IHNjb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnNjb3BlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVhZEluaGVyaXRhYmxlU3RhdGljQXJyYXlWYWx1ZXMoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSkge1xuICAgIGNvbnN0IGFuY2VzdG9ycyA9IGdldEFuY2VzdG9yc0ZvckNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhbmNlc3RvcnMucmVkdWNlKCh2YWx1ZXMsIGNvbnN0cnVjdG9yKSA9PiB7XG4gICAgICAgIGdldE93blN0YXRpY0FycmF5VmFsdWVzKGNvbnN0cnVjdG9yLCBwcm9wZXJ0eU5hbWUpLmZvckVhY2goKG5hbWUpID0+IHZhbHVlcy5hZGQobmFtZSkpO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0sIG5ldyBTZXQoKSkpO1xufVxuZnVuY3Rpb24gcmVhZEluaGVyaXRhYmxlU3RhdGljT2JqZWN0UGFpcnMoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSkge1xuICAgIGNvbnN0IGFuY2VzdG9ycyA9IGdldEFuY2VzdG9yc0ZvckNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yKTtcbiAgICByZXR1cm4gYW5jZXN0b3JzLnJlZHVjZSgocGFpcnMsIGNvbnN0cnVjdG9yKSA9PiB7XG4gICAgICAgIHBhaXJzLnB1c2goLi4uZ2V0T3duU3RhdGljT2JqZWN0UGFpcnMoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSkpO1xuICAgICAgICByZXR1cm4gcGFpcnM7XG4gICAgfSwgW10pO1xufVxuZnVuY3Rpb24gZ2V0QW5jZXN0b3JzRm9yQ29uc3RydWN0b3IoY29uc3RydWN0b3IpIHtcbiAgICBjb25zdCBhbmNlc3RvcnMgPSBbXTtcbiAgICB3aGlsZSAoY29uc3RydWN0b3IpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goY29uc3RydWN0b3IpO1xuICAgICAgICBjb25zdHJ1Y3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBhbmNlc3RvcnMucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gZ2V0T3duU3RhdGljQXJyYXlWYWx1ZXMoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSkge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSBjb25zdHJ1Y3Rvcltwcm9wZXJ0eU5hbWVdO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGRlZmluaXRpb24pID8gZGVmaW5pdGlvbiA6IFtdO1xufVxuZnVuY3Rpb24gZ2V0T3duU3RhdGljT2JqZWN0UGFpcnMoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSkge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSBjb25zdHJ1Y3Rvcltwcm9wZXJ0eU5hbWVdO1xuICAgIHJldHVybiBkZWZpbml0aW9uID8gT2JqZWN0LmtleXMoZGVmaW5pdGlvbikubWFwKChrZXkpID0+IFtrZXksIGRlZmluaXRpb25ba2V5XV0pIDogW107XG59XG5cbmNsYXNzIE91dGxldE9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBkZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLm91dGxldHNCeU5hbWUgPSBuZXcgTXVsdGltYXAoKTtcbiAgICAgICAgdGhpcy5vdXRsZXRFbGVtZW50c0J5TmFtZSA9IG5ldyBNdWx0aW1hcCgpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yT2JzZXJ2ZXJNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXJNYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5vdXRsZXREZWZpbml0aW9ucy5mb3JFYWNoKChvdXRsZXROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR1cFNlbGVjdG9yT2JzZXJ2ZXJGb3JPdXRsZXQob3V0bGV0TmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR1cEF0dHJpYnV0ZU9ic2VydmVyRm9yT3V0bGV0KG91dGxldE5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kZXBlbmRlbnRDb250ZXh0cy5mb3JFYWNoKChjb250ZXh0KSA9PiBjb250ZXh0LnJlZnJlc2goKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rvck9ic2VydmVyTWFwLmZvckVhY2goKG9ic2VydmVyKSA9PiBvYnNlcnZlci5yZWZyZXNoKCkpO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZU9ic2VydmVyTWFwLmZvckVhY2goKG9ic2VydmVyKSA9PiBvYnNlcnZlci5yZWZyZXNoKCkpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbE91dGxldHMoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcFNlbGVjdG9yT2JzZXJ2ZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnN0b3BBdHRyaWJ1dGVPYnNlcnZlcnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wU2VsZWN0b3JPYnNlcnZlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdG9yT2JzZXJ2ZXJNYXAuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JPYnNlcnZlck1hcC5mb3JFYWNoKChvYnNlcnZlcikgPT4gb2JzZXJ2ZXIuc3RvcCgpKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JPYnNlcnZlck1hcC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3BBdHRyaWJ1dGVPYnNlcnZlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZU9ic2VydmVyTWFwLnNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZU9ic2VydmVyTWFwLmZvckVhY2goKG9ic2VydmVyKSA9PiBvYnNlcnZlci5zdG9wKCkpO1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVPYnNlcnZlck1hcC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdG9yTWF0Y2hlZChlbGVtZW50LCBfc2VsZWN0b3IsIHsgb3V0bGV0TmFtZSB9KSB7XG4gICAgICAgIGNvbnN0IG91dGxldCA9IHRoaXMuZ2V0T3V0bGV0KGVsZW1lbnQsIG91dGxldE5hbWUpO1xuICAgICAgICBpZiAob3V0bGV0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RPdXRsZXQob3V0bGV0LCBlbGVtZW50LCBvdXRsZXROYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RvclVubWF0Y2hlZChlbGVtZW50LCBfc2VsZWN0b3IsIHsgb3V0bGV0TmFtZSB9KSB7XG4gICAgICAgIGNvbnN0IG91dGxldCA9IHRoaXMuZ2V0T3V0bGV0RnJvbU1hcChlbGVtZW50LCBvdXRsZXROYW1lKTtcbiAgICAgICAgaWYgKG91dGxldCkge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0T3V0bGV0KG91dGxldCwgZWxlbWVudCwgb3V0bGV0TmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0b3JNYXRjaEVsZW1lbnQoZWxlbWVudCwgeyBvdXRsZXROYW1lIH0pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yKG91dGxldE5hbWUpO1xuICAgICAgICBjb25zdCBoYXNPdXRsZXQgPSB0aGlzLmhhc091dGxldChlbGVtZW50LCBvdXRsZXROYW1lKTtcbiAgICAgICAgY29uc3QgaGFzT3V0bGV0Q29udHJvbGxlciA9IGVsZW1lbnQubWF0Y2hlcyhgWyR7dGhpcy5zY2hlbWEuY29udHJvbGxlckF0dHJpYnV0ZX1+PSR7b3V0bGV0TmFtZX1dYCk7XG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGhhc091dGxldCAmJiBoYXNPdXRsZXRDb250cm9sbGVyICYmIGVsZW1lbnQubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudE1hdGNoZWRBdHRyaWJ1dGUoX2VsZW1lbnQsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgY29uc3Qgb3V0bGV0TmFtZSA9IHRoaXMuZ2V0T3V0bGV0TmFtZUZyb21PdXRsZXRBdHRyaWJ1dGVOYW1lKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBpZiAob3V0bGV0TmFtZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rvck9ic2VydmVyRm9yT3V0bGV0KG91dGxldE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRBdHRyaWJ1dGVWYWx1ZUNoYW5nZWQoX2VsZW1lbnQsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgY29uc3Qgb3V0bGV0TmFtZSA9IHRoaXMuZ2V0T3V0bGV0TmFtZUZyb21PdXRsZXRBdHRyaWJ1dGVOYW1lKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBpZiAob3V0bGV0TmFtZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rvck9ic2VydmVyRm9yT3V0bGV0KG91dGxldE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRVbm1hdGNoZWRBdHRyaWJ1dGUoX2VsZW1lbnQsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgY29uc3Qgb3V0bGV0TmFtZSA9IHRoaXMuZ2V0T3V0bGV0TmFtZUZyb21PdXRsZXRBdHRyaWJ1dGVOYW1lKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBpZiAob3V0bGV0TmFtZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rvck9ic2VydmVyRm9yT3V0bGV0KG91dGxldE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3RPdXRsZXQob3V0bGV0LCBlbGVtZW50LCBvdXRsZXROYW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLm91dGxldEVsZW1lbnRzQnlOYW1lLmhhcyhvdXRsZXROYW1lLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5vdXRsZXRzQnlOYW1lLmFkZChvdXRsZXROYW1lLCBvdXRsZXQpO1xuICAgICAgICAgICAgdGhpcy5vdXRsZXRFbGVtZW50c0J5TmFtZS5hZGQob3V0bGV0TmFtZSwgZWxlbWVudCk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnNlbGVjdG9yT2JzZXJ2ZXJNYXAuZ2V0KG91dGxldE5hbWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF1c2UoKCkgPT4gdGhpcy5kZWxlZ2F0ZS5vdXRsZXRDb25uZWN0ZWQob3V0bGV0LCBlbGVtZW50LCBvdXRsZXROYW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdE91dGxldChvdXRsZXQsIGVsZW1lbnQsIG91dGxldE5hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5vdXRsZXRFbGVtZW50c0J5TmFtZS5oYXMob3V0bGV0TmFtZSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGV0c0J5TmFtZS5kZWxldGUob3V0bGV0TmFtZSwgb3V0bGV0KTtcbiAgICAgICAgICAgIHRoaXMub3V0bGV0RWxlbWVudHNCeU5hbWUuZGVsZXRlKG91dGxldE5hbWUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5zZWxlY3Rvck9ic2VydmVyTWFwXG4gICAgICAgICAgICAgICAgLmdldChvdXRsZXROYW1lKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdXNlKCgpID0+IHRoaXMuZGVsZWdhdGUub3V0bGV0RGlzY29ubmVjdGVkKG91dGxldCwgZWxlbWVudCwgb3V0bGV0TmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RBbGxPdXRsZXRzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IG91dGxldE5hbWUgb2YgdGhpcy5vdXRsZXRFbGVtZW50c0J5TmFtZS5rZXlzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5vdXRsZXRFbGVtZW50c0J5TmFtZS5nZXRWYWx1ZXNGb3JLZXkob3V0bGV0TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG91dGxldCBvZiB0aGlzLm91dGxldHNCeU5hbWUuZ2V0VmFsdWVzRm9yS2V5KG91dGxldE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdE91dGxldChvdXRsZXQsIGVsZW1lbnQsIG91dGxldE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTZWxlY3Rvck9ic2VydmVyRm9yT3V0bGV0KG91dGxldE5hbWUpIHtcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLnNlbGVjdG9yT2JzZXJ2ZXJNYXAuZ2V0KG91dGxldE5hbWUpO1xuICAgICAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcihvdXRsZXROYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXR1cFNlbGVjdG9yT2JzZXJ2ZXJGb3JPdXRsZXQob3V0bGV0TmFtZSkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3Iob3V0bGV0TmFtZSk7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yT2JzZXJ2ZXIgPSBuZXcgU2VsZWN0b3JPYnNlcnZlcihkb2N1bWVudC5ib2R5LCBzZWxlY3RvciwgdGhpcywgeyBvdXRsZXROYW1lIH0pO1xuICAgICAgICB0aGlzLnNlbGVjdG9yT2JzZXJ2ZXJNYXAuc2V0KG91dGxldE5hbWUsIHNlbGVjdG9yT2JzZXJ2ZXIpO1xuICAgICAgICBzZWxlY3Rvck9ic2VydmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIHNldHVwQXR0cmlidXRlT2JzZXJ2ZXJGb3JPdXRsZXQob3V0bGV0TmFtZSkge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gdGhpcy5hdHRyaWJ1dGVOYW1lRm9yT3V0bGV0TmFtZShvdXRsZXROYW1lKTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlT2JzZXJ2ZXIgPSBuZXcgQXR0cmlidXRlT2JzZXJ2ZXIodGhpcy5zY29wZS5lbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCB0aGlzKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVPYnNlcnZlck1hcC5zZXQob3V0bGV0TmFtZSwgYXR0cmlidXRlT2JzZXJ2ZXIpO1xuICAgICAgICBhdHRyaWJ1dGVPYnNlcnZlci5zdGFydCgpO1xuICAgIH1cbiAgICBzZWxlY3RvcihvdXRsZXROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLm91dGxldHMuZ2V0U2VsZWN0b3JGb3JPdXRsZXROYW1lKG91dGxldE5hbWUpO1xuICAgIH1cbiAgICBhdHRyaWJ1dGVOYW1lRm9yT3V0bGV0TmFtZShvdXRsZXROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLnNjaGVtYS5vdXRsZXRBdHRyaWJ1dGVGb3JTY29wZSh0aGlzLmlkZW50aWZpZXIsIG91dGxldE5hbWUpO1xuICAgIH1cbiAgICBnZXRPdXRsZXROYW1lRnJvbU91dGxldEF0dHJpYnV0ZU5hbWUoYXR0cmlidXRlTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRsZXREZWZpbml0aW9ucy5maW5kKChvdXRsZXROYW1lKSA9PiB0aGlzLmF0dHJpYnV0ZU5hbWVGb3JPdXRsZXROYW1lKG91dGxldE5hbWUpID09PSBhdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gICAgZ2V0IG91dGxldERlcGVuZGVuY2llcygpIHtcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gbmV3IE11bHRpbWFwKCk7XG4gICAgICAgIHRoaXMucm91dGVyLm1vZHVsZXMuZm9yRWFjaCgobW9kdWxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IG1vZHVsZS5kZWZpbml0aW9uLmNvbnRyb2xsZXJDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGNvbnN0IG91dGxldHMgPSByZWFkSW5oZXJpdGFibGVTdGF0aWNBcnJheVZhbHVlcyhjb25zdHJ1Y3RvciwgXCJvdXRsZXRzXCIpO1xuICAgICAgICAgICAgb3V0bGV0cy5mb3JFYWNoKChvdXRsZXQpID0+IGRlcGVuZGVuY2llcy5hZGQob3V0bGV0LCBtb2R1bGUuaWRlbnRpZmllcikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgICB9XG4gICAgZ2V0IG91dGxldERlZmluaXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRsZXREZXBlbmRlbmNpZXMuZ2V0S2V5c0ZvclZhbHVlKHRoaXMuaWRlbnRpZmllcik7XG4gICAgfVxuICAgIGdldCBkZXBlbmRlbnRDb250cm9sbGVySWRlbnRpZmllcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGxldERlcGVuZGVuY2llcy5nZXRWYWx1ZXNGb3JLZXkodGhpcy5pZGVudGlmaWVyKTtcbiAgICB9XG4gICAgZ2V0IGRlcGVuZGVudENvbnRleHRzKCkge1xuICAgICAgICBjb25zdCBpZGVudGlmaWVycyA9IHRoaXMuZGVwZW5kZW50Q29udHJvbGxlcklkZW50aWZpZXJzO1xuICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZXIuY29udGV4dHMuZmlsdGVyKChjb250ZXh0KSA9PiBpZGVudGlmaWVycy5pbmNsdWRlcyhjb250ZXh0LmlkZW50aWZpZXIpKTtcbiAgICB9XG4gICAgaGFzT3V0bGV0KGVsZW1lbnQsIG91dGxldE5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRPdXRsZXQoZWxlbWVudCwgb3V0bGV0TmFtZSkgfHwgISF0aGlzLmdldE91dGxldEZyb21NYXAoZWxlbWVudCwgb3V0bGV0TmFtZSk7XG4gICAgfVxuICAgIGdldE91dGxldChlbGVtZW50LCBvdXRsZXROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGxpY2F0aW9uLmdldENvbnRyb2xsZXJGb3JFbGVtZW50QW5kSWRlbnRpZmllcihlbGVtZW50LCBvdXRsZXROYW1lKTtcbiAgICB9XG4gICAgZ2V0T3V0bGV0RnJvbU1hcChlbGVtZW50LCBvdXRsZXROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGxldHNCeU5hbWUuZ2V0VmFsdWVzRm9yS2V5KG91dGxldE5hbWUpLmZpbmQoKG91dGxldCkgPT4gb3V0bGV0LmVsZW1lbnQgPT09IGVsZW1lbnQpO1xuICAgIH1cbiAgICBnZXQgc2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuc2NvcGU7XG4gICAgfVxuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuc2NoZW1hO1xuICAgIH1cbiAgICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5pZGVudGlmaWVyO1xuICAgIH1cbiAgICBnZXQgYXBwbGljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuYXBwbGljYXRpb247XG4gICAgfVxuICAgIGdldCByb3V0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGxpY2F0aW9uLnJvdXRlcjtcbiAgICB9XG59XG5cbmNsYXNzIENvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKG1vZHVsZSwgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5ID0gKGZ1bmN0aW9uTmFtZSwgZGV0YWlsID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaWRlbnRpZmllciwgY29udHJvbGxlciwgZWxlbWVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIGRldGFpbCA9IE9iamVjdC5hc3NpZ24oeyBpZGVudGlmaWVyLCBjb250cm9sbGVyLCBlbGVtZW50IH0sIGRldGFpbCk7XG4gICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uLmxvZ0RlYnVnQWN0aXZpdHkodGhpcy5pZGVudGlmaWVyLCBmdW5jdGlvbk5hbWUsIGRldGFpbCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubW9kdWxlID0gbW9kdWxlO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBtb2R1bGUuY29udHJvbGxlckNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICB0aGlzLmJpbmRpbmdPYnNlcnZlciA9IG5ldyBCaW5kaW5nT2JzZXJ2ZXIodGhpcywgdGhpcy5kaXNwYXRjaGVyKTtcbiAgICAgICAgdGhpcy52YWx1ZU9ic2VydmVyID0gbmV3IFZhbHVlT2JzZXJ2ZXIodGhpcywgdGhpcy5jb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy50YXJnZXRPYnNlcnZlciA9IG5ldyBUYXJnZXRPYnNlcnZlcih0aGlzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vdXRsZXRPYnNlcnZlciA9IG5ldyBPdXRsZXRPYnNlcnZlcih0aGlzLCB0aGlzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5pbml0aWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLmxvZ0RlYnVnQWN0aXZpdHkoXCJpbml0aWFsaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgXCJpbml0aWFsaXppbmcgY29udHJvbGxlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdPYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB0aGlzLnZhbHVlT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgdGhpcy50YXJnZXRPYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB0aGlzLm91dGxldE9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5KFwiY29ubmVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIFwiY29ubmVjdGluZyBjb250cm9sbGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMub3V0bGV0T2JzZXJ2ZXIucmVmcmVzaCgpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMubG9nRGVidWdBY3Rpdml0eShcImRpc2Nvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yLCBcImRpc2Nvbm5lY3RpbmcgY29udHJvbGxlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dGxldE9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy50YXJnZXRPYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHRoaXMudmFsdWVPYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHRoaXMuYmluZGluZ09ic2VydmVyLnN0b3AoKTtcbiAgICB9XG4gICAgZ2V0IGFwcGxpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGUuYXBwbGljYXRpb247XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGUuaWRlbnRpZmllcjtcbiAgICB9XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGljYXRpb24uc2NoZW1hO1xuICAgIH1cbiAgICBnZXQgZGlzcGF0Y2hlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGljYXRpb24uZGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBwYXJlbnRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtZXNzYWdlLCBkZXRhaWwgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGlkZW50aWZpZXIsIGNvbnRyb2xsZXIsIGVsZW1lbnQgfSA9IHRoaXM7XG4gICAgICAgIGRldGFpbCA9IE9iamVjdC5hc3NpZ24oeyBpZGVudGlmaWVyLCBjb250cm9sbGVyLCBlbGVtZW50IH0sIGRldGFpbCk7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24uaGFuZGxlRXJyb3IoZXJyb3IsIGBFcnJvciAke21lc3NhZ2V9YCwgZGV0YWlsKTtcbiAgICB9XG4gICAgdGFyZ2V0Q29ubmVjdGVkKGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5pbnZva2VDb250cm9sbGVyTWV0aG9kKGAke25hbWV9VGFyZ2V0Q29ubmVjdGVkYCwgZWxlbWVudCk7XG4gICAgfVxuICAgIHRhcmdldERpc2Nvbm5lY3RlZChlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIHRoaXMuaW52b2tlQ29udHJvbGxlck1ldGhvZChgJHtuYW1lfVRhcmdldERpc2Nvbm5lY3RlZGAsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBvdXRsZXRDb25uZWN0ZWQob3V0bGV0LCBlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIHRoaXMuaW52b2tlQ29udHJvbGxlck1ldGhvZChgJHtuYW1lc3BhY2VDYW1lbGl6ZShuYW1lKX1PdXRsZXRDb25uZWN0ZWRgLCBvdXRsZXQsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBvdXRsZXREaXNjb25uZWN0ZWQob3V0bGV0LCBlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIHRoaXMuaW52b2tlQ29udHJvbGxlck1ldGhvZChgJHtuYW1lc3BhY2VDYW1lbGl6ZShuYW1lKX1PdXRsZXREaXNjb25uZWN0ZWRgLCBvdXRsZXQsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBpbnZva2VDb250cm9sbGVyTWV0aG9kKG1ldGhvZE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY29udHJvbGxlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250cm9sbGVyW21ldGhvZE5hbWVdID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29udHJvbGxlclttZXRob2ROYW1lXSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYmxlc3MoY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gc2hhZG93KGNvbnN0cnVjdG9yLCBnZXRCbGVzc2VkUHJvcGVydGllcyhjb25zdHJ1Y3RvcikpO1xufVxuZnVuY3Rpb24gc2hhZG93KGNvbnN0cnVjdG9yLCBwcm9wZXJ0aWVzKSB7XG4gICAgY29uc3Qgc2hhZG93Q29uc3RydWN0b3IgPSBleHRlbmQoY29uc3RydWN0b3IpO1xuICAgIGNvbnN0IHNoYWRvd1Byb3BlcnRpZXMgPSBnZXRTaGFkb3dQcm9wZXJ0aWVzKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2hhZG93Q29uc3RydWN0b3IucHJvdG90eXBlLCBzaGFkb3dQcm9wZXJ0aWVzKTtcbiAgICByZXR1cm4gc2hhZG93Q29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBnZXRCbGVzc2VkUHJvcGVydGllcyhjb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGJsZXNzaW5ncyA9IHJlYWRJbmhlcml0YWJsZVN0YXRpY0FycmF5VmFsdWVzKGNvbnN0cnVjdG9yLCBcImJsZXNzaW5nc1wiKTtcbiAgICByZXR1cm4gYmxlc3NpbmdzLnJlZHVjZSgoYmxlc3NlZFByb3BlcnRpZXMsIGJsZXNzaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBibGVzc2luZyhjb25zdHJ1Y3Rvcik7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBibGVzc2VkUHJvcGVydGllc1trZXldIHx8IHt9O1xuICAgICAgICAgICAgYmxlc3NlZFByb3BlcnRpZXNba2V5XSA9IE9iamVjdC5hc3NpZ24oZGVzY3JpcHRvciwgcHJvcGVydGllc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxlc3NlZFByb3BlcnRpZXM7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gZ2V0U2hhZG93UHJvcGVydGllcyhwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gZ2V0T3duS2V5cyhwcm9wZXJ0aWVzKS5yZWR1Y2UoKHNoYWRvd1Byb3BlcnRpZXMsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gZ2V0U2hhZG93ZWREZXNjcmlwdG9yKHByb3RvdHlwZSwgcHJvcGVydGllcywga2V5KTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2hhZG93UHJvcGVydGllcywgeyBba2V5XTogZGVzY3JpcHRvciB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2hhZG93UHJvcGVydGllcztcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRTaGFkb3dlZERlc2NyaXB0b3IocHJvdG90eXBlLCBwcm9wZXJ0aWVzLCBrZXkpIHtcbiAgICBjb25zdCBzaGFkb3dpbmdEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90b3R5cGUsIGtleSk7XG4gICAgY29uc3Qgc2hhZG93ZWRCeVZhbHVlID0gc2hhZG93aW5nRGVzY3JpcHRvciAmJiBcInZhbHVlXCIgaW4gc2hhZG93aW5nRGVzY3JpcHRvcjtcbiAgICBpZiAoIXNoYWRvd2VkQnlWYWx1ZSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm9wZXJ0aWVzLCBrZXkpLnZhbHVlO1xuICAgICAgICBpZiAoc2hhZG93aW5nRGVzY3JpcHRvcikge1xuICAgICAgICAgICAgZGVzY3JpcHRvci5nZXQgPSBzaGFkb3dpbmdEZXNjcmlwdG9yLmdldCB8fCBkZXNjcmlwdG9yLmdldDtcbiAgICAgICAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gc2hhZG93aW5nRGVzY3JpcHRvci5zZXQgfHwgZGVzY3JpcHRvci5zZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfVxufVxuY29uc3QgZ2V0T3duS2V5cyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gKG9iamVjdCkgPT4gWy4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCksIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gICAgfVxufSkoKTtcbmNvbnN0IGV4dGVuZCA9ICgoKSA9PiB7XG4gICAgZnVuY3Rpb24gZXh0ZW5kV2l0aFJlZmxlY3QoY29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gZXh0ZW5kZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QoY29uc3RydWN0b3IsIGFyZ3VtZW50cywgbmV3LnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5kZWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBleHRlbmRlZCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgUmVmbGVjdC5zZXRQcm90b3R5cGVPZihleHRlbmRlZCwgY29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gZXh0ZW5kZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RSZWZsZWN0RXh0ZW5zaW9uKCkge1xuICAgICAgICBjb25zdCBhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hLmNhbGwodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGIgPSBleHRlbmRXaXRoUmVmbGVjdChhKTtcbiAgICAgICAgYi5wcm90b3R5cGUuYSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBiKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHRlc3RSZWZsZWN0RXh0ZW5zaW9uKCk7XG4gICAgICAgIHJldHVybiBleHRlbmRXaXRoUmVmbGVjdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiAoY29uc3RydWN0b3IpID0+IGNsYXNzIGV4dGVuZGVkIGV4dGVuZHMgY29uc3RydWN0b3Ige1xuICAgICAgICB9O1xuICAgIH1cbn0pKCk7XG5cbmZ1bmN0aW9uIGJsZXNzRGVmaW5pdGlvbihkZWZpbml0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWRlbnRpZmllcjogZGVmaW5pdGlvbi5pZGVudGlmaWVyLFxuICAgICAgICBjb250cm9sbGVyQ29uc3RydWN0b3I6IGJsZXNzKGRlZmluaXRpb24uY29udHJvbGxlckNvbnN0cnVjdG9yKSxcbiAgICB9O1xufVxuXG5jbGFzcyBNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcGxpY2F0aW9uLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24gPSBhcHBsaWNhdGlvbjtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uID0gYmxlc3NEZWZpbml0aW9uKGRlZmluaXRpb24pO1xuICAgICAgICB0aGlzLmNvbnRleHRzQnlTY29wZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkQ29udGV4dHMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uLmlkZW50aWZpZXI7XG4gICAgfVxuICAgIGdldCBjb250cm9sbGVyQ29uc3RydWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmluaXRpb24uY29udHJvbGxlckNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBnZXQgY29udGV4dHMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY29ubmVjdGVkQ29udGV4dHMpO1xuICAgIH1cbiAgICBjb25uZWN0Q29udGV4dEZvclNjb3BlKHNjb3BlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmZldGNoQ29udGV4dEZvclNjb3BlKHNjb3BlKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRDb250ZXh0cy5hZGQoY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQuY29ubmVjdCgpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0Q29udGV4dEZvclNjb3BlKHNjb3BlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRzQnlTY29wZS5nZXQoc2NvcGUpO1xuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWRDb250ZXh0cy5kZWxldGUoY29udGV4dCk7XG4gICAgICAgICAgICBjb250ZXh0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmZXRjaENvbnRleHRGb3JTY29wZShzY29wZSkge1xuICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMuY29udGV4dHNCeVNjb3BlLmdldChzY29wZSk7XG4gICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dCA9IG5ldyBDb250ZXh0KHRoaXMsIHNjb3BlKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHNCeVNjb3BlLnNldChzY29wZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxufVxuXG5jbGFzcyBDbGFzc01hcCB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGUpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIH1cbiAgICBoYXMobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmhhcyh0aGlzLmdldERhdGFLZXkobmFtZSkpO1xuICAgIH1cbiAgICBnZXQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGwobmFtZSlbMF07XG4gICAgfVxuICAgIGdldEFsbChuYW1lKSB7XG4gICAgICAgIGNvbnN0IHRva2VuU3RyaW5nID0gdGhpcy5kYXRhLmdldCh0aGlzLmdldERhdGFLZXkobmFtZSkpIHx8IFwiXCI7XG4gICAgICAgIHJldHVybiB0b2tlbml6ZSh0b2tlblN0cmluZyk7XG4gICAgfVxuICAgIGdldEF0dHJpYnV0ZU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmdldEF0dHJpYnV0ZU5hbWVGb3JLZXkodGhpcy5nZXREYXRhS2V5KG5hbWUpKTtcbiAgICB9XG4gICAgZ2V0RGF0YUtleShuYW1lKSB7XG4gICAgICAgIHJldHVybiBgJHtuYW1lfS1jbGFzc2A7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5kYXRhO1xuICAgIH1cbn1cblxuY2xhc3MgRGF0YU1hcCB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGUpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmlkZW50aWZpZXI7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlTmFtZUZvcktleShrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlTmFtZUZvcktleShrZXkpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlTmFtZUZvcktleShrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlTmFtZUZvcktleShrZXkpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEF0dHJpYnV0ZU5hbWVGb3JLZXkoa2V5KSB7XG4gICAgICAgIHJldHVybiBgZGF0YS0ke3RoaXMuaWRlbnRpZmllcn0tJHtkYXNoZXJpemUoa2V5KX1gO1xuICAgIH1cbn1cblxuY2xhc3MgR3VpZGUge1xuICAgIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgICAgICB0aGlzLndhcm5lZEtleXNCeU9iamVjdCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cbiAgICB3YXJuKG9iamVjdCwga2V5LCBtZXNzYWdlKSB7XG4gICAgICAgIGxldCB3YXJuZWRLZXlzID0gdGhpcy53YXJuZWRLZXlzQnlPYmplY3QuZ2V0KG9iamVjdCk7XG4gICAgICAgIGlmICghd2FybmVkS2V5cykge1xuICAgICAgICAgICAgd2FybmVkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHRoaXMud2FybmVkS2V5c0J5T2JqZWN0LnNldChvYmplY3QsIHdhcm5lZEtleXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd2FybmVkS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgd2FybmVkS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4obWVzc2FnZSwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYXR0cmlidXRlVmFsdWVDb250YWluc1Rva2VuKGF0dHJpYnV0ZU5hbWUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGBbJHthdHRyaWJ1dGVOYW1lfX49XCIke3Rva2VufVwiXWA7XG59XG5cbmNsYXNzIFRhcmdldFNldCB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGUpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmlkZW50aWZpZXI7XG4gICAgfVxuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLnNjaGVtYTtcbiAgICB9XG4gICAgaGFzKHRhcmdldE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZCh0YXJnZXROYW1lKSAhPSBudWxsO1xuICAgIH1cbiAgICBmaW5kKC4uLnRhcmdldE5hbWVzKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXROYW1lcy5yZWR1Y2UoKHRhcmdldCwgdGFyZ2V0TmFtZSkgPT4gdGFyZ2V0IHx8IHRoaXMuZmluZFRhcmdldCh0YXJnZXROYW1lKSB8fCB0aGlzLmZpbmRMZWdhY3lUYXJnZXQodGFyZ2V0TmFtZSksIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGZpbmRBbGwoLi4udGFyZ2V0TmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldE5hbWVzLnJlZHVjZSgodGFyZ2V0cywgdGFyZ2V0TmFtZSkgPT4gW1xuICAgICAgICAgICAgLi4udGFyZ2V0cyxcbiAgICAgICAgICAgIC4uLnRoaXMuZmluZEFsbFRhcmdldHModGFyZ2V0TmFtZSksXG4gICAgICAgICAgICAuLi50aGlzLmZpbmRBbGxMZWdhY3lUYXJnZXRzKHRhcmdldE5hbWUpLFxuICAgICAgICBdLCBbXSk7XG4gICAgfVxuICAgIGZpbmRUYXJnZXQodGFyZ2V0TmFtZSkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuZ2V0U2VsZWN0b3JGb3JUYXJnZXROYW1lKHRhcmdldE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5maW5kRWxlbWVudChzZWxlY3Rvcik7XG4gICAgfVxuICAgIGZpbmRBbGxUYXJnZXRzKHRhcmdldE5hbWUpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSB0aGlzLmdldFNlbGVjdG9yRm9yVGFyZ2V0TmFtZSh0YXJnZXROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZmluZEFsbEVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgZ2V0U2VsZWN0b3JGb3JUYXJnZXROYW1lKHRhcmdldE5hbWUpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMuc2NoZW1hLnRhcmdldEF0dHJpYnV0ZUZvclNjb3BlKHRoaXMuaWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZUNvbnRhaW5zVG9rZW4oYXR0cmlidXRlTmFtZSwgdGFyZ2V0TmFtZSk7XG4gICAgfVxuICAgIGZpbmRMZWdhY3lUYXJnZXQodGFyZ2V0TmFtZSkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuZ2V0TGVnYWN5U2VsZWN0b3JGb3JUYXJnZXROYW1lKHRhcmdldE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGUodGhpcy5zY29wZS5maW5kRWxlbWVudChzZWxlY3RvciksIHRhcmdldE5hbWUpO1xuICAgIH1cbiAgICBmaW5kQWxsTGVnYWN5VGFyZ2V0cyh0YXJnZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gdGhpcy5nZXRMZWdhY3lTZWxlY3RvckZvclRhcmdldE5hbWUodGFyZ2V0TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmZpbmRBbGxFbGVtZW50cyhzZWxlY3RvcikubWFwKChlbGVtZW50KSA9PiB0aGlzLmRlcHJlY2F0ZShlbGVtZW50LCB0YXJnZXROYW1lKSk7XG4gICAgfVxuICAgIGdldExlZ2FjeVNlbGVjdG9yRm9yVGFyZ2V0TmFtZSh0YXJnZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldERlc2NyaXB0b3IgPSBgJHt0aGlzLmlkZW50aWZpZXJ9LiR7dGFyZ2V0TmFtZX1gO1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWVDb250YWluc1Rva2VuKHRoaXMuc2NoZW1hLnRhcmdldEF0dHJpYnV0ZSwgdGFyZ2V0RGVzY3JpcHRvcik7XG4gICAgfVxuICAgIGRlcHJlY2F0ZShlbGVtZW50LCB0YXJnZXROYW1lKSB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IGlkZW50aWZpZXIgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gdGhpcy5zY2hlbWEudGFyZ2V0QXR0cmlidXRlO1xuICAgICAgICAgICAgY29uc3QgcmV2aXNlZEF0dHJpYnV0ZU5hbWUgPSB0aGlzLnNjaGVtYS50YXJnZXRBdHRyaWJ1dGVGb3JTY29wZShpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIHRoaXMuZ3VpZGUud2FybihlbGVtZW50LCBgdGFyZ2V0OiR7dGFyZ2V0TmFtZX1gLCBgUGxlYXNlIHJlcGxhY2UgJHthdHRyaWJ1dGVOYW1lfT1cIiR7aWRlbnRpZmllcn0uJHt0YXJnZXROYW1lfVwiIHdpdGggJHtyZXZpc2VkQXR0cmlidXRlTmFtZX09XCIke3RhcmdldE5hbWV9XCIuIGAgK1xuICAgICAgICAgICAgICAgIGBUaGUgJHthdHRyaWJ1dGVOYW1lfSBhdHRyaWJ1dGUgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgU3RpbXVsdXMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBndWlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZ3VpZGU7XG4gICAgfVxufVxuXG5jbGFzcyBPdXRsZXRTZXQge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlLCBjb250cm9sbGVyRWxlbWVudCkge1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuY29udHJvbGxlckVsZW1lbnQgPSBjb250cm9sbGVyRWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5pZGVudGlmaWVyO1xuICAgIH1cbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5zY2hlbWE7XG4gICAgfVxuICAgIGhhcyhvdXRsZXROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmQob3V0bGV0TmFtZSkgIT0gbnVsbDtcbiAgICB9XG4gICAgZmluZCguLi5vdXRsZXROYW1lcykge1xuICAgICAgICByZXR1cm4gb3V0bGV0TmFtZXMucmVkdWNlKChvdXRsZXQsIG91dGxldE5hbWUpID0+IG91dGxldCB8fCB0aGlzLmZpbmRPdXRsZXQob3V0bGV0TmFtZSksIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGZpbmRBbGwoLi4ub3V0bGV0TmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIG91dGxldE5hbWVzLnJlZHVjZSgob3V0bGV0cywgb3V0bGV0TmFtZSkgPT4gWy4uLm91dGxldHMsIC4uLnRoaXMuZmluZEFsbE91dGxldHMob3V0bGV0TmFtZSldLCBbXSk7XG4gICAgfVxuICAgIGdldFNlbGVjdG9yRm9yT3V0bGV0TmFtZShvdXRsZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLnNjaGVtYS5vdXRsZXRBdHRyaWJ1dGVGb3JTY29wZSh0aGlzLmlkZW50aWZpZXIsIG91dGxldE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sbGVyRWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgfVxuICAgIGZpbmRPdXRsZXQob3V0bGV0TmFtZSkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuZ2V0U2VsZWN0b3JGb3JPdXRsZXROYW1lKG91dGxldE5hbWUpO1xuICAgICAgICBpZiAoc2VsZWN0b3IpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kRWxlbWVudChzZWxlY3Rvciwgb3V0bGV0TmFtZSk7XG4gICAgfVxuICAgIGZpbmRBbGxPdXRsZXRzKG91dGxldE5hbWUpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSB0aGlzLmdldFNlbGVjdG9yRm9yT3V0bGV0TmFtZShvdXRsZXROYW1lKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yID8gdGhpcy5maW5kQWxsRWxlbWVudHMoc2VsZWN0b3IsIG91dGxldE5hbWUpIDogW107XG4gICAgfVxuICAgIGZpbmRFbGVtZW50KHNlbGVjdG9yLCBvdXRsZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5zY29wZS5xdWVyeUVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcigoZWxlbWVudCkgPT4gdGhpcy5tYXRjaGVzRWxlbWVudChlbGVtZW50LCBzZWxlY3Rvciwgb3V0bGV0TmFtZSkpWzBdO1xuICAgIH1cbiAgICBmaW5kQWxsRWxlbWVudHMoc2VsZWN0b3IsIG91dGxldE5hbWUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnNjb3BlLnF1ZXJ5RWxlbWVudHMoc2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHMuZmlsdGVyKChlbGVtZW50KSA9PiB0aGlzLm1hdGNoZXNFbGVtZW50KGVsZW1lbnQsIHNlbGVjdG9yLCBvdXRsZXROYW1lKSk7XG4gICAgfVxuICAgIG1hdGNoZXNFbGVtZW50KGVsZW1lbnQsIHNlbGVjdG9yLCBvdXRsZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXJBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSh0aGlzLnNjb3BlLnNjaGVtYS5jb250cm9sbGVyQXR0cmlidXRlKSB8fCBcIlwiO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSAmJiBjb250cm9sbGVyQXR0cmlidXRlLnNwbGl0KFwiIFwiKS5pbmNsdWRlcyhvdXRsZXROYW1lKTtcbiAgICB9XG59XG5cbmNsYXNzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIGVsZW1lbnQsIGlkZW50aWZpZXIsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLnRhcmdldHMgPSBuZXcgVGFyZ2V0U2V0KHRoaXMpO1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSBuZXcgQ2xhc3NNYXAodGhpcyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhTWFwKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbnRhaW5zRWxlbWVudCA9IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5jbG9zZXN0KHRoaXMuY29udHJvbGxlclNlbGVjdG9yKSA9PT0gdGhpcy5lbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5ndWlkZSA9IG5ldyBHdWlkZShsb2dnZXIpO1xuICAgICAgICB0aGlzLm91dGxldHMgPSBuZXcgT3V0bGV0U2V0KHRoaXMuZG9jdW1lbnRTY29wZSwgZWxlbWVudCk7XG4gICAgfVxuICAgIGZpbmRFbGVtZW50KHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikgPyB0aGlzLmVsZW1lbnQgOiB0aGlzLnF1ZXJ5RWxlbWVudHMoc2VsZWN0b3IpLmZpbmQodGhpcy5jb250YWluc0VsZW1lbnQpO1xuICAgIH1cbiAgICBmaW5kQWxsRWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLih0aGlzLmVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikgPyBbdGhpcy5lbGVtZW50XSA6IFtdKSxcbiAgICAgICAgICAgIC4uLnRoaXMucXVlcnlFbGVtZW50cyhzZWxlY3RvcikuZmlsdGVyKHRoaXMuY29udGFpbnNFbGVtZW50KSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcXVlcnlFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgIH1cbiAgICBnZXQgY29udHJvbGxlclNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWVDb250YWluc1Rva2VuKHRoaXMuc2NoZW1hLmNvbnRyb2xsZXJBdHRyaWJ1dGUsIHRoaXMuaWRlbnRpZmllcik7XG4gICAgfVxuICAgIGdldCBpc0RvY3VtZW50U2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGRvY3VtZW50U2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRG9jdW1lbnRTY29wZVxuICAgICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgICA6IG5ldyBTY29wZSh0aGlzLnNjaGVtYSwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLmlkZW50aWZpZXIsIHRoaXMuZ3VpZGUubG9nZ2VyKTtcbiAgICB9XG59XG5cbmNsYXNzIFNjb3BlT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHNjaGVtYSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy52YWx1ZUxpc3RPYnNlcnZlciA9IG5ldyBWYWx1ZUxpc3RPYnNlcnZlcih0aGlzLmVsZW1lbnQsIHRoaXMuY29udHJvbGxlckF0dHJpYnV0ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuc2NvcGVzQnlJZGVudGlmaWVyQnlFbGVtZW50ID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5zY29wZVJlZmVyZW5jZUNvdW50cyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnZhbHVlTGlzdE9ic2VydmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMudmFsdWVMaXN0T2JzZXJ2ZXIuc3RvcCgpO1xuICAgIH1cbiAgICBnZXQgY29udHJvbGxlckF0dHJpYnV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hLmNvbnRyb2xsZXJBdHRyaWJ1dGU7XG4gICAgfVxuICAgIHBhcnNlVmFsdWVGb3JUb2tlbih0b2tlbikge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIGNvbnRlbnQ6IGlkZW50aWZpZXIgfSA9IHRva2VuO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhbHVlRm9yRWxlbWVudEFuZElkZW50aWZpZXIoZWxlbWVudCwgaWRlbnRpZmllcik7XG4gICAgfVxuICAgIHBhcnNlVmFsdWVGb3JFbGVtZW50QW5kSWRlbnRpZmllcihlbGVtZW50LCBpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IHNjb3Blc0J5SWRlbnRpZmllciA9IHRoaXMuZmV0Y2hTY29wZXNCeUlkZW50aWZpZXJGb3JFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBsZXQgc2NvcGUgPSBzY29wZXNCeUlkZW50aWZpZXIuZ2V0KGlkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIXNjb3BlKSB7XG4gICAgICAgICAgICBzY29wZSA9IHRoaXMuZGVsZWdhdGUuY3JlYXRlU2NvcGVGb3JFbGVtZW50QW5kSWRlbnRpZmllcihlbGVtZW50LCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIHNjb3Blc0J5SWRlbnRpZmllci5zZXQoaWRlbnRpZmllciwgc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG4gICAgZWxlbWVudE1hdGNoZWRWYWx1ZShlbGVtZW50LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VDb3VudCA9ICh0aGlzLnNjb3BlUmVmZXJlbmNlQ291bnRzLmdldCh2YWx1ZSkgfHwgMCkgKyAxO1xuICAgICAgICB0aGlzLnNjb3BlUmVmZXJlbmNlQ291bnRzLnNldCh2YWx1ZSwgcmVmZXJlbmNlQ291bnQpO1xuICAgICAgICBpZiAocmVmZXJlbmNlQ291bnQgPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zY29wZUNvbm5lY3RlZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudFVubWF0Y2hlZFZhbHVlKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUNvdW50ID0gdGhpcy5zY29wZVJlZmVyZW5jZUNvdW50cy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAocmVmZXJlbmNlQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVSZWZlcmVuY2VDb3VudHMuc2V0KHZhbHVlLCByZWZlcmVuY2VDb3VudCAtIDEpO1xuICAgICAgICAgICAgaWYgKHJlZmVyZW5jZUNvdW50ID09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnNjb3BlRGlzY29ubmVjdGVkKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmZXRjaFNjb3Blc0J5SWRlbnRpZmllckZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBsZXQgc2NvcGVzQnlJZGVudGlmaWVyID0gdGhpcy5zY29wZXNCeUlkZW50aWZpZXJCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoIXNjb3Blc0J5SWRlbnRpZmllcikge1xuICAgICAgICAgICAgc2NvcGVzQnlJZGVudGlmaWVyID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5zY29wZXNCeUlkZW50aWZpZXJCeUVsZW1lbnQuc2V0KGVsZW1lbnQsIHNjb3Blc0J5SWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3Blc0J5SWRlbnRpZmllcjtcbiAgICB9XG59XG5cbmNsYXNzIFJvdXRlciB7XG4gICAgY29uc3RydWN0b3IoYXBwbGljYXRpb24pIHtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbiA9IGFwcGxpY2F0aW9uO1xuICAgICAgICB0aGlzLnNjb3BlT2JzZXJ2ZXIgPSBuZXcgU2NvcGVPYnNlcnZlcih0aGlzLmVsZW1lbnQsIHRoaXMuc2NoZW1hLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zY29wZXNCeUlkZW50aWZpZXIgPSBuZXcgTXVsdGltYXAoKTtcbiAgICAgICAgdGhpcy5tb2R1bGVzQnlJZGVudGlmaWVyID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGljYXRpb24uZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGljYXRpb24uc2NoZW1hO1xuICAgIH1cbiAgICBnZXQgbG9nZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBsaWNhdGlvbi5sb2dnZXI7XG4gICAgfVxuICAgIGdldCBjb250cm9sbGVyQXR0cmlidXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWEuY29udHJvbGxlckF0dHJpYnV0ZTtcbiAgICB9XG4gICAgZ2V0IG1vZHVsZXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubW9kdWxlc0J5SWRlbnRpZmllci52YWx1ZXMoKSk7XG4gICAgfVxuICAgIGdldCBjb250ZXh0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kdWxlcy5yZWR1Y2UoKGNvbnRleHRzLCBtb2R1bGUpID0+IGNvbnRleHRzLmNvbmNhdChtb2R1bGUuY29udGV4dHMpLCBbXSk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnNjb3BlT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5zY29wZU9ic2VydmVyLnN0b3AoKTtcbiAgICB9XG4gICAgbG9hZERlZmluaXRpb24oZGVmaW5pdGlvbikge1xuICAgICAgICB0aGlzLnVubG9hZElkZW50aWZpZXIoZGVmaW5pdGlvbi5pZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gbmV3IE1vZHVsZSh0aGlzLmFwcGxpY2F0aW9uLCBkZWZpbml0aW9uKTtcbiAgICAgICAgdGhpcy5jb25uZWN0TW9kdWxlKG1vZHVsZSk7XG4gICAgICAgIGNvbnN0IGFmdGVyTG9hZCA9IGRlZmluaXRpb24uY29udHJvbGxlckNvbnN0cnVjdG9yLmFmdGVyTG9hZDtcbiAgICAgICAgaWYgKGFmdGVyTG9hZCkge1xuICAgICAgICAgICAgYWZ0ZXJMb2FkLmNhbGwoZGVmaW5pdGlvbi5jb250cm9sbGVyQ29uc3RydWN0b3IsIGRlZmluaXRpb24uaWRlbnRpZmllciwgdGhpcy5hcHBsaWNhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5sb2FkSWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMubW9kdWxlc0J5SWRlbnRpZmllci5nZXQoaWRlbnRpZmllcik7XG4gICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdE1vZHVsZShtb2R1bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENvbnRleHRGb3JFbGVtZW50QW5kSWRlbnRpZmllcihlbGVtZW50LCBpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMubW9kdWxlc0J5SWRlbnRpZmllci5nZXQoaWRlbnRpZmllcik7XG4gICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGUuY29udGV4dHMuZmluZCgoY29udGV4dCkgPT4gY29udGV4dC5lbGVtZW50ID09IGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3Bvc2VUb0Nvbm5lY3RTY29wZUZvckVsZW1lbnRBbmRJZGVudGlmaWVyKGVsZW1lbnQsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlT2JzZXJ2ZXIucGFyc2VWYWx1ZUZvckVsZW1lbnRBbmRJZGVudGlmaWVyKGVsZW1lbnQsIGlkZW50aWZpZXIpO1xuICAgICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVPYnNlcnZlci5lbGVtZW50TWF0Y2hlZFZhbHVlKHNjb3BlLmVsZW1lbnQsIHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkbid0IGZpbmQgb3IgY3JlYXRlIHNjb3BlIGZvciBpZGVudGlmaWVyOiBcIiR7aWRlbnRpZmllcn1cIiBhbmQgZWxlbWVudDpgLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlcnJvciwgbWVzc2FnZSwgZGV0YWlsKSB7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24uaGFuZGxlRXJyb3IoZXJyb3IsIG1lc3NhZ2UsIGRldGFpbCk7XG4gICAgfVxuICAgIGNyZWF0ZVNjb3BlRm9yRWxlbWVudEFuZElkZW50aWZpZXIoZWxlbWVudCwgaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMuc2NoZW1hLCBlbGVtZW50LCBpZGVudGlmaWVyLCB0aGlzLmxvZ2dlcik7XG4gICAgfVxuICAgIHNjb3BlQ29ubmVjdGVkKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuc2NvcGVzQnlJZGVudGlmaWVyLmFkZChzY29wZS5pZGVudGlmaWVyLCBzY29wZSk7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMubW9kdWxlc0J5SWRlbnRpZmllci5nZXQoc2NvcGUuaWRlbnRpZmllcik7XG4gICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICAgIG1vZHVsZS5jb25uZWN0Q29udGV4dEZvclNjb3BlKHNjb3BlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY29wZURpc2Nvbm5lY3RlZChzY29wZSkge1xuICAgICAgICB0aGlzLnNjb3Blc0J5SWRlbnRpZmllci5kZWxldGUoc2NvcGUuaWRlbnRpZmllciwgc2NvcGUpO1xuICAgICAgICBjb25zdCBtb2R1bGUgPSB0aGlzLm1vZHVsZXNCeUlkZW50aWZpZXIuZ2V0KHNjb3BlLmlkZW50aWZpZXIpO1xuICAgICAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgICAgICBtb2R1bGUuZGlzY29ubmVjdENvbnRleHRGb3JTY29wZShzY29wZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdE1vZHVsZShtb2R1bGUpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzQnlJZGVudGlmaWVyLnNldChtb2R1bGUuaWRlbnRpZmllciwgbW9kdWxlKTtcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gdGhpcy5zY29wZXNCeUlkZW50aWZpZXIuZ2V0VmFsdWVzRm9yS2V5KG1vZHVsZS5pZGVudGlmaWVyKTtcbiAgICAgICAgc2NvcGVzLmZvckVhY2goKHNjb3BlKSA9PiBtb2R1bGUuY29ubmVjdENvbnRleHRGb3JTY29wZShzY29wZSkpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0TW9kdWxlKG1vZHVsZSkge1xuICAgICAgICB0aGlzLm1vZHVsZXNCeUlkZW50aWZpZXIuZGVsZXRlKG1vZHVsZS5pZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gdGhpcy5zY29wZXNCeUlkZW50aWZpZXIuZ2V0VmFsdWVzRm9yS2V5KG1vZHVsZS5pZGVudGlmaWVyKTtcbiAgICAgICAgc2NvcGVzLmZvckVhY2goKHNjb3BlKSA9PiBtb2R1bGUuZGlzY29ubmVjdENvbnRleHRGb3JTY29wZShzY29wZSkpO1xuICAgIH1cbn1cblxuY29uc3QgZGVmYXVsdFNjaGVtYSA9IHtcbiAgICBjb250cm9sbGVyQXR0cmlidXRlOiBcImRhdGEtY29udHJvbGxlclwiLFxuICAgIGFjdGlvbkF0dHJpYnV0ZTogXCJkYXRhLWFjdGlvblwiLFxuICAgIHRhcmdldEF0dHJpYnV0ZTogXCJkYXRhLXRhcmdldFwiLFxuICAgIHRhcmdldEF0dHJpYnV0ZUZvclNjb3BlOiAoaWRlbnRpZmllcikgPT4gYGRhdGEtJHtpZGVudGlmaWVyfS10YXJnZXRgLFxuICAgIG91dGxldEF0dHJpYnV0ZUZvclNjb3BlOiAoaWRlbnRpZmllciwgb3V0bGV0KSA9PiBgZGF0YS0ke2lkZW50aWZpZXJ9LSR7b3V0bGV0fS1vdXRsZXRgLFxuICAgIGtleU1hcHBpbmdzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBlbnRlcjogXCJFbnRlclwiLCB0YWI6IFwiVGFiXCIsIGVzYzogXCJFc2NhcGVcIiwgc3BhY2U6IFwiIFwiLCB1cDogXCJBcnJvd1VwXCIsIGRvd246IFwiQXJyb3dEb3duXCIsIGxlZnQ6IFwiQXJyb3dMZWZ0XCIsIHJpZ2h0OiBcIkFycm93UmlnaHRcIiwgaG9tZTogXCJIb21lXCIsIGVuZDogXCJFbmRcIiwgcGFnZV91cDogXCJQYWdlVXBcIiwgcGFnZV9kb3duOiBcIlBhZ2VEb3duXCIgfSwgb2JqZWN0RnJvbUVudHJpZXMoXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4gW2MsIGNdKSkpLCBvYmplY3RGcm9tRW50cmllcyhcIjAxMjM0NTY3ODlcIi5zcGxpdChcIlwiKS5tYXAoKG4pID0+IFtuLCBuXSkpKSxcbn07XG5mdW5jdGlvbiBvYmplY3RGcm9tRW50cmllcyhhcnJheSkge1xuICAgIHJldHVybiBhcnJheS5yZWR1Y2UoKG1lbW8sIFtrLCB2XSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWVtbyksIHsgW2tdOiB2IH0pKSwge30pO1xufVxuXG5jbGFzcyBBcHBsaWNhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgc2NoZW1hID0gZGVmYXVsdFNjaGVtYSkge1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGNvbnNvbGU7XG4gICAgICAgIHRoaXMuZGVidWcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5ID0gKGlkZW50aWZpZXIsIGZ1bmN0aW9uTmFtZSwgZGV0YWlsID0ge30pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dGb3JtYXR0ZWRNZXNzYWdlKGlkZW50aWZpZXIsIGZ1bmN0aW9uTmFtZSwgZGV0YWlsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnJvdXRlciA9IG5ldyBSb3V0ZXIodGhpcyk7XG4gICAgICAgIHRoaXMuYWN0aW9uRGVzY3JpcHRvckZpbHRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0QWN0aW9uRGVzY3JpcHRvckZpbHRlcnMpO1xuICAgIH1cbiAgICBzdGF0aWMgc3RhcnQoZWxlbWVudCwgc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGFwcGxpY2F0aW9uID0gbmV3IHRoaXMoZWxlbWVudCwgc2NoZW1hKTtcbiAgICAgICAgYXBwbGljYXRpb24uc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIGFwcGxpY2F0aW9uO1xuICAgIH1cbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgYXdhaXQgZG9tUmVhZHkoKTtcbiAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5KFwiYXBwbGljYXRpb25cIiwgXCJzdGFydGluZ1wiKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMucm91dGVyLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMubG9nRGVidWdBY3Rpdml0eShcImFwcGxpY2F0aW9uXCIsIFwic3RhcnRcIik7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMubG9nRGVidWdBY3Rpdml0eShcImFwcGxpY2F0aW9uXCIsIFwic3RvcHBpbmdcIik7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5zdG9wKCk7XG4gICAgICAgIHRoaXMucm91dGVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5KFwiYXBwbGljYXRpb25cIiwgXCJzdG9wXCIpO1xuICAgIH1cbiAgICByZWdpc3RlcihpZGVudGlmaWVyLCBjb250cm9sbGVyQ29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhpcy5sb2FkKHsgaWRlbnRpZmllciwgY29udHJvbGxlckNvbnN0cnVjdG9yIH0pO1xuICAgIH1cbiAgICByZWdpc3RlckFjdGlvbk9wdGlvbihuYW1lLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5hY3Rpb25EZXNjcmlwdG9yRmlsdGVyc1tuYW1lXSA9IGZpbHRlcjtcbiAgICB9XG4gICAgbG9hZChoZWFkLCAuLi5yZXN0KSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb25zID0gQXJyYXkuaXNBcnJheShoZWFkKSA/IGhlYWQgOiBbaGVhZCwgLi4ucmVzdF07XG4gICAgICAgIGRlZmluaXRpb25zLmZvckVhY2goKGRlZmluaXRpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLmNvbnRyb2xsZXJDb25zdHJ1Y3Rvci5zaG91bGRMb2FkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3V0ZXIubG9hZERlZmluaXRpb24oZGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bmxvYWQoaGVhZCwgLi4ucmVzdCkge1xuICAgICAgICBjb25zdCBpZGVudGlmaWVycyA9IEFycmF5LmlzQXJyYXkoaGVhZCkgPyBoZWFkIDogW2hlYWQsIC4uLnJlc3RdO1xuICAgICAgICBpZGVudGlmaWVycy5mb3JFYWNoKChpZGVudGlmaWVyKSA9PiB0aGlzLnJvdXRlci51bmxvYWRJZGVudGlmaWVyKGlkZW50aWZpZXIpKTtcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2xsZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZXIuY29udGV4dHMubWFwKChjb250ZXh0KSA9PiBjb250ZXh0LmNvbnRyb2xsZXIpO1xuICAgIH1cbiAgICBnZXRDb250cm9sbGVyRm9yRWxlbWVudEFuZElkZW50aWZpZXIoZWxlbWVudCwgaWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5yb3V0ZXIuZ2V0Q29udGV4dEZvckVsZW1lbnRBbmRJZGVudGlmaWVyKGVsZW1lbnQsIGlkZW50aWZpZXIpO1xuICAgICAgICByZXR1cm4gY29udGV4dCA/IGNvbnRleHQuY29udHJvbGxlciA6IG51bGw7XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtZXNzYWdlLCBkZXRhaWwpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihgJXNcXG5cXG4lb1xcblxcbiVvYCwgbWVzc2FnZSwgZXJyb3IsIGRldGFpbCk7XG4gICAgICAgIChfYSA9IHdpbmRvdy5vbmVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh3aW5kb3csIG1lc3NhZ2UsIFwiXCIsIDAsIDAsIGVycm9yKTtcbiAgICB9XG4gICAgbG9nRm9ybWF0dGVkTWVzc2FnZShpZGVudGlmaWVyLCBmdW5jdGlvbk5hbWUsIGRldGFpbCA9IHt9KSB7XG4gICAgICAgIGRldGFpbCA9IE9iamVjdC5hc3NpZ24oeyBhcHBsaWNhdGlvbjogdGhpcyB9LCBkZXRhaWwpO1xuICAgICAgICB0aGlzLmxvZ2dlci5ncm91cENvbGxhcHNlZChgJHtpZGVudGlmaWVyfSAjJHtmdW5jdGlvbk5hbWV9YCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcImRldGFpbHM6XCIsIE9iamVjdC5hc3NpZ24oe30sIGRldGFpbCkpO1xuICAgICAgICB0aGlzLmxvZ2dlci5ncm91cEVuZCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRvbVJlYWR5KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSBcImxvYWRpbmdcIikge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBDbGFzc1Byb3BlcnRpZXNCbGVzc2luZyhjb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGNsYXNzZXMgPSByZWFkSW5oZXJpdGFibGVTdGF0aWNBcnJheVZhbHVlcyhjb25zdHJ1Y3RvciwgXCJjbGFzc2VzXCIpO1xuICAgIHJldHVybiBjbGFzc2VzLnJlZHVjZSgocHJvcGVydGllcywgY2xhc3NEZWZpbml0aW9uKSA9PiB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb3BlcnRpZXMsIHByb3BlcnRpZXNGb3JDbGFzc0RlZmluaXRpb24oY2xhc3NEZWZpbml0aW9uKSk7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gcHJvcGVydGllc0ZvckNsYXNzRGVmaW5pdGlvbihrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBbYCR7a2V5fUNsYXNzYF06IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNsYXNzZXMgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKGNsYXNzZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBjbGFzc2VzLmdldEF0dHJpYnV0ZU5hbWUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGF0dHJpYnV0ZSBcIiR7YXR0cmlidXRlfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW2Ake2tleX1DbGFzc2VzYF06IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzLmdldEFsbChrZXkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW2BoYXMke2NhcGl0YWxpemUoa2V5KX1DbGFzc2BdOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3Nlcy5oYXMoa2V5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gT3V0bGV0UHJvcGVydGllc0JsZXNzaW5nKGNvbnN0cnVjdG9yKSB7XG4gICAgY29uc3Qgb3V0bGV0cyA9IHJlYWRJbmhlcml0YWJsZVN0YXRpY0FycmF5VmFsdWVzKGNvbnN0cnVjdG9yLCBcIm91dGxldHNcIik7XG4gICAgcmV0dXJuIG91dGxldHMucmVkdWNlKChwcm9wZXJ0aWVzLCBvdXRsZXREZWZpbml0aW9uKSA9PiB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb3BlcnRpZXMsIHByb3BlcnRpZXNGb3JPdXRsZXREZWZpbml0aW9uKG91dGxldERlZmluaXRpb24pKTtcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRPdXRsZXRDb250cm9sbGVyKGNvbnRyb2xsZXIsIGVsZW1lbnQsIGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gY29udHJvbGxlci5hcHBsaWNhdGlvbi5nZXRDb250cm9sbGVyRm9yRWxlbWVudEFuZElkZW50aWZpZXIoZWxlbWVudCwgaWRlbnRpZmllcik7XG59XG5mdW5jdGlvbiBnZXRDb250cm9sbGVyQW5kRW5zdXJlQ29ubmVjdGVkU2NvcGUoY29udHJvbGxlciwgZWxlbWVudCwgb3V0bGV0TmFtZSkge1xuICAgIGxldCBvdXRsZXRDb250cm9sbGVyID0gZ2V0T3V0bGV0Q29udHJvbGxlcihjb250cm9sbGVyLCBlbGVtZW50LCBvdXRsZXROYW1lKTtcbiAgICBpZiAob3V0bGV0Q29udHJvbGxlcilcbiAgICAgICAgcmV0dXJuIG91dGxldENvbnRyb2xsZXI7XG4gICAgY29udHJvbGxlci5hcHBsaWNhdGlvbi5yb3V0ZXIucHJvcG9zZVRvQ29ubmVjdFNjb3BlRm9yRWxlbWVudEFuZElkZW50aWZpZXIoZWxlbWVudCwgb3V0bGV0TmFtZSk7XG4gICAgb3V0bGV0Q29udHJvbGxlciA9IGdldE91dGxldENvbnRyb2xsZXIoY29udHJvbGxlciwgZWxlbWVudCwgb3V0bGV0TmFtZSk7XG4gICAgaWYgKG91dGxldENvbnRyb2xsZXIpXG4gICAgICAgIHJldHVybiBvdXRsZXRDb250cm9sbGVyO1xufVxuZnVuY3Rpb24gcHJvcGVydGllc0Zvck91dGxldERlZmluaXRpb24obmFtZSkge1xuICAgIGNvbnN0IGNhbWVsaXplZE5hbWUgPSBuYW1lc3BhY2VDYW1lbGl6ZShuYW1lKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBbYCR7Y2FtZWxpemVkTmFtZX1PdXRsZXRgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dGxldEVsZW1lbnQgPSB0aGlzLm91dGxldHMuZmluZChuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMub3V0bGV0cy5nZXRTZWxlY3RvckZvck91dGxldE5hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKG91dGxldEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0bGV0Q29udHJvbGxlciA9IGdldENvbnRyb2xsZXJBbmRFbnN1cmVDb25uZWN0ZWRTY29wZSh0aGlzLCBvdXRsZXRFbGVtZW50LCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dGxldENvbnRyb2xsZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0bGV0Q29udHJvbGxlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcHJvdmlkZWQgb3V0bGV0IGVsZW1lbnQgaXMgbWlzc2luZyBhbiBvdXRsZXQgY29udHJvbGxlciBcIiR7bmFtZX1cIiBpbnN0YW5jZSBmb3IgaG9zdCBjb250cm9sbGVyIFwiJHt0aGlzLmlkZW50aWZpZXJ9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIG91dGxldCBlbGVtZW50IFwiJHtuYW1lfVwiIGZvciBob3N0IGNvbnRyb2xsZXIgXCIke3RoaXMuaWRlbnRpZmllcn1cIi4gU3RpbXVsdXMgY291bGRuJ3QgZmluZCBhIG1hdGNoaW5nIG91dGxldCBlbGVtZW50IHVzaW5nIHNlbGVjdG9yIFwiJHtzZWxlY3Rvcn1cIi5gKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtgJHtjYW1lbGl6ZWROYW1lfU91dGxldHNgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dGxldHMgPSB0aGlzLm91dGxldHMuZmluZEFsbChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAob3V0bGV0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRsZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChvdXRsZXRFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRsZXRDb250cm9sbGVyID0gZ2V0Q29udHJvbGxlckFuZEVuc3VyZUNvbm5lY3RlZFNjb3BlKHRoaXMsIG91dGxldEVsZW1lbnQsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGxldENvbnRyb2xsZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dGxldENvbnRyb2xsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSBwcm92aWRlZCBvdXRsZXQgZWxlbWVudCBpcyBtaXNzaW5nIGFuIG91dGxldCBjb250cm9sbGVyIFwiJHtuYW1lfVwiIGluc3RhbmNlIGZvciBob3N0IGNvbnRyb2xsZXIgXCIke3RoaXMuaWRlbnRpZmllcn1cImAsIG91dGxldEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoY29udHJvbGxlcikgPT4gY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtgJHtjYW1lbGl6ZWROYW1lfU91dGxldEVsZW1lbnRgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dGxldEVsZW1lbnQgPSB0aGlzLm91dGxldHMuZmluZChuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMub3V0bGV0cy5nZXRTZWxlY3RvckZvck91dGxldE5hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKG91dGxldEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dGxldEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3Npbmcgb3V0bGV0IGVsZW1lbnQgXCIke25hbWV9XCIgZm9yIGhvc3QgY29udHJvbGxlciBcIiR7dGhpcy5pZGVudGlmaWVyfVwiLiBTdGltdWx1cyBjb3VsZG4ndCBmaW5kIGEgbWF0Y2hpbmcgb3V0bGV0IGVsZW1lbnQgdXNpbmcgc2VsZWN0b3IgXCIke3NlbGVjdG9yfVwiLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtgJHtjYW1lbGl6ZWROYW1lfU91dGxldEVsZW1lbnRzYF06IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vdXRsZXRzLmZpbmRBbGwobmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbYGhhcyR7Y2FwaXRhbGl6ZShjYW1lbGl6ZWROYW1lKX1PdXRsZXRgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm91dGxldHMuaGFzKG5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBUYXJnZXRQcm9wZXJ0aWVzQmxlc3NpbmcoY29uc3RydWN0b3IpIHtcbiAgICBjb25zdCB0YXJnZXRzID0gcmVhZEluaGVyaXRhYmxlU3RhdGljQXJyYXlWYWx1ZXMoY29uc3RydWN0b3IsIFwidGFyZ2V0c1wiKTtcbiAgICByZXR1cm4gdGFyZ2V0cy5yZWR1Y2UoKHByb3BlcnRpZXMsIHRhcmdldERlZmluaXRpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvcGVydGllcywgcHJvcGVydGllc0ZvclRhcmdldERlZmluaXRpb24odGFyZ2V0RGVmaW5pdGlvbikpO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIHByb3BlcnRpZXNGb3JUYXJnZXREZWZpbml0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBbYCR7bmFtZX1UYXJnZXRgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0cy5maW5kKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyB0YXJnZXQgZWxlbWVudCBcIiR7bmFtZX1cIiBmb3IgXCIke3RoaXMuaWRlbnRpZmllcn1cIiBjb250cm9sbGVyYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW2Ake25hbWV9VGFyZ2V0c2BdOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0cy5maW5kQWxsKG5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW2BoYXMke2NhcGl0YWxpemUobmFtZSl9VGFyZ2V0YF06IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRzLmhhcyhuYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gVmFsdWVQcm9wZXJ0aWVzQmxlc3NpbmcoY29uc3RydWN0b3IpIHtcbiAgICBjb25zdCB2YWx1ZURlZmluaXRpb25QYWlycyA9IHJlYWRJbmhlcml0YWJsZVN0YXRpY09iamVjdFBhaXJzKGNvbnN0cnVjdG9yLCBcInZhbHVlc1wiKTtcbiAgICBjb25zdCBwcm9wZXJ0eURlc2NyaXB0b3JNYXAgPSB7XG4gICAgICAgIHZhbHVlRGVzY3JpcHRvck1hcDoge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZURlZmluaXRpb25QYWlycy5yZWR1Y2UoKHJlc3VsdCwgdmFsdWVEZWZpbml0aW9uUGFpcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZURlc2NyaXB0b3IgPSBwYXJzZVZhbHVlRGVmaW5pdGlvblBhaXIodmFsdWVEZWZpbml0aW9uUGFpciwgdGhpcy5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMuZGF0YS5nZXRBdHRyaWJ1dGVOYW1lRm9yS2V5KHZhbHVlRGVzY3JpcHRvci5rZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHsgW2F0dHJpYnV0ZU5hbWVdOiB2YWx1ZURlc2NyaXB0b3IgfSk7XG4gICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiB2YWx1ZURlZmluaXRpb25QYWlycy5yZWR1Y2UoKHByb3BlcnRpZXMsIHZhbHVlRGVmaW5pdGlvblBhaXIpID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvcGVydGllcywgcHJvcGVydGllc0ZvclZhbHVlRGVmaW5pdGlvblBhaXIodmFsdWVEZWZpbml0aW9uUGFpcikpO1xuICAgIH0sIHByb3BlcnR5RGVzY3JpcHRvck1hcCk7XG59XG5mdW5jdGlvbiBwcm9wZXJ0aWVzRm9yVmFsdWVEZWZpbml0aW9uUGFpcih2YWx1ZURlZmluaXRpb25QYWlyLCBjb250cm9sbGVyKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHBhcnNlVmFsdWVEZWZpbml0aW9uUGFpcih2YWx1ZURlZmluaXRpb25QYWlyLCBjb250cm9sbGVyKTtcbiAgICBjb25zdCB7IGtleSwgbmFtZSwgcmVhZGVyOiByZWFkLCB3cml0ZXI6IHdyaXRlIH0gPSBkZWZpbml0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIFtuYW1lXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5kYXRhLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbi5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zZXQoa2V5LCB3cml0ZSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtgaGFzJHtjYXBpdGFsaXplKG5hbWUpfWBdOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5oYXMoa2V5KSB8fCBkZWZpbml0aW9uLmhhc0N1c3RvbURlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWVEZWZpbml0aW9uUGFpcihbdG9rZW4sIHR5cGVEZWZpbml0aW9uXSwgY29udHJvbGxlcikge1xuICAgIHJldHVybiB2YWx1ZURlc2NyaXB0b3JGb3JUb2tlbkFuZFR5cGVEZWZpbml0aW9uKHtcbiAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgdG9rZW4sXG4gICAgICAgIHR5cGVEZWZpbml0aW9uLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VWYWx1ZVR5cGVDb25zdGFudChjb25zdGFudCkge1xuICAgIHN3aXRjaCAoY29uc3RhbnQpIHtcbiAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3RcIjtcbiAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlVHlwZURlZmF1bHQoZGVmYXVsdFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdFZhbHVlKSlcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRlZmF1bHRWYWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpXG4gICAgICAgIHJldHVybiBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gcGFyc2VWYWx1ZVR5cGVPYmplY3QocGF5bG9hZCkge1xuICAgIGNvbnN0IHsgY29udHJvbGxlciwgdG9rZW4sIHR5cGVPYmplY3QgfSA9IHBheWxvYWQ7XG4gICAgY29uc3QgaGFzVHlwZSA9IGlzU29tZXRoaW5nKHR5cGVPYmplY3QudHlwZSk7XG4gICAgY29uc3QgaGFzRGVmYXVsdCA9IGlzU29tZXRoaW5nKHR5cGVPYmplY3QuZGVmYXVsdCk7XG4gICAgY29uc3QgZnVsbE9iamVjdCA9IGhhc1R5cGUgJiYgaGFzRGVmYXVsdDtcbiAgICBjb25zdCBvbmx5VHlwZSA9IGhhc1R5cGUgJiYgIWhhc0RlZmF1bHQ7XG4gICAgY29uc3Qgb25seURlZmF1bHQgPSAhaGFzVHlwZSAmJiBoYXNEZWZhdWx0O1xuICAgIGNvbnN0IHR5cGVGcm9tT2JqZWN0ID0gcGFyc2VWYWx1ZVR5cGVDb25zdGFudCh0eXBlT2JqZWN0LnR5cGUpO1xuICAgIGNvbnN0IHR5cGVGcm9tRGVmYXVsdFZhbHVlID0gcGFyc2VWYWx1ZVR5cGVEZWZhdWx0KHBheWxvYWQudHlwZU9iamVjdC5kZWZhdWx0KTtcbiAgICBpZiAob25seVR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlRnJvbU9iamVjdDtcbiAgICBpZiAob25seURlZmF1bHQpXG4gICAgICAgIHJldHVybiB0eXBlRnJvbURlZmF1bHRWYWx1ZTtcbiAgICBpZiAodHlwZUZyb21PYmplY3QgIT09IHR5cGVGcm9tRGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5UGF0aCA9IGNvbnRyb2xsZXIgPyBgJHtjb250cm9sbGVyfS4ke3Rva2VufWAgOiB0b2tlbjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc3BlY2lmaWVkIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBTdGltdWx1cyBWYWx1ZSBcIiR7cHJvcGVydHlQYXRofVwiIG11c3QgbWF0Y2ggdGhlIGRlZmluZWQgdHlwZSBcIiR7dHlwZUZyb21PYmplY3R9XCIuIFRoZSBwcm92aWRlZCBkZWZhdWx0IHZhbHVlIG9mIFwiJHt0eXBlT2JqZWN0LmRlZmF1bHR9XCIgaXMgb2YgdHlwZSBcIiR7dHlwZUZyb21EZWZhdWx0VmFsdWV9XCIuYCk7XG4gICAgfVxuICAgIGlmIChmdWxsT2JqZWN0KVxuICAgICAgICByZXR1cm4gdHlwZUZyb21PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlVHlwZURlZmluaXRpb24ocGF5bG9hZCkge1xuICAgIGNvbnN0IHsgY29udHJvbGxlciwgdG9rZW4sIHR5cGVEZWZpbml0aW9uIH0gPSBwYXlsb2FkO1xuICAgIGNvbnN0IHR5cGVPYmplY3QgPSB7IGNvbnRyb2xsZXIsIHRva2VuLCB0eXBlT2JqZWN0OiB0eXBlRGVmaW5pdGlvbiB9O1xuICAgIGNvbnN0IHR5cGVGcm9tT2JqZWN0ID0gcGFyc2VWYWx1ZVR5cGVPYmplY3QodHlwZU9iamVjdCk7XG4gICAgY29uc3QgdHlwZUZyb21EZWZhdWx0VmFsdWUgPSBwYXJzZVZhbHVlVHlwZURlZmF1bHQodHlwZURlZmluaXRpb24pO1xuICAgIGNvbnN0IHR5cGVGcm9tQ29uc3RhbnQgPSBwYXJzZVZhbHVlVHlwZUNvbnN0YW50KHR5cGVEZWZpbml0aW9uKTtcbiAgICBjb25zdCB0eXBlID0gdHlwZUZyb21PYmplY3QgfHwgdHlwZUZyb21EZWZhdWx0VmFsdWUgfHwgdHlwZUZyb21Db25zdGFudDtcbiAgICBpZiAodHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgY29uc3QgcHJvcGVydHlQYXRoID0gY29udHJvbGxlciA/IGAke2NvbnRyb2xsZXJ9LiR7dHlwZURlZmluaXRpb259YCA6IHRva2VuO1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB2YWx1ZSB0eXBlIFwiJHtwcm9wZXJ0eVBhdGh9XCIgZm9yIFwiJHt0b2tlbn1cIiB2YWx1ZWApO1xufVxuZnVuY3Rpb24gZGVmYXVsdFZhbHVlRm9yRGVmaW5pdGlvbih0eXBlRGVmaW5pdGlvbikge1xuICAgIGNvbnN0IGNvbnN0YW50ID0gcGFyc2VWYWx1ZVR5cGVDb25zdGFudCh0eXBlRGVmaW5pdGlvbik7XG4gICAgaWYgKGNvbnN0YW50KVxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlc0J5VHlwZVtjb25zdGFudF07XG4gICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc1Byb3BlcnR5KHR5cGVEZWZpbml0aW9uLCBcImRlZmF1bHRcIik7XG4gICAgY29uc3QgaGFzVHlwZSA9IGhhc1Byb3BlcnR5KHR5cGVEZWZpbml0aW9uLCBcInR5cGVcIik7XG4gICAgY29uc3QgdHlwZU9iamVjdCA9IHR5cGVEZWZpbml0aW9uO1xuICAgIGlmIChoYXNEZWZhdWx0KVxuICAgICAgICByZXR1cm4gdHlwZU9iamVjdC5kZWZhdWx0O1xuICAgIGlmIChoYXNUeXBlKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gdHlwZU9iamVjdDtcbiAgICAgICAgY29uc3QgY29uc3RhbnRGcm9tVHlwZSA9IHBhcnNlVmFsdWVUeXBlQ29uc3RhbnQodHlwZSk7XG4gICAgICAgIGlmIChjb25zdGFudEZyb21UeXBlKVxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZXNCeVR5cGVbY29uc3RhbnRGcm9tVHlwZV07XG4gICAgfVxuICAgIHJldHVybiB0eXBlRGVmaW5pdGlvbjtcbn1cbmZ1bmN0aW9uIHZhbHVlRGVzY3JpcHRvckZvclRva2VuQW5kVHlwZURlZmluaXRpb24ocGF5bG9hZCkge1xuICAgIGNvbnN0IHsgdG9rZW4sIHR5cGVEZWZpbml0aW9uIH0gPSBwYXlsb2FkO1xuICAgIGNvbnN0IGtleSA9IGAke2Rhc2hlcml6ZSh0b2tlbil9LXZhbHVlYDtcbiAgICBjb25zdCB0eXBlID0gcGFyc2VWYWx1ZVR5cGVEZWZpbml0aW9uKHBheWxvYWQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGtleSxcbiAgICAgICAgbmFtZTogY2FtZWxpemUoa2V5KSxcbiAgICAgICAgZ2V0IGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWVGb3JEZWZpbml0aW9uKHR5cGVEZWZpbml0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGhhc0N1c3RvbURlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVZhbHVlVHlwZURlZmF1bHQodHlwZURlZmluaXRpb24pICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRlcjogcmVhZGVyc1t0eXBlXSxcbiAgICAgICAgd3JpdGVyOiB3cml0ZXJzW3R5cGVdIHx8IHdyaXRlcnMuZGVmYXVsdCxcbiAgICB9O1xufVxuY29uc3QgZGVmYXVsdFZhbHVlc0J5VHlwZSA9IHtcbiAgICBnZXQgYXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGJvb2xlYW46IGZhbHNlLFxuICAgIG51bWJlcjogMCxcbiAgICBnZXQgb2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICBzdHJpbmc6IFwiXCIsXG59O1xuY29uc3QgcmVhZGVycyA9IHtcbiAgICBhcnJheSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBhcnJheSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCB2YWx1ZSBvZiB0eXBlIFwiYXJyYXlcIiBidXQgaW5zdGVhZCBnb3QgdmFsdWUgXCIke3ZhbHVlfVwiIG9mIHR5cGUgXCIke3BhcnNlVmFsdWVUeXBlRGVmYXVsdChhcnJheSl9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSxcbiAgICBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhKHZhbHVlID09IFwiMFwiIHx8IFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKSA9PSBcImZhbHNlXCIpO1xuICAgIH0sXG4gICAgbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUucmVwbGFjZSgvXy9nLCBcIlwiKSk7XG4gICAgfSxcbiAgICBvYmplY3QodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIGlmIChvYmplY3QgPT09IG51bGwgfHwgdHlwZW9mIG9iamVjdCAhPSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgdmFsdWUgb2YgdHlwZSBcIm9iamVjdFwiIGJ1dCBpbnN0ZWFkIGdvdCB2YWx1ZSBcIiR7dmFsdWV9XCIgb2YgdHlwZSBcIiR7cGFyc2VWYWx1ZVR5cGVEZWZhdWx0KG9iamVjdCl9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG4gICAgc3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxufTtcbmNvbnN0IHdyaXRlcnMgPSB7XG4gICAgZGVmYXVsdDogd3JpdGVTdHJpbmcsXG4gICAgYXJyYXk6IHdyaXRlSlNPTixcbiAgICBvYmplY3Q6IHdyaXRlSlNPTixcbn07XG5mdW5jdGlvbiB3cml0ZUpTT04odmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xufVxuZnVuY3Rpb24gd3JpdGVTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gYCR7dmFsdWV9YDtcbn1cblxuY2xhc3MgQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IHNob3VsZExvYWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzdGF0aWMgYWZ0ZXJMb2FkKF9pZGVudGlmaWVyLCBfYXBwbGljYXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBnZXQgYXBwbGljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuYXBwbGljYXRpb247XG4gICAgfVxuICAgIGdldCBzY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5zY29wZTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5pZGVudGlmaWVyO1xuICAgIH1cbiAgICBnZXQgdGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUudGFyZ2V0cztcbiAgICB9XG4gICAgZ2V0IG91dGxldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLm91dGxldHM7XG4gICAgfVxuICAgIGdldCBjbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5jbGFzc2VzO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZGF0YTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICB9XG4gICAgZGlzcGF0Y2goZXZlbnROYW1lLCB7IHRhcmdldCA9IHRoaXMuZWxlbWVudCwgZGV0YWlsID0ge30sIHByZWZpeCA9IHRoaXMuaWRlbnRpZmllciwgYnViYmxlcyA9IHRydWUsIGNhbmNlbGFibGUgPSB0cnVlLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHByZWZpeCA/IGAke3ByZWZpeH06JHtldmVudE5hbWV9YCA6IGV2ZW50TmFtZTtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQodHlwZSwgeyBkZXRhaWwsIGJ1YmJsZXMsIGNhbmNlbGFibGUgfSk7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbn1cbkNvbnRyb2xsZXIuYmxlc3NpbmdzID0gW1xuICAgIENsYXNzUHJvcGVydGllc0JsZXNzaW5nLFxuICAgIFRhcmdldFByb3BlcnRpZXNCbGVzc2luZyxcbiAgICBWYWx1ZVByb3BlcnRpZXNCbGVzc2luZyxcbiAgICBPdXRsZXRQcm9wZXJ0aWVzQmxlc3NpbmcsXG5dO1xuQ29udHJvbGxlci50YXJnZXRzID0gW107XG5Db250cm9sbGVyLm91dGxldHMgPSBbXTtcbkNvbnRyb2xsZXIudmFsdWVzID0ge307XG5cbmV4cG9ydCB7IEFwcGxpY2F0aW9uLCBBdHRyaWJ1dGVPYnNlcnZlciwgQ29udGV4dCwgQ29udHJvbGxlciwgRWxlbWVudE9ic2VydmVyLCBJbmRleGVkTXVsdGltYXAsIE11bHRpbWFwLCBTZWxlY3Rvck9ic2VydmVyLCBTdHJpbmdNYXBPYnNlcnZlciwgVG9rZW5MaXN0T2JzZXJ2ZXIsIFZhbHVlTGlzdE9ic2VydmVyLCBhZGQsIGRlZmF1bHRTY2hlbWEsIGRlbCwgZmV0Y2gsIHBydW5lIH07XG4iLCJpbXBvcnQgeyBBcHBsaWNhdGlvbiB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5pbXBvcnQgc3ltZm9ueUNvbnRyb2xsZXJzIGZyb20gJy4vd2VicGFjay9sb2FkZXIhQHN5bWZvbnkvc3RpbXVsdXMtYnJpZGdlL2NvbnRyb2xsZXJzLmpzb24nO1xuXG4vKlxuU3RpbXVsdXMgV2VicGFjayBIZWxwZXJzIDEuMC4wXG5Db3B5cmlnaHQgwqkgMjAyMSBCYXNlY2FtcCwgTExDXG4gKi9cbmZ1bmN0aW9uIGRlZmluaXRpb25zRnJvbUNvbnRleHQoY29udGV4dCkge1xuICAgIHJldHVybiBjb250ZXh0LmtleXMoKVxuICAgICAgICAubWFwKChrZXkpID0+IGRlZmluaXRpb25Gb3JNb2R1bGVXaXRoQ29udGV4dEFuZEtleShjb250ZXh0LCBrZXkpKVxuICAgICAgICAuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUpO1xufVxuZnVuY3Rpb24gZGVmaW5pdGlvbkZvck1vZHVsZVdpdGhDb250ZXh0QW5kS2V5KGNvbnRleHQsIGtleSkge1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBpZGVudGlmaWVyRm9yQ29udGV4dEtleShrZXkpO1xuICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uRm9yTW9kdWxlQW5kSWRlbnRpZmllcihjb250ZXh0KGtleSksIGlkZW50aWZpZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlZmluaXRpb25Gb3JNb2R1bGVBbmRJZGVudGlmaWVyKG1vZHVsZSwgaWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyb2xsZXJDb25zdHJ1Y3RvciA9IG1vZHVsZS5kZWZhdWx0O1xuICAgIGlmICh0eXBlb2YgY29udHJvbGxlckNvbnN0cnVjdG9yID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4geyBpZGVudGlmaWVyLCBjb250cm9sbGVyQ29uc3RydWN0b3IgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBpZGVudGlmaWVyRm9yQ29udGV4dEtleShrZXkpIHtcbiAgICBjb25zdCBsb2dpY2FsTmFtZSA9IChrZXkubWF0Y2goL14oPzpcXC5cXC8pPyguKykoPzpbXy1dY29udHJvbGxlclxcLi4rPykkLykgfHwgW10pWzFdO1xuICAgIGlmIChsb2dpY2FsTmFtZSkge1xuICAgICAgICByZXR1cm4gbG9naWNhbE5hbWUucmVwbGFjZSgvXy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiLS1cIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFN0aW11bHVzQXBwKGNvbnRleHQpIHtcbiAgICBjb25zdCBhcHBsaWNhdGlvbiA9IEFwcGxpY2F0aW9uLnN0YXJ0KCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGFwcGxpY2F0aW9uLmRlYnVnID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgYXBwbGljYXRpb24ubG9hZChkZWZpbml0aW9uc0Zyb21Db250ZXh0KGNvbnRleHQpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb250cm9sbGVyTmFtZSBpbiBzeW1mb255Q29udHJvbGxlcnMpIHtcbiAgICAgICAgaWYgKCFzeW1mb255Q29udHJvbGxlcnMuaGFzT3duUHJvcGVydHkoY29udHJvbGxlck5hbWUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhcHBsaWNhdGlvbi5yZWdpc3Rlcihjb250cm9sbGVyTmFtZSwgc3ltZm9ueUNvbnRyb2xsZXJzW2NvbnRyb2xsZXJOYW1lXSk7XG4gICAgfVxuICAgIHJldHVybiBhcHBsaWNhdGlvbjtcbn1cblxuZXhwb3J0IHsgc3RhcnRTdGltdWx1c0FwcCB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciB0cnlUb1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90cnktdG8tc3RyaW5nJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NhbGxhYmxlKGFyZ3VtZW50KSBpcyB0cnVlYFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93IG5ldyAkVHlwZUVycm9yKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRyeVRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RyeS10by1zdHJpbmcnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ29uc3RydWN0b3IoYXJndW1lbnQpIGlzIHRydWVgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc1Bvc3NpYmxlUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXBvc3NpYmxlLXByb3RvdHlwZScpO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNQb3NzaWJsZVByb3RvdHlwZShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyAkU3RyaW5nKGFyZ3VtZW50KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT09IHVuZGVmaW5lZCkge1xuICBkZWZpbmVQcm9wZXJ0eShBcnJheVByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGNyZWF0ZShudWxsKVxuICB9KTtcbn1cblxuLy8gYWRkIGEga2V5IHRvIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUHJvdG90eXBlKSB7XG4gIGlmIChpc1Byb3RvdHlwZU9mKFByb3RvdHlwZSwgaXQpKSByZXR1cm4gaXQ7XG4gIHRocm93IG5ldyAkVHlwZUVycm9yKCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyICRTdHJpbmcgPSBTdHJpbmc7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzT2JqZWN0KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcigkU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5mb3JFYWNoO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdCcpO1xuXG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ2ZvckVhY2gnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbm1vZHVsZS5leHBvcnRzID0gIVNUUklDVF9NRVRIT0QgPyBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWZvcmVhY2ggLS0gc2FmZVxufSA6IFtdLmZvckVhY2g7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nJyk7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIGlzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY29uc3RydWN0b3InKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvcicpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QnKTtcblxudmFyICRBcnJheSA9IEFycmF5O1xuXG4vLyBgQXJyYXkuZnJvbWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gIHZhciBJU19DT05TVFJVQ1RPUiA9IGlzQ29uc3RydWN0b3IodGhpcyk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gIGlmIChtYXBwaW5nKSBtYXBmbiA9IGJpbmQobWFwZm4sIGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChPKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvciwgbmV4dCwgdmFsdWU7XG4gIC8vIGlmIHRoZSB0YXJnZXQgaXMgbm90IGl0ZXJhYmxlIG9yIGl0J3MgYW4gYXJyYXkgd2l0aCB0aGUgZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBhIHNpbXBsZSBjYXNlXG4gIGlmIChpdGVyYXRvck1ldGhvZCAmJiAhKHRoaXMgPT09ICRBcnJheSAmJiBpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlcmF0b3JNZXRob2QpKSkge1xuICAgIHJlc3VsdCA9IElTX0NPTlNUUlVDVE9SID8gbmV3IHRoaXMoKSA6IFtdO1xuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoTywgaXRlcmF0b3JNZXRob2QpO1xuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgIGZvciAoOyEoc3RlcCA9IGNhbGwobmV4dCwgaXRlcmF0b3IpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICB2YWx1ZSA9IG1hcHBpbmcgPyBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlO1xuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcbiAgICByZXN1bHQgPSBJU19DT05TVFJVQ1RPUiA/IG5ldyB0aGlzKGxlbmd0aCkgOiAkQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdO1xuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9PSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5cbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBmb3JFYWNoLCBtYXAsIGZpbHRlciwgc29tZSwgZXZlcnksIGZpbmQsIGZpbmRJbmRleCwgZmlsdGVyUmVqZWN0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVFlQRSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09PSA2O1xuICB2YXIgSVNfRklMVEVSX1JFSkVDVCA9IFRZUEUgPT09IDc7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCwgc3BlY2lmaWNDcmVhdGUpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKHNlbGYpO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZChjYWxsYmFja2ZuLCB0aGF0KTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjcmVhdGUgPSBzcGVjaWZpY0NyZWF0ZSB8fCBhcnJheVNwZWNpZXNDcmVhdGU7XG4gICAgdmFyIHRhcmdldCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiB8fCBJU19GSUxURVJfUkVKRUNUID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsdWUsIHJlc3VsdDtcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbHVlID0gc2VsZltpbmRleF07XG4gICAgICByZXN1bHQgPSBib3VuZEZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSB0YXJnZXRbaW5kZXhdID0gcmVzdWx0OyAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzdWx0KSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbHVlOyAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcHVzaCh0YXJnZXQsIHZhbHVlKTsgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgNDogcmV0dXJuIGZhbHNlOyAgICAgICAgICAgICAvLyBldmVyeVxuICAgICAgICAgIGNhc2UgNzogcHVzaCh0YXJnZXQsIHZhbHVlKTsgICAgICAvLyBmaWx0ZXJSZWplY3RcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiAgZm9yRWFjaDogY3JlYXRlTWV0aG9kKDApLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuICBtYXA6IGNyZWF0ZU1ldGhvZCgxKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgZmlsdGVyOiBjcmVhdGVNZXRob2QoMiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcbiAgc29tZTogY3JlYXRlTWV0aG9kKDMpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcbiAgZXZlcnk6IGNyZWF0ZU1ldGhvZCg0KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuICBmaW5kOiBjcmVhdGVNZXRob2QoNSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XG4gIGZpbmRJbmRleDogY3JlYXRlTWV0aG9kKDYpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlclJlamVjdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5LWZpbHRlcmluZ1xuICBmaWx0ZXJSZWplY3Q6IGNyZWF0ZU1ldGhvZCg3KVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW52aXJvbm1lbnQtdjgtdmVyc2lvbicpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICAvLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3N1xuICByZXR1cm4gVjhfVkVSU0lPTiA+PSA1MSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGFycmF5LmNvbnN0cnVjdG9yID0ge307XG4gICAgY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBmb286IDEgfTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheVtNRVRIT0RfTkFNRV0oQm9vbGVhbikuZm9vICE9PSAxO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUsIGFyZ3VtZW50KSB7XG4gIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE7IH0sIDEpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIFNhZmFyaSA8IDEzIGRvZXMgbm90IHRocm93IGFuIGVycm9yIGluIHRoaXMgY2FzZVxudmFyIFNJTEVOVF9PTl9OT05fV1JJVEFCTEVfTEVOR1RIX1NFVCA9IERFU0NSSVBUT1JTICYmICFmdW5jdGlvbiAoKSB7XG4gIC8vIG1ha2VzIG5vIHNlbnNlIHdpdGhvdXQgcHJvcGVyIHN0cmljdCBtb2RlIHN1cHBvcnRcbiAgaWYgKHRoaXMgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFtdLCAnbGVuZ3RoJywgeyB3cml0YWJsZTogZmFsc2UgfSkubGVuZ3RoID0gMTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3I7XG4gIH1cbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTSUxFTlRfT05fTk9OX1dSSVRBQkxFX0xFTkdUSF9TRVQgPyBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gIGlmIChpc0FycmF5KE8pICYmICFnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgJ2xlbmd0aCcpLndyaXRhYmxlKSB7XG4gICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0Nhbm5vdCBzZXQgcmVhZCBvbmx5IC5sZW5ndGgnKTtcbiAgfSByZXR1cm4gTy5sZW5ndGggPSBsZW5ndGg7XG59IDogZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuICByZXR1cm4gTy5sZW5ndGggPSBsZW5ndGg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuY3VycnlUaGlzKFtdLnNsaWNlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhcnJheVNsaWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNsaWNlJyk7XG5cbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbnZhciBzb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgOCkge1xuICAgIC8vIGluc2VydGlvbiBzb3J0XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciBlbGVtZW50LCBqO1xuXG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgIGogPSBpO1xuICAgICAgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgICAgd2hpbGUgKGogJiYgY29tcGFyZWZuKGFycmF5W2ogLSAxXSwgZWxlbWVudCkgPiAwKSB7XG4gICAgICAgIGFycmF5W2pdID0gYXJyYXlbLS1qXTtcbiAgICAgIH1cbiAgICAgIGlmIChqICE9PSBpKyspIGFycmF5W2pdID0gZWxlbWVudDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbWVyZ2Ugc29ydFxuICAgIHZhciBtaWRkbGUgPSBmbG9vcihsZW5ndGggLyAyKTtcbiAgICB2YXIgbGVmdCA9IHNvcnQoYXJyYXlTbGljZShhcnJheSwgMCwgbWlkZGxlKSwgY29tcGFyZWZuKTtcbiAgICB2YXIgcmlnaHQgPSBzb3J0KGFycmF5U2xpY2UoYXJyYXksIG1pZGRsZSksIGNvbXBhcmVmbik7XG4gICAgdmFyIGxsZW5ndGggPSBsZWZ0Lmxlbmd0aDtcbiAgICB2YXIgcmxlbmd0aCA9IHJpZ2h0Lmxlbmd0aDtcbiAgICB2YXIgbGluZGV4ID0gMDtcbiAgICB2YXIgcmluZGV4ID0gMDtcblxuICAgIHdoaWxlIChsaW5kZXggPCBsbGVuZ3RoIHx8IHJpbmRleCA8IHJsZW5ndGgpIHtcbiAgICAgIGFycmF5W2xpbmRleCArIHJpbmRleF0gPSAobGluZGV4IDwgbGxlbmd0aCAmJiByaW5kZXggPCBybGVuZ3RoKVxuICAgICAgICA/IGNvbXBhcmVmbihsZWZ0W2xpbmRleF0sIHJpZ2h0W3JpbmRleF0pIDw9IDAgPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXVxuICAgICAgICA6IGxpbmRleCA8IGxsZW5ndGggPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIGlzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY29uc3RydWN0b3InKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcbnZhciAkQXJyYXkgPSBBcnJheTtcblxuLy8gYSBwYXJ0IG9mIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXkpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsQXJyYXkpKSB7XG4gICAgQyA9IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAoaXNDb25zdHJ1Y3RvcihDKSAmJiAoQyA9PT0gJEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBlbHNlIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/ICRBcnJheSA6IEM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFycmF5U3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxuLy8gYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKGFycmF5U3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsQXJyYXkpKShsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvci1jbG9zZScpO1xuXG4vLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBFTlRSSUVTKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEVOVFJJRVMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgZG9uZTogISFjYWxsZWQrKyB9O1xuICAgIH0sXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7XG4gICAgfVxuICB9O1xuICBpdGVyYXRvcldpdGhSZXR1cm5bSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktZnJvbSwgbm8tdGhyb3ctbGl0ZXJhbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG4gIHRyeSB7XG4gICAgaWYgKCFTS0lQX0NMT1NJTkcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChlcnJvcikgeyByZXR1cm4gZmFsc2U7IH0gLy8gd29ya2Fyb3VuZCBvZiBvbGQgV2ViS2l0ICsgYGV2YWxgIGJ1Z1xuICB2YXIgSVRFUkFUSU9OX1NVUFBPUlQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgb2JqZWN0W0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiBJVEVSQVRJT05fU1VQUE9SVCA9IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4ZWMob2JqZWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xuXG52YXIgdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyh7fS50b1N0cmluZyk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBzdHJpbmdTbGljZSh0b1N0cmluZyhpdCksIDgsIC0xKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCcpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBjbGFzc29mUmF3ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gJE9iamVjdChpdCksIFRPX1NUUklOR19UQUcpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09PSAnT2JqZWN0JyAmJiBpc0NhbGxhYmxlKE8uY2FsbGVlKSA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIG93bktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb3duLWtleXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGV4Y2VwdGlvbnMpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpICYmICEoZXhjZXB0aW9ucyAmJiBoYXNPd24oZXhjZXB0aW9ucywga2V5KSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCgnbWF0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgdmFyIHJlZ2V4cCA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4cFtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gYENyZWF0ZUl0ZXJSZXN1bHRPYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVpdGVycmVzdWx0b2JqZWN0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgZG9uZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IGRvbmUgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2tleV0gPSB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vcmRpbmFyeS10by1wcmltaXRpdmUnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBEYXRlLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWRhdGUucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhpbnQpIHtcbiAgYW5PYmplY3QodGhpcyk7XG4gIGlmIChoaW50ID09PSAnc3RyaW5nJyB8fCBoaW50ID09PSAnZGVmYXVsdCcpIGhpbnQgPSAnc3RyaW5nJztcbiAgZWxzZSBpZiAoaGludCAhPT0gJ251bWJlcicpIHRocm93IG5ldyAkVHlwZUVycm9yKCdJbmNvcnJlY3QgaGludCcpO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZSh0aGlzLCBoaW50KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgbWFrZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbWFrZS1idWlsdC1pbicpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gIGlmIChkZXNjcmlwdG9yLmdldCkgbWFrZUJ1aWx0SW4oZGVzY3JpcHRvci5nZXQsIG5hbWUsIHsgZ2V0dGVyOiB0cnVlIH0pO1xuICBpZiAoZGVzY3JpcHRvci5zZXQpIG1ha2VCdWlsdEluKGRlc2NyaXB0b3Iuc2V0LCBuYW1lLCB7IHNldHRlcjogdHJ1ZSB9KTtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5LmYodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBtYWtlQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9tYWtlLWJ1aWx0LWluJyk7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucy5lbnVtZXJhYmxlO1xuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDoga2V5O1xuICBpZiAoaXNDYWxsYWJsZSh2YWx1ZSkpIG1ha2VCdWlsdEluKHZhbHVlLCBuYW1lLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVHbG9iYWxQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnVuc2FmZSkgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGVsc2UgaWYgKE9ba2V5XSkgc2ltcGxlID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6ICFvcHRpb25zLm5vbkNvbmZpZ3VyYWJsZSxcbiAgICAgIHdyaXRhYmxlOiAhb3B0aW9ucy5ub25Xcml0YWJsZVxuICAgIH0pO1xuICB9IHJldHVybiBPO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBkZWZpbmVCdWlsdEluKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbFRoaXNba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPT0gNztcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyIGRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MUZGRkZGRkZGRkZGRkY7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID4gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgJFR5cGVFcnJvcignTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBpdGVyYWJsZSBET00gY29sbGVjdGlvbnNcbi8vIGZsYWcgLSBgaXRlcmFibGVgIGludGVyZmFjZSAtICdlbnRyaWVzJywgJ2tleXMnLCAndmFsdWVzJywgJ2ZvckVhY2gnIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBDU1NSdWxlTGlzdDogMCxcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogMCxcbiAgQ1NTVmFsdWVMaXN0OiAwLFxuICBDbGllbnRSZWN0TGlzdDogMCxcbiAgRE9NUmVjdExpc3Q6IDAsXG4gIERPTVN0cmluZ0xpc3Q6IDAsXG4gIERPTVRva2VuTGlzdDogMSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IDAsXG4gIEZpbGVMaXN0OiAwLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiAgSFRNTENvbGxlY3Rpb246IDAsXG4gIEhUTUxGb3JtRWxlbWVudDogMCxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gIE1lZGlhTGlzdDogMCxcbiAgTWltZVR5cGVBcnJheTogMCxcbiAgTmFtZWROb2RlTWFwOiAwLFxuICBOb2RlTGlzdDogMSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcbiAgUGx1Z2luOiAwLFxuICBQbHVnaW5BcnJheTogMCxcbiAgU1ZHTGVuZ3RoTGlzdDogMCxcbiAgU1ZHTnVtYmVyTGlzdDogMCxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IDAsXG4gIFNWR1BvaW50TGlzdDogMCxcbiAgU1ZHU3RyaW5nTGlzdDogMCxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogMCxcbiAgU291cmNlQnVmZmVyTGlzdDogMCxcbiAgU3R5bGVTaGVldExpc3Q6IDAsXG4gIFRleHRUcmFja0N1ZUxpc3Q6IDAsXG4gIFRleHRUcmFja0xpc3Q6IDAsXG4gIFRvdWNoTGlzdDogMFxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGluIG9sZCBXZWJLaXQgdmVyc2lvbnMsIGBlbGVtZW50LmNsYXNzTGlzdGAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGdsb2JhbCBgRE9NVG9rZW5MaXN0YFxudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xuXG52YXIgY2xhc3NMaXN0ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdzcGFuJykuY2xhc3NMaXN0O1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSA9IGNsYXNzTGlzdCAmJiBjbGFzc0xpc3QuY29uc3RydWN0b3IgJiYgY2xhc3NMaXN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Ub2tlbkxpc3RQcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgPyB1bmRlZmluZWQgOiBET01Ub2tlbkxpc3RQcm90b3R5cGU7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG5cbnZhciBuYXZpZ2F0b3IgPSBnbG9iYWxUaGlzLm5hdmlnYXRvcjtcbnZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxubW9kdWxlLmV4cG9ydHMgPSB1c2VyQWdlbnQgPyBTdHJpbmcodXNlckFnZW50KSA6ICcnO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW52aXJvbm1lbnQtdXNlci1hZ2VudCcpO1xuXG52YXIgcHJvY2VzcyA9IGdsb2JhbFRoaXMucHJvY2VzcztcbnZhciBEZW5vID0gZ2xvYmFsVGhpcy5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zIHx8IERlbm8gJiYgRGVuby52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcbiAgLy8gYnV0IHRoZWlyIGNvcnJlY3QgdmVyc2lvbnMgYXJlIG5vdCBpbnRlcmVzdGluZyBmb3IgdXNcbiAgdmVyc2lvbiA9IG1hdGNoWzBdID4gMCAmJiBtYXRjaFswXSA8IDQgPyAxIDogKyhtYXRjaFswXSArIG1hdGNoWzFdKTtcbn1cblxuLy8gQnJvd3NlckZTIE5vZGVKUyBgcHJvY2Vzc2AgcG9seWZpbGwgaW5jb3JyZWN0bHkgc2V0IGAudjhgIHRvIGAwLjBgXG4vLyBzbyBjaGVjayBgdXNlckFnZW50YCBldmVuIGlmIGAudjhgIGV4aXN0cywgYnV0IDBcbmlmICghdmVyc2lvbiAmJiB1c2VyQWdlbnQpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSArbWF0Y2hbMV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2ZXJzaW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIEJ1biwgRGVubyAtLSBkZXRlY3Rpb24gKi9cbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Vudmlyb25tZW50LXVzZXItYWdlbnQnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbnZhciB1c2VyQWdlbnRTdGFydHNXaXRoID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gdXNlckFnZW50LnNsaWNlKDAsIHN0cmluZy5sZW5ndGgpID09PSBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gIGlmICh1c2VyQWdlbnRTdGFydHNXaXRoKCdCdW4vJykpIHJldHVybiAnQlVOJztcbiAgaWYgKHVzZXJBZ2VudFN0YXJ0c1dpdGgoJ0Nsb3VkZmxhcmUtV29ya2VycycpKSByZXR1cm4gJ0NMT1VERkxBUkUnO1xuICBpZiAodXNlckFnZW50U3RhcnRzV2l0aCgnRGVuby8nKSkgcmV0dXJuICdERU5PJztcbiAgaWYgKHVzZXJBZ2VudFN0YXJ0c1dpdGgoJ05vZGUuanMvJykpIHJldHVybiAnTk9ERSc7XG4gIGlmIChnbG9iYWxUaGlzLkJ1biAmJiB0eXBlb2YgQnVuLnZlcnNpb24gPT0gJ3N0cmluZycpIHJldHVybiAnQlVOJztcbiAgaWYgKGdsb2JhbFRoaXMuRGVubyAmJiB0eXBlb2YgRGVuby52ZXJzaW9uID09ICdvYmplY3QnKSByZXR1cm4gJ0RFTk8nO1xuICBpZiAoY2xhc3NvZihnbG9iYWxUaGlzLnByb2Nlc3MpID09PSAncHJvY2VzcycpIHJldHVybiAnTk9ERSc7XG4gIGlmIChnbG9iYWxUaGlzLndpbmRvdyAmJiBnbG9iYWxUaGlzLmRvY3VtZW50KSByZXR1cm4gJ0JST1dTRVInO1xuICByZXR1cm4gJ1JFU1QnO1xufSkoKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxudmFyICRFcnJvciA9IEVycm9yO1xudmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcygnJy5yZXBsYWNlKTtcblxudmFyIFRFU1QgPSAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gU3RyaW5nKG5ldyAkRXJyb3IoYXJnKS5zdGFjayk7IH0pKCd6eGNhc2QnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWRvcy9uby12dWxuZXJhYmxlLCBzb25hcmpzL3Nsb3ctcmVnZXggLS0gc2FmZVxudmFyIFY4X09SX0NIQUtSQV9TVEFDS19FTlRSWSA9IC9cXG5cXHMqYXQgW146XSo6W15cXG5dKi87XG52YXIgSVNfVjhfT1JfQ0hBS1JBX1NUQUNLID0gVjhfT1JfQ0hBS1JBX1NUQUNLX0VOVFJZLnRlc3QoVEVTVCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0YWNrLCBkcm9wRW50cmllcykge1xuICBpZiAoSVNfVjhfT1JfQ0hBS1JBX1NUQUNLICYmIHR5cGVvZiBzdGFjayA9PSAnc3RyaW5nJyAmJiAhJEVycm9yLnByZXBhcmVTdGFja1RyYWNlKSB7XG4gICAgd2hpbGUgKGRyb3BFbnRyaWVzLS0pIHN0YWNrID0gcmVwbGFjZShzdGFjaywgVjhfT1JfQ0hBS1JBX1NUQUNLX0VOVFJZLCAnJyk7XG4gIH0gcmV0dXJuIHN0YWNrO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgY2xlYXJFcnJvclN0YWNrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Vycm9yLXN0YWNrLWNsZWFyJyk7XG52YXIgRVJST1JfU1RBQ0tfSU5TVEFMTEFCTEUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXJyb3Itc3RhY2staW5zdGFsbGFibGUnKTtcblxuLy8gbm9uLXN0YW5kYXJkIFY4XG52YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXJyb3IsIEMsIHN0YWNrLCBkcm9wRW50cmllcykge1xuICBpZiAoRVJST1JfU1RBQ0tfSU5TVEFMTEFCTEUpIHtcbiAgICBpZiAoY2FwdHVyZVN0YWNrVHJhY2UpIGNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCBDKTtcbiAgICBlbHNlIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShlcnJvciwgJ3N0YWNrJywgY2xlYXJFcnJvclN0YWNrKHN0YWNrLCBkcm9wRW50cmllcykpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdhJyk7XG4gIGlmICghKCdzdGFjaycgaW4gZXJyb3IpKSByZXR1cm4gdHJ1ZTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgJ3N0YWNrJywgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIDcpKTtcbiAgcmV0dXJuIGVycm9yLnN0YWNrICE9PSA3O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIG5vcm1hbGl6ZVN0cmluZ0FyZ3VtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25vcm1hbGl6ZS1zdHJpbmctYXJndW1lbnQnKTtcblxudmFyIG5hdGl2ZUVycm9yVG9TdHJpbmcgPSBFcnJvci5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnZhciBJTkNPUlJFQ1RfVE9fU1RSSU5HID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgICAvLyBDaHJvbWUgMzItIGluY29ycmVjdGx5IGNhbGwgYWNjZXNzb3JcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWNyZWF0ZSwgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiAgICB2YXIgb2JqZWN0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICduYW1lJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzID09PSBvYmplY3Q7XG4gICAgfSB9KSk7XG4gICAgaWYgKG5hdGl2ZUVycm9yVG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSAndHJ1ZScpIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIEZGMTAtIGRvZXMgbm90IHByb3Blcmx5IGhhbmRsZSBub24tc3RyaW5nc1xuICByZXR1cm4gbmF0aXZlRXJyb3JUb1N0cmluZy5jYWxsKHsgbWVzc2FnZTogMSwgbmFtZTogMiB9KSAhPT0gJzI6IDEnXG4gICAgLy8gSUU4IGRvZXMgbm90IHByb3Blcmx5IGhhbmRsZSBkZWZhdWx0c1xuICAgIHx8IG5hdGl2ZUVycm9yVG9TdHJpbmcuY2FsbCh7fSkgIT09ICdFcnJvcic7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBJTkNPUlJFQ1RfVE9fU1RSSU5HID8gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHZhciBPID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciBuYW1lID0gbm9ybWFsaXplU3RyaW5nQXJndW1lbnQoTy5uYW1lLCAnRXJyb3InKTtcbiAgdmFyIG1lc3NhZ2UgPSBub3JtYWxpemVTdHJpbmdBcmd1bWVudChPLm1lc3NhZ2UpO1xuICByZXR1cm4gIW5hbWUgPyBtZXNzYWdlIDogIW1lc3NhZ2UgPyBuYW1lIDogbmFtZSArICc6ICcgKyBtZXNzYWdlO1xufSA6IG5hdGl2ZUVycm9yVG9TdHJpbmc7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5Jyk7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5kb250Q2FsbEdldFNldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbFRoaXM7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsVGhpc1tUQVJHRVRdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IGdsb2JhbFRoaXNbVEFSR0VUXSAmJiBnbG9iYWxUaGlzW1RBUkdFVF0ucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMuZG9udENhbGxHZXRTZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmaW5lQnVpbHRJbih0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3MgbW92ZWQgdG8gZW50cnkgcG9pbnRzXG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjJyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG52YXIgUmVnRXhwUHJvdG90eXBlID0gUmVnRXhwLnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjLCBGT1JDRUQsIFNIQU0pIHtcbiAgdmFyIFNZTUJPTCA9IHdlbGxLbm93blN5bWJvbChLRVkpO1xuXG4gIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdHJpbmcgbWV0aG9kcyBjYWxsIHN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPT0gNztcbiAgfSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19FWEVDID0gREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmUgPSAvYS87XG5cbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBXZSBjYW4ndCB1c2UgcmVhbCByZWdleCBoZXJlIHNpbmNlIGl0IGNhdXNlcyBkZW9wdGltaXphdGlvblxuICAgICAgLy8gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24gaW4gVjhcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMDZcbiAgICAgIHJlID0ge307XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgICByZS5mbGFncyA9ICcnO1xuICAgICAgcmVbU1lNQk9MXSA9IC8uL1tTWU1CT0xdO1xuICAgIH1cblxuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBleGVjQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICByZVtTWU1CT0xdKCcnKTtcbiAgICByZXR1cm4gIWV4ZWNDYWxsZWQ7XG4gIH0pO1xuXG4gIGlmIChcbiAgICAhREVMRUdBVEVTX1RPX1NZTUJPTCB8fFxuICAgICFERUxFR0FURVNfVE9fRVhFQyB8fFxuICAgIEZPUkNFRFxuICApIHtcbiAgICB2YXIgbmF0aXZlUmVnRXhwTWV0aG9kID0gLy4vW1NZTUJPTF07XG4gICAgdmFyIG1ldGhvZHMgPSBleGVjKFNZTUJPTCwgJydbS0VZXSwgZnVuY3Rpb24gKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICB2YXIgJGV4ZWMgPSByZWdleHAuZXhlYztcbiAgICAgIGlmICgkZXhlYyA9PT0gcmVnZXhwRXhlYyB8fCAkZXhlYyA9PT0gUmVnRXhwUHJvdG90eXBlLmV4ZWMpIHtcbiAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgLy8gcG9seWZpbGxlZCBmdW5jdGlvbiksIGxlYXNpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IGNhbGwobmF0aXZlUmVnRXhwTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogY2FsbChuYXRpdmVNZXRob2QsIHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICB9KTtcblxuICAgIGRlZmluZUJ1aWx0SW4oU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBtZXRob2RzWzBdKTtcbiAgICBkZWZpbmVCdWlsdEluKFJlZ0V4cFByb3RvdHlwZSwgU1lNQk9MLCBtZXRob2RzWzFdKTtcbiAgfVxuXG4gIGlmIChTSEFNKSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoUmVnRXhwUHJvdG90eXBlW1NZTUJPTF0sICdzaGFtJywgdHJ1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIE5BVElWRV9CSU5EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlJyk7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSA9IEZ1bmN0aW9uUHJvdG90eXBlLmFwcGx5O1xudmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQsIGVzL25vLXJlZmxlY3QgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgUmVmbGVjdCA9PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmFwcGx5IHx8IChOQVRJVkVfQklORCA/IGNhbGwuYmluZChhcHBseSkgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsLmFwcGx5KGFwcGx5LCBhcmd1bWVudHMpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLWNsYXVzZScpO1xudmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG52YXIgTkFUSVZFX0JJTkQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUnKTtcblxudmFyIGJpbmQgPSB1bmN1cnJ5VGhpcyh1bmN1cnJ5VGhpcy5iaW5kKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCkge1xuICBhQ2FsbGFibGUoZm4pO1xuICByZXR1cm4gdGhhdCA9PT0gdW5kZWZpbmVkID8gZm4gOiBOQVRJVkVfQklORCA/IGJpbmQoZm4sIHRoYXQpIDogZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQgLS0gc2FmZVxuICB2YXIgdGVzdCA9IChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pLmJpbmQoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiB0eXBlb2YgdGVzdCAhPSAnZnVuY3Rpb24nIHx8IHRlc3QuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZScpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgYUNhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtY2FsbGFibGUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIGFycmF5U2xpY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc2xpY2UnKTtcbnZhciBOQVRJVkVfQklORCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZScpO1xuXG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG52YXIgY29uY2F0ID0gdW5jdXJyeVRoaXMoW10uY29uY2F0KTtcbnZhciBqb2luID0gdW5jdXJyeVRoaXMoW10uam9pbik7XG52YXIgZmFjdG9yaWVzID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbiAoQywgYXJnc0xlbmd0aCwgYXJncykge1xuICBpZiAoIWhhc093bihmYWN0b3JpZXMsIGFyZ3NMZW5ndGgpKSB7XG4gICAgdmFyIGxpc3QgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBhcmdzTGVuZ3RoOyBpKyspIGxpc3RbaV0gPSAnYVsnICsgaSArICddJztcbiAgICBmYWN0b3JpZXNbYXJnc0xlbmd0aF0gPSAkRnVuY3Rpb24oJ0MsYScsICdyZXR1cm4gbmV3IEMoJyArIGpvaW4obGlzdCwgJywnKSArICcpJyk7XG4gIH0gcmV0dXJuIGZhY3Rvcmllc1thcmdzTGVuZ3RoXShDLCBhcmdzKTtcbn07XG5cbi8vIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQgLS0gZGV0ZWN0aW9uXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9CSU5EID8gJEZ1bmN0aW9uLmJpbmQgOiBmdW5jdGlvbiBiaW5kKHRoYXQgLyogLCAuLi5hcmdzICovKSB7XG4gIHZhciBGID0gYUNhbGxhYmxlKHRoaXMpO1xuICB2YXIgUHJvdG90eXBlID0gRi5wcm90b3R5cGU7XG4gIHZhciBwYXJ0QXJncyA9IGFycmF5U2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGJvdW5kRnVuY3Rpb24gPSBmdW5jdGlvbiBib3VuZCgvKiBhcmdzLi4uICovKSB7XG4gICAgdmFyIGFyZ3MgPSBjb25jYXQocGFydEFyZ3MsIGFycmF5U2xpY2UoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZEZ1bmN0aW9uID8gY29uc3RydWN0KEYsIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IEYuYXBwbHkodGhhdCwgYXJncyk7XG4gIH07XG4gIGlmIChpc09iamVjdChQcm90b3R5cGUpKSBib3VuZEZ1bmN0aW9uLnByb3RvdHlwZSA9IFByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kRnVuY3Rpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIE5BVElWRV9CSU5EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlJyk7XG5cbnZhciBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IGNhbGwuYmluZChjYWxsKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwuYXBwbHkoY2FsbCwgYXJndW1lbnRzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbnZhciBFWElTVFMgPSBoYXNPd24oRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJyk7XG4vLyBhZGRpdGlvbmFsIHByb3RlY3Rpb24gZnJvbSBtaW5pZmllZCAvIG1hbmdsZWQgLyBkcm9wcGVkIGZ1bmN0aW9uIG5hbWVzXG52YXIgUFJPUEVSID0gRVhJU1RTICYmIChmdW5jdGlvbiBzb21ldGhpbmcoKSB7IC8qIGVtcHR5ICovIH0pLm5hbWUgPT09ICdzb21ldGhpbmcnO1xudmFyIENPTkZJR1VSQUJMRSA9IEVYSVNUUyAmJiAoIURFU0NSSVBUT1JTIHx8IChERVNDUklQVE9SUyAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpLmNvbmZpZ3VyYWJsZSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRVhJU1RTOiBFWElTVFMsXG4gIFBST1BFUjogUFJPUEVSLFxuICBDT05GSUdVUkFCTEU6IENPTkZJR1VSQUJMRVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgbWV0aG9kKSB7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuICAgIHJldHVybiB1bmN1cnJ5VGhpcyhhQ2FsbGFibGUoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIGtleSlbbWV0aG9kXSkpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNsYXNzb2ZSYXcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgLy8gTmFzaG9ybiBidWc6XG4gIC8vICAgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzExMjhcbiAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTEzMFxuICBpZiAoY2xhc3NvZlJhdyhmbikgPT09ICdGdW5jdGlvbicpIHJldHVybiB1bmN1cnJ5VGhpcyhmbik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIE5BVElWRV9CSU5EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlJyk7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBjYWxsID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG52YXIgdW5jdXJyeVRoaXNXaXRoQmluZCA9IE5BVElWRV9CSU5EICYmIEZ1bmN0aW9uUHJvdG90eXBlLmJpbmQuYmluZChjYWxsLCBjYWxsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IHVuY3VycnlUaGlzV2l0aEJpbmQgOiBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbC5hcHBseShmbiwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNDYWxsYWJsZShhcmd1bWVudCkgPyBhcmd1bWVudCA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWxUaGlzW25hbWVzcGFjZV0pIDogZ2xvYmFsVGhpc1tuYW1lc3BhY2VdICYmIGdsb2JhbFRoaXNbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGBHZXRJdGVyYXRvckRpcmVjdChvYmopYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9wcm9wb3NhbC1pdGVyYXRvci1oZWxwZXJzLyNzZWMtZ2V0aXRlcmF0b3JkaXJlY3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4ge1xuICAgIGl0ZXJhdG9yOiBvYmosXG4gICAgbmV4dDogb2JqLm5leHQsXG4gICAgZG9uZTogZmFsc2VcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgZ2V0TWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1tZXRob2QnKTtcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGl0KSkgcmV0dXJuIGdldE1ldGhvZChpdCwgSVRFUkFUT1IpXG4gICAgfHwgZ2V0TWV0aG9kKGl0LCAnQEBpdGVyYXRvcicpXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgYUNhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtY2FsbGFibGUnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0cnlUb1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90cnktdG8tc3RyaW5nJyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQsIHVzaW5nSXRlcmF0b3IpIHtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBnZXRJdGVyYXRvck1ldGhvZChhcmd1bWVudCkgOiB1c2luZ0l0ZXJhdG9yO1xuICBpZiAoYUNhbGxhYmxlKGl0ZXJhdG9yTWV0aG9kKSkgcmV0dXJuIGFuT2JqZWN0KGNhbGwoaXRlcmF0b3JNZXRob2QsIGFyZ3VtZW50KSk7XG4gIHRocm93IG5ldyAkVHlwZUVycm9yKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xuXG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZXBsYWNlcikge1xuICBpZiAoaXNDYWxsYWJsZShyZXBsYWNlcikpIHJldHVybiByZXBsYWNlcjtcbiAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmV0dXJuO1xuICB2YXIgcmF3TGVuZ3RoID0gcmVwbGFjZXIubGVuZ3RoO1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0xlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZW1lbnQgPSByZXBsYWNlcltpXTtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT0gJ3N0cmluZycpIHB1c2goa2V5cywgZWxlbWVudCk7XG4gICAgZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT0gJ251bWJlcicgfHwgY2xhc3NvZihlbGVtZW50KSA9PT0gJ051bWJlcicgfHwgY2xhc3NvZihlbGVtZW50KSA9PT0gJ1N0cmluZycpIHB1c2goa2V5cywgdG9TdHJpbmcoZWxlbWVudCkpO1xuICB9XG4gIHZhciBrZXlzTGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciByb290ID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgIHJvb3QgPSBmYWxzZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkodGhpcykpIHJldHVybiB2YWx1ZTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXNMZW5ndGg7IGorKykgaWYgKGtleXNbal0gPT09IGtleSkgcmV0dXJuIHZhbHVlO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkJyk7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQoZnVuYykgPyB1bmRlZmluZWQgOiBhQ2FsbGFibGUoZnVuYyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbm1vZHVsZS5leHBvcnRzID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgfHxcbiAgY2hlY2sodHlwZW9mIHRoaXMgPT0gJ29iamVjdCcgJiYgdGhpcykgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jIC0tIGZhbGxiYWNrXG4gIChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKHt9Lmhhc093blByb3BlcnR5KTtcblxuLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaGFzb3duIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QoaXQpLCBrZXkpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0ge307XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xuXG4vLyBUaGFua3MgdG8gSUU4IGZvciBpdHMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIURFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT09IDc7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcygnJy5zcGxpdCk7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICEkT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZihpdCkgPT09ICdTdHJpbmcnID8gc3BsaXQoaXQsICcnKSA6ICRPYmplY3QoaXQpO1xufSA6ICRPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG5cbi8vIG1ha2VzIHN1YmNsYXNzaW5nIHdvcmsgY29ycmVjdCBmb3Igd3JhcHBlZCBidWlsdC1pbnNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCR0aGlzLCBkdW1teSwgV3JhcHBlcikge1xuICB2YXIgTmV3VGFyZ2V0LCBOZXdUYXJnZXRQcm90b3R5cGU7XG4gIGlmIChcbiAgICAvLyBpdCBjYW4gd29yayBvbmx5IHdpdGggbmF0aXZlIGBzZXRQcm90b3R5cGVPZmBcbiAgICBzZXRQcm90b3R5cGVPZiAmJlxuICAgIC8vIHdlIGhhdmVuJ3QgY29tcGxldGVseSBjb3JyZWN0IHByZS1FUzYgd2F5IGZvciBnZXR0aW5nIGBuZXcudGFyZ2V0YCwgc28gdXNlIHRoaXNcbiAgICBpc0NhbGxhYmxlKE5ld1RhcmdldCA9IGR1bW15LmNvbnN0cnVjdG9yKSAmJlxuICAgIE5ld1RhcmdldCAhPT0gV3JhcHBlciAmJlxuICAgIGlzT2JqZWN0KE5ld1RhcmdldFByb3RvdHlwZSA9IE5ld1RhcmdldC5wcm90b3R5cGUpICYmXG4gICAgTmV3VGFyZ2V0UHJvdG90eXBlICE9PSBXcmFwcGVyLnByb3RvdHlwZVxuICApIHNldFByb3RvdHlwZU9mKCR0aGlzLCBOZXdUYXJnZXRQcm90b3R5cGUpO1xuICByZXR1cm4gJHRoaXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBzdG9yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcblxudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhGdW5jdGlvbi50b1N0cmluZyk7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICghaXNDYWxsYWJsZShzdG9yZS5pbnNwZWN0U291cmNlKSkge1xuICBzdG9yZS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlLmluc3BlY3RTb3VyY2U7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xuXG4vLyBgSW5zdGFsbEVycm9yQ2F1c2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL3Byb3Bvc2FsLWVycm9yLWNhdXNlLyNzZWMtZXJyb3JvYmplY3RzLWluc3RhbGwtZXJyb3ItY2F1c2Vcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIG9wdGlvbnMpIHtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjYXVzZScgaW4gb3B0aW9ucykge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShPLCAnY2F1c2UnLCBvcHRpb25zLmNhdXNlKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBOQVRJVkVfV0VBS19NQVAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2Vhay1tYXAtYmFzaWMtZGV0ZWN0aW9uJyk7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxudmFyIE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gJ09iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWxUaGlzLlR5cGVFcnJvcjtcbnZhciBXZWFrTWFwID0gZ2xvYmFsVGhpcy5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVAgfHwgc2hhcmVkLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtYXNzaWduIC0tIHByb3RvdHlwZSBtZXRob2RzIHByb3RlY3Rpb24gKi9cbiAgc3RvcmUuZ2V0ID0gc3RvcmUuZ2V0O1xuICBzdG9yZS5oYXMgPSBzdG9yZS5oYXM7XG4gIHN0b3JlLnNldCA9IHN0b3JlLnNldDtcbiAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWFzc2lnbiAtLSBwcm90b3R5cGUgbWV0aG9kcyBwcm90ZWN0aW9uICovXG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoc3RvcmUuaGFzKGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgc3RvcmUuc2V0KGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gc3RvcmUuZ2V0KGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHN0b3JlLmhhcyhpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChoYXNPd24oaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093bihpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24oaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZVtJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xuXG4vLyBgSXNBcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1pc2FycmF5IC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZ3VtZW50KSB7XG4gIHJldHVybiBjbGFzc29mKGFyZ3VtZW50KSA9PT0gJ0FycmF5Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLUlzSFRNTEREQS1pbnRlcm5hbC1zbG90XG52YXIgZG9jdW1lbnRBbGwgPSB0eXBlb2YgZG9jdW1lbnQgPT0gJ29iamVjdCcgJiYgZG9jdW1lbnQuYWxsO1xuXG4vLyBgSXNDYWxsYWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLXR5cGVvZi11bmRlZmluZWQgLS0gcmVxdWlyZWQgZm9yIHRlc3Rpbmdcbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIGRvY3VtZW50QWxsID09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50QWxsICE9PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50ID09PSBkb2N1bWVudEFsbDtcbn0gOiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGluc3BlY3RTb3VyY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UnKTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgY29uc3RydWN0ID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbnZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXFxzKig/OmNsYXNzfGZ1bmN0aW9uKVxcYi87XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzKGNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMpO1xudmFyIElOQ09SUkVDVF9UT19TVFJJTkcgPSAhY29uc3RydWN0b3JSZWdFeHAudGVzdChub29wKTtcblxudmFyIGlzQ29uc3RydWN0b3JNb2Rlcm4gPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdHJ1Y3Qobm9vcCwgW10sIGFyZ3VtZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBpc0NvbnN0cnVjdG9yTGVnYWN5ID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAoY2xhc3NvZihhcmd1bWVudCkpIHtcbiAgICBjYXNlICdBc3luY0Z1bmN0aW9uJzpcbiAgICBjYXNlICdHZW5lcmF0b3JGdW5jdGlvbic6XG4gICAgY2FzZSAnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbic6IHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIC8vIHdlIGNhbid0IGNoZWNrIC5wcm90b3R5cGUgc2luY2UgY29uc3RydWN0b3JzIHByb2R1Y2VkIGJ5IC5iaW5kIGhhdmVuJ3QgaXRcbiAgICAvLyBgRnVuY3Rpb24jdG9TdHJpbmdgIHRocm93cyBvbiBzb21lIGJ1aWx0LWl0IGZ1bmN0aW9uIGluIHNvbWUgbGVnYWN5IGVuZ2luZXNcbiAgICAvLyAoZm9yIGV4YW1wbGUsIGBET01RdWFkYCBhbmQgc2ltaWxhciBpbiBGRjQxLSlcbiAgICByZXR1cm4gSU5DT1JSRUNUX1RPX1NUUklORyB8fCAhIWV4ZWMoY29uc3RydWN0b3JSZWdFeHAsIGluc3BlY3RTb3VyY2UoYXJndW1lbnQpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuaXNDb25zdHJ1Y3RvckxlZ2FjeS5zaGFtID0gdHJ1ZTtcblxuLy8gYElzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXG5tb2R1bGUuZXhwb3J0cyA9ICFjb25zdHJ1Y3QgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGVkO1xuICByZXR1cm4gaXNDb25zdHJ1Y3Rvck1vZGVybihpc0NvbnN0cnVjdG9yTW9kZXJuLmNhbGwpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZTsgfSlcbiAgICB8fCBjYWxsZWQ7XG59KSA/IGlzQ29uc3RydWN0b3JMZWdhY3kgOiBpc0NvbnN0cnVjdG9yTW9kZXJuO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCAmJiAoaGFzT3duKGRlc2NyaXB0b3IsICd2YWx1ZScpIHx8IGhhc093bihkZXNjcmlwdG9yLCAnd3JpdGFibGUnKSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09PSBQT0xZRklMTCA/IHRydWVcbiAgICA6IHZhbHVlID09PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogaXNDYWxsYWJsZShkZXRlY3Rpb24pID8gZmFpbHMoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBJc0ludGVncmFsTnVtYmVyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNpbnRlZ3JhbG51bWJlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW51bWJlci1pc2ludGVnZXIgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCkge1xuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyB3ZSBjYW4ndCB1c2UganVzdCBgaXQgPT0gbnVsbGAgc2luY2Ugb2YgYGRvY3VtZW50LmFsbGAgc3BlY2lhbCBjYXNlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLUlzSFRNTEREQS1pbnRlcm5hbC1zbG90LWFlY1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID09PSBudWxsIHx8IGl0ID09PSB1bmRlZmluZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZShpdCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNPYmplY3QoYXJndW1lbnQpIHx8IGFyZ3VtZW50ID09PSBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2woJ21hdGNoJyk7XG5cbi8vIGBJc1JlZ0V4cGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzcmVnZXhwXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjbGFzc29mKGl0KSA9PT0gJ1JlZ0V4cCcpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZCcpO1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxubW9kdWxlLmV4cG9ydHMgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpO1xuICByZXR1cm4gaXNDYWxsYWJsZSgkU3ltYm9sKSAmJiBpc1Byb3RvdHlwZU9mKCRTeW1ib2wucHJvdG90eXBlLCAkT2JqZWN0KGl0KSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdHJ5VG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZycpO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xudmFyIGdldEl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvcicpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBpdGVyYXRvckNsb3NlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG52YXIgUmVzdWx0ID0gZnVuY3Rpb24gKHN0b3BwZWQsIHJlc3VsdCkge1xuICB0aGlzLnN0b3BwZWQgPSBzdG9wcGVkO1xuICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbn07XG5cbnZhciBSZXN1bHRQcm90b3R5cGUgPSBSZXN1bHQucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgdW5ib3VuZEZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciB0aGF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRoYXQ7XG4gIHZhciBBU19FTlRSSUVTID0gISEob3B0aW9ucyAmJiBvcHRpb25zLkFTX0VOVFJJRVMpO1xuICB2YXIgSVNfUkVDT1JEID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklTX1JFQ09SRCk7XG4gIHZhciBJU19JVEVSQVRPUiA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JU19JVEVSQVRPUik7XG4gIHZhciBJTlRFUlJVUFRFRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JTlRFUlJVUFRFRCk7XG4gIHZhciBmbiA9IGJpbmQodW5ib3VuZEZ1bmN0aW9uLCB0aGF0KTtcbiAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcblxuICB2YXIgc3RvcCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICBpZiAoaXRlcmF0b3IpIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICdub3JtYWwnLCBjb25kaXRpb24pO1xuICAgIHJldHVybiBuZXcgUmVzdWx0KHRydWUsIGNvbmRpdGlvbik7XG4gIH07XG5cbiAgdmFyIGNhbGxGbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChBU19FTlRSSUVTKSB7XG4gICAgICBhbk9iamVjdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZVswXSwgdmFsdWVbMV0sIHN0b3ApIDogZm4odmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICB9IHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiAgfTtcblxuICBpZiAoSVNfUkVDT1JEKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZS5pdGVyYXRvcjtcbiAgfSBlbHNlIGlmIChJU19JVEVSQVRPUikge1xuICAgIGl0ZXJhdG9yID0gaXRlcmFibGU7XG4gIH0gZWxzZSB7XG4gICAgaXRlckZuID0gZ2V0SXRlcmF0b3JNZXRob2QoaXRlcmFibGUpO1xuICAgIGlmICghaXRlckZuKSB0aHJvdyBuZXcgJFR5cGVFcnJvcih0cnlUb1N0cmluZyhpdGVyYWJsZSkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xuICAgIC8vIG9wdGltaXNhdGlvbiBmb3IgYXJyYXkgaXRlcmF0b3JzXG4gICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoaXRlcmFibGUpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICByZXN1bHQgPSBjYWxsRm4oaXRlcmFibGVbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuICAgIH1cbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlLCBpdGVyRm4pO1xuICB9XG5cbiAgbmV4dCA9IElTX1JFQ09SRCA/IGl0ZXJhYmxlLm5leHQgOiBpdGVyYXRvci5uZXh0O1xuICB3aGlsZSAoIShzdGVwID0gY2FsbChuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdvYmplY3QnICYmIHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGdldE1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtbWV0aG9kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBraW5kLCB2YWx1ZSkge1xuICB2YXIgaW5uZXJSZXN1bHQsIGlubmVyRXJyb3I7XG4gIGFuT2JqZWN0KGl0ZXJhdG9yKTtcbiAgdHJ5IHtcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZChpdGVyYXRvciwgJ3JldHVybicpO1xuICAgIGlmICghaW5uZXJSZXN1bHQpIHtcbiAgICAgIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaW5uZXJSZXN1bHQgPSBjYWxsKGlubmVyUmVzdWx0LCBpdGVyYXRvcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW5uZXJFcnJvciA9IHRydWU7XG4gICAgaW5uZXJSZXN1bHQgPSBlcnJvcjtcbiAgfVxuICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gIGlmIChpbm5lckVycm9yKSB0aHJvdyBpbm5lclJlc3VsdDtcbiAgYW5PYmplY3QoaW5uZXJSZXN1bHQpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJykuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0LCBFTlVNRVJBQkxFX05FWFQpIHtcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigrIUVOVU1FUkFCTEVfTkVYVCwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiAgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgRnVuY3Rpb25OYW1lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvci1jcmVhdGUtY29uc3RydWN0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgSXRlcmF0b3JzQ29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZScpO1xuXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUgPSBGdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gRnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcblxuICAgIHN3aXRjaCAoS0lORCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgRU5UUklFUzogcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7IH07XG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl1cbiAgICB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddXG4gICAgfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcbiAgdmFyIGRlZmF1bHRJdGVyYXRvciA9ICFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIG5hdGl2ZUl0ZXJhdG9yIHx8IGdldEl0ZXJhdGlvbk1ldGhvZChERUZBVUxUKTtcbiAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIGlmICghSVNfUFVSRSAmJiBnZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUpICE9PSBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICBzZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNDYWxsYWJsZShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdKSkge1xuICAgICAgICAgIGRlZmluZUJ1aWx0SW4oQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBpZiAoSVNfUFVSRSkgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgICB9XG4gIH1cblxuICAvLyBmaXggQXJyYXkucHJvdG90eXBlLnsgdmFsdWVzLCBAQGl0ZXJhdG9yIH0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChQUk9QRVJfRlVOQ1RJT05fTkFNRSAmJiBERUZBVUxUID09PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgaWYgKCFJU19QVVJFICYmIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoSXRlcmFibGVQcm90b3R5cGUsICduYW1lJywgVkFMVUVTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcbiAgICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIGNhbGwobmF0aXZlSXRlcmF0b3IsIHRoaXMpOyB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICBkZWZpbmVCdWlsdEluKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICQoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xuICB9XG5cbiAgLy8gZGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUlTX1BVUkUgfHwgRk9SQ0VEKSAmJiBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIGRlZmluZUJ1aWx0SW4oSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SLCBkZWZhdWx0SXRlcmF0b3IsIHsgbmFtZTogREVGQVVMVCB9KTtcbiAgfVxuICBJdGVyYXRvcnNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvZWNtYTI2Mi9wdWxsLzM0Njdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBFeHBlY3RlZEVycm9yKSB7XG4gIHZhciBJdGVyYXRvciA9IGdsb2JhbFRoaXMuSXRlcmF0b3I7XG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yICYmIEl0ZXJhdG9yLnByb3RvdHlwZTtcbiAgdmFyIG1ldGhvZCA9IEl0ZXJhdG9yUHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlW01FVEhPRF9OQU1FXTtcblxuICB2YXIgQ0xPU0VEID0gZmFsc2U7XG5cbiAgaWYgKG1ldGhvZCkgdHJ5IHtcbiAgICBtZXRob2QuY2FsbCh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHRydWUgfTsgfSxcbiAgICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7IENMT1NFRCA9IHRydWU7IH1cbiAgICB9LCAtMSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MTE5NVxuICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgRXhwZWN0ZWRFcnJvcikpIENMT1NFRCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCFDTE9TRUQpIHJldHVybiBtZXRob2Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IGZhbHNlO1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJWAgb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XG52YXIgSXRlcmF0b3JQcm90b3R5cGUsIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSwgYXJyYXlJdGVyYXRvcjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWtleXMgLS0gc2FmZSAqL1xuaWYgKFtdLmtleXMpIHtcbiAgYXJyYXlJdGVyYXRvciA9IFtdLmtleXMoKTtcbiAgLy8gU2FmYXJpIDggaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gIGlmICghKCduZXh0JyBpbiBhcnJheUl0ZXJhdG9yKSkgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IHRydWU7XG4gIGVsc2Uge1xuICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGdldFByb3RvdHlwZU9mKGFycmF5SXRlcmF0b3IpKTtcbiAgICBpZiAoUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKSBJdGVyYXRvclByb3RvdHlwZSA9IFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxufVxuXG52YXIgTkVXX0lURVJBVE9SX1BST1RPVFlQRSA9ICFpc09iamVjdChJdGVyYXRvclByb3RvdHlwZSkgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgdGVzdCA9IHt9O1xuICAvLyBGRjQ0LSBsZWdhY3kgaXRlcmF0b3JzIGNhc2VcbiAgcmV0dXJuIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXS5jYWxsKHRlc3QpICE9PSB0ZXN0O1xufSk7XG5cbmlmIChORVdfSVRFUkFUT1JfUFJPVE9UWVBFKSBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuZWxzZSBpZiAoSVNfUFVSRSkgSXRlcmF0b3JQcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1AQGl0ZXJhdG9yXG5pZiAoIWlzQ2FsbGFibGUoSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdKSkge1xuICBkZWZpbmVCdWlsdEluKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSxcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SU1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0ge307XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoKG9iai5sZW5ndGgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZScpLkNPTkZJR1VSQUJMRTtcbnZhciBpbnNwZWN0U291cmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xuXG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyICRTdHJpbmcgPSBTdHJpbmc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG52YXIgam9pbiA9IHVuY3VycnlUaGlzKFtdLmpvaW4pO1xuXG52YXIgQ09ORklHVVJBQkxFX0xFTkdUSCA9IERFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdsZW5ndGgnLCB7IHZhbHVlOiA4IH0pLmxlbmd0aCAhPT0gODtcbn0pO1xuXG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbnZhciBtYWtlQnVpbHRJbiA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChzdHJpbmdTbGljZSgkU3RyaW5nKG5hbWUpLCAwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgbmFtZSA9ICdbJyArIHJlcGxhY2UoJFN0cmluZyhuYW1lKSwgL15TeW1ib2xcXCgoW14pXSopXFwpLiokLywgJyQxJykgKyAnXSc7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5nZXR0ZXIpIG5hbWUgPSAnZ2V0ICcgKyBuYW1lO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNldHRlcikgbmFtZSA9ICdzZXQgJyArIG5hbWU7XG4gIGlmICghaGFzT3duKHZhbHVlLCAnbmFtZScpIHx8IChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSAmJiB2YWx1ZS5uYW1lICE9PSBuYW1lKSkge1xuICAgIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHkodmFsdWUsICduYW1lJywgeyB2YWx1ZTogbmFtZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIGVsc2UgdmFsdWUubmFtZSA9IG5hbWU7XG4gIH1cbiAgaWYgKENPTkZJR1VSQUJMRV9MRU5HVEggJiYgb3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgJ2FyaXR5JykgJiYgdmFsdWUubGVuZ3RoICE9PSBvcHRpb25zLmFyaXR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHkodmFsdWUsICdwcm90b3R5cGUnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAvLyBpbiBWOCB+IENocm9tZSA1MywgcHJvdG90eXBlcyBvZiBzb21lIG1ldGhvZHMsIGxpa2UgYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgLCBhcmUgbm9uLXdyaXRhYmxlXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5wcm90b3R5cGUpIHZhbHVlLnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gIGlmICghaGFzT3duKHN0YXRlLCAnc291cmNlJykpIHtcbiAgICBzdGF0ZS5zb3VyY2UgPSBqb2luKFRFTVBMQVRFLCB0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyA/IG5hbWUgOiAnJyk7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0ZW5kLW5hdGl2ZSAtLSByZXF1aXJlZFxuRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gbWFrZUJ1aWx0SW4oZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBpc0NhbGxhYmxlKHRoaXMpICYmIGdldEludGVybmFsU3RhdGUodGhpcykuc291cmNlIHx8IGluc3BlY3RTb3VyY2UodGhpcyk7XG59LCAndG9TdHJpbmcnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuLy8gYE1hdGgudHJ1bmNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tbWF0aC10cnVuYyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gdHJ1bmMoeCkge1xuICB2YXIgbiA9ICt4O1xuICByZXR1cm4gKG4gPiAwID8gZmxvb3IgOiBjZWlsKShuKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50LCAkZGVmYXVsdCkge1xuICByZXR1cm4gYXJndW1lbnQgPT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gJycgOiAkZGVmYXVsdCA6IHRvU3RyaW5nKGFyZ3VtZW50KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcmVnZXhwJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNSZWdFeHAoaXQpKSB7XG4gICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciB0cmltID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy10cmltJykudHJpbTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xuXG52YXIgJHBhcnNlSW50ID0gZ2xvYmFsVGhpcy5wYXJzZUludDtcbnZhciBTeW1ib2wgPSBnbG9iYWxUaGlzLlN5bWJvbDtcbnZhciBJVEVSQVRPUiA9IFN5bWJvbCAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgaGV4ID0gL15bKy1dPzB4L2k7XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzKGhleC5leGVjKTtcbnZhciBGT1JDRUQgPSAkcGFyc2VJbnQod2hpdGVzcGFjZXMgKyAnMDgnKSAhPT0gOCB8fCAkcGFyc2VJbnQod2hpdGVzcGFjZXMgKyAnMHgxNicpICE9PSAyMlxuICAvLyBNUyBFZGdlIDE4LSBicm9rZW4gd2l0aCBib3hlZCBzeW1ib2xzXG4gIHx8IChJVEVSQVRPUiAmJiAhZmFpbHMoZnVuY3Rpb24gKCkgeyAkcGFyc2VJbnQoT2JqZWN0KElURVJBVE9SKSk7IH0pKTtcblxuLy8gYHBhcnNlSW50YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcGFyc2VpbnQtc3RyaW5nLXJhZGl4XG5tb2R1bGUuZXhwb3J0cyA9IEZPUkNFRCA/IGZ1bmN0aW9uIHBhcnNlSW50KHN0cmluZywgcmFkaXgpIHtcbiAgdmFyIFMgPSB0cmltKHRvU3RyaW5nKHN0cmluZykpO1xuICByZXR1cm4gJHBhcnNlSW50KFMsIChyYWRpeCA+Pj4gMCkgfHwgKGV4ZWMoaGV4LCBTKSA/IDE2IDogMTApKTtcbn0gOiAkcGFyc2VJbnQ7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAtLSBvbGQgSUUsIFdTSCAqL1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2h0bWwnKTtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xuXG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtYXNzaWdubWVudCAtLSBhdm9pZCBtZW1vcnkgbGVha1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsO1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGlnbm9yZSAqLyB9XG4gIE51bGxQcm90b09iamVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJ1xuICAgID8gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudFxuICAgICAgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgLy8gb2xkIElFXG4gICAgICA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpXG4gICAgOiBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7IC8vIFdTSFxuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtY3JlYXRlIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXNNb2R1bGUuZihyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyAmJiAhVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0KFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pZTgtZG9tLWRlZmluZScpO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXknKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbnZhciBDT05GSUdVUkFCTEUgPSAnY29uZmlndXJhYmxlJztcbnZhciBXUklUQUJMRSA9ICd3cml0YWJsZSc7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmICh0eXBlb2YgTyA9PT0gJ2Z1bmN0aW9uJyAmJiBQID09PSAncHJvdG90eXBlJyAmJiAndmFsdWUnIGluIEF0dHJpYnV0ZXMgJiYgV1JJVEFCTEUgaW4gQXR0cmlidXRlcyAmJiAhQXR0cmlidXRlc1tXUklUQUJMRV0pIHtcbiAgICB2YXIgY3VycmVudCA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcbiAgICAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgQXR0cmlidXRlcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFXSxcbiAgICAgICAgZW51bWVyYWJsZTogRU5VTUVSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tFTlVNRVJBQkxFXSA6IGN1cnJlbnRbRU5VTUVSQUJMRV0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH0gcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbn0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IG5ldyAkVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhc093bihPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighY2FsbChwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLCBPLCBQKSwgT1tQXSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZSAqL1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpLmY7XG52YXIgYXJyYXlTbGljZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zbGljZScpO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gYXJyYXlTbGljZSh3aW5kb3dOYW1lcyk7XG4gIH1cbn07XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiBjbGFzc29mKGl0KSA9PT0gJ1dpbmRvdydcbiAgICA/IGdldFdpbmRvd05hbWVzKGl0KVxuICAgIDogJGdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KGl0KSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlcicpO1xuXG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciBPYmplY3RQcm90b3R5cGUgPSAkT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/ICRPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXNPd24ob2JqZWN0LCBJRV9QUk9UTykpIHJldHVybiBvYmplY3RbSUVfUFJPVE9dO1xuICB2YXIgY29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmIChpc0NhbGxhYmxlKGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mICRPYmplY3QgPyBPYmplY3RQcm90b3R5cGUgOiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmN1cnJ5VGhpcyh7fS5pc1Byb3RvdHlwZU9mKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhc093bihoaWRkZW5LZXlzLCBrZXkpICYmIGhhc093bihPLCBrZXkpICYmIHB1c2gocmVzdWx0LCBrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gocmVzdWx0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cbnZhciB1bmN1cnJ5VGhpc0FjY2Vzc29yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1hY2Nlc3NvcicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIHNldHRlciA9IHVuY3VycnlUaGlzQWNjZXNzb3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycsICdzZXQnKTtcbiAgICBzZXR0ZXIodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIHJlcXVpcmVPYmplY3RDb2VyY2libGUoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoIWlzT2JqZWN0KE8pKSByZXR1cm4gTztcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlcihPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgb2JqZWN0R2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJykuZjtcblxudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gdW5jdXJyeVRoaXMoJHByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XG5cbi8vIGluIHNvbWUgSUUgdmVyc2lvbnMsIGBwcm9wZXJ0eUlzRW51bWVyYWJsZWAgcmV0dXJucyBpbmNvcnJlY3QgcmVzdWx0IG9uIGludGVnZXIga2V5c1xuLy8gb2YgYG51bGxgIHByb3RvdHlwZSBvYmplY3RzXG52YXIgSUVfQlVHID0gREVTQ1JJUFRPUlMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWNyZWF0ZSAtLSBzYWZlXG4gIHZhciBPID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgT1syXSA9IDI7XG4gIHJldHVybiAhcHJvcGVydHlJc0VudW1lcmFibGUoTywgMik7XG59KTtcblxuLy8gYE9iamVjdC57IGVudHJpZXMsIHZhbHVlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRPX0VOVFJJRVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KGl0KTtcbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoTyk7XG4gICAgdmFyIElFX1dPUktBUk9VTkQgPSBJRV9CVUcgJiYgb2JqZWN0R2V0UHJvdG90eXBlT2YoTykgPT09IG51bGw7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaSkge1xuICAgICAga2V5ID0ga2V5c1tpKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCAoSUVfV09SS0FST1VORCA/IGtleSBpbiBPIDogcHJvcGVydHlJc0VudW1lcmFibGUoTywga2V5KSkpIHtcbiAgICAgICAgcHVzaChyZXN1bHQsIFRPX0VOVFJJRVMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgT2JqZWN0LmVudHJpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5lbnRyaWVzXG4gIGVudHJpZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYE9iamVjdC52YWx1ZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC52YWx1ZXNcbiAgdmFsdWVzOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IHt9LnRvU3RyaW5nIDogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0KHZhbCA9IGNhbGwoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChpc0NhbGxhYmxlKGZuID0gaW5wdXQudmFsdWVPZikgJiYgIWlzT2JqZWN0KHZhbCA9IGNhbGwoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxudmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzKFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQoa2V5cywgZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsVGhpcztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVGFyZ2V0LCBTb3VyY2UsIGtleSkge1xuICBrZXkgaW4gVGFyZ2V0IHx8IGRlZmluZVByb3BlcnR5KFRhcmdldCwga2V5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU291cmNlW2tleV07IH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoaXQpIHsgU291cmNlW2tleV0gPSBpdDsgfVxuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgUmVnRXhwRXhlY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG4gIGlmIChpc0NhbGxhYmxlKGV4ZWMpKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNhbGwoZXhlYywgUiwgUyk7XG4gICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkgYW5PYmplY3QocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChjbGFzc29mKFIpID09PSAnUmVnRXhwJykgcmV0dXJuIGNhbGwocmVnZXhwRXhlYywgUiwgUyk7XG4gIHRocm93IG5ldyAkVHlwZUVycm9yKCdSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgcmVnZXhwL25vLWVtcHR5LWNhcHR1cmluZy1ncm91cCwgcmVnZXhwL25vLWVtcHR5LWdyb3VwLCByZWdleHAvbm8tbGF6eS1lbmRzIC0tIHRlc3RpbmcgKi9cbi8qIGVzbGludC1kaXNhYmxlIHJlZ2V4cC9uby11c2VsZXNzLXF1YW50aWZpZXIgLS0gdGVzdGluZyAqL1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIHJlZ2V4cEZsYWdzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1mbGFncycpO1xudmFyIHN0aWNreUhlbHBlcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLXN0aWNreS1oZWxwZXJzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpLmdldDtcbnZhciBVTlNVUFBPUlRFRF9ET1RfQUxMID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC11bnN1cHBvcnRlZC1kb3QtYWxsJyk7XG52YXIgVU5TVVBQT1JURURfTkNHID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC11bnN1cHBvcnRlZC1uY2cnKTtcblxudmFyIG5hdGl2ZVJlcGxhY2UgPSBzaGFyZWQoJ25hdGl2ZS1zdHJpbmctcmVwbGFjZScsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbnZhciBwYXRjaGVkRXhlYyA9IG5hdGl2ZUV4ZWM7XG52YXIgY2hhckF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckF0KTtcbnZhciBpbmRleE9mID0gdW5jdXJyeVRoaXMoJycuaW5kZXhPZik7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKCcnLnJlcGxhY2UpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuXG52YXIgVVBEQVRFU19MQVNUX0lOREVYX1dST05HID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlMSA9IC9hLztcbiAgdmFyIHJlMiA9IC9iKi9nO1xuICBjYWxsKG5hdGl2ZUV4ZWMsIHJlMSwgJ2EnKTtcbiAgY2FsbChuYXRpdmVFeGVjLCByZTIsICdhJyk7XG4gIHJldHVybiByZTEubGFzdEluZGV4ICE9PSAwIHx8IHJlMi5sYXN0SW5kZXggIT09IDA7XG59KSgpO1xuXG52YXIgVU5TVVBQT1JURURfWSA9IHN0aWNreUhlbHBlcnMuQlJPS0VOX0NBUkVUO1xuXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRCB8fCBVTlNVUFBPUlRFRF9ZIHx8IFVOU1VQUE9SVEVEX0RPVF9BTEwgfHwgVU5TVVBQT1JURURfTkNHO1xuXG5pZiAoUEFUQ0gpIHtcbiAgcGF0Y2hlZEV4ZWMgPSBmdW5jdGlvbiBleGVjKHN0cmluZykge1xuICAgIHZhciByZSA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZShyZSk7XG4gICAgdmFyIHN0ciA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgdmFyIHJhdyA9IHN0YXRlLnJhdztcbiAgICB2YXIgcmVzdWx0LCByZUNvcHksIGxhc3RJbmRleCwgbWF0Y2gsIGksIG9iamVjdCwgZ3JvdXA7XG5cbiAgICBpZiAocmF3KSB7XG4gICAgICByYXcubGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgcmVzdWx0ID0gY2FsbChwYXRjaGVkRXhlYywgcmF3LCBzdHIpO1xuICAgICAgcmUubGFzdEluZGV4ID0gcmF3Lmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwcyA9IHN0YXRlLmdyb3VwcztcbiAgICB2YXIgc3RpY2t5ID0gVU5TVVBQT1JURURfWSAmJiByZS5zdGlja3k7XG4gICAgdmFyIGZsYWdzID0gY2FsbChyZWdleHBGbGFncywgcmUpO1xuICAgIHZhciBzb3VyY2UgPSByZS5zb3VyY2U7XG4gICAgdmFyIGNoYXJzQWRkZWQgPSAwO1xuICAgIHZhciBzdHJDb3B5ID0gc3RyO1xuXG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgZmxhZ3MgPSByZXBsYWNlKGZsYWdzLCAneScsICcnKTtcbiAgICAgIGlmIChpbmRleE9mKGZsYWdzLCAnZycpID09PSAtMSkge1xuICAgICAgICBmbGFncyArPSAnZyc7XG4gICAgICB9XG5cbiAgICAgIHN0ckNvcHkgPSBzdHJpbmdTbGljZShzdHIsIHJlLmxhc3RJbmRleCk7XG4gICAgICAvLyBTdXBwb3J0IGFuY2hvcmVkIHN0aWNreSBiZWhhdmlvci5cbiAgICAgIGlmIChyZS5sYXN0SW5kZXggPiAwICYmICghcmUubXVsdGlsaW5lIHx8IHJlLm11bHRpbGluZSAmJiBjaGFyQXQoc3RyLCByZS5sYXN0SW5kZXggLSAxKSAhPT0gJ1xcbicpKSB7XG4gICAgICAgIHNvdXJjZSA9ICcoPzogJyArIHNvdXJjZSArICcpJztcbiAgICAgICAgc3RyQ29weSA9ICcgJyArIHN0ckNvcHk7XG4gICAgICAgIGNoYXJzQWRkZWQrKztcbiAgICAgIH1cbiAgICAgIC8vIF4oPyArIHJ4ICsgKSBpcyBuZWVkZWQsIGluIGNvbWJpbmF0aW9uIHdpdGggc29tZSBzdHIgc2xpY2luZywgdG9cbiAgICAgIC8vIHNpbXVsYXRlIHRoZSAneScgZmxhZy5cbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14oPzonICsgc291cmNlICsgJyknLCBmbGFncyk7XG4gICAgfVxuXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQpIHtcbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14nICsgc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgfVxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcpIGxhc3RJbmRleCA9IHJlLmxhc3RJbmRleDtcblxuICAgIG1hdGNoID0gY2FsbChuYXRpdmVFeGVjLCBzdGlja3kgPyByZUNvcHkgOiByZSwgc3RyQ29weSk7XG5cbiAgICBpZiAoc3RpY2t5KSB7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbWF0Y2guaW5wdXQgPSBzdHJpbmdTbGljZShtYXRjaC5pbnB1dCwgY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoWzBdID0gc3RyaW5nU2xpY2UobWF0Y2hbMF0sIGNoYXJzQWRkZWQpO1xuICAgICAgICBtYXRjaC5pbmRleCA9IHJlLmxhc3RJbmRleDtcbiAgICAgICAgcmUubGFzdEluZGV4ICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH0gZWxzZSByZS5sYXN0SW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HICYmIG1hdGNoKSB7XG4gICAgICByZS5sYXN0SW5kZXggPSByZS5nbG9iYWwgPyBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA6IGxhc3RJbmRleDtcbiAgICB9XG4gICAgaWYgKE5QQ0dfSU5DTFVERUQgJiYgbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAgIC8vIGZvciBOUENHLCBsaWtlIElFOC4gTk9URTogVGhpcyBkb2Vzbid0IHdvcmsgZm9yIC8oLj8pPy9cbiAgICAgIGNhbGwobmF0aXZlUmVwbGFjZSwgbWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCAmJiBncm91cHMpIHtcbiAgICAgIG1hdGNoLmdyb3VwcyA9IG9iamVjdCA9IGNyZWF0ZShudWxsKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIG9iamVjdFtncm91cFswXV0gPSBtYXRjaFtncm91cFsxXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoZWRFeGVjO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5oYXNJbmRpY2VzKSByZXN1bHQgKz0gJ2QnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC51bmljb2RlU2V0cykgcmVzdWx0ICs9ICd2JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xudmFyIHJlZ0V4cEZsYWdzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1mbGFncycpO1xuXG52YXIgUmVnRXhwUHJvdG90eXBlID0gUmVnRXhwLnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUikge1xuICB2YXIgZmxhZ3MgPSBSLmZsYWdzO1xuICByZXR1cm4gZmxhZ3MgPT09IHVuZGVmaW5lZCAmJiAhKCdmbGFncycgaW4gUmVnRXhwUHJvdG90eXBlKSAmJiAhaGFzT3duKFIsICdmbGFncycpICYmIGlzUHJvdG90eXBlT2YoUmVnRXhwUHJvdG90eXBlLCBSKVxuICAgID8gY2FsbChyZWdFeHBGbGFncywgUikgOiBmbGFncztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG5cbi8vIGJhYmVsLW1pbmlmeSBhbmQgQ2xvc3VyZSBDb21waWxlciB0cmFuc3BpbGVzIFJlZ0V4cCgnYScsICd5JykgLT4gL2EveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgJFJlZ0V4cCA9IGdsb2JhbFRoaXMuUmVnRXhwO1xuXG52YXIgVU5TVVBQT1JURURfWSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gJFJlZ0V4cCgnYScsICd5Jyk7XG4gIHJlLmxhc3RJbmRleCA9IDI7XG4gIHJldHVybiByZS5leGVjKCdhYmNkJykgIT09IG51bGw7XG59KTtcblxuLy8gVUMgQnJvd3NlciBidWdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xMDA4XG52YXIgTUlTU0VEX1NUSUNLWSA9IFVOU1VQUE9SVEVEX1kgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISRSZWdFeHAoJ2EnLCAneScpLnN0aWNreTtcbn0pO1xuXG52YXIgQlJPS0VOX0NBUkVUID0gVU5TVVBQT1JURURfWSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc3MzY4N1xuICB2YXIgcmUgPSAkUmVnRXhwKCdecicsICdneScpO1xuICByZS5sYXN0SW5kZXggPSAyO1xuICByZXR1cm4gcmUuZXhlYygnc3RyJykgIT09IG51bGw7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJST0tFTl9DQVJFVDogQlJPS0VOX0NBUkVULFxuICBNSVNTRURfU1RJQ0tZOiBNSVNTRURfU1RJQ0tZLFxuICBVTlNVUFBPUlRFRF9ZOiBVTlNVUFBPUlRFRF9ZXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xuXG4vLyBiYWJlbC1taW5pZnkgYW5kIENsb3N1cmUgQ29tcGlsZXIgdHJhbnNwaWxlcyBSZWdFeHAoJy4nLCAncycpIC0+IC8uL3MgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxudmFyICRSZWdFeHAgPSBnbG9iYWxUaGlzLlJlZ0V4cDtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAoJy4nLCAncycpO1xuICByZXR1cm4gIShyZS5kb3RBbGwgJiYgcmUudGVzdCgnXFxuJykgJiYgcmUuZmxhZ3MgPT09ICdzJyk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCcoPzxhPmIpJywgJ2cnKSAtPiAvKD88YT5iKS9nIGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwID0gZ2xvYmFsVGhpcy5SZWdFeHA7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAkUmVnRXhwKCcoPzxhPmIpJywgJ2cnKTtcbiAgcmV0dXJuIHJlLmV4ZWMoJ2InKS5ncm91cHMuYSAhPT0gJ2InIHx8XG4gICAgJ2InLnJlcGxhY2UocmUsICckPGE+YycpICE9PSAnYmMnO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNOdWxsT3JVbmRlZmluZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKGl0KSkgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIEF2b2lkIE5vZGVKUyBleHBlcmltZW50YWwgd2FybmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIURFU0NSSVBUT1JTKSByZXR1cm4gZ2xvYmFsVGhpc1tuYW1lXTtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsVGhpcywgbmFtZSk7XG4gIHJldHVybiBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gYFNhbWVWYWx1ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNhbWV2YWx1ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1pcyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9PSB4ICYmIHkgIT09IHk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciBhcHBseSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1hcHBseScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBFTlZJUk9OTUVOVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnZpcm9ubWVudCcpO1xudmFyIFVTRVJfQUdFTlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW52aXJvbm1lbnQtdXNlci1hZ2VudCcpO1xudmFyIGFycmF5U2xpY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc2xpY2UnKTtcbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy92YWxpZGF0ZS1hcmd1bWVudHMtbGVuZ3RoJyk7XG5cbnZhciBGdW5jdGlvbiA9IGdsb2JhbFRoaXMuRnVuY3Rpb247XG4vLyBkaXJ0eSBJRTktIGFuZCBCdW4gMC4zLjAtIGNoZWNrc1xudmFyIFdSQVAgPSAvTVNJRSAuXFwuLy50ZXN0KFVTRVJfQUdFTlQpIHx8IEVOVklST05NRU5UID09PSAnQlVOJyAmJiAoZnVuY3Rpb24gKCkge1xuICB2YXIgdmVyc2lvbiA9IGdsb2JhbFRoaXMuQnVuLnZlcnNpb24uc3BsaXQoJy4nKTtcbiAgcmV0dXJuIHZlcnNpb24ubGVuZ3RoIDwgMyB8fCB2ZXJzaW9uWzBdID09PSAnMCcgJiYgKHZlcnNpb25bMV0gPCAzIHx8IHZlcnNpb25bMV0gPT09ICczJyAmJiB2ZXJzaW9uWzJdID09PSAnMCcpO1xufSkoKTtcblxuLy8gSUU5LSAvIEJ1biAwLjMuMC0gc2V0VGltZW91dCAvIHNldEludGVydmFsIC8gc2V0SW1tZWRpYXRlIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3RpbWVycy1hbmQtdXNlci1wcm9tcHRzLmh0bWwjdGltZXJzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vb3Zlbi1zaC9idW4vaXNzdWVzLzE2MzNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaGFzVGltZUFyZykge1xuICB2YXIgZmlyc3RQYXJhbUluZGV4ID0gaGFzVGltZUFyZyA/IDIgOiAxO1xuICByZXR1cm4gV1JBUCA/IGZ1bmN0aW9uIChoYW5kbGVyLCB0aW1lb3V0IC8qICwgLi4uYXJndW1lbnRzICovKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpID4gZmlyc3RQYXJhbUluZGV4O1xuICAgIHZhciBmbiA9IGlzQ2FsbGFibGUoaGFuZGxlcikgPyBoYW5kbGVyIDogRnVuY3Rpb24oaGFuZGxlcik7XG4gICAgdmFyIHBhcmFtcyA9IGJvdW5kQXJncyA/IGFycmF5U2xpY2UoYXJndW1lbnRzLCBmaXJzdFBhcmFtSW5kZXgpIDogW107XG4gICAgdmFyIGNhbGxiYWNrID0gYm91bmRBcmdzID8gZnVuY3Rpb24gKCkge1xuICAgICAgYXBwbHkoZm4sIHRoaXMsIHBhcmFtcyk7XG4gICAgfSA6IGZuO1xuICAgIHJldHVybiBoYXNUaW1lQXJnID8gc2NoZWR1bGVyKGNhbGxiYWNrLCB0aW1lb3V0KSA6IHNjaGVkdWxlcihjYWxsYmFjayk7XG4gIH0gOiBzY2hlZHVsZXI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIFRBRywgU1RBVElDKSB7XG4gIGlmICh0YXJnZXQgJiYgIVNUQVRJQykgdGFyZ2V0ID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgaWYgKHRhcmdldCAmJiAhaGFzT3duKHRhcmdldCwgVE9fU1RSSU5HX1RBRykpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIFRPX1NUUklOR19UQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG5cbnZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5Jyk7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsVGhpc1tTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFNIQVJFRCwge30pO1xuXG4oc3RvcmUudmVyc2lvbnMgfHwgKHN0b3JlLnZlcnNpb25zID0gW10pKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuNDIuMCcsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxNC0yMDI1IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJyxcbiAgbGljZW5zZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvdjMuNDIuMC9MSUNFTlNFJyxcbiAgc291cmNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMnXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdG9yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlIHx8IHt9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5Jyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxudmFyIGNoYXJBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJBdCk7XG52YXIgY2hhckNvZGVBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJDb2RlQXQpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuICAgIHZhciBTID0gdG9TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgIHZhciBwb3NpdGlvbiA9IHRvSW50ZWdlck9ySW5maW5pdHkocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBjaGFyQ29kZUF0KFMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gY2hhckNvZGVBdChTLCBwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkZcbiAgICAgICAgPyBDT05WRVJUX1RPX1NUUklOR1xuICAgICAgICAgID8gY2hhckF0KFMsIHBvc2l0aW9uKVxuICAgICAgICAgIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklOR1xuICAgICAgICAgID8gc3RyaW5nU2xpY2UoUywgcG9zaXRpb24sIHBvc2l0aW9uICsgMilcbiAgICAgICAgICA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcbiAgY29kZUF0OiBjcmVhdGVNZXRob2QoZmFsc2UpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5hdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbiAgY2hhckF0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xuXG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKCcnLnJlcGxhY2UpO1xudmFyIGx0cmltID0gUmVnRXhwKCdeWycgKyB3aGl0ZXNwYWNlcyArICddKycpO1xudmFyIHJ0cmltID0gUmVnRXhwKCcoXnxbXicgKyB3aGl0ZXNwYWNlcyArICddKVsnICsgd2hpdGVzcGFjZXMgKyAnXSskJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbSwgdHJpbVN0YXJ0LCB0cmltRW5kLCB0cmltTGVmdCwgdHJpbVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzKSB7XG4gICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHJlcGxhY2Uoc3RyaW5nLCBsdHJpbSwgJycpO1xuICAgIGlmIChUWVBFICYgMikgc3RyaW5nID0gcmVwbGFjZShzdHJpbmcsIHJ0cmltLCAnJDEnKTtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbUxlZnQsIHRyaW1TdGFydCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltc3RhcnRcbiAgc3RhcnQ6IGNyZWF0ZU1ldGhvZCgxKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltUmlnaHQsIHRyaW1FbmQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbWVuZFxuICBlbmQ6IGNyZWF0ZU1ldGhvZCgyKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltXG4gIHRyaW06IGNyZWF0ZU1ldGhvZCgzKVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW52aXJvbm1lbnQtdjgtdmVyc2lvbicpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xuXG52YXIgJFN0cmluZyA9IGdsb2JhbFRoaXMuU3RyaW5nO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgnc3ltYm9sIGRldGVjdGlvbicpO1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG4gIC8vIG5iOiBEbyBub3QgY2FsbCBgU3RyaW5nYCBkaXJlY3RseSB0byBhdm9pZCB0aGlzIGJlaW5nIG9wdGltaXplZCBvdXQgdG8gYHN5bWJvbCsnJ2Agd2hpY2ggd2lsbCxcbiAgLy8gb2YgY291cnNlLCBmYWlsLlxuICByZXR1cm4gISRTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04gJiYgVjhfVkVSU0lPTiA8IDQxO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIFN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpO1xuICB2YXIgU3ltYm9sUHJvdG90eXBlID0gU3ltYm9sICYmIFN5bWJvbC5wcm90b3R5cGU7XG4gIHZhciB2YWx1ZU9mID0gU3ltYm9sUHJvdG90eXBlICYmIFN5bWJvbFByb3RvdHlwZS52YWx1ZU9mO1xuICB2YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xuXG4gIGlmIChTeW1ib2xQcm90b3R5cGUgJiYgIVN5bWJvbFByb3RvdHlwZVtUT19QUklNSVRJVkVdKSB7XG4gICAgLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvcHJpbWl0aXZlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciAubGVuZ3RoXG4gICAgZGVmaW5lQnVpbHRJbihTeW1ib2xQcm90b3R5cGUsIFRPX1BSSU1JVElWRSwgZnVuY3Rpb24gKGhpbnQpIHtcbiAgICAgIHJldHVybiBjYWxsKHZhbHVlT2YsIHRoaXMpO1xuICAgIH0sIHsgYXJpdHk6IDEgfSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uJyk7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSBzYWZlICovXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9TWU1CT0wgJiYgISFTeW1ib2xbJ2ZvciddICYmICEhU3ltYm9sLmtleUZvcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxuLy8gYHRoaXNOdW1iZXJWYWx1ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRoaXNudW1iZXJ2YWx1ZVxubW9kdWxlLmV4cG9ydHMgPSB1bmN1cnJ5VGhpcygxLjAudmFsdWVPZik7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5Jyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRydW5jID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL21hdGgtdHJ1bmMnKTtcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgbnVtYmVyID0gK2FyZ3VtZW50O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICByZXR1cm4gbnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSAwID8gMCA6IHRydW5jKG51bWJlcik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xuXG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgbGVuID0gdG9JbnRlZ2VyT3JJbmZpbml0eShhcmd1bWVudCk7XG4gIHJldHVybiBsZW4gPiAwID8gbWluKGxlbiwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1zeW1ib2wnKTtcbnZhciBnZXRNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LW1ldGhvZCcpO1xudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcblxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIGlmICghaXNPYmplY3QoaW5wdXQpIHx8IGlzU3ltYm9sKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kKGlucHV0LCBUT19QUklNSVRJVkUpO1xuICB2YXIgcmVzdWx0O1xuICBpZiAoZXhvdGljVG9QcmltKSB7XG4gICAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdkZWZhdWx0JztcbiAgICByZXN1bHQgPSBjYWxsKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QocmVzdWx0KSB8fCBpc1N5bWJvbChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHRocm93IG5ldyAkVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1zeW1ib2wnKTtcblxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBrZXkgKyAnJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHXSA9ICd6JztcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmcodGVzdCkgPT09ICdbb2JqZWN0IHpdJztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcblxudmFyICRTdHJpbmcgPSBTdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChjbGFzc29mKGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XG4gIHJldHVybiAkU3RyaW5nKGFyZ3VtZW50KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJFN0cmluZyA9IFN0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xuXG52YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xudmFyIHRvU3RyaW5nID0gdW5jdXJyeVRoaXMoMS4wLnRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyAoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgdG9TdHJpbmcoKytpZCArIHBvc3RmaXgsIDM2KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcmVsYXRpdmUtdXJsLXN0eWxlIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHZhciB1cmwgPSBuZXcgVVJMKCdiP2E9MSZiPTImYz0zJywgJ2h0dHBzOi8vYScpO1xuICB2YXIgcGFyYW1zID0gdXJsLnNlYXJjaFBhcmFtcztcbiAgdmFyIHBhcmFtczIgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCdhPTEmYT0yJmI9MycpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHVybC5wYXRobmFtZSA9ICdjJTIwZCc7XG4gIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcGFyYW1zWydkZWxldGUnXSgnYicpO1xuICAgIHJlc3VsdCArPSBrZXkgKyB2YWx1ZTtcbiAgfSk7XG4gIHBhcmFtczJbJ2RlbGV0ZSddKCdhJywgMik7XG4gIC8vIGB1bmRlZmluZWRgIGNhc2UgaXMgYSBDaHJvbWl1bSAxMTcgYnVnXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTE0MjIyXG4gIHBhcmFtczJbJ2RlbGV0ZSddKCdiJywgdW5kZWZpbmVkKTtcbiAgcmV0dXJuIChJU19QVVJFICYmICghdXJsLnRvSlNPTiB8fCAhcGFyYW1zMi5oYXMoJ2EnLCAxKSB8fCBwYXJhbXMyLmhhcygnYScsIDIpIHx8ICFwYXJhbXMyLmhhcygnYScsIHVuZGVmaW5lZCkgfHwgcGFyYW1zMi5oYXMoJ2InKSkpXG4gICAgfHwgKCFwYXJhbXMuc2l6ZSAmJiAoSVNfUFVSRSB8fCAhREVTQ1JJUFRPUlMpKVxuICAgIHx8ICFwYXJhbXMuc29ydFxuICAgIHx8IHVybC5ocmVmICE9PSAnaHR0cHM6Ly9hL2MlMjBkP2E9MSZjPTMnXG4gICAgfHwgcGFyYW1zLmdldCgnYycpICE9PSAnMydcbiAgICB8fCBTdHJpbmcobmV3IFVSTFNlYXJjaFBhcmFtcygnP2E9MScpKSAhPT0gJ2E9MSdcbiAgICB8fCAhcGFyYW1zW0lURVJBVE9SXVxuICAgIC8vIHRocm93cyBpbiBFZGdlXG4gICAgfHwgbmV3IFVSTCgnaHR0cHM6Ly9hQGInKS51c2VybmFtZSAhPT0gJ2EnXG4gICAgfHwgbmV3IFVSTFNlYXJjaFBhcmFtcyhuZXcgVVJMU2VhcmNoUGFyYW1zKCdhPWInKSkuZ2V0KCdhJykgIT09ICdiJ1xuICAgIC8vIG5vdCBwdW55Y29kZWQgaW4gRWRnZVxuICAgIHx8IG5ldyBVUkwoJ2h0dHBzOi8v0YLQtdGB0YInKS5ob3N0ICE9PSAneG4tLWUxYXliYydcbiAgICAvLyBub3QgZXNjYXBlZCBpbiBDaHJvbWUgNjItXG4gICAgfHwgbmV3IFVSTCgnaHR0cHM6Ly9hI9CxJykuaGFzaCAhPT0gJyMlRDAlQjEnXG4gICAgLy8gZmFpbHMgaW4gQ2hyb21lIDY2LVxuICAgIHx8IHJlc3VsdCAhPT0gJ2ExYzMnXG4gICAgLy8gdGhyb3dzIGluIFNhZmFyaVxuICAgIHx8IG5ldyBVUkwoJ2h0dHBzOi8veCcsIHVuZGVmaW5lZCkuaG9zdCAhPT0gJ3gnO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N5bWJvbC1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfU1lNQk9MICYmXG4gICFTeW1ib2wuc2hhbSAmJlxuICB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxuLy8gVjggfiBDaHJvbWUgMzYtXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMzM0XG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ3Byb3RvdHlwZScsIHtcbiAgICB2YWx1ZTogNDIsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLnByb3RvdHlwZSAhPT0gNDI7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXNzZWQsIHJlcXVpcmVkKSB7XG4gIGlmIChwYXNzZWQgPCByZXF1aXJlZCkgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gIHJldHVybiBwYXNzZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG5cbnZhciBXZWFrTWFwID0gZ2xvYmFsVGhpcy5XZWFrTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQ2FsbGFibGUoV2Vha01hcCkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFN0cmluZyhXZWFrTWFwKSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICB2YXIgU3ltYm9sID0gcGF0aC5TeW1ib2wgfHwgKHBhdGguU3ltYm9sID0ge30pO1xuICBpZiAoIWhhc093bihTeW1ib2wsIE5BTUUpKSBkZWZpbmVQcm9wZXJ0eShTeW1ib2wsIE5BTUUsIHtcbiAgICB2YWx1ZTogd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mKE5BTUUpXG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxuZXhwb3J0cy5mID0gd2VsbEtub3duU3ltYm9sO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uJyk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQnKTtcblxudmFyIFN5bWJvbCA9IGdsb2JhbFRoaXMuU3ltYm9sO1xudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2xbJ2ZvciddIHx8IFN5bWJvbCA6IFN5bWJvbCAmJiBTeW1ib2wud2l0aG91dFNldHRlciB8fCB1aWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXNPd24oV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSkge1xuICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IE5BVElWRV9TWU1CT0wgJiYgaGFzT3duKFN5bWJvbCwgbmFtZSlcbiAgICAgID8gU3ltYm9sW25hbWVdXG4gICAgICA6IGNyZWF0ZVdlbGxLbm93blN5bWJvbCgnU3ltYm9sLicgKyBuYW1lKTtcbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGEgc3RyaW5nIG9mIGFsbCB2YWxpZCB1bmljb2RlIHdoaXRlc3BhY2VzXG5tb2R1bGUuZXhwb3J0cyA9ICdcXHUwMDA5XFx1MDAwQVxcdTAwMEJcXHUwMDBDXFx1MDAwRFxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTIwMDBcXHUyMDAxXFx1MjAwMicgK1xuICAnXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgaXNQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcycpO1xudmFyIHByb3h5QWNjZXNzb3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcHJveHktYWNjZXNzb3InKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgbm9ybWFsaXplU3RyaW5nQXJndW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbm9ybWFsaXplLXN0cmluZy1hcmd1bWVudCcpO1xudmFyIGluc3RhbGxFcnJvckNhdXNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luc3RhbGwtZXJyb3ItY2F1c2UnKTtcbnZhciBpbnN0YWxsRXJyb3JTdGFjayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lcnJvci1zdGFjay1pbnN0YWxsJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoRlVMTF9OQU1FLCB3cmFwcGVyLCBGT1JDRUQsIElTX0FHR1JFR0FURV9FUlJPUikge1xuICB2YXIgU1RBQ0tfVFJBQ0VfTElNSVQgPSAnc3RhY2tUcmFjZUxpbWl0JztcbiAgdmFyIE9QVElPTlNfUE9TSVRJT04gPSBJU19BR0dSRUdBVEVfRVJST1IgPyAyIDogMTtcbiAgdmFyIHBhdGggPSBGVUxMX05BTUUuc3BsaXQoJy4nKTtcbiAgdmFyIEVSUk9SX05BTUUgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIHZhciBPcmlnaW5hbEVycm9yID0gZ2V0QnVpbHRJbi5hcHBseShudWxsLCBwYXRoKTtcblxuICBpZiAoIU9yaWdpbmFsRXJyb3IpIHJldHVybjtcblxuICB2YXIgT3JpZ2luYWxFcnJvclByb3RvdHlwZSA9IE9yaWdpbmFsRXJyb3IucHJvdG90eXBlO1xuXG4gIC8vIFY4IDkuMy0gYnVnIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTEyMDA2XG4gIGlmICghSVNfUFVSRSAmJiBoYXNPd24oT3JpZ2luYWxFcnJvclByb3RvdHlwZSwgJ2NhdXNlJykpIGRlbGV0ZSBPcmlnaW5hbEVycm9yUHJvdG90eXBlLmNhdXNlO1xuXG4gIGlmICghRk9SQ0VEKSByZXR1cm4gT3JpZ2luYWxFcnJvcjtcblxuICB2YXIgQmFzZUVycm9yID0gZ2V0QnVpbHRJbignRXJyb3InKTtcblxuICB2YXIgV3JhcHBlZEVycm9yID0gd3JhcHBlcihmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBtZXNzYWdlID0gbm9ybWFsaXplU3RyaW5nQXJndW1lbnQoSVNfQUdHUkVHQVRFX0VSUk9SID8gYiA6IGEsIHVuZGVmaW5lZCk7XG4gICAgdmFyIHJlc3VsdCA9IElTX0FHR1JFR0FURV9FUlJPUiA/IG5ldyBPcmlnaW5hbEVycm9yKGEpIDogbmV3IE9yaWdpbmFsRXJyb3IoKTtcbiAgICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkocmVzdWx0LCAnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIGluc3RhbGxFcnJvclN0YWNrKHJlc3VsdCwgV3JhcHBlZEVycm9yLCByZXN1bHQuc3RhY2ssIDIpO1xuICAgIGlmICh0aGlzICYmIGlzUHJvdG90eXBlT2YoT3JpZ2luYWxFcnJvclByb3RvdHlwZSwgdGhpcykpIGluaGVyaXRJZlJlcXVpcmVkKHJlc3VsdCwgdGhpcywgV3JhcHBlZEVycm9yKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IE9QVElPTlNfUE9TSVRJT04pIGluc3RhbGxFcnJvckNhdXNlKHJlc3VsdCwgYXJndW1lbnRzW09QVElPTlNfUE9TSVRJT05dKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcblxuICBXcmFwcGVkRXJyb3IucHJvdG90eXBlID0gT3JpZ2luYWxFcnJvclByb3RvdHlwZTtcblxuICBpZiAoRVJST1JfTkFNRSAhPT0gJ0Vycm9yJykge1xuICAgIGlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoV3JhcHBlZEVycm9yLCBCYXNlRXJyb3IpO1xuICAgIGVsc2UgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhXcmFwcGVkRXJyb3IsIEJhc2VFcnJvciwgeyBuYW1lOiB0cnVlIH0pO1xuICB9IGVsc2UgaWYgKERFU0NSSVBUT1JTICYmIFNUQUNLX1RSQUNFX0xJTUlUIGluIE9yaWdpbmFsRXJyb3IpIHtcbiAgICBwcm94eUFjY2Vzc29yKFdyYXBwZWRFcnJvciwgT3JpZ2luYWxFcnJvciwgU1RBQ0tfVFJBQ0VfTElNSVQpO1xuICAgIHByb3h5QWNjZXNzb3IoV3JhcHBlZEVycm9yLCBPcmlnaW5hbEVycm9yLCAncHJlcGFyZVN0YWNrVHJhY2UnKTtcbiAgfVxuXG4gIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoV3JhcHBlZEVycm9yLCBPcmlnaW5hbEVycm9yKTtcblxuICBpZiAoIUlTX1BVUkUpIHRyeSB7XG4gICAgLy8gU2FmYXJpIDEzLSBidWc6IFdlYkFzc2VtYmx5IGVycm9ycyBkb2VzIG5vdCBoYXZlIGEgcHJvcGVyIGAubmFtZWBcbiAgICBpZiAoT3JpZ2luYWxFcnJvclByb3RvdHlwZS5uYW1lICE9PSBFUlJPUl9OQU1FKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoT3JpZ2luYWxFcnJvclByb3RvdHlwZSwgJ25hbWUnLCBFUlJPUl9OQU1FKTtcbiAgICB9XG4gICAgT3JpZ2luYWxFcnJvclByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdyYXBwZWRFcnJvcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG4gIHJldHVybiBXcmFwcGVkRXJyb3I7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UnKTtcbnZhciBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9lcy1ub3QtZXhjZWVkLXNhZmUtaW50ZWdlcicpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBWOF9WRVJTSU9OID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Vudmlyb25tZW50LXY4LXZlcnNpb24nKTtcblxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gd2VsbEtub3duU3ltYm9sKCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcblxuLy8gV2UgY2FuJ3QgdXNlIHRoaXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4vLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3OVxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgPSBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBhcnJheVtJU19DT05DQVRfU1BSRUFEQUJMRV0gPSBmYWxzZTtcbiAgcmV0dXJuIGFycmF5LmNvbmNhdCgpWzBdICE9PSBhcnJheTtcbn0pO1xuXG52YXIgaXNDb25jYXRTcHJlYWRhYmxlID0gZnVuY3Rpb24gKE8pIHtcbiAgaWYgKCFpc09iamVjdChPKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgc3ByZWFkYWJsZSA9IE9bSVNfQ09OQ0FUX1NQUkVBREFCTEVdO1xuICByZXR1cm4gc3ByZWFkYWJsZSAhPT0gdW5kZWZpbmVkID8gISFzcHJlYWRhYmxlIDogaXNBcnJheShPKTtcbn07XG5cbnZhciBGT1JDRUQgPSAhSVNfQ09OQ0FUX1NQUkVBREFCTEVfU1VQUE9SVCB8fCAhYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnY29uY2F0Jyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuY29uY2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQGlzQ29uY2F0U3ByZWFkYWJsZSBhbmQgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgYXJpdHk6IDEsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgY29uY2F0OiBmdW5jdGlvbiBjb25jYXQoYXJnKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIGksIGssIGxlbmd0aCwgbGVuLCBFO1xuICAgIGZvciAoaSA9IC0xLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIEUgPSBpID09PSAtMSA/IE8gOiBhcmd1bWVudHNbaV07XG4gICAgICBpZiAoaXNDb25jYXRTcHJlYWRhYmxlKEUpKSB7XG4gICAgICAgIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlKEUpO1xuICAgICAgICBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIobiArIGxlbik7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBsZW47IGsrKywgbisrKSBpZiAoayBpbiBFKSBjcmVhdGVQcm9wZXJ0eShBLCBuLCBFW2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlcihuICsgMSk7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KEEsIG4rKywgRSk7XG4gICAgICB9XG4gICAgfVxuICAgIEEubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkZXZlcnkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZXZlcnk7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0Jyk7XG5cbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnZXZlcnknKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIVNUUklDVF9NRVRIT0QgfSwge1xuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGV2ZXJ5KHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZvci1lYWNoJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWZvcmVhY2ggLS0gc2FmZVxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogW10uZm9yRWFjaCAhPT0gZm9yRWFjaCB9LCB7XG4gIGZvckVhY2g6IGZvckVhY2hcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZnJvbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1mcm9tJyk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbicpO1xuXG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1mcm9tIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmFibGUpO1xufSk7XG5cbi8vIGBBcnJheS5mcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxuJCh7IHRhcmdldDogJ0FycmF5Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfSVRFUkFUSU9OIH0sIHtcbiAgZnJvbTogZnJvbVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmNsdWRlcztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzJyk7XG5cbi8vIEZGOTkrIGJ1Z1xudmFyIEJST0tFTl9PTl9TUEFSU0UgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1wcm90b3R5cGUtaW5jbHVkZXMgLS0gZGV0ZWN0aW9uXG4gIHJldHVybiAhQXJyYXkoMSkuaW5jbHVkZXMoKTtcbn0pO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCUk9LRU5fT05fU1BBUlNFIH0sIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsIC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2luY2x1ZGVzJyk7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1hcnJheS1wcm90b3R5cGUtaW5kZXhvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLWNsYXVzZScpO1xudmFyICRpbmRleE9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzJykuaW5kZXhPZjtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QnKTtcblxudmFyIG5hdGl2ZUluZGV4T2YgPSB1bmN1cnJ5VGhpcyhbXS5pbmRleE9mKTtcblxudmFyIE5FR0FUSVZFX1pFUk8gPSAhIW5hdGl2ZUluZGV4T2YgJiYgMSAvIG5hdGl2ZUluZGV4T2YoWzFdLCAxLCAtMCkgPCAwO1xudmFyIEZPUkNFRCA9IE5FR0FUSVZFX1pFUk8gfHwgIWFycmF5TWV0aG9kSXNTdHJpY3QoJ2luZGV4T2YnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICB2YXIgZnJvbUluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk9cbiAgICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICAgID8gbmF0aXZlSW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHx8IDBcbiAgICAgIDogJGluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG5cbi8vIGBBcnJheS5pc0FycmF5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuaXNhcnJheVxuJCh7IHRhcmdldDogJ0FycmF5Jywgc3RhdDogdHJ1ZSB9LCB7XG4gIGlzQXJyYXk6IGlzQXJyYXlcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBkZWZpbmVJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvci1kZWZpbmUnKTtcbnZhciBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1pdGVyLXJlc3VsdC1vYmplY3QnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xuXG52YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICAgIGtpbmQ6IGtpbmQgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICB9KTtcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSBudWxsO1xuICAgIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbiAgc3dpdGNoIChzdGF0ZS5raW5kKSB7XG4gICAgY2FzZSAna2V5cyc6IHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KGluZGV4LCBmYWxzZSk7XG4gICAgY2FzZSAndmFsdWVzJzogcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodGFyZ2V0W2luZGV4XSwgZmFsc2UpO1xuICB9IHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGZhbHNlKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxudmFyIHZhbHVlcyA9IEl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG4vLyBWOCB+IENocm9tZSA0NS0gYnVnXG5pZiAoIUlTX1BVUkUgJiYgREVTQ1JJUFRPUlMgJiYgdmFsdWVzLm5hbWUgIT09ICd2YWx1ZXMnKSB0cnkge1xuICBkZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsICduYW1lJywgeyB2YWx1ZTogJ3ZhbHVlcycgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xudmFyIHNldEFycmF5TGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNldC1sZW5ndGgnKTtcbnZhciBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9lcy1ub3QtZXhjZWVkLXNhZmUtaW50ZWdlcicpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciBJTkNPUlJFQ1RfVE9fTEVOR1RIID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW10ucHVzaC5jYWxsKHsgbGVuZ3RoOiAweDEwMDAwMDAwMCB9LCAxKSAhPT0gNDI5NDk2NzI5Nztcbn0pO1xuXG4vLyBWOCA8PSAxMjEgYW5kIFNhZmFyaSA8PSAxNS40OyBGRiA8IDIzIHRocm93cyBJbnRlcm5hbEVycm9yXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0xMjY4MVxudmFyIHByb3BlckVycm9yT25Ob25Xcml0YWJsZUxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KS5wdXNoKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yO1xuICB9XG59O1xuXG52YXIgRk9SQ0VEID0gSU5DT1JSRUNUX1RPX0xFTkdUSCB8fCAhcHJvcGVyRXJyb3JPbk5vbldyaXRhYmxlTGVuZ3RoKCk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUucHVzaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5wdXNoXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgYXJpdHk6IDEsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgcHVzaDogZnVuY3Rpb24gcHVzaChpdGVtKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gICAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIobGVuICsgYXJnQ291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnQ291bnQ7IGkrKykge1xuICAgICAgT1tsZW5dID0gYXJndW1lbnRzW2ldO1xuICAgICAgbGVuKys7XG4gICAgfVxuICAgIHNldEFycmF5TGVuZ3RoKE8sIGxlbik7XG4gICAgcmV0dXJuIGxlbjtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgaXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jb25zdHJ1Y3RvcicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCcpO1xudmFyIG5hdGl2ZVNsaWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNsaWNlJyk7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnc2xpY2UnKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcbnZhciAkQXJyYXkgPSBBcnJheTtcbnZhciBtYXggPSBNYXRoLm1heDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5zbGljZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zbGljZVxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQgfSwge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcbiAgICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcbiAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpO1xuICAgIC8vIGlubGluZSBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBmb3IgdXNhZ2UgbmF0aXZlIGBBcnJheSNzbGljZWAgd2hlcmUgaXQncyBwb3NzaWJsZVxuICAgIHZhciBDb25zdHJ1Y3RvciwgcmVzdWx0LCBuO1xuICAgIGlmIChpc0FycmF5KE8pKSB7XG4gICAgICBDb25zdHJ1Y3RvciA9IE8uY29uc3RydWN0b3I7XG4gICAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgICAgaWYgKGlzQ29uc3RydWN0b3IoQ29uc3RydWN0b3IpICYmIChDb25zdHJ1Y3RvciA9PT0gJEFycmF5IHx8IGlzQXJyYXkoQ29uc3RydWN0b3IucHJvdG90eXBlKSkpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KENvbnN0cnVjdG9yKSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yW1NQRUNJRVNdO1xuICAgICAgICBpZiAoQ29uc3RydWN0b3IgPT09IG51bGwpIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yID09PSAkQXJyYXkgfHwgQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlU2xpY2UoTywgaywgZmluKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0ID0gbmV3IChDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkID8gJEFycmF5IDogQ29uc3RydWN0b3IpKG1heChmaW4gLSBrLCAwKSk7XG4gICAgZm9yIChuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGlmIChrIGluIE8pIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgbiwgT1trXSk7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xuXG52YXIgRk9SQ0VEID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IERhdGUoTmFOKS50b0pTT04oKSAhPT0gbnVsbFxuICAgIHx8IERhdGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHsgdG9JU09TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE7IH0gfSkgIT09IDE7XG59KTtcblxuLy8gYERhdGUucHJvdG90eXBlLnRvSlNPTmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWRhdGUucHJvdG90eXBlLnRvanNvblxuJCh7IHRhcmdldDogJ0RhdGUnLCBwcm90bzogdHJ1ZSwgYXJpdHk6IDEsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oa2V5KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgcHYgPSB0b1ByaW1pdGl2ZShPLCAnbnVtYmVyJyk7XG4gICAgcmV0dXJuIHR5cGVvZiBwdiA9PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUocHYpID8gbnVsbCA6IE8udG9JU09TdHJpbmcoKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xudmFyIGRhdGVUb1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kYXRlLXRvLXByaW1pdGl2ZScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xudmFyIERhdGVQcm90b3R5cGUgPSBEYXRlLnByb3RvdHlwZTtcblxuLy8gYERhdGUucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZGF0ZS5wcm90b3R5cGUtQEB0b3ByaW1pdGl2ZVxuaWYgKCFoYXNPd24oRGF0ZVByb3RvdHlwZSwgVE9fUFJJTUlUSVZFKSkge1xuICBkZWZpbmVCdWlsdEluKERhdGVQcm90b3R5cGUsIFRPX1BSSU1JVElWRSwgZGF0ZVRvUHJpbWl0aXZlKTtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcblxudmFyIERhdGVQcm90b3R5cGUgPSBEYXRlLnByb3RvdHlwZTtcbnZhciBJTlZBTElEX0RBVEUgPSAnSW52YWxpZCBEYXRlJztcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyIG5hdGl2ZURhdGVUb1N0cmluZyA9IHVuY3VycnlUaGlzKERhdGVQcm90b3R5cGVbVE9fU1RSSU5HXSk7XG52YXIgdGhpc1RpbWVWYWx1ZSA9IHVuY3VycnlUaGlzKERhdGVQcm90b3R5cGUuZ2V0VGltZSk7XG5cbi8vIGBEYXRlLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWRhdGUucHJvdG90eXBlLnRvc3RyaW5nXG5pZiAoU3RyaW5nKG5ldyBEYXRlKE5hTikpICE9PSBJTlZBTElEX0RBVEUpIHtcbiAgZGVmaW5lQnVpbHRJbihEYXRlUHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXNUaW1lVmFsdWUodGhpcyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gbmF0aXZlRGF0ZVRvU3RyaW5nKHRoaXMpIDogSU5WQUxJRF9EQVRFO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBmdW5jdGlvbnMgYC5sZW5ndGhgICovXG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgYXBwbHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYXBwbHknKTtcbnZhciB3cmFwRXJyb3JDb25zdHJ1Y3RvcldpdGhDYXVzZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93cmFwLWVycm9yLWNvbnN0cnVjdG9yLXdpdGgtY2F1c2UnKTtcblxudmFyIFdFQl9BU1NFTUJMWSA9ICdXZWJBc3NlbWJseSc7XG52YXIgV2ViQXNzZW1ibHkgPSBnbG9iYWxUaGlzW1dFQl9BU1NFTUJMWV07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1lcnJvci1jYXVzZSAtLSBmZWF0dXJlIGRldGVjdGlvblxudmFyIEZPUkNFRCA9IG5ldyBFcnJvcignZScsIHsgY2F1c2U6IDcgfSkuY2F1c2UgIT09IDc7XG5cbnZhciBleHBvcnRHbG9iYWxFcnJvckNhdXNlV3JhcHBlciA9IGZ1bmN0aW9uIChFUlJPUl9OQU1FLCB3cmFwcGVyKSB7XG4gIHZhciBPID0ge307XG4gIE9bRVJST1JfTkFNRV0gPSB3cmFwRXJyb3JDb25zdHJ1Y3RvcldpdGhDYXVzZShFUlJPUl9OQU1FLCB3cmFwcGVyLCBGT1JDRUQpO1xuICAkKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgYXJpdHk6IDEsIGZvcmNlZDogRk9SQ0VEIH0sIE8pO1xufTtcblxudmFyIGV4cG9ydFdlYkFzc2VtYmx5RXJyb3JDYXVzZVdyYXBwZXIgPSBmdW5jdGlvbiAoRVJST1JfTkFNRSwgd3JhcHBlcikge1xuICBpZiAoV2ViQXNzZW1ibHkgJiYgV2ViQXNzZW1ibHlbRVJST1JfTkFNRV0pIHtcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bRVJST1JfTkFNRV0gPSB3cmFwRXJyb3JDb25zdHJ1Y3RvcldpdGhDYXVzZShXRUJfQVNTRU1CTFkgKyAnLicgKyBFUlJPUl9OQU1FLCB3cmFwcGVyLCBGT1JDRUQpO1xuICAgICQoeyB0YXJnZXQ6IFdFQl9BU1NFTUJMWSwgc3RhdDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGFyaXR5OiAxLCBmb3JjZWQ6IEZPUkNFRCB9LCBPKTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1uYXRpdmVlcnJvclxuZXhwb3J0R2xvYmFsRXJyb3JDYXVzZVdyYXBwZXIoJ0Vycm9yJywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEVycm9yKG1lc3NhZ2UpIHsgcmV0dXJuIGFwcGx5KGluaXQsIHRoaXMsIGFyZ3VtZW50cyk7IH07XG59KTtcbmV4cG9ydEdsb2JhbEVycm9yQ2F1c2VXcmFwcGVyKCdFdmFsRXJyb3InLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRXZhbEVycm9yKG1lc3NhZ2UpIHsgcmV0dXJuIGFwcGx5KGluaXQsIHRoaXMsIGFyZ3VtZW50cyk7IH07XG59KTtcbmV4cG9ydEdsb2JhbEVycm9yQ2F1c2VXcmFwcGVyKCdSYW5nZUVycm9yJywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFJhbmdlRXJyb3IobWVzc2FnZSkgeyByZXR1cm4gYXBwbHkoaW5pdCwgdGhpcywgYXJndW1lbnRzKTsgfTtcbn0pO1xuZXhwb3J0R2xvYmFsRXJyb3JDYXVzZVdyYXBwZXIoJ1JlZmVyZW5jZUVycm9yJywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFJlZmVyZW5jZUVycm9yKG1lc3NhZ2UpIHsgcmV0dXJuIGFwcGx5KGluaXQsIHRoaXMsIGFyZ3VtZW50cyk7IH07XG59KTtcbmV4cG9ydEdsb2JhbEVycm9yQ2F1c2VXcmFwcGVyKCdTeW50YXhFcnJvcicsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTeW50YXhFcnJvcihtZXNzYWdlKSB7IHJldHVybiBhcHBseShpbml0LCB0aGlzLCBhcmd1bWVudHMpOyB9O1xufSk7XG5leHBvcnRHbG9iYWxFcnJvckNhdXNlV3JhcHBlcignVHlwZUVycm9yJywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFR5cGVFcnJvcihtZXNzYWdlKSB7IHJldHVybiBhcHBseShpbml0LCB0aGlzLCBhcmd1bWVudHMpOyB9O1xufSk7XG5leHBvcnRHbG9iYWxFcnJvckNhdXNlV3JhcHBlcignVVJJRXJyb3InLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVVJJRXJyb3IobWVzc2FnZSkgeyByZXR1cm4gYXBwbHkoaW5pdCwgdGhpcywgYXJndW1lbnRzKTsgfTtcbn0pO1xuZXhwb3J0V2ViQXNzZW1ibHlFcnJvckNhdXNlV3JhcHBlcignQ29tcGlsZUVycm9yJywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIENvbXBpbGVFcnJvcihtZXNzYWdlKSB7IHJldHVybiBhcHBseShpbml0LCB0aGlzLCBhcmd1bWVudHMpOyB9O1xufSk7XG5leHBvcnRXZWJBc3NlbWJseUVycm9yQ2F1c2VXcmFwcGVyKCdMaW5rRXJyb3InLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gTGlua0Vycm9yKG1lc3NhZ2UpIHsgcmV0dXJuIGFwcGx5KGluaXQsIHRoaXMsIGFyZ3VtZW50cyk7IH07XG59KTtcbmV4cG9ydFdlYkFzc2VtYmx5RXJyb3JDYXVzZVdyYXBwZXIoJ1J1bnRpbWVFcnJvcicsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBSdW50aW1lRXJyb3IobWVzc2FnZSkgeyByZXR1cm4gYXBwbHkoaW5pdCwgdGhpcywgYXJndW1lbnRzKTsgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG52YXIgZXJyb3JUb1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lcnJvci10by1zdHJpbmcnKTtcblxudmFyIEVycm9yUHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4vLyBgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2QgZml4XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWVycm9yLnByb3RvdHlwZS50b3N0cmluZ1xuaWYgKEVycm9yUHJvdG90eXBlLnRvU3RyaW5nICE9PSBlcnJvclRvU3RyaW5nKSB7XG4gIGRlZmluZUJ1aWx0SW4oRXJyb3JQcm90b3R5cGUsICd0b1N0cmluZycsIGVycm9yVG9TdHJpbmcpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZCcpO1xuXG4vLyBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kIC0tIGRldGVjdGlvblxuJCh7IHRhcmdldDogJ0Z1bmN0aW9uJywgcHJvdG86IHRydWUsIGZvcmNlZDogRnVuY3Rpb24uYmluZCAhPT0gYmluZCB9LCB7XG4gIGJpbmQ6IGJpbmRcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgRlVOQ1RJT05fTkFNRV9FWElTVFMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZScpLkVYSVNUUztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBkZWZpbmVCdWlsdEluQWNjZXNzb3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLWFjY2Vzc29yJyk7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMoRnVuY3Rpb25Qcm90b3R5cGUudG9TdHJpbmcpO1xudmFyIG5hbWVSRSA9IC9mdW5jdGlvblxcYig/Olxcc3xcXC9cXCpbXFxTXFxzXSo/XFwqXFwvfFxcL1xcL1teXFxuXFxyXSpbXFxuXFxyXSspKihbXlxccygvXSopLztcbnZhciByZWdFeHBFeGVjID0gdW5jdXJyeVRoaXMobmFtZVJFLmV4ZWMpO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIEZ1bmN0aW9uIGluc3RhbmNlcyBgLm5hbWVgIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLWluc3RhbmNlcy1uYW1lXG5pZiAoREVTQ1JJUFRPUlMgJiYgIUZVTkNUSU9OX05BTUVfRVhJU1RTKSB7XG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihGdW5jdGlvblByb3RvdHlwZSwgTkFNRSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZWdFeHBFeGVjKG5hbWVSRSwgZnVuY3Rpb25Ub1N0cmluZyh0aGlzKSlbMV07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi1hY2Nlc3NvcicpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZScpLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG5cbnZhciBDT05TVFJVQ1RPUiA9ICdjb25zdHJ1Y3Rvcic7XG52YXIgSVRFUkFUT1IgPSAnSXRlcmF0b3InO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xudmFyIE5hdGl2ZUl0ZXJhdG9yID0gZ2xvYmFsVGhpc1tJVEVSQVRPUl07XG5cbi8vIEZGNTYtIGhhdmUgbm9uLXN0YW5kYXJkIGdsb2JhbCBoZWxwZXIgYEl0ZXJhdG9yYFxudmFyIEZPUkNFRCA9IElTX1BVUkVcbiAgfHwgIWlzQ2FsbGFibGUoTmF0aXZlSXRlcmF0b3IpXG4gIHx8IE5hdGl2ZUl0ZXJhdG9yLnByb3RvdHlwZSAhPT0gSXRlcmF0b3JQcm90b3R5cGVcbiAgLy8gRkY0NC0gbm9uLXN0YW5kYXJkIGBJdGVyYXRvcmAgcGFzc2VzIHByZXZpb3VzIHRlc3RzXG4gIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7IE5hdGl2ZUl0ZXJhdG9yKHt9KTsgfSk7XG5cbnZhciBJdGVyYXRvckNvbnN0cnVjdG9yID0gZnVuY3Rpb24gSXRlcmF0b3IoKSB7XG4gIGFuSW5zdGFuY2UodGhpcywgSXRlcmF0b3JQcm90b3R5cGUpO1xuICBpZiAoZ2V0UHJvdG90eXBlT2YodGhpcykgPT09IEl0ZXJhdG9yUHJvdG90eXBlKSB0aHJvdyBuZXcgJFR5cGVFcnJvcignQWJzdHJhY3QgY2xhc3MgSXRlcmF0b3Igbm90IGRpcmVjdGx5IGNvbnN0cnVjdGFibGUnKTtcbn07XG5cbnZhciBkZWZpbmVJdGVyYXRvclByb3RvdHlwZUFjY2Vzc29yID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKEl0ZXJhdG9yUHJvdG90eXBlLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAocmVwbGFjZW1lbnQpIHtcbiAgICAgICAgYW5PYmplY3QodGhpcyk7XG4gICAgICAgIGlmICh0aGlzID09PSBJdGVyYXRvclByb3RvdHlwZSkgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJZb3UgY2FuJ3QgcmVkZWZpbmUgdGhpcyBwcm9wZXJ0eVwiKTtcbiAgICAgICAgaWYgKGhhc093bih0aGlzLCBrZXkpKSB0aGlzW2tleV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgZWxzZSBjcmVhdGVQcm9wZXJ0eSh0aGlzLCBrZXksIHJlcGxhY2VtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIEl0ZXJhdG9yUHJvdG90eXBlW2tleV0gPSB2YWx1ZTtcbn07XG5cbmlmICghaGFzT3duKEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHKSkgZGVmaW5lSXRlcmF0b3JQcm90b3R5cGVBY2Nlc3NvcihUT19TVFJJTkdfVEFHLCBJVEVSQVRPUik7XG5cbmlmIChGT1JDRUQgfHwgIWhhc093bihJdGVyYXRvclByb3RvdHlwZSwgQ09OU1RSVUNUT1IpIHx8IEl0ZXJhdG9yUHJvdG90eXBlW0NPTlNUUlVDVE9SXSA9PT0gT2JqZWN0KSB7XG4gIGRlZmluZUl0ZXJhdG9yUHJvdG90eXBlQWNjZXNzb3IoQ09OU1RSVUNUT1IsIEl0ZXJhdG9yQ29uc3RydWN0b3IpO1xufVxuXG5JdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IEl0ZXJhdG9yUHJvdG90eXBlO1xuXG4vLyBgSXRlcmF0b3JgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yXG4kKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBJdGVyYXRvcjogSXRlcmF0b3JDb25zdHJ1Y3RvclxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdGUnKTtcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGdldEl0ZXJhdG9yRGlyZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1kaXJlY3QnKTtcbnZhciBpdGVyYXRvckNsb3NlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlJyk7XG52YXIgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvci1oZWxwZXItd2l0aG91dC1jbG9zaW5nLW9uLWVhcmx5LWVycm9yJyk7XG5cbnZhciBldmVyeVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcignZXZlcnknLCBUeXBlRXJyb3IpO1xuXG4vLyBgSXRlcmF0b3IucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXRlcmF0b3IucHJvdG90eXBlLmV2ZXJ5XG4kKHsgdGFyZ2V0OiAnSXRlcmF0b3InLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBldmVyeVdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yIH0sIHtcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KHByZWRpY2F0ZSkge1xuICAgIGFuT2JqZWN0KHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBhQ2FsbGFibGUocHJlZGljYXRlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZSh0aGlzLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKGV2ZXJ5V2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IpIHJldHVybiBjYWxsKGV2ZXJ5V2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IsIHRoaXMsIHByZWRpY2F0ZSk7XG5cbiAgICB2YXIgcmVjb3JkID0gZ2V0SXRlcmF0b3JEaXJlY3QodGhpcyk7XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHJldHVybiAhaXRlcmF0ZShyZWNvcmQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RvcCkge1xuICAgICAgaWYgKCFwcmVkaWNhdGUodmFsdWUsIGNvdW50ZXIrKykpIHJldHVybiBzdG9wKCk7XG4gICAgfSwgeyBJU19SRUNPUkQ6IHRydWUsIElOVEVSUlVQVEVEOiB0cnVlIH0pLnN0b3BwZWQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRlJyk7XG52YXIgYUNhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtY2FsbGFibGUnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBnZXRJdGVyYXRvckRpcmVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItZGlyZWN0Jyk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvci1jbG9zZScpO1xudmFyIGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3ItaGVscGVyLXdpdGhvdXQtY2xvc2luZy1vbi1lYXJseS1lcnJvcicpO1xuXG52YXIgZm9yRWFjaFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcignZm9yRWFjaCcsIFR5cGVFcnJvcik7XG5cbi8vIGBJdGVyYXRvci5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yLnByb3RvdHlwZS5mb3JlYWNoXG4kKHsgdGFyZ2V0OiAnSXRlcmF0b3InLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBmb3JFYWNoV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgfSwge1xuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gICAgYW5PYmplY3QodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGFDYWxsYWJsZShmbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UodGhpcywgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChmb3JFYWNoV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IpIHJldHVybiBjYWxsKGZvckVhY2hXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciwgdGhpcywgZm4pO1xuXG4gICAgdmFyIHJlY29yZCA9IGdldEl0ZXJhdG9yRGlyZWN0KHRoaXMpO1xuICAgIHZhciBjb3VudGVyID0gMDtcbiAgICBpdGVyYXRlKHJlY29yZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBmbih2YWx1ZSwgY291bnRlcisrKTtcbiAgICB9LCB7IElTX1JFQ09SRDogdHJ1ZSB9KTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGFwcGx5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWFwcGx5Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtc3ltYm9sJyk7XG52YXIgYXJyYXlTbGljZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zbGljZScpO1xudmFyIGdldFJlcGxhY2VyRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWpzb24tcmVwbGFjZXItZnVuY3Rpb24nKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N5bWJvbC1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24nKTtcblxudmFyICRTdHJpbmcgPSBTdHJpbmc7XG52YXIgJHN0cmluZ2lmeSA9IGdldEJ1aWx0SW4oJ0pTT04nLCAnc3RyaW5naWZ5Jyk7XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzKC8uLy5leGVjKTtcbnZhciBjaGFyQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQXQpO1xudmFyIGNoYXJDb2RlQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQ29kZUF0KTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG52YXIgbnVtYmVyVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcygxLjAudG9TdHJpbmcpO1xuXG52YXIgdGVzdGVyID0gL1tcXHVEODAwLVxcdURGRkZdL2c7XG52YXIgbG93ID0gL15bXFx1RDgwMC1cXHVEQkZGXSQvO1xudmFyIGhpID0gL15bXFx1REMwMC1cXHVERkZGXSQvO1xuXG52YXIgV1JPTkdfU1lNQk9MU19DT05WRVJTSU9OID0gIU5BVElWRV9TWU1CT0wgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gZ2V0QnVpbHRJbignU3ltYm9sJykoJ3N0cmluZ2lmeSBkZXRlY3Rpb24nKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgcmV0dXJuICRzdHJpbmdpZnkoW3N5bWJvbF0pICE9PSAnW251bGxdJ1xuICAgIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAgIHx8ICRzdHJpbmdpZnkoeyBhOiBzeW1ib2wgfSkgIT09ICd7fSdcbiAgICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICAgIHx8ICRzdHJpbmdpZnkoT2JqZWN0KHN5bWJvbCkpICE9PSAne30nO1xufSk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXdlbGwtZm9ybWVkLXN0cmluZ2lmeVxudmFyIElMTF9GT1JNRURfVU5JQ09ERSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICRzdHJpbmdpZnkoJ1xcdURGMDZcXHVEODM0JykgIT09ICdcIlxcXFx1ZGYwNlxcXFx1ZDgzNFwiJ1xuICAgIHx8ICRzdHJpbmdpZnkoJ1xcdURFQUQnKSAhPT0gJ1wiXFxcXHVkZWFkXCInO1xufSk7XG5cbnZhciBzdHJpbmdpZnlXaXRoU3ltYm9sc0ZpeCA9IGZ1bmN0aW9uIChpdCwgcmVwbGFjZXIpIHtcbiAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlKGFyZ3VtZW50cyk7XG4gIHZhciAkcmVwbGFjZXIgPSBnZXRSZXBsYWNlckZ1bmN0aW9uKHJlcGxhY2VyKTtcbiAgaWYgKCFpc0NhbGxhYmxlKCRyZXBsYWNlcikgJiYgKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gIGFyZ3NbMV0gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIC8vIHNvbWUgb2xkIGltcGxlbWVudGF0aW9ucyAobGlrZSBXZWJLaXQpIGNvdWxkIHBhc3MgbnVtYmVycyBhcyBrZXlzXG4gICAgaWYgKGlzQ2FsbGFibGUoJHJlcGxhY2VyKSkgdmFsdWUgPSBjYWxsKCRyZXBsYWNlciwgdGhpcywgJFN0cmluZyhrZXkpLCB2YWx1ZSk7XG4gICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgcmV0dXJuIGFwcGx5KCRzdHJpbmdpZnksIG51bGwsIGFyZ3MpO1xufTtcblxudmFyIGZpeElsbEZvcm1lZCA9IGZ1bmN0aW9uIChtYXRjaCwgb2Zmc2V0LCBzdHJpbmcpIHtcbiAgdmFyIHByZXYgPSBjaGFyQXQoc3RyaW5nLCBvZmZzZXQgLSAxKTtcbiAgdmFyIG5leHQgPSBjaGFyQXQoc3RyaW5nLCBvZmZzZXQgKyAxKTtcbiAgaWYgKChleGVjKGxvdywgbWF0Y2gpICYmICFleGVjKGhpLCBuZXh0KSkgfHwgKGV4ZWMoaGksIG1hdGNoKSAmJiAhZXhlYyhsb3csIHByZXYpKSkge1xuICAgIHJldHVybiAnXFxcXHUnICsgbnVtYmVyVG9TdHJpbmcoY2hhckNvZGVBdChtYXRjaCwgMCksIDE2KTtcbiAgfSByZXR1cm4gbWF0Y2g7XG59O1xuXG5pZiAoJHN0cmluZ2lmeSkge1xuICAvLyBgSlNPTi5zdHJpbmdpZnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5XG4gICQoeyB0YXJnZXQ6ICdKU09OJywgc3RhdDogdHJ1ZSwgYXJpdHk6IDMsIGZvcmNlZDogV1JPTkdfU1lNQk9MU19DT05WRVJTSU9OIHx8IElMTF9GT1JNRURfVU5JQ09ERSB9LCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UoYXJndW1lbnRzKTtcbiAgICAgIHZhciByZXN1bHQgPSBhcHBseShXUk9OR19TWU1CT0xTX0NPTlZFUlNJT04gPyBzdHJpbmdpZnlXaXRoU3ltYm9sc0ZpeCA6ICRzdHJpbmdpZnksIG51bGwsIGFyZ3MpO1xuICAgICAgcmV0dXJuIElMTF9GT1JNRURfVU5JQ09ERSAmJiB0eXBlb2YgcmVzdWx0ID09ICdzdHJpbmcnID8gcmVwbGFjZShyZXN1bHQsIHRlc3RlciwgZml4SWxsRm9ybWVkKSA6IHJlc3VsdDtcbiAgICB9XG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgaXNQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mJyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtc3ltYm9sJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJykuZjtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgdGhpc051bWJlclZhbHVlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RoaXMtbnVtYmVyLXZhbHVlJyk7XG52YXIgdHJpbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctdHJpbScpLnRyaW07XG5cbnZhciBOVU1CRVIgPSAnTnVtYmVyJztcbnZhciBOYXRpdmVOdW1iZXIgPSBnbG9iYWxUaGlzW05VTUJFUl07XG52YXIgUHVyZU51bWJlck5hbWVzcGFjZSA9IHBhdGhbTlVNQkVSXTtcbnZhciBOdW1iZXJQcm90b3R5cGUgPSBOYXRpdmVOdW1iZXIucHJvdG90eXBlO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbFRoaXMuVHlwZUVycm9yO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xudmFyIGNoYXJDb2RlQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQ29kZUF0KTtcblxuLy8gYFRvTnVtZXJpY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbnVtZXJpY1xudmFyIHRvTnVtZXJpYyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJpbVZhbHVlID0gdG9QcmltaXRpdmUodmFsdWUsICdudW1iZXInKTtcbiAgcmV0dXJuIHR5cGVvZiBwcmltVmFsdWUgPT0gJ2JpZ2ludCcgPyBwcmltVmFsdWUgOiB0b051bWJlcihwcmltVmFsdWUpO1xufTtcblxuLy8gYFRvTnVtYmVyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9udW1iZXJcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ251bWJlcicpO1xuICB2YXIgZmlyc3QsIHRoaXJkLCByYWRpeCwgbWF4Q29kZSwgZGlnaXRzLCBsZW5ndGgsIGluZGV4LCBjb2RlO1xuICBpZiAoaXNTeW1ib2woaXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIG51bWJlcicpO1xuICBpZiAodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIpIHtcbiAgICBpdCA9IHRyaW0oaXQpO1xuICAgIGZpcnN0ID0gY2hhckNvZGVBdChpdCwgMCk7XG4gICAgaWYgKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpIHtcbiAgICAgIHRoaXJkID0gY2hhckNvZGVBdChpdCwgMik7XG4gICAgICBpZiAodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApIHJldHVybiBOYU47IC8vIE51bWJlcignKzB4MScpIHNob3VsZCBiZSBOYU4sIG9sZCBWOCBmaXhcbiAgICB9IGVsc2UgaWYgKGZpcnN0ID09PSA0OCkge1xuICAgICAgc3dpdGNoIChjaGFyQ29kZUF0KGl0LCAxKSkge1xuICAgICAgICAvLyBmYXN0IGVxdWFsIG9mIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDY2OlxuICAgICAgICBjYXNlIDk4OlxuICAgICAgICAgIHJhZGl4ID0gMjtcbiAgICAgICAgICBtYXhDb2RlID0gNDk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGZhc3QgZXF1YWwgb2YgL14wb1swLTddKyQvaVxuICAgICAgICBjYXNlIDc5OlxuICAgICAgICBjYXNlIDExMTpcbiAgICAgICAgICByYWRpeCA9IDg7XG4gICAgICAgICAgbWF4Q29kZSA9IDU1O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAraXQ7XG4gICAgICB9XG4gICAgICBkaWdpdHMgPSBzdHJpbmdTbGljZShpdCwgMik7XG4gICAgICBsZW5ndGggPSBkaWdpdHMubGVuZ3RoO1xuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvZGUgPSBjaGFyQ29kZUF0KGRpZ2l0cywgaW5kZXgpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSkgcmV0dXJuIE5hTjtcbiAgICAgIH0gcmV0dXJuIHBhcnNlSW50KGRpZ2l0cywgcmFkaXgpO1xuICAgIH1cbiAgfSByZXR1cm4gK2l0O1xufTtcblxudmFyIEZPUkNFRCA9IGlzRm9yY2VkKE5VTUJFUiwgIU5hdGl2ZU51bWJlcignIDBvMScpIHx8ICFOYXRpdmVOdW1iZXIoJzBiMScpIHx8IE5hdGl2ZU51bWJlcignKzB4MScpKTtcblxudmFyIGNhbGxlZFdpdGhOZXcgPSBmdW5jdGlvbiAoZHVtbXkpIHtcbiAgLy8gaW5jbHVkZXMgY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gIHJldHVybiBpc1Byb3RvdHlwZU9mKE51bWJlclByb3RvdHlwZSwgZHVtbXkpICYmIGZhaWxzKGZ1bmN0aW9uICgpIHsgdGhpc051bWJlclZhbHVlKGR1bW15KTsgfSk7XG59O1xuXG4vLyBgTnVtYmVyYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1udW1iZXItY29uc3RydWN0b3JcbnZhciBOdW1iZXJXcmFwcGVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKSB7XG4gIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogTmF0aXZlTnVtYmVyKHRvTnVtZXJpYyh2YWx1ZSkpO1xuICByZXR1cm4gY2FsbGVkV2l0aE5ldyh0aGlzKSA/IGluaGVyaXRJZlJlcXVpcmVkKE9iamVjdChuKSwgdGhpcywgTnVtYmVyV3JhcHBlcikgOiBuO1xufTtcblxuTnVtYmVyV3JhcHBlci5wcm90b3R5cGUgPSBOdW1iZXJQcm90b3R5cGU7XG5pZiAoRk9SQ0VEICYmICFJU19QVVJFKSBOdW1iZXJQcm90b3R5cGUuY29uc3RydWN0b3IgPSBOdW1iZXJXcmFwcGVyO1xuXG4kKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgd3JhcDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBOdW1iZXI6IE51bWJlcldyYXBwZXJcbn0pO1xuXG4vLyBVc2UgYGludGVybmFsL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllc2AgaGVscGVyIGluIGBjb3JlLWpzQDRgXG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICBmb3IgKHZhciBrZXlzID0gREVTQ1JJUFRPUlMgPyBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZSkgOiAoXG4gICAgLy8gRVMzOlxuICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAvLyBFUzIwMTUgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzIwMTUgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgICAnRVBTSUxPTixNQVhfU0FGRV9JTlRFR0VSLE1JTl9TQUZFX0lOVEVHRVIsaXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIscGFyc2VGbG9hdCxwYXJzZUludCwnICtcbiAgICAvLyBFU05leHRcbiAgICAnZnJvbVN0cmluZyxyYW5nZSdcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKykge1xuICAgIGlmIChoYXNPd24oc291cmNlLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH1cbiAgfVxufTtcblxuaWYgKElTX1BVUkUgJiYgUHVyZU51bWJlck5hbWVzcGFjZSkgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhwYXRoW05VTUJFUl0sIFB1cmVOdW1iZXJOYW1lc3BhY2UpO1xuaWYgKEZPUkNFRCB8fCBJU19QVVJFKSBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHBhdGhbTlVNQkVSXSwgTmF0aXZlTnVtYmVyKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGlzSW50ZWdyYWxOdW1iZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtaW50ZWdyYWwtbnVtYmVyJyk7XG5cbi8vIGBOdW1iZXIuaXNJbnRlZ2VyYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbnVtYmVyLmlzaW50ZWdlclxuJCh7IHRhcmdldDogJ051bWJlcicsIHN0YXQ6IHRydWUgfSwge1xuICBpc0ludGVnZXI6IGlzSW50ZWdyYWxOdW1iZXJcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgY3JlYXRlOiBjcmVhdGVcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBPYmplY3QuZGVmaW5lUHJvcGVydHkgIT09IGRlZmluZVByb3BlcnR5LCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBkZWZpbmVQcm9wZXJ0eTogZGVmaW5lUHJvcGVydHlcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJGVudHJpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXRvLWFycmF5JykuZW50cmllcztcblxuLy8gYE9iamVjdC5lbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmVudHJpZXNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhPKSB7XG4gICAgcmV0dXJuICRlbnRyaWVzKE8pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG5cbnZhciBGT1JDRUQgPSAhREVTQ1JJUFRPUlMgfHwgZmFpbHMoZnVuY3Rpb24gKCkgeyBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JbmRleGVkT2JqZWN0KGl0KSwga2V5KTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N5bWJvbC1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24nKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG5cbi8vIFY4IH4gQ2hyb21lIDM4IGFuZCAzOSBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgZmFpbHMgb24gcHJpbWl0aXZlc1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0M1xudmFyIEZPUkNFRCA9ICFOQVRJVkVfU1lNQk9MIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHsgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmYoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eXN5bWJvbHNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIGdldE93blByb3BlcnR5U3ltYm9sczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gICAgdmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5U3ltYm9scyA/ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHModG9PYmplY3QoaXQpKSA6IFtdO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgbmF0aXZlR2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyJyk7XG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBuYXRpdmVHZXRQcm90b3R5cGVPZigxKTsgfSk7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2ZcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMsIHNoYW06ICFDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgfSwge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICByZXR1cm4gbmF0aXZlR2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfVxufSk7XG5cbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgbmF0aXZlS2V5cygxKTsgfSk7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTIH0sIHtcbiAga2V5czogZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUgfSwge1xuICBzZXRQcm90b3R5cGVPZjogc2V0UHJvdG90eXBlT2Zcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQnKTtcbnZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcnKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5pZiAoIVRPX1NUUklOR19UQUdfU1VQUE9SVCkge1xuICBkZWZpbmVCdWlsdEluKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIHRvU3RyaW5nLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICR2YWx1ZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXRvLWFycmF5JykudmFsdWVzO1xuXG4vLyBgT2JqZWN0LnZhbHVlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC52YWx1ZXNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoTykge1xuICAgIHJldHVybiAkdmFsdWVzKE8pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9udW1iZXItcGFyc2UtaW50Jyk7XG5cbi8vIGBwYXJzZUludGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXBhcnNlaW50LXN0cmluZy1yYWRpeFxuJCh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiBwYXJzZUludCAhPT0gJHBhcnNlSW50IH0sIHtcbiAgcGFyc2VJbnQ6ICRwYXJzZUludFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGFwcGx5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWFwcGx5Jyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kJyk7XG52YXIgYUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtY29uc3RydWN0b3InKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciBuYXRpdmVDb25zdHJ1Y3QgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgcHVzaCA9IFtdLnB1c2g7XG5cbi8vIGBSZWZsZWN0LmNvbnN0cnVjdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZmxlY3QuY29uc3RydWN0XG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcbnZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShuYXRpdmVDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xuXG52YXIgQVJHU19CVUcgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBuYXRpdmVDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG52YXIgRk9SQ0VEID0gTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUc7XG5cbiQoeyB0YXJnZXQ6ICdSZWZsZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQsIHNoYW06IEZPUkNFRCB9LCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJncyAvKiAsIG5ld1RhcmdldCAqLykge1xuICAgIGFDb25zdHJ1Y3RvcihUYXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFDb25zdHJ1Y3Rvcihhcmd1bWVudHNbMl0pO1xuICAgIGlmIChBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpIHJldHVybiBuYXRpdmVDb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuICAgIGlmIChUYXJnZXQgPT09IG5ld1RhcmdldCkge1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldCgpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgIGFwcGx5KHB1c2gsICRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGFwcGx5KGJpbmQsIFRhcmdldCwgJGFyZ3MpKSgpO1xuICAgIH1cbiAgICAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcbiAgICB2YXIgcHJvdG8gPSBuZXdUYXJnZXQucHJvdG90eXBlO1xuICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdFByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IGFwcGx5KFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNEYXRhRGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1kYXRhLWRlc2NyaXB0b3InKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG5cbi8vIGBSZWZsZWN0LmdldGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZmxlY3QuZ2V0XG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSAvKiAsIHJlY2VpdmVyICovKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdO1xuICB2YXIgZGVzY3JpcHRvciwgcHJvdG90eXBlO1xuICBpZiAoYW5PYmplY3QodGFyZ2V0KSA9PT0gcmVjZWl2ZXIpIHJldHVybiB0YXJnZXRbcHJvcGVydHlLZXldO1xuICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmYodGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gIGlmIChkZXNjcmlwdG9yKSByZXR1cm4gaXNEYXRhRGVzY3JpcHRvcihkZXNjcmlwdG9yKVxuICAgID8gZGVzY3JpcHRvci52YWx1ZVxuICAgIDogZGVzY3JpcHRvci5nZXQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNhbGwoZGVzY3JpcHRvci5nZXQsIHJlY2VpdmVyKTtcbiAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSByZXR1cm4gZ2V0KHByb3RvdHlwZSwgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJCh7IHRhcmdldDogJ1JlZmxlY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgZ2V0OiBnZXRcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG5cbiQoeyBnbG9iYWw6IHRydWUgfSwgeyBSZWZsZWN0OiB7fSB9KTtcblxuLy8gUmVmbGVjdFtAQHRvU3RyaW5nVGFnXSBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWZsZWN0LUBAdG9zdHJpbmd0YWdcbnNldFRvU3RyaW5nVGFnKGdsb2JhbFRoaXMuUmVmbGVjdCwgJ1JlZmxlY3QnLCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMnKTtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZXhlY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUuZXhlY1xuJCh7IHRhcmdldDogJ1JlZ0V4cCcsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IC8uLy5leGVjICE9PSBleGVjIH0sIHtcbiAgZXhlYzogZXhlY1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YCBzaW5jZSBpdCdzIG1vdmVkIHRvIGVudHJ5IHBvaW50c1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5yZWdleHAuZXhlYycpO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xuXG52YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gIHZhciByZSA9IC9bYWNdLztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBleGVjQ2FsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gLy4vLmV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgcmV0dXJuIHJlLnRlc3QoJ2FiYycpID09PSB0cnVlICYmIGV4ZWNDYWxsZWQ7XG59KCk7XG5cbnZhciBuYXRpdmVUZXN0ID0gLy4vLnRlc3Q7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLnRlc3RgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLnRlc3RcbiQoeyB0YXJnZXQ6ICdSZWdFeHAnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhREVMRUdBVEVTX1RPX0VYRUMgfSwge1xuICB0ZXN0OiBmdW5jdGlvbiAoUykge1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nKFMpO1xuICAgIHZhciBleGVjID0gUi5leGVjO1xuICAgIGlmICghaXNDYWxsYWJsZShleGVjKSkgcmV0dXJuIGNhbGwobmF0aXZlVGVzdCwgUiwgc3RyaW5nKTtcbiAgICB2YXIgcmVzdWx0ID0gY2FsbChleGVjLCBSLCBzdHJpbmcpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICBhbk9iamVjdChyZXN1bHQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1uYW1lJykuUFJPUEVSO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgJHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgZ2V0UmVnRXhwRmxhZ3MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWdldC1mbGFncycpO1xuXG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xudmFyIG5hdGl2ZVRvU3RyaW5nID0gUmVnRXhwUHJvdG90eXBlW1RPX1NUUklOR107XG5cbnZhciBOT1RfR0VORVJJQyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdGl2ZVRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPT0gJy9hL2InOyB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG52YXIgSU5DT1JSRUNUX05BTUUgPSBQUk9QRVJfRlVOQ1RJT05fTkFNRSAmJiBuYXRpdmVUb1N0cmluZy5uYW1lICE9PSBUT19TVFJJTkc7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuaWYgKE5PVF9HRU5FUklDIHx8IElOQ09SUkVDVF9OQU1FKSB7XG4gIGRlZmluZUJ1aWx0SW4oUmVnRXhwUHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgdmFyIHBhdHRlcm4gPSAkdG9TdHJpbmcoUi5zb3VyY2UpO1xuICAgIHZhciBmbGFncyA9ICR0b1N0cmluZyhnZXRSZWdFeHBGbGFncyhSKSk7XG4gICAgcmV0dXJuICcvJyArIHBhdHRlcm4gKyAnLycgKyBmbGFncztcbiAgfSwgeyB1bnNhZmU6IHRydWUgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcblxudmFyICRSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXN0cmluZy1mcm9tY29kZXBvaW50IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgJGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcbnZhciBqb2luID0gdW5jdXJyeVRoaXMoW10uam9pbik7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbnZhciBJTkNPUlJFQ1RfTEVOR1RIID0gISEkZnJvbUNvZGVQb2ludCAmJiAkZnJvbUNvZGVQb2ludC5sZW5ndGggIT09IDE7XG5cbi8vIGBTdHJpbmcuZnJvbUNvZGVQb2ludGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5mcm9tY29kZXBvaW50XG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgc3RhdDogdHJ1ZSwgYXJpdHk6IDEsIGZvcmNlZDogSU5DT1JSRUNUX0xFTkdUSCB9LCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoeCkge1xuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgY29kZTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaSkge1xuICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcbiAgICAgIGlmICh0b0Fic29sdXRlSW5kZXgoY29kZSwgMHgxMEZGRkYpICE9PSBjb2RlKSB0aHJvdyBuZXcgJFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xuICAgICAgZWxlbWVudHNbaV0gPSBjb2RlIDwgMHgxMDAwMFxuICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgICA6IGZyb21DaGFyQ29kZSgoKGNvZGUgLT0gMHgxMDAwMCkgPj4gMTApICsgMHhEODAwLCBjb2RlICUgMHg0MDAgKyAweERDMDApO1xuICAgIH0gcmV0dXJuIGpvaW4oZWxlbWVudHMsICcnKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBub3RBUmVnRXhwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25vdC1hLXJlZ2V4cCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgY29ycmVjdElzUmVnRXhwTG9naWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29ycmVjdC1pcy1yZWdleHAtbG9naWMnKTtcblxudmFyIHN0cmluZ0luZGV4T2YgPSB1bmN1cnJ5VGhpcygnJy5pbmRleE9mKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzXG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogIWNvcnJlY3RJc1JlZ0V4cExvZ2ljKCdpbmNsdWRlcycpIH0sIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHJldHVybiAhIX5zdHJpbmdJbmRleE9mKFxuICAgICAgdG9TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSksXG4gICAgICB0b1N0cmluZyhub3RBUmVnRXhwKHNlYXJjaFN0cmluZykpLFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICApO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjaGFyQXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZScpLmNoYXJBdDtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lJyk7XG52YXIgY3JlYXRlSXRlclJlc3VsdE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0Jyk7XG5cbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5kZWZpbmVJdGVyYXRvcihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxuICAgIHN0cmluZzogdG9TdHJpbmcoaXRlcmF0ZWQpLFxuICAgIGluZGV4OiAwXG4gIH0pO1xuLy8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIHBvaW50ID0gY2hhckF0KHN0cmluZywgaW5kZXgpO1xuICBzdGF0ZS5pbmRleCArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHBvaW50LCBmYWxzZSk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBzYW1lVmFsdWUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2FtZS12YWx1ZScpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIGdldE1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtbWV0aG9kJyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xuXG4vLyBAQHNlYXJjaCBsb2dpY1xuZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ3NlYXJjaCcsIGZ1bmN0aW9uIChTRUFSQ0gsIG5hdGl2ZVNlYXJjaCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUuc2VhcmNoYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuc2VhcmNoXG4gICAgZnVuY3Rpb24gc2VhcmNoKHJlZ2V4cCkge1xuICAgICAgdmFyIE8gPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuICAgICAgdmFyIHNlYXJjaGVyID0gaXNPYmplY3QocmVnZXhwKSA/IGdldE1ldGhvZChyZWdleHAsIFNFQVJDSCkgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gc2VhcmNoZXIgPyBjYWxsKHNlYXJjaGVyLCByZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW1NFQVJDSF0odG9TdHJpbmcoTykpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzZWFyY2hcbiAgICBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICB2YXIgcnggPSBhbk9iamVjdCh0aGlzKTtcbiAgICAgIHZhciBTID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlU2VhcmNoLCByeCwgUyk7XG5cbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHByZXZpb3VzTGFzdEluZGV4ID0gcngubGFzdEluZGV4O1xuICAgICAgaWYgKCFzYW1lVmFsdWUocHJldmlvdXNMYXN0SW5kZXgsIDApKSByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgICAgaWYgKCFzYW1lVmFsdWUocngubGFzdEluZGV4LCBwcmV2aW91c0xhc3RJbmRleCkpIHJ4Lmxhc3RJbmRleCA9IHByZXZpb3VzTGFzdEluZGV4O1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IC0xIDogcmVzdWx0LmluZGV4O1xuICAgIH1cbiAgXTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHknKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcblxudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItc3RyaW5nLXNsaWNlIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgRk9SQ0VEID0gIScnLnN1YnN0ciB8fCAnYWInLnN1YnN0cigtMSkgIT09ICdiJztcblxuLy8gYFN0cmluZy5wcm90b3R5cGUuc3Vic3RyYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zdWJzdHJcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBzdWJzdHI6IGZ1bmN0aW9uIHN1YnN0cihzdGFydCwgbGVuZ3RoKSB7XG4gICAgdmFyIHRoYXQgPSB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKTtcbiAgICB2YXIgc2l6ZSA9IHRoYXQubGVuZ3RoO1xuICAgIHZhciBpbnRTdGFydCA9IHRvSW50ZWdlck9ySW5maW5pdHkoc3RhcnQpO1xuICAgIHZhciBpbnRMZW5ndGgsIGludEVuZDtcbiAgICBpZiAoaW50U3RhcnQgPT09IEluZmluaXR5KSBpbnRTdGFydCA9IDA7XG4gICAgaWYgKGludFN0YXJ0IDwgMCkgaW50U3RhcnQgPSBtYXgoc2l6ZSArIGludFN0YXJ0LCAwKTtcbiAgICBpbnRMZW5ndGggPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHNpemUgOiB0b0ludGVnZXJPckluZmluaXR5KGxlbmd0aCk7XG4gICAgaWYgKGludExlbmd0aCA8PSAwIHx8IGludExlbmd0aCA9PT0gSW5maW5pdHkpIHJldHVybiAnJztcbiAgICBpbnRFbmQgPSBtaW4oaW50U3RhcnQgKyBpbnRMZW5ndGgsIHNpemUpO1xuICAgIHJldHVybiBpbnRTdGFydCA+PSBpbnRFbmQgPyAnJyA6IHN0cmluZ1NsaWNlKHRoYXQsIGludFN0YXJ0LCBpbnRFbmQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbicpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleScpO1xudmFyICR0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBuYXRpdmVPYmplY3RDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcycpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVCdWlsdEluQWNjZXNzb3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLWFjY2Vzc29yJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWQnKTtcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtZGVmaW5lJyk7XG52YXIgZGVmaW5lU3ltYm9sVG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLWRlZmluZS10by1wcmltaXRpdmUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5mb3JFYWNoO1xuXG52YXIgSElEREVOID0gc2hhcmVkS2V5KCdoaWRkZW4nKTtcbnZhciBTWU1CT0wgPSAnU3ltYm9sJztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1lNQk9MKTtcblxudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyICRTeW1ib2wgPSBnbG9iYWxUaGlzLlN5bWJvbDtcbnZhciBTeW1ib2xQcm90b3R5cGUgPSAkU3ltYm9sICYmICRTeW1ib2xbUFJPVE9UWVBFXTtcbnZhciBSYW5nZUVycm9yID0gZ2xvYmFsVGhpcy5SYW5nZUVycm9yO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbFRoaXMuVHlwZUVycm9yO1xudmFyIFFPYmplY3QgPSBnbG9iYWxUaGlzLlFPYmplY3Q7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG52YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZjtcbnZhciBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xuXG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvdHlwZVN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xuXG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBVU0VfU0VUVEVSID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgZmFsbGJhY2tEZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIHZhciBPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yID0gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdFByb3RvdHlwZSwgUCk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKSBkZWxldGUgT2JqZWN0UHJvdG90eXBlW1BdO1xuICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgaWYgKE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IgJiYgTyAhPT0gT2JqZWN0UHJvdG90eXBlKSB7XG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlLCBQLCBPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKTtcbiAgfVxufTtcblxudmFyIHNldFN5bWJvbERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RDcmVhdGUobmF0aXZlRGVmaW5lUHJvcGVydHkoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT09IDc7XG59KSA/IGZhbGxiYWNrRGVmaW5lUHJvcGVydHkgOiBuYXRpdmVEZWZpbmVQcm9wZXJ0eTtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnLCBkZXNjcmlwdGlvbikge1xuICB2YXIgc3ltYm9sID0gQWxsU3ltYm9sc1t0YWddID0gbmF0aXZlT2JqZWN0Q3JlYXRlKFN5bWJvbFByb3RvdHlwZSk7XG4gIHNldEludGVybmFsU3RhdGUoc3ltYm9sLCB7XG4gICAgdHlwZTogU1lNQk9MLFxuICAgIHRhZzogdGFnLFxuICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICB9KTtcbiAgaWYgKCFERVNDUklQVE9SUykgc3ltYm9sLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIHJldHVybiBzeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBpZiAoTyA9PT0gT2JqZWN0UHJvdG90eXBlKSAkZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCwgQXR0cmlidXRlcyk7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5ID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChoYXNPd24oQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghQXR0cmlidXRlcy5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhc093bihPLCBISURERU4pKSBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBISURERU4sIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCBuYXRpdmVPYmplY3RDcmVhdGUobnVsbCkpKTtcbiAgICAgIE9bSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhc093bihPLCBISURERU4pICYmIE9bSElEREVOXVtrZXldKSBPW0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgQXR0cmlidXRlcyA9IG5hdGl2ZU9iamVjdENyZWF0ZShBdHRyaWJ1dGVzLCB7IGVudW1lcmFibGU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzY3JpcHRvcihPLCBrZXksIEF0dHJpYnV0ZXMpO1xuICB9IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBrZXksIEF0dHJpYnV0ZXMpO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIgcHJvcGVydGllcyA9IHRvSW5kZXhlZE9iamVjdChQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHByb3BlcnRpZXMpLmNvbmNhdCgkZ2V0T3duUHJvcGVydHlTeW1ib2xzKHByb3BlcnRpZXMpKTtcbiAgJGZvckVhY2goa2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghREVTQ1JJUFRPUlMgfHwgY2FsbCgkcHJvcGVydHlJc0VudW1lcmFibGUsIHByb3BlcnRpZXMsIGtleSkpICRkZWZpbmVQcm9wZXJ0eShPLCBrZXksIHByb3BlcnRpZXNba2V5XSk7XG4gIH0pO1xuICByZXR1cm4gTztcbn07XG5cbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IG5hdGl2ZU9iamVjdENyZWF0ZShPKSA6ICRkZWZpbmVQcm9wZXJ0aWVzKG5hdGl2ZU9iamVjdENyZWF0ZShPKSwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgUCA9IHRvUHJvcGVydHlLZXkoVik7XG4gIHZhciBlbnVtZXJhYmxlID0gY2FsbChuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSwgdGhpcywgUCk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUgJiYgaGFzT3duKEFsbFN5bWJvbHMsIFApICYmICFoYXNPd24oT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGVudW1lcmFibGUgfHwgIWhhc093bih0aGlzLCBQKSB8fCAhaGFzT3duKEFsbFN5bWJvbHMsIFApIHx8IGhhc093bih0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtQXVxuICAgID8gZW51bWVyYWJsZSA6IHRydWU7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIHZhciBpdCA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgdmFyIGtleSA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG90eXBlICYmIGhhc093bihBbGxTeW1ib2xzLCBrZXkpICYmICFoYXNPd24oT2JqZWN0UHJvdG90eXBlU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgZGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbiAgaWYgKGRlc2NyaXB0b3IgJiYgaGFzT3duKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXNPd24oaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkge1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyh0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFoYXNPd24oQWxsU3ltYm9scywga2V5KSAmJiAhaGFzT3duKGhpZGRlbktleXMsIGtleSkpIHB1c2gocmVzdWx0LCBrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gKE8pIHtcbiAgdmFyIElTX09CSkVDVF9QUk9UT1RZUEUgPSBPID09PSBPYmplY3RQcm90b3R5cGU7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMoSVNfT0JKRUNUX1BST1RPVFlQRSA/IE9iamVjdFByb3RvdHlwZVN5bWJvbHMgOiB0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGhhc093bihBbGxTeW1ib2xzLCBrZXkpICYmICghSVNfT0JKRUNUX1BST1RPVFlQRSB8fCBoYXNPd24oT2JqZWN0UHJvdG90eXBlLCBrZXkpKSkge1xuICAgICAgcHVzaChyZXN1bHQsIEFsbFN5bWJvbHNba2V5XSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIGBTeW1ib2xgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC1jb25zdHJ1Y3RvclxuaWYgKCFOQVRJVkVfU1lNQk9MKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKGlzUHJvdG90eXBlT2YoU3ltYm9sUHJvdG90eXBlLCB0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gIWFyZ3VtZW50cy5sZW5ndGggfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiAkdG9TdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgdGFnID0gdWlkKGRlc2NyaXB0aW9uKTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgJHRoaXMgPSB0aGlzID09PSB1bmRlZmluZWQgPyBnbG9iYWxUaGlzIDogdGhpcztcbiAgICAgIGlmICgkdGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlKSBjYWxsKHNldHRlciwgT2JqZWN0UHJvdG90eXBlU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhc093bigkdGhpcywgSElEREVOKSAmJiBoYXNPd24oJHRoaXNbSElEREVOXSwgdGFnKSkgJHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSk7XG4gICAgICB0cnkge1xuICAgICAgICBzZXRTeW1ib2xEZXNjcmlwdG9yKCR0aGlzLCB0YWcsIGRlc2NyaXB0b3IpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yKSkgdGhyb3cgZXJyb3I7XG4gICAgICAgIGZhbGxiYWNrRGVmaW5lUHJvcGVydHkoJHRoaXMsIHRhZywgZGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgVVNFX1NFVFRFUikgc2V0U3ltYm9sRGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogc2V0dGVyIH0pO1xuICAgIHJldHVybiB3cmFwKHRhZywgZGVzY3JpcHRpb24pO1xuICB9O1xuXG4gIFN5bWJvbFByb3RvdHlwZSA9ICRTeW1ib2xbUFJPVE9UWVBFXTtcblxuICBkZWZpbmVCdWlsdEluKFN5bWJvbFByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykudGFnO1xuICB9KTtcblxuICBkZWZpbmVCdWlsdEluKCRTeW1ib2wsICd3aXRob3V0U2V0dGVyJywgZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHdyYXAodWlkKGRlc2NyaXB0aW9uKSwgZGVzY3JpcHRpb24pO1xuICB9KTtcblxuICBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mID0gJGRlZmluZVByb3BlcnR5O1xuICBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlLmYgPSAkZGVmaW5lUHJvcGVydGllcztcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3ZWxsS25vd25TeW1ib2wobmFtZSksIG5hbWUpO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLVN5bWJvbC1kZXNjcmlwdGlvblxuICAgIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihTeW1ib2xQcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLmRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghSVNfUFVSRSkge1xuICAgICAgZGVmaW5lQnVpbHRJbihPYmplY3RQcm90b3R5cGUsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgeyB1bnNhZmU6IHRydWUgfSk7XG4gICAgfVxuICB9XG59XG5cbiQoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLCBzaGFtOiAhTkFUSVZFX1NZTUJPTCB9LCB7XG4gIFN5bWJvbDogJFN5bWJvbFxufSk7XG5cbiRmb3JFYWNoKG9iamVjdEtleXMoV2VsbEtub3duU3ltYm9sc1N0b3JlKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sKG5hbWUpO1xufSk7XG5cbiQoeyB0YXJnZXQ6IFNZTUJPTCwgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCB9LCB7XG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBVU0VfU0VUVEVSID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IFVTRV9TRVRURVIgPSBmYWxzZTsgfVxufSk7XG5cbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICAvLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG59KTtcblxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wgfSwge1xuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzXG59KTtcblxuLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmRlZmluZVN5bWJvbFRvUHJpbWl0aXZlKCk7XG5cbi8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddYCBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9zdHJpbmd0YWdcbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsIFNZTUJPTCk7XG5cbmhpZGRlbktleXNbSElEREVOXSA9IHRydWU7XG4iLCIvLyBgU3ltYm9sLnByb3RvdHlwZS5kZXNjcmlwdGlvbmAgZ2V0dGVyXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUuZGVzY3JpcHRpb25cbid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4tYWNjZXNzb3InKTtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcycpO1xuXG52YXIgTmF0aXZlU3ltYm9sID0gZ2xvYmFsVGhpcy5TeW1ib2w7XG52YXIgU3ltYm9sUHJvdG90eXBlID0gTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5wcm90b3R5cGU7XG5cbmlmIChERVNDUklQVE9SUyAmJiBpc0NhbGxhYmxlKE5hdGl2ZVN5bWJvbCkgJiYgKCEoJ2Rlc2NyaXB0aW9uJyBpbiBTeW1ib2xQcm90b3R5cGUpIHx8XG4gIC8vIFNhZmFyaSAxMiBidWdcbiAgTmF0aXZlU3ltYm9sKCkuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZFxuKSkge1xuICB2YXIgRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlID0ge307XG4gIC8vIHdyYXAgU3ltYm9sIGNvbnN0cnVjdG9yIGZvciBjb3JyZWN0IHdvcmsgd2l0aCB1bmRlZmluZWQgZGVzY3JpcHRpb25cbiAgdmFyIFN5bWJvbFdyYXBwZXIgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0b1N0cmluZyhhcmd1bWVudHNbMF0pO1xuICAgIHZhciByZXN1bHQgPSBpc1Byb3RvdHlwZU9mKFN5bWJvbFByb3RvdHlwZSwgdGhpcylcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzb25hcmpzL2luY29uc2lzdGVudC1mdW5jdGlvbi1jYWxsIC0tIG9rXG4gICAgICA/IG5ldyBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pXG4gICAgICAvLyBpbiBFZGdlIDEzLCBTdHJpbmcoU3ltYm9sKHVuZGVmaW5lZCkpID09PSAnU3ltYm9sKHVuZGVmaW5lZCknXG4gICAgICA6IGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgPyBOYXRpdmVTeW1ib2woKSA6IE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgaWYgKGRlc2NyaXB0aW9uID09PSAnJykgRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlW3Jlc3VsdF0gPSB0cnVlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhTeW1ib2xXcmFwcGVyLCBOYXRpdmVTeW1ib2wpO1xuICBTeW1ib2xXcmFwcGVyLnByb3RvdHlwZSA9IFN5bWJvbFByb3RvdHlwZTtcbiAgU3ltYm9sUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ltYm9sV3JhcHBlcjtcblxuICB2YXIgTkFUSVZFX1NZTUJPTCA9IFN0cmluZyhOYXRpdmVTeW1ib2woJ2Rlc2NyaXB0aW9uIGRldGVjdGlvbicpKSA9PT0gJ1N5bWJvbChkZXNjcmlwdGlvbiBkZXRlY3Rpb24pJztcbiAgdmFyIHRoaXNTeW1ib2xWYWx1ZSA9IHVuY3VycnlUaGlzKFN5bWJvbFByb3RvdHlwZS52YWx1ZU9mKTtcbiAgdmFyIHN5bWJvbERlc2NyaXB0aXZlU3RyaW5nID0gdW5jdXJyeVRoaXMoU3ltYm9sUHJvdG90eXBlLnRvU3RyaW5nKTtcbiAgdmFyIHJlZ2V4cCA9IC9eU3ltYm9sXFwoKC4qKVxcKVteKV0rJC87XG4gIHZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG4gIHZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoU3ltYm9sUHJvdG90eXBlLCAnZGVzY3JpcHRpb24nLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICB2YXIgc3ltYm9sID0gdGhpc1N5bWJvbFZhbHVlKHRoaXMpO1xuICAgICAgaWYgKGhhc093bihFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmUsIHN5bWJvbCkpIHJldHVybiAnJztcbiAgICAgIHZhciBzdHJpbmcgPSBzeW1ib2xEZXNjcmlwdGl2ZVN0cmluZyhzeW1ib2wpO1xuICAgICAgdmFyIGRlc2MgPSBOQVRJVkVfU1lNQk9MID8gc3RyaW5nU2xpY2Uoc3RyaW5nLCA3LCAtMSkgOiByZXBsYWNlKHN0cmluZywgcmVnZXhwLCAnJDEnKTtcbiAgICAgIHJldHVybiBkZXNjID09PSAnJyA/IHVuZGVmaW5lZCA6IGRlc2M7XG4gICAgfVxuICB9KTtcblxuICAkKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcbiAgICBTeW1ib2w6IFN5bWJvbFdyYXBwZXJcbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIE5BVElWRV9TWU1CT0xfUkVHSVNUUlkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLXJlZ2lzdHJ5LWRldGVjdGlvbicpO1xuXG52YXIgU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3RyaW5nLXRvLXN5bWJvbC1yZWdpc3RyeScpO1xudmFyIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC10by1zdHJpbmctcmVnaXN0cnknKTtcblxuLy8gYFN5bWJvbC5mb3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuZm9yXG4kKHsgdGFyZ2V0OiAnU3ltYm9sJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTF9SRUdJU1RSWSB9LCB7XG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nKGtleSk7XG4gICAgaWYgKGhhc093bihTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5LCBzdHJpbmcpKSByZXR1cm4gU3RyaW5nVG9TeW1ib2xSZWdpc3RyeVtzdHJpbmddO1xuICAgIHZhciBzeW1ib2wgPSBnZXRCdWlsdEluKCdTeW1ib2wnKShzdHJpbmcpO1xuICAgIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXSA9IHN5bWJvbDtcbiAgICBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5W3N5bWJvbF0gPSBzdHJpbmc7XG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLWRlZmluZScpO1xuXG4vLyBgU3ltYm9sLml0ZXJhdG9yYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuaXRlcmF0b3JcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE86IFJlbW92ZSB0aGlzIG1vZHVsZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3Mgc3BsaXQgdG8gbW9kdWxlcyBsaXN0ZWQgYmVsb3dcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3ltYm9sLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN5bWJvbC5mb3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3ltYm9sLmtleS1mb3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuanNvbi5zdHJpbmdpZnknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1zeW1ib2wnKTtcbnZhciB0cnlUb1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90cnktdG8tc3RyaW5nJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIE5BVElWRV9TWU1CT0xfUkVHSVNUUlkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLXJlZ2lzdHJ5LWRldGVjdGlvbicpO1xuXG52YXIgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXRvLXN0cmluZy1yZWdpc3RyeScpO1xuXG4vLyBgU3ltYm9sLmtleUZvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5rZXlmb3JcbiQoeyB0YXJnZXQ6ICdTeW1ib2wnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MX1JFR0lTVFJZIH0sIHtcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBuZXcgVHlwZUVycm9yKHRyeVRvU3RyaW5nKHN5bSkgKyAnIGlzIG5vdCBhIHN5bWJvbCcpO1xuICAgIGlmIChoYXNPd24oU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSwgc3ltKSkgcmV0dXJuIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnlbc3ltXTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLWRlZmluZScpO1xudmFyIGRlZmluZVN5bWJvbFRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N5bWJvbC1kZWZpbmUtdG8tcHJpbWl0aXZlJyk7XG5cbi8vIGBTeW1ib2wudG9QcmltaXRpdmVgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC50b3ByaW1pdGl2ZVxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3ByaW1pdGl2ZVxuZGVmaW5lU3ltYm9sVG9QcmltaXRpdmUoKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLml0ZXJhdG9yLmNvbnN0cnVjdG9yJyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5pdGVyYXRvci5ldmVyeScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuaXRlcmF0b3IuZm9yLWVhY2gnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgRE9NSXRlcmFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMnKTtcbnZhciBET01Ub2tlbkxpc3RQcm90b3R5cGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9tLXRva2VuLWxpc3QtcHJvdG90eXBlJyk7XG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1mb3ItZWFjaCcpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcblxudmFyIGhhbmRsZVByb3RvdHlwZSA9IGZ1bmN0aW9uIChDb2xsZWN0aW9uUHJvdG90eXBlKSB7XG4gIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSAmJiBDb2xsZWN0aW9uUHJvdG90eXBlLmZvckVhY2ggIT09IGZvckVhY2gpIHRyeSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsICdmb3JFYWNoJywgZm9yRWFjaCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgQ29sbGVjdGlvblByb3RvdHlwZS5mb3JFYWNoID0gZm9yRWFjaDtcbiAgfVxufTtcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pIHtcbiAgICBoYW5kbGVQcm90b3R5cGUoZ2xvYmFsVGhpc1tDT0xMRUNUSU9OX05BTUVdICYmIGdsb2JhbFRoaXNbQ09MTEVDVElPTl9OQU1FXS5wcm90b3R5cGUpO1xuICB9XG59XG5cbmhhbmRsZVByb3RvdHlwZShET01Ub2tlbkxpc3RQcm90b3R5cGUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciBET01JdGVyYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcycpO1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb20tdG9rZW4tbGlzdC1wcm90b3R5cGUnKTtcbnZhciBBcnJheUl0ZXJhdG9yTWV0aG9kcyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvck1ldGhvZHMudmFsdWVzO1xuXG52YXIgaGFuZGxlUHJvdG90eXBlID0gZnVuY3Rpb24gKENvbGxlY3Rpb25Qcm90b3R5cGUsIENPTExFQ1RJT05fTkFNRSkge1xuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSkge1xuICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gQXJyYXlWYWx1ZXMpIHRyeSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gPSBBcnJheVZhbHVlcztcbiAgICB9XG4gICAgc2V0VG9TdHJpbmdUYWcoQ29sbGVjdGlvblByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FLCB0cnVlKTtcbiAgICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pIGZvciAodmFyIE1FVEhPRF9OQU1FIGluIEFycmF5SXRlcmF0b3JNZXRob2RzKSB7XG4gICAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSAhPT0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKSB0cnkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgTUVUSE9EX05BTUUsIEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSA9IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMpIHtcbiAgaGFuZGxlUHJvdG90eXBlKGdsb2JhbFRoaXNbQ09MTEVDVElPTl9OQU1FXSAmJiBnbG9iYWxUaGlzW0NPTExFQ1RJT05fTkFNRV0ucHJvdG90eXBlLCBDT0xMRUNUSU9OX05BTUUpO1xufVxuXG5oYW5kbGVQcm90b3R5cGUoRE9NVG9rZW5MaXN0UHJvdG90eXBlLCAnRE9NVG9rZW5MaXN0Jyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgc2NoZWR1bGVyc0ZpeCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zY2hlZHVsZXJzLWZpeCcpO1xuXG52YXIgc2V0SW50ZXJ2YWwgPSBzY2hlZHVsZXJzRml4KGdsb2JhbFRoaXMuc2V0SW50ZXJ2YWwsIHRydWUpO1xuXG4vLyBCdW4gLyBJRTktIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3RpbWVycy1hbmQtdXNlci1wcm9tcHRzLmh0bWwjZG9tLXNldGludGVydmFsXG4kKHsgZ2xvYmFsOiB0cnVlLCBiaW5kOiB0cnVlLCBmb3JjZWQ6IGdsb2JhbFRoaXMuc2V0SW50ZXJ2YWwgIT09IHNldEludGVydmFsIH0sIHtcbiAgc2V0SW50ZXJ2YWw6IHNldEludGVydmFsXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciBzY2hlZHVsZXJzRml4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NjaGVkdWxlcnMtZml4Jyk7XG5cbnZhciBzZXRUaW1lb3V0ID0gc2NoZWR1bGVyc0ZpeChnbG9iYWxUaGlzLnNldFRpbWVvdXQsIHRydWUpO1xuXG4vLyBCdW4gLyBJRTktIHNldFRpbWVvdXQgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdGltZXJzLWFuZC11c2VyLXByb21wdHMuaHRtbCNkb20tc2V0dGltZW91dFxuJCh7IGdsb2JhbDogdHJ1ZSwgYmluZDogdHJ1ZSwgZm9yY2VkOiBnbG9iYWxUaGlzLnNldFRpbWVvdXQgIT09IHNldFRpbWVvdXQgfSwge1xuICBzZXRUaW1lb3V0OiBzZXRUaW1lb3V0XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE86IFJlbW92ZSB0aGlzIG1vZHVsZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3Mgc3BsaXQgdG8gbW9kdWxlcyBsaXN0ZWQgYmVsb3dcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLnNldC1pbnRlcnZhbCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuc2V0LXRpbWVvdXQnKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE86IGluIGNvcmUtanNANCwgbW92ZSAvbW9kdWxlcy8gZGVwZW5kZW5jaWVzIHRvIHB1YmxpYyBlbnRyaWVzIGZvciBiZXR0ZXIgb3B0aW1pemF0aW9uIGJ5IHRvb2xzIGxpa2UgYHByZXNldC1lbnZgXG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5mcm9tLWNvZGUtcG9pbnQnKTtcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciBzYWZlR2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zYWZlLWdldC1idWlsdC1pbicpO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBVU0VfTkFUSVZFX1VSTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91cmwtY29uc3RydWN0b3ItZGV0ZWN0aW9uJyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVCdWlsdEluQWNjZXNzb3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLWFjY2Vzc29yJyk7XG52YXIgZGVmaW5lQnVpbHRJbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWlucycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvci1jcmVhdGUtY29uc3RydWN0b3InKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgJHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgZ2V0SXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yJyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdCcpO1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3ZhbGlkYXRlLWFyZ3VtZW50cy1sZW5ndGgnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBhcnJheVNvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc29ydCcpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgVVJMX1NFQVJDSF9QQVJBTVMgPSAnVVJMU2VhcmNoUGFyYW1zJztcbnZhciBVUkxfU0VBUkNIX1BBUkFNU19JVEVSQVRPUiA9IFVSTF9TRUFSQ0hfUEFSQU1TICsgJ0l0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFVSTF9TRUFSQ0hfUEFSQU1TKTtcbnZhciBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihVUkxfU0VBUkNIX1BBUkFNU19JVEVSQVRPUik7XG5cbnZhciBuYXRpdmVGZXRjaCA9IHNhZmVHZXRCdWlsdEluKCdmZXRjaCcpO1xudmFyIE5hdGl2ZVJlcXVlc3QgPSBzYWZlR2V0QnVpbHRJbignUmVxdWVzdCcpO1xudmFyIEhlYWRlcnMgPSBzYWZlR2V0QnVpbHRJbignSGVhZGVycycpO1xudmFyIFJlcXVlc3RQcm90b3R5cGUgPSBOYXRpdmVSZXF1ZXN0ICYmIE5hdGl2ZVJlcXVlc3QucHJvdG90eXBlO1xudmFyIEhlYWRlcnNQcm90b3R5cGUgPSBIZWFkZXJzICYmIEhlYWRlcnMucHJvdG90eXBlO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbFRoaXMuVHlwZUVycm9yO1xudmFyIGVuY29kZVVSSUNvbXBvbmVudCA9IGdsb2JhbFRoaXMuZW5jb2RlVVJJQ29tcG9uZW50O1xudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG52YXIgZnJvbUNvZGVQb2ludCA9IGdldEJ1aWx0SW4oJ1N0cmluZycsICdmcm9tQ29kZVBvaW50Jyk7XG52YXIgJHBhcnNlSW50ID0gcGFyc2VJbnQ7XG52YXIgY2hhckF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckF0KTtcbnZhciBqb2luID0gdW5jdXJyeVRoaXMoW10uam9pbik7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xudmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcygnJy5yZXBsYWNlKTtcbnZhciBzaGlmdCA9IHVuY3VycnlUaGlzKFtdLnNoaWZ0KTtcbnZhciBzcGxpY2UgPSB1bmN1cnJ5VGhpcyhbXS5zcGxpY2UpO1xudmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMoJycuc3BsaXQpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcygvLi8uZXhlYyk7XG5cbnZhciBwbHVzID0gL1xcKy9nO1xudmFyIEZBTExCQUNLX1JFUExBQ0VSID0gJ1xcdUZGRkQnO1xudmFyIFZBTElEX0hFWCA9IC9eWzAtOWEtZl0rJC9pO1xuXG52YXIgcGFyc2VIZXhPY3RldCA9IGZ1bmN0aW9uIChzdHJpbmcsIHN0YXJ0KSB7XG4gIHZhciBzdWJzdHIgPSBzdHJpbmdTbGljZShzdHJpbmcsIHN0YXJ0LCBzdGFydCArIDIpO1xuICBpZiAoIWV4ZWMoVkFMSURfSEVYLCBzdWJzdHIpKSByZXR1cm4gTmFOO1xuXG4gIHJldHVybiAkcGFyc2VJbnQoc3Vic3RyLCAxNik7XG59O1xuXG52YXIgZ2V0TGVhZGluZ09uZXMgPSBmdW5jdGlvbiAob2N0ZXQpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgZm9yICh2YXIgbWFzayA9IDB4ODA7IG1hc2sgPiAwICYmIChvY3RldCAmIG1hc2spICE9PSAwOyBtYXNrID4+PSAxKSB7XG4gICAgY291bnQrKztcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG52YXIgdXRmOERlY29kZSA9IGZ1bmN0aW9uIChvY3RldHMpIHtcbiAgdmFyIGNvZGVQb2ludCA9IG51bGw7XG5cbiAgc3dpdGNoIChvY3RldHMubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgY29kZVBvaW50ID0gb2N0ZXRzWzBdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgY29kZVBvaW50ID0gKG9jdGV0c1swXSAmIDB4MUYpIDw8IDYgfCAob2N0ZXRzWzFdICYgMHgzRik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICBjb2RlUG9pbnQgPSAob2N0ZXRzWzBdICYgMHgwRikgPDwgMTIgfCAob2N0ZXRzWzFdICYgMHgzRikgPDwgNiB8IChvY3RldHNbMl0gJiAweDNGKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIGNvZGVQb2ludCA9IChvY3RldHNbMF0gJiAweDA3KSA8PCAxOCB8IChvY3RldHNbMV0gJiAweDNGKSA8PCAxMiB8IChvY3RldHNbMl0gJiAweDNGKSA8PCA2IHwgKG9jdGV0c1szXSAmIDB4M0YpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gY29kZVBvaW50ID4gMHgxMEZGRkYgPyBudWxsIDogY29kZVBvaW50O1xufTtcblxudmFyIGRlY29kZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICBpbnB1dCA9IHJlcGxhY2UoaW5wdXQsIHBsdXMsICcgJyk7XG4gIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgdmFyIGRlY29kZWRDaGFyID0gY2hhckF0KGlucHV0LCBpKTtcblxuICAgIGlmIChkZWNvZGVkQ2hhciA9PT0gJyUnKSB7XG4gICAgICBpZiAoY2hhckF0KGlucHV0LCBpICsgMSkgPT09ICclJyB8fCBpICsgMyA+IGxlbmd0aCkge1xuICAgICAgICByZXN1bHQgKz0gJyUnO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2N0ZXQgPSBwYXJzZUhleE9jdGV0KGlucHV0LCBpICsgMSk7XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICBpZiAob2N0ZXQgIT09IG9jdGV0KSB7XG4gICAgICAgIHJlc3VsdCArPSBkZWNvZGVkQ2hhcjtcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAyO1xuICAgICAgdmFyIGJ5dGVTZXF1ZW5jZUxlbmd0aCA9IGdldExlYWRpbmdPbmVzKG9jdGV0KTtcblxuICAgICAgaWYgKGJ5dGVTZXF1ZW5jZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWNvZGVkQ2hhciA9IGZyb21DaGFyQ29kZShvY3RldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYnl0ZVNlcXVlbmNlTGVuZ3RoID09PSAxIHx8IGJ5dGVTZXF1ZW5jZUxlbmd0aCA+IDQpIHtcbiAgICAgICAgICByZXN1bHQgKz0gRkFMTEJBQ0tfUkVQTEFDRVI7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9jdGV0cyA9IFtvY3RldF07XG4gICAgICAgIHZhciBzZXF1ZW5jZUluZGV4ID0gMTtcblxuICAgICAgICB3aGlsZSAoc2VxdWVuY2VJbmRleCA8IGJ5dGVTZXF1ZW5jZUxlbmd0aCkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBpZiAoaSArIDMgPiBsZW5ndGggfHwgY2hhckF0KGlucHV0LCBpKSAhPT0gJyUnKSBicmVhaztcblxuICAgICAgICAgIHZhciBuZXh0Qnl0ZSA9IHBhcnNlSGV4T2N0ZXQoaW5wdXQsIGkgKyAxKTtcblxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICAgICAgaWYgKG5leHRCeXRlICE9PSBuZXh0Qnl0ZSkge1xuICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXh0Qnl0ZSA+IDE5MSB8fCBuZXh0Qnl0ZSA8IDEyOCkgYnJlYWs7XG5cbiAgICAgICAgICBwdXNoKG9jdGV0cywgbmV4dEJ5dGUpO1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICBzZXF1ZW5jZUluZGV4Kys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2N0ZXRzLmxlbmd0aCAhPT0gYnl0ZVNlcXVlbmNlTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IEZBTExCQUNLX1JFUExBQ0VSO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvZGVQb2ludCA9IHV0ZjhEZWNvZGUob2N0ZXRzKTtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdCArPSBGQUxMQkFDS19SRVBMQUNFUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWNvZGVkQ2hhciA9IGZyb21Db2RlUG9pbnQoY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdCArPSBkZWNvZGVkQ2hhcjtcbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGZpbmQgPSAvWyEnKCl+XXwlMjAvZztcblxudmFyIHJlcGxhY2VtZW50cyA9IHtcbiAgJyEnOiAnJTIxJyxcbiAgXCInXCI6ICclMjcnLFxuICAnKCc6ICclMjgnLFxuICAnKSc6ICclMjknLFxuICAnfic6ICclN0UnLFxuICAnJTIwJzogJysnXG59O1xuXG52YXIgcmVwbGFjZXIgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgcmV0dXJuIHJlcGxhY2VtZW50c1ttYXRjaF07XG59O1xuXG52YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiByZXBsYWNlKGVuY29kZVVSSUNvbXBvbmVudChpdCksIGZpbmQsIHJlcGxhY2VyKTtcbn07XG5cbnZhciBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvciA9IGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoZnVuY3Rpb24gSXRlcmF0b3IocGFyYW1zLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IFVSTF9TRUFSQ0hfUEFSQU1TX0lURVJBVE9SLFxuICAgIHRhcmdldDogZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZShwYXJhbXMpLmVudHJpZXMsXG4gICAgaW5kZXg6IDAsXG4gICAga2luZDoga2luZFxuICB9KTtcbn0sIFVSTF9TRUFSQ0hfUEFSQU1TLCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUodGhpcyk7XG4gIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSBudWxsO1xuICAgIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbiAgdmFyIGVudHJ5ID0gdGFyZ2V0W2luZGV4XTtcbiAgc3dpdGNoIChzdGF0ZS5raW5kKSB7XG4gICAgY2FzZSAna2V5cyc6IHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KGVudHJ5LmtleSwgZmFsc2UpO1xuICAgIGNhc2UgJ3ZhbHVlcyc6IHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KGVudHJ5LnZhbHVlLCBmYWxzZSk7XG4gIH0gcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QoW2VudHJ5LmtleSwgZW50cnkudmFsdWVdLCBmYWxzZSk7XG59LCB0cnVlKTtcblxudmFyIFVSTFNlYXJjaFBhcmFtc1N0YXRlID0gZnVuY3Rpb24gKGluaXQpIHtcbiAgdGhpcy5lbnRyaWVzID0gW107XG4gIHRoaXMudXJsID0gbnVsbDtcblxuICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGlzT2JqZWN0KGluaXQpKSB0aGlzLnBhcnNlT2JqZWN0KGluaXQpO1xuICAgIGVsc2UgdGhpcy5wYXJzZVF1ZXJ5KHR5cGVvZiBpbml0ID09ICdzdHJpbmcnID8gY2hhckF0KGluaXQsIDApID09PSAnPycgPyBzdHJpbmdTbGljZShpbml0LCAxKSA6IGluaXQgOiAkdG9TdHJpbmcoaW5pdCkpO1xuICB9XG59O1xuXG5VUkxTZWFyY2hQYXJhbXNTdGF0ZS5wcm90b3R5cGUgPSB7XG4gIHR5cGU6IFVSTF9TRUFSQ0hfUEFSQU1TLFxuICBiaW5kVVJMOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfSxcbiAgcGFyc2VPYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChvYmplY3QpO1xuICAgIHZhciBpdGVyYXRvciwgbmV4dCwgc3RlcCwgZW50cnlJdGVyYXRvciwgZW50cnlOZXh0LCBmaXJzdCwgc2Vjb25kO1xuXG4gICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKG9iamVjdCwgaXRlcmF0b3JNZXRob2QpO1xuICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gICAgICB3aGlsZSAoIShzdGVwID0gY2FsbChuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICAgICAgZW50cnlJdGVyYXRvciA9IGdldEl0ZXJhdG9yKGFuT2JqZWN0KHN0ZXAudmFsdWUpKTtcbiAgICAgICAgZW50cnlOZXh0ID0gZW50cnlJdGVyYXRvci5uZXh0O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKGZpcnN0ID0gY2FsbChlbnRyeU5leHQsIGVudHJ5SXRlcmF0b3IpKS5kb25lIHx8XG4gICAgICAgICAgKHNlY29uZCA9IGNhbGwoZW50cnlOZXh0LCBlbnRyeUl0ZXJhdG9yKSkuZG9uZSB8fFxuICAgICAgICAgICFjYWxsKGVudHJ5TmV4dCwgZW50cnlJdGVyYXRvcikuZG9uZVxuICAgICAgICApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHNlcXVlbmNlIHdpdGggbGVuZ3RoIDInKTtcbiAgICAgICAgcHVzaChlbnRyaWVzLCB7IGtleTogJHRvU3RyaW5nKGZpcnN0LnZhbHVlKSwgdmFsdWU6ICR0b1N0cmluZyhzZWNvbmQudmFsdWUpIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBpZiAoaGFzT3duKG9iamVjdCwga2V5KSkge1xuICAgICAgcHVzaChlbnRyaWVzLCB7IGtleToga2V5LCB2YWx1ZTogJHRvU3RyaW5nKG9iamVjdFtrZXldKSB9KTtcbiAgICB9XG4gIH0sXG4gIHBhcnNlUXVlcnk6IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIGlmIChxdWVyeSkge1xuICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHNwbGl0KHF1ZXJ5LCAnJicpO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBhdHRyaWJ1dGUsIGVudHJ5O1xuICAgICAgd2hpbGUgKGluZGV4IDwgYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpbmRleCsrXTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5sZW5ndGgpIHtcbiAgICAgICAgICBlbnRyeSA9IHNwbGl0KGF0dHJpYnV0ZSwgJz0nKTtcbiAgICAgICAgICBwdXNoKGVudHJpZXMsIHtcbiAgICAgICAgICAgIGtleTogZGVjb2RlKHNoaWZ0KGVudHJ5KSksXG4gICAgICAgICAgICB2YWx1ZTogZGVjb2RlKGpvaW4oZW50cnksICc9JykpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNlcmlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBlbnRyeTtcbiAgICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgZW50cnkgPSBlbnRyaWVzW2luZGV4KytdO1xuICAgICAgcHVzaChyZXN1bHQsIHNlcmlhbGl6ZShlbnRyeS5rZXkpICsgJz0nICsgc2VyaWFsaXplKGVudHJ5LnZhbHVlKSk7XG4gICAgfSByZXR1cm4gam9pbihyZXN1bHQsICcmJyk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW50cmllcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucGFyc2VRdWVyeSh0aGlzLnVybC5xdWVyeSk7XG4gIH0sXG4gIHVwZGF0ZVVSTDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnVybCkgdGhpcy51cmwudXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIGBVUkxTZWFyY2hQYXJhbXNgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS11cmxzZWFyY2hwYXJhbXNcbnZhciBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFVSTFNlYXJjaFBhcmFtcygvKiBpbml0ICovKSB7XG4gIGFuSW5zdGFuY2UodGhpcywgVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlKTtcbiAgdmFyIGluaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZDtcbiAgdmFyIHN0YXRlID0gc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCBuZXcgVVJMU2VhcmNoUGFyYW1zU3RhdGUoaW5pdCkpO1xuICBpZiAoIURFU0NSSVBUT1JTKSB0aGlzLnNpemUgPSBzdGF0ZS5lbnRyaWVzLmxlbmd0aDtcbn07XG5cbnZhciBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUgPSBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbmRlZmluZUJ1aWx0SW5zKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwge1xuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5hcHBlbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtYXBwZW5kXG4gIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICBwdXNoKHN0YXRlLmVudHJpZXMsIHsga2V5OiAkdG9TdHJpbmcobmFtZSksIHZhbHVlOiAkdG9TdHJpbmcodmFsdWUpIH0pO1xuICAgIGlmICghREVTQ1JJUFRPUlMpIHRoaXMubGVuZ3RoKys7XG4gICAgc3RhdGUudXBkYXRlVVJMKCk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmRlbGV0ZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1kZWxldGVcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChuYW1lIC8qICwgdmFsdWUgKi8pIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgZW50cmllcyA9IHN0YXRlLmVudHJpZXM7XG4gICAgdmFyIGtleSA9ICR0b1N0cmluZyhuYW1lKTtcbiAgICB2YXIgJHZhbHVlID0gbGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgdmFsdWUgPSAkdmFsdWUgPT09IHVuZGVmaW5lZCA/ICR2YWx1ZSA6ICR0b1N0cmluZygkdmFsdWUpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgaWYgKGVudHJ5LmtleSA9PT0ga2V5ICYmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGVudHJ5LnZhbHVlID09PSB2YWx1ZSkpIHtcbiAgICAgICAgc3BsaWNlKGVudHJpZXMsIGluZGV4LCAxKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgfSBlbHNlIGluZGV4Kys7XG4gICAgfVxuICAgIGlmICghREVTQ1JJUFRPUlMpIHRoaXMuc2l6ZSA9IGVudHJpZXMubGVuZ3RoO1xuICAgIHN0YXRlLnVwZGF0ZVVSTCgpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5nZXRgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtZ2V0XG4gIGdldDogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIga2V5ID0gJHRvU3RyaW5nKG5hbWUpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgZm9yICg7IGluZGV4IDwgZW50cmllcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChlbnRyaWVzW2luZGV4XS5rZXkgPT09IGtleSkgcmV0dXJuIGVudHJpZXNbaW5kZXhdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuZ2V0QWxsYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLWdldGFsbFxuICBnZXRBbGw6IGZ1bmN0aW9uIGdldEFsbChuYW1lKSB7XG4gICAgdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGtleSA9ICR0b1N0cmluZyhuYW1lKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBmb3IgKDsgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGVudHJpZXNbaW5kZXhdLmtleSA9PT0ga2V5KSBwdXNoKHJlc3VsdCwgZW50cmllc1tpbmRleF0udmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5oYXNgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtaGFzXG4gIGhhczogZnVuY3Rpb24gaGFzKG5hbWUgLyogLCB2YWx1ZSAqLykge1xuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICAgIHZhciBsZW5ndGggPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIga2V5ID0gJHRvU3RyaW5nKG5hbWUpO1xuICAgIHZhciAkdmFsdWUgPSBsZW5ndGggPCAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdO1xuICAgIHZhciB2YWx1ZSA9ICR2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJHZhbHVlIDogJHRvU3RyaW5nKCR2YWx1ZSk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleCsrXTtcbiAgICAgIGlmIChlbnRyeS5rZXkgPT09IGtleSAmJiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCBlbnRyeS52YWx1ZSA9PT0gdmFsdWUpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5zZXRgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtc2V0XG4gIHNldDogZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgZW50cmllcyA9IHN0YXRlLmVudHJpZXM7XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgdmFyIGtleSA9ICR0b1N0cmluZyhuYW1lKTtcbiAgICB2YXIgdmFsID0gJHRvU3RyaW5nKHZhbHVlKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBlbnRyeTtcbiAgICBmb3IgKDsgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgIGlmIChlbnRyeS5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoZm91bmQpIHNwbGljZShlbnRyaWVzLCBpbmRleC0tLCAxKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIGVudHJ5LnZhbHVlID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm91bmQpIHB1c2goZW50cmllcywgeyBrZXk6IGtleSwgdmFsdWU6IHZhbCB9KTtcbiAgICBpZiAoIURFU0NSSVBUT1JTKSB0aGlzLnNpemUgPSBlbnRyaWVzLmxlbmd0aDtcbiAgICBzdGF0ZS51cGRhdGVVUkwoKTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuc29ydGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1zb3J0XG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgICBhcnJheVNvcnQoc3RhdGUuZW50cmllcywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmtleSA+IGIua2V5ID8gMSA6IC0xO1xuICAgIH0pO1xuICAgIHN0YXRlLnVwZGF0ZVVSTCgpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjayAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2ssIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBlbnRyeTtcbiAgICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgZW50cnkgPSBlbnRyaWVzW2luZGV4KytdO1xuICAgICAgYm91bmRGdW5jdGlvbihlbnRyeS52YWx1ZSwgZW50cnkua2V5LCB0aGlzKTtcbiAgICB9XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IodGhpcywgJ2tleXMnKTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUudmFsdWVzYCBtZXRob2RcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvcih0aGlzLCAndmFsdWVzJyk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IodGhpcywgJ2VudHJpZXMnKTtcbiAgfVxufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG5kZWZpbmVCdWlsdEluKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwgSVRFUkFUT1IsIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5lbnRyaWVzLCB7IG5hbWU6ICdlbnRyaWVzJyB9KTtcblxuLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmxzZWFyY2hwYXJhbXMtc3RyaW5naWZpY2F0aW9uLWJlaGF2aW9yXG5kZWZpbmVCdWlsdEluKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLnNlcmlhbGl6ZSgpO1xufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5zaXplYCBnZXR0ZXJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvdXJsL3B1bGwvNzM0XG5pZiAoREVTQ1JJUFRPUlMpIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsICdzaXplJywge1xuICBnZXQ6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgcmV0dXJuIGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcy5sZW5ndGg7XG4gIH0sXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSk7XG5cbnNldFRvU3RyaW5nVGFnKFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yLCBVUkxfU0VBUkNIX1BBUkFNUyk7XG5cbiQoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCBmb3JjZWQ6ICFVU0VfTkFUSVZFX1VSTCB9LCB7XG4gIFVSTFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3Jcbn0pO1xuXG4vLyBXcmFwIGBmZXRjaGAgYW5kIGBSZXF1ZXN0YCBmb3IgY29ycmVjdCB3b3JrIHdpdGggcG9seWZpbGxlZCBgVVJMU2VhcmNoUGFyYW1zYFxuaWYgKCFVU0VfTkFUSVZFX1VSTCAmJiBpc0NhbGxhYmxlKEhlYWRlcnMpKSB7XG4gIHZhciBoZWFkZXJzSGFzID0gdW5jdXJyeVRoaXMoSGVhZGVyc1Byb3RvdHlwZS5oYXMpO1xuICB2YXIgaGVhZGVyc1NldCA9IHVuY3VycnlUaGlzKEhlYWRlcnNQcm90b3R5cGUuc2V0KTtcblxuICB2YXIgd3JhcFJlcXVlc3RPcHRpb25zID0gZnVuY3Rpb24gKGluaXQpIHtcbiAgICBpZiAoaXNPYmplY3QoaW5pdCkpIHtcbiAgICAgIHZhciBib2R5ID0gaW5pdC5ib2R5O1xuICAgICAgdmFyIGhlYWRlcnM7XG4gICAgICBpZiAoY2xhc3NvZihib2R5KSA9PT0gVVJMX1NFQVJDSF9QQVJBTVMpIHtcbiAgICAgICAgaGVhZGVycyA9IGluaXQuaGVhZGVycyA/IG5ldyBIZWFkZXJzKGluaXQuaGVhZGVycykgOiBuZXcgSGVhZGVycygpO1xuICAgICAgICBpZiAoIWhlYWRlcnNIYXMoaGVhZGVycywgJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgICAgaGVhZGVyc1NldChoZWFkZXJzLCAnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZShpbml0LCB7XG4gICAgICAgICAgYm9keTogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsICR0b1N0cmluZyhib2R5KSksXG4gICAgICAgICAgaGVhZGVyczogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIGhlYWRlcnMpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gcmV0dXJuIGluaXQ7XG4gIH07XG5cbiAgaWYgKGlzQ2FsbGFibGUobmF0aXZlRmV0Y2gpKSB7XG4gICAgJCh7IGdsb2JhbDogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgZG9udENhbGxHZXRTZXQ6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7XG4gICAgICBmZXRjaDogZnVuY3Rpb24gZmV0Y2goaW5wdXQgLyogLCBpbml0ICovKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVGZXRjaChpbnB1dCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB3cmFwUmVxdWVzdE9wdGlvbnMoYXJndW1lbnRzWzFdKSA6IHt9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc0NhbGxhYmxlKE5hdGl2ZVJlcXVlc3QpKSB7XG4gICAgdmFyIFJlcXVlc3RDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQgLyogLCBpbml0ICovKSB7XG4gICAgICBhbkluc3RhbmNlKHRoaXMsIFJlcXVlc3RQcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIG5ldyBOYXRpdmVSZXF1ZXN0KGlucHV0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHdyYXBSZXF1ZXN0T3B0aW9ucyhhcmd1bWVudHNbMV0pIDoge30pO1xuICAgIH07XG5cbiAgICBSZXF1ZXN0UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVxdWVzdENvbnN0cnVjdG9yO1xuICAgIFJlcXVlc3RDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBSZXF1ZXN0UHJvdG90eXBlO1xuXG4gICAgJCh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGRvbnRDYWxsR2V0U2V0OiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICAgICAgUmVxdWVzdDogUmVxdWVzdENvbnN0cnVjdG9yXG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFVSTFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IsXG4gIGdldFN0YXRlOiBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gVE9ETzogUmVtb3ZlIHRoaXMgbW9kdWxlIGZyb20gYGNvcmUtanNANGAgc2luY2UgaXQncyByZXBsYWNlZCB0byBtb2R1bGUgYmVsb3dcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLnVybC1zZWFyY2gtcGFyYW1zLmNvbnN0cnVjdG9yJyk7XG4iLCIvKiFcbiogVFcgRWxlbWVudHMgMS4xLjBcbiogXG4qIFRXIEVsZW1lbnRzIGlzIGFuIG9wZW4tc291cmNlIFVJIGtpdCBvZiBhZHZhbmNlZCBjb21wb25lbnRzIGZvciBUYWlsd2luZENTUy5cbiogQ29weXJpZ2h0IMKpIDIwMjMgTURCb290c3RyYXAuY29tXG4qIFxuKiBVbmxlc3MgYSBjdXN0b20sIGluZGl2aWR1YWxseSBhc3NpZ25lZCBsaWNlbnNlIGhhcyBiZWVuIGdyYW50ZWQsIHRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuKiBJbiBhZGRpdGlvbiwgYSBjdXN0b20gbGljZW5zZSBtYXkgYmUgYXZhaWxhYmxlIHVwb24gcmVxdWVzdCwgc3ViamVjdCB0byB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdGhhdCBsaWNlbnNlLiBQbGVhc2UgY29udGFjdCB0YWlsd2luZEBtZGJvb3RzdHJhcC5jb20gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gb2J0YWluaW5nIGEgY3VzdG9tIGxpY2Vuc2UuXG4qIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4qIFxuKiBJZiB5b3Ugd291bGQgbGlrZSB0byBwdXJjaGFzZSBhIENPTU1FUkNJQUwsIG5vbi1BR1BMIGxpY2Vuc2UgZm9yIFRXRSwgcGxlYXNlIGNoZWNrIG91dCBvdXIgcHJpY2luZzogaHR0cHM6Ly90dy1lbGVtZW50cy5jb20vcHJvL1xuKi9cbnZhciBoZCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBkZCA9IChzLCB0LCBlKSA9PiB0IGluIHMgPyBoZChzLCB0LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiBlIH0pIDogc1t0XSA9IGU7XG52YXIgd3QgPSAocywgdCwgZSkgPT4gKGRkKHMsIHR5cGVvZiB0ICE9IFwic3ltYm9sXCIgPyB0ICsgXCJcIiA6IHQsIGUpLCBlKTtcbmNvbnN0IEluID0gKCgpID0+IHtcbiAgY29uc3QgcyA9IHt9O1xuICBsZXQgdCA9IDE7XG4gIHJldHVybiB7XG4gICAgc2V0KGUsIGksIG4pIHtcbiAgICAgIHR5cGVvZiBlW2ldID4gXCJ1XCIgJiYgKGVbaV0gPSB7XG4gICAgICAgIGtleTogaSxcbiAgICAgICAgaWQ6IHRcbiAgICAgIH0sIHQrKyksIHNbZVtpXS5pZF0gPSBuO1xuICAgIH0sXG4gICAgZ2V0KGUsIGkpIHtcbiAgICAgIGlmICghZSB8fCB0eXBlb2YgZVtpXSA+IFwidVwiKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IG4gPSBlW2ldO1xuICAgICAgcmV0dXJuIG4ua2V5ID09PSBpID8gc1tuLmlkXSA6IG51bGw7XG4gICAgfSxcbiAgICBkZWxldGUoZSwgaSkge1xuICAgICAgaWYgKHR5cGVvZiBlW2ldID4gXCJ1XCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG4gPSBlW2ldO1xuICAgICAgbi5rZXkgPT09IGkgJiYgKGRlbGV0ZSBzW24uaWRdLCBkZWxldGUgZVtpXSk7XG4gICAgfVxuICB9O1xufSkoKSwgQSA9IHtcbiAgc2V0RGF0YShzLCB0LCBlKSB7XG4gICAgSW4uc2V0KHMsIHQsIGUpO1xuICB9LFxuICBnZXREYXRhKHMsIHQpIHtcbiAgICByZXR1cm4gSW4uZ2V0KHMsIHQpO1xuICB9LFxuICByZW1vdmVEYXRhKHMsIHQpIHtcbiAgICBJbi5kZWxldGUocywgdCk7XG4gIH1cbn0sIHVkID0gMWU2LCBwZCA9IDFlMywgSG8gPSBcInRyYW5zaXRpb25lbmRcIiwgX2QgPSAocykgPT4gcyA9PSBudWxsID8gYCR7c31gIDoge30udG9TdHJpbmcuY2FsbChzKS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKSwgZXQgPSAocykgPT4ge1xuICBkb1xuICAgIHMgKz0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdWQpO1xuICB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocykpO1xuICByZXR1cm4gcztcbn0sIHBjID0gKHMpID0+IHtcbiAgbGV0IHQgPSBzLmdldEF0dHJpYnV0ZShcImRhdGEtdGUtdGFyZ2V0XCIpO1xuICBpZiAoIXQgfHwgdCA9PT0gXCIjXCIpIHtcbiAgICBsZXQgZSA9IHMuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICBpZiAoIWUgfHwgIWUuaW5jbHVkZXMoXCIjXCIpICYmICFlLnN0YXJ0c1dpdGgoXCIuXCIpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZS5pbmNsdWRlcyhcIiNcIikgJiYgIWUuc3RhcnRzV2l0aChcIiNcIikgJiYgKGUgPSBgIyR7ZS5zcGxpdChcIiNcIilbMV19YCksIHQgPSBlICYmIGUgIT09IFwiI1wiID8gZS50cmltKCkgOiBudWxsO1xuICB9XG4gIHJldHVybiB0O1xufSwgbHIgPSAocykgPT4ge1xuICBjb25zdCB0ID0gcGMocyk7XG4gIHJldHVybiB0ICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkgPyB0IDogbnVsbDtcbn0sIHRlID0gKHMpID0+IHtcbiAgY29uc3QgdCA9IHBjKHMpO1xuICByZXR1cm4gdCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkgOiBudWxsO1xufSwgY24gPSAocykgPT4ge1xuICBpZiAoIXMpXG4gICAgcmV0dXJuIDA7XG4gIGxldCB7IHRyYW5zaXRpb25EdXJhdGlvbjogdCwgdHJhbnNpdGlvbkRlbGF5OiBlIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzKTtcbiAgY29uc3QgaSA9IE51bWJlci5wYXJzZUZsb2F0KHQpLCBuID0gTnVtYmVyLnBhcnNlRmxvYXQoZSk7XG4gIHJldHVybiAhaSAmJiAhbiA/IDAgOiAodCA9IHQuc3BsaXQoXCIsXCIpWzBdLCBlID0gZS5zcGxpdChcIixcIilbMF0sIChOdW1iZXIucGFyc2VGbG9hdCh0KSArIE51bWJlci5wYXJzZUZsb2F0KGUpKSAqIHBkKTtcbn0sIF9jID0gKHMpID0+IHtcbiAgcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChIbykpO1xufSwgWGUgPSAocykgPT4gIXMgfHwgdHlwZW9mIHMgIT0gXCJvYmplY3RcIiA/ICExIDogKHR5cGVvZiBzLmpxdWVyeSA8IFwidVwiICYmIChzID0gc1swXSksIHR5cGVvZiBzLm5vZGVUeXBlIDwgXCJ1XCIpLCBlZSA9IChzKSA9PiBYZShzKSA/IHMuanF1ZXJ5ID8gc1swXSA6IHMgOiB0eXBlb2YgcyA9PSBcInN0cmluZ1wiICYmIHMubGVuZ3RoID4gMCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocykgOiBudWxsLCBJID0gKHMsIHQsIGUpID0+IHtcbiAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGNvbnN0IG4gPSBlW2ldLCBvID0gdFtpXSwgciA9IG8gJiYgWGUobykgPyBcImVsZW1lbnRcIiA6IF9kKG8pO1xuICAgIGlmICghbmV3IFJlZ0V4cChuKS50ZXN0KHIpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtzLnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCIke2l9XCIgcHJvdmlkZWQgdHlwZSBcIiR7cn1cIiBidXQgZXhwZWN0ZWQgdHlwZSBcIiR7bn1cIi5gXG4gICAgICApO1xuICB9KTtcbn0sIE10ID0gKHMpID0+IHtcbiAgaWYgKCFzIHx8IHMuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuICExO1xuICBpZiAocy5zdHlsZSAmJiBzLnBhcmVudE5vZGUgJiYgcy5wYXJlbnROb2RlLnN0eWxlKSB7XG4gICAgY29uc3QgdCA9IGdldENvbXB1dGVkU3R5bGUocyksIGUgPSBnZXRDb21wdXRlZFN0eWxlKHMucGFyZW50Tm9kZSk7XG4gICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocykuZ2V0UHJvcGVydHlWYWx1ZShcInZpc2liaWxpdHlcIikgPT09IFwidmlzaWJsZVwiIHx8IHQuZGlzcGxheSAhPT0gXCJub25lXCIgJiYgZS5kaXNwbGF5ICE9PSBcIm5vbmVcIiAmJiB0LnZpc2liaWxpdHkgIT09IFwiaGlkZGVuXCI7XG4gIH1cbiAgcmV0dXJuICExO1xufSwgYmUgPSAocykgPT4gIXMgfHwgcy5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgfHwgcy5jbGFzc0xpc3QuY29udGFpbnMoXCJkaXNhYmxlZFwiKSA/ICEwIDogdHlwZW9mIHMuZGlzYWJsZWQgPCBcInVcIiA/IHMuZGlzYWJsZWQgOiBzLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpICYmIHMuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgIT09IFwiZmFsc2VcIiwgZmMgPSAocykgPT4ge1xuICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmICh0eXBlb2Ygcy5nZXRSb290Tm9kZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCB0ID0gcy5nZXRSb290Tm9kZSgpO1xuICAgIHJldHVybiB0IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHQgOiBudWxsO1xuICB9XG4gIHJldHVybiBzIGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHMgOiBzLnBhcmVudE5vZGUgPyBmYyhzLnBhcmVudE5vZGUpIDogbnVsbDtcbn0sIGhuID0gKCkgPT4gZnVuY3Rpb24oKSB7XG59LCBzaSA9IChzKSA9PiB7XG4gIHMub2Zmc2V0SGVpZ2h0O1xufSwgbWMgPSAoKSA9PiB7XG4gIGNvbnN0IHsgalF1ZXJ5OiBzIH0gPSB3aW5kb3c7XG4gIHJldHVybiBzICYmICFkb2N1bWVudC5ib2R5Lmhhc0F0dHJpYnV0ZShcImRhdGEtdGUtbm8tanF1ZXJ5XCIpID8gcyA6IG51bGw7XG59LCBEbiA9IFtdLCBnYyA9IChzKSA9PiB7XG4gIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwibG9hZGluZ1wiID8gKERuLmxlbmd0aCB8fCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gICAgRG4uZm9yRWFjaCgodCkgPT4gdCgpKTtcbiAgfSksIERuLnB1c2gocykpIDogcygpO1xufSwgVyA9ICgpID0+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXIgPT09IFwicnRsXCIsIGZkID0gKHMpID0+IEFycmF5LmZyb20ocyksICQgPSAocykgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChzKSwgZ2UgPSAocykgPT4ge1xuICB0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIgJiYgcygpO1xufSwgYmMgPSAocywgdCwgZSA9ICEwKSA9PiB7XG4gIGlmICghZSkge1xuICAgIGdlKHMpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpID0gNSwgbiA9IGNuKHQpICsgaTtcbiAgbGV0IG8gPSAhMTtcbiAgY29uc3QgciA9ICh7IHRhcmdldDogYSB9KSA9PiB7XG4gICAgYSA9PT0gdCAmJiAobyA9ICEwLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoSG8sIHIpLCBnZShzKSk7XG4gIH07XG4gIHQuYWRkRXZlbnRMaXN0ZW5lcihIbywgciksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIG8gfHwgX2ModCk7XG4gIH0sIG4pO1xufSwgdmMgPSAocywgdCwgZSwgaSkgPT4ge1xuICBsZXQgbiA9IHMuaW5kZXhPZih0KTtcbiAgaWYgKG4gPT09IC0xKVxuICAgIHJldHVybiBzWyFlICYmIGkgPyBzLmxlbmd0aCAtIDEgOiAwXTtcbiAgY29uc3QgbyA9IHMubGVuZ3RoO1xuICByZXR1cm4gbiArPSBlID8gMSA6IC0xLCBpICYmIChuID0gKG4gKyBvKSAlIG8pLCBzW01hdGgubWF4KDAsIE1hdGgubWluKG4sIG8gLSAxKSldO1xufSwgbWQgPSAvW14uXSooPz1cXC4uKilcXC58LiovLCBnZCA9IC9cXC4uKi8sIGJkID0gLzo6XFxkKyQvLCAkbiA9IHt9O1xubGV0IEhyID0gMTtcbmNvbnN0IHZkID0ge1xuICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuICBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJcbn0sIFRkID0gL14obW91c2VlbnRlcnxtb3VzZWxlYXZlKS9pLCBUYyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJjbGlja1wiLFxuICBcImRibGNsaWNrXCIsXG4gIFwibW91c2V1cFwiLFxuICBcIm1vdXNlZG93blwiLFxuICBcImNvbnRleHRtZW51XCIsXG4gIFwibW91c2V3aGVlbFwiLFxuICBcIkRPTU1vdXNlU2Nyb2xsXCIsXG4gIFwibW91c2VvdmVyXCIsXG4gIFwibW91c2VvdXRcIixcbiAgXCJtb3VzZW1vdmVcIixcbiAgXCJzZWxlY3RzdGFydFwiLFxuICBcInNlbGVjdGVuZFwiLFxuICBcImtleWRvd25cIixcbiAgXCJrZXlwcmVzc1wiLFxuICBcImtleXVwXCIsXG4gIFwib3JpZW50YXRpb25jaGFuZ2VcIixcbiAgXCJ0b3VjaHN0YXJ0XCIsXG4gIFwidG91Y2htb3ZlXCIsXG4gIFwidG91Y2hlbmRcIixcbiAgXCJ0b3VjaGNhbmNlbFwiLFxuICBcInBvaW50ZXJkb3duXCIsXG4gIFwicG9pbnRlcm1vdmVcIixcbiAgXCJwb2ludGVydXBcIixcbiAgXCJwb2ludGVybGVhdmVcIixcbiAgXCJwb2ludGVyY2FuY2VsXCIsXG4gIFwiZ2VzdHVyZXN0YXJ0XCIsXG4gIFwiZ2VzdHVyZWNoYW5nZVwiLFxuICBcImdlc3R1cmVlbmRcIixcbiAgXCJmb2N1c1wiLFxuICBcImJsdXJcIixcbiAgXCJjaGFuZ2VcIixcbiAgXCJyZXNldFwiLFxuICBcInNlbGVjdFwiLFxuICBcInN1Ym1pdFwiLFxuICBcImZvY3VzaW5cIixcbiAgXCJmb2N1c291dFwiLFxuICBcImxvYWRcIixcbiAgXCJ1bmxvYWRcIixcbiAgXCJiZWZvcmV1bmxvYWRcIixcbiAgXCJyZXNpemVcIixcbiAgXCJtb3ZlXCIsXG4gIFwiRE9NQ29udGVudExvYWRlZFwiLFxuICBcInJlYWR5c3RhdGVjaGFuZ2VcIixcbiAgXCJlcnJvclwiLFxuICBcImFib3J0XCIsXG4gIFwic2Nyb2xsXCJcbl0pO1xuZnVuY3Rpb24gRWMocywgdCkge1xuICByZXR1cm4gdCAmJiBgJHt0fTo6JHtIcisrfWAgfHwgcy51aWRFdmVudCB8fCBIcisrO1xufVxuZnVuY3Rpb24gQ2Mocykge1xuICBjb25zdCB0ID0gRWMocyk7XG4gIHJldHVybiBzLnVpZEV2ZW50ID0gdCwgJG5bdF0gPSAkblt0XSB8fCB7fSwgJG5bdF07XG59XG5mdW5jdGlvbiBFZChzLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBlKGkpIHtcbiAgICByZXR1cm4gaS5kZWxlZ2F0ZVRhcmdldCA9IHMsIGUub25lT2ZmICYmIGMub2ZmKHMsIGkudHlwZSwgdCksIHQuYXBwbHkocywgW2ldKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIENkKHMsIHQsIGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGkobikge1xuICAgIGNvbnN0IG8gPSBzLnF1ZXJ5U2VsZWN0b3JBbGwodCk7XG4gICAgZm9yIChsZXQgeyB0YXJnZXQ6IHIgfSA9IG47IHIgJiYgciAhPT0gdGhpczsgciA9IHIucGFyZW50Tm9kZSlcbiAgICAgIGZvciAobGV0IGEgPSBvLmxlbmd0aDsgYS0tOyBcIlwiKVxuICAgICAgICBpZiAob1thXSA9PT0gcilcbiAgICAgICAgICByZXR1cm4gbi5kZWxlZ2F0ZVRhcmdldCA9IHIsIGkub25lT2ZmICYmIGMub2ZmKHMsIG4udHlwZSwgZSksIGUuYXBwbHkociwgW25dKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cbmZ1bmN0aW9uIEFjKHMsIHQsIGUgPSBudWxsKSB7XG4gIGNvbnN0IGkgPSBPYmplY3Qua2V5cyhzKTtcbiAgZm9yIChsZXQgbiA9IDAsIG8gPSBpLmxlbmd0aDsgbiA8IG87IG4rKykge1xuICAgIGNvbnN0IHIgPSBzW2lbbl1dO1xuICAgIGlmIChyLm9yaWdpbmFsSGFuZGxlciA9PT0gdCAmJiByLmRlbGVnYXRpb25TZWxlY3RvciA9PT0gZSlcbiAgICAgIHJldHVybiByO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24geWMocywgdCwgZSkge1xuICBjb25zdCBpID0gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiwgbiA9IGkgPyBlIDogdDtcbiAgbGV0IG8gPSB3YyhzKTtcbiAgcmV0dXJuIFRjLmhhcyhvKSB8fCAobyA9IHMpLCBbaSwgbiwgb107XG59XG5mdW5jdGlvbiBWcihzLCB0LCBlLCBpLCBuKSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8ICFzKVxuICAgIHJldHVybjtcbiAgaWYgKGUgfHwgKGUgPSBpLCBpID0gbnVsbCksIFRkLnRlc3QodCkpIHtcbiAgICBjb25zdCBnID0gKG0pID0+IGZ1bmN0aW9uKGIpIHtcbiAgICAgIGlmICghYi5yZWxhdGVkVGFyZ2V0IHx8IGIucmVsYXRlZFRhcmdldCAhPT0gYi5kZWxlZ2F0ZVRhcmdldCAmJiAhYi5kZWxlZ2F0ZVRhcmdldC5jb250YWlucyhiLnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICByZXR1cm4gbS5jYWxsKHRoaXMsIGIpO1xuICAgIH07XG4gICAgaSA/IGkgPSBnKGkpIDogZSA9IGcoZSk7XG4gIH1cbiAgY29uc3QgW28sIHIsIGFdID0geWMoXG4gICAgdCxcbiAgICBlLFxuICAgIGlcbiAgKSwgbCA9IENjKHMpLCBwID0gbFthXSB8fCAobFthXSA9IHt9KSwgdSA9IEFjKFxuICAgIHAsXG4gICAgcixcbiAgICBvID8gZSA6IG51bGxcbiAgKTtcbiAgaWYgKHUpIHtcbiAgICB1Lm9uZU9mZiA9IHUub25lT2ZmICYmIG47XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IF8gPSBFYyhcbiAgICByLFxuICAgIHQucmVwbGFjZShtZCwgXCJcIilcbiAgKSwgZiA9IG8gPyBDZChzLCBlLCBpKSA6IEVkKHMsIGUpO1xuICBmLmRlbGVnYXRpb25TZWxlY3RvciA9IG8gPyBlIDogbnVsbCwgZi5vcmlnaW5hbEhhbmRsZXIgPSByLCBmLm9uZU9mZiA9IG4sIGYudWlkRXZlbnQgPSBfLCBwW19dID0gZiwgcy5hZGRFdmVudExpc3RlbmVyKGEsIGYsIG8pO1xufVxuZnVuY3Rpb24gVm8ocywgdCwgZSwgaSwgbikge1xuICBjb25zdCBvID0gQWModFtlXSwgaSwgbik7XG4gIG8gJiYgKHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBvLCAhIW4pLCBkZWxldGUgdFtlXVtvLnVpZEV2ZW50XSk7XG59XG5mdW5jdGlvbiBBZChzLCB0LCBlLCBpKSB7XG4gIGNvbnN0IG4gPSB0W2VdIHx8IHt9O1xuICBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgaWYgKG8uaW5jbHVkZXMoaSkpIHtcbiAgICAgIGNvbnN0IHIgPSBuW29dO1xuICAgICAgVm8oXG4gICAgICAgIHMsXG4gICAgICAgIHQsXG4gICAgICAgIGUsXG4gICAgICAgIHIub3JpZ2luYWxIYW5kbGVyLFxuICAgICAgICByLmRlbGVnYXRpb25TZWxlY3RvclxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gd2Mocykge1xuICByZXR1cm4gcyA9IHMucmVwbGFjZShnZCwgXCJcIiksIHZkW3NdIHx8IHM7XG59XG5jb25zdCBjID0ge1xuICBvbihzLCB0LCBlLCBpKSB7XG4gICAgVnIocywgdCwgZSwgaSwgITEpO1xuICB9LFxuICBvbmUocywgdCwgZSwgaSkge1xuICAgIFZyKHMsIHQsIGUsIGksICEwKTtcbiAgfSxcbiAgb2ZmKHMsIHQsIGUsIGkpIHtcbiAgICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIiB8fCAhcylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbbiwgbywgcl0gPSB5YyhcbiAgICAgIHQsXG4gICAgICBlLFxuICAgICAgaVxuICAgICksIGEgPSByICE9PSB0LCBsID0gQ2MocyksIHAgPSB0LnN0YXJ0c1dpdGgoXCIuXCIpO1xuICAgIGlmICh0eXBlb2YgbyA8IFwidVwiKSB7XG4gICAgICBpZiAoIWwgfHwgIWxbcl0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIFZvKFxuICAgICAgICBzLFxuICAgICAgICBsLFxuICAgICAgICByLFxuICAgICAgICBvLFxuICAgICAgICBuID8gZSA6IG51bGxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHAgJiYgT2JqZWN0LmtleXMobCkuZm9yRWFjaCgoXykgPT4ge1xuICAgICAgQWQoXG4gICAgICAgIHMsXG4gICAgICAgIGwsXG4gICAgICAgIF8sXG4gICAgICAgIHQuc2xpY2UoMSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgY29uc3QgdSA9IGxbcl0gfHwge307XG4gICAgT2JqZWN0LmtleXModSkuZm9yRWFjaCgoXykgPT4ge1xuICAgICAgY29uc3QgZiA9IF8ucmVwbGFjZShiZCwgXCJcIik7XG4gICAgICBpZiAoIWEgfHwgdC5pbmNsdWRlcyhmKSkge1xuICAgICAgICBjb25zdCBnID0gdVtfXTtcbiAgICAgICAgVm8oXG4gICAgICAgICAgcyxcbiAgICAgICAgICBsLFxuICAgICAgICAgIHIsXG4gICAgICAgICAgZy5vcmlnaW5hbEhhbmRsZXIsXG4gICAgICAgICAgZy5kZWxlZ2F0aW9uU2VsZWN0b3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgdHJpZ2dlcihzLCB0LCBlKSB7XG4gICAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIgfHwgIXMpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBpID0gbWMoKSwgbiA9IHdjKHQpLCBvID0gdCAhPT0gbiwgciA9IFRjLmhhcyhuKTtcbiAgICBsZXQgYSwgbCA9ICEwLCBwID0gITAsIHUgPSAhMSwgXyA9IG51bGw7XG4gICAgcmV0dXJuIG8gJiYgaSAmJiAoYSA9IGkuRXZlbnQodCwgZSksIGkocykudHJpZ2dlcihhKSwgbCA9ICFhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCksIHAgPSAhYS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpLCB1ID0gYS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSksIHIgPyAoXyA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKSwgXy5pbml0RXZlbnQobiwgbCwgITApKSA6IF8gPSBuZXcgQ3VzdG9tRXZlbnQodCwge1xuICAgICAgYnViYmxlczogbCxcbiAgICAgIGNhbmNlbGFibGU6ICEwXG4gICAgfSksIHR5cGVvZiBlIDwgXCJ1XCIgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF8sIGYsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBlW2ZdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSwgdSAmJiBfLnByZXZlbnREZWZhdWx0KCksIHAgJiYgcy5kaXNwYXRjaEV2ZW50KF8pLCBfLmRlZmF1bHRQcmV2ZW50ZWQgJiYgdHlwZW9mIGEgPCBcInVcIiAmJiBhLnByZXZlbnREZWZhdWx0KCksIF87XG4gIH1cbn0sIEsgPSB7XG4gIG9uKHMsIHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gdC5zcGxpdChcIiBcIik7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBuLmxlbmd0aDsgbysrKVxuICAgICAgYy5vbihzLCBuW29dLCBlLCBpKTtcbiAgfSxcbiAgb2ZmKHMsIHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gdC5zcGxpdChcIiBcIik7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBuLmxlbmd0aDsgbysrKVxuICAgICAgYy5vZmYocywgbltvXSwgZSwgaSk7XG4gIH1cbn0sIHlkID0gXCI1LjEuM1wiO1xuY2xhc3MgZnQge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdCA9IGVlKHQpLCB0ICYmICh0aGlzLl9lbGVtZW50ID0gdCwgQS5zZXREYXRhKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIEEucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKSwgYy5vZmYodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9LRVkpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0aGlzW3RdID0gbnVsbDtcbiAgICB9KTtcbiAgfVxuICBfcXVldWVDYWxsYmFjayh0LCBlLCBpID0gITApIHtcbiAgICBiYyh0LCBlLCBpKTtcbiAgfVxuICAvKiogU3RhdGljICovXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEEuZ2V0RGF0YShlZSh0KSwgdGhpcy5EQVRBX0tFWSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgcmV0dXJuIHlkO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnWW91IGhhdmUgdG8gaW1wbGVtZW50IHRoZSBzdGF0aWMgbWV0aG9kIFwiTkFNRVwiLCBmb3IgZWFjaCBjb21wb25lbnQhJ1xuICAgICk7XG4gIH1cbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gYHRlLiR7dGhpcy5OQU1FfWA7XG4gIH1cbiAgc3RhdGljIGdldCBFVkVOVF9LRVkoKSB7XG4gICAgcmV0dXJuIGAuJHt0aGlzLkRBVEFfS0VZfWA7XG4gIH1cbn1cbmNvbnN0IHdkID0gXCJidXR0b25cIiwga2QgPSBcImFjdGl2ZVwiO1xuY2xhc3Mga2MgZXh0ZW5kcyBmdCB7XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiB3ZDtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLXByZXNzZWRcIixcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShrZClcbiAgICApO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IGtjLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICB0ID09PSBcInRvZ2dsZVwiICYmIGVbdF0oKTtcbiAgICB9KTtcbiAgfVxufVxudmFyIHN0ID0gXCJ0b3BcIiwgdXQgPSBcImJvdHRvbVwiLCBwdCA9IFwicmlnaHRcIiwgbnQgPSBcImxlZnRcIiwgamkgPSBcImF1dG9cIiwgbmkgPSBbc3QsIHV0LCBwdCwgbnRdLCBBZSA9IFwic3RhcnRcIiwgR2UgPSBcImVuZFwiLCB4YyA9IFwiY2xpcHBpbmdQYXJlbnRzXCIsIGNyID0gXCJ2aWV3cG9ydFwiLCBCZSA9IFwicG9wcGVyXCIsIE9jID0gXCJyZWZlcmVuY2VcIiwgV28gPSAvKiBAX19QVVJFX18gKi8gbmkucmVkdWNlKGZ1bmN0aW9uKHMsIHQpIHtcbiAgcmV0dXJuIHMuY29uY2F0KFt0ICsgXCItXCIgKyBBZSwgdCArIFwiLVwiICsgR2VdKTtcbn0sIFtdKSwgaHIgPSAvKiBAX19QVVJFX18gKi8gW10uY29uY2F0KG5pLCBbamldKS5yZWR1Y2UoZnVuY3Rpb24ocywgdCkge1xuICByZXR1cm4gcy5jb25jYXQoW3QsIHQgKyBcIi1cIiArIEFlLCB0ICsgXCItXCIgKyBHZV0pO1xufSwgW10pLCBTYyA9IFwiYmVmb3JlUmVhZFwiLCBJYyA9IFwicmVhZFwiLCBEYyA9IFwiYWZ0ZXJSZWFkXCIsICRjID0gXCJiZWZvcmVNYWluXCIsIExjID0gXCJtYWluXCIsIE5jID0gXCJhZnRlck1haW5cIiwgTWMgPSBcImJlZm9yZVdyaXRlXCIsIFJjID0gXCJ3cml0ZVwiLCBQYyA9IFwiYWZ0ZXJXcml0ZVwiLCBkbiA9IFtTYywgSWMsIERjLCAkYywgTGMsIE5jLCBNYywgUmMsIFBjXTtcbmZ1bmN0aW9uIFJ0KHMpIHtcbiAgcmV0dXJuIHMgPyAocy5ub2RlTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIF90KHMpIHtcbiAgaWYgKHMgPT0gbnVsbClcbiAgICByZXR1cm4gd2luZG93O1xuICBpZiAocy50b1N0cmluZygpICE9PSBcIltvYmplY3QgV2luZG93XVwiKSB7XG4gICAgdmFyIHQgPSBzLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIHQgJiYgdC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiB5ZShzKSB7XG4gIHZhciB0ID0gX3QocykuRWxlbWVudDtcbiAgcmV0dXJuIHMgaW5zdGFuY2VvZiB0IHx8IHMgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuZnVuY3Rpb24gZHQocykge1xuICB2YXIgdCA9IF90KHMpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gcyBpbnN0YW5jZW9mIHQgfHwgcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gZHIocykge1xuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPiBcInVcIilcbiAgICByZXR1cm4gITE7XG4gIHZhciB0ID0gX3QocykuU2hhZG93Um9vdDtcbiAgcmV0dXJuIHMgaW5zdGFuY2VvZiB0IHx8IHMgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuZnVuY3Rpb24geGQocykge1xuICB2YXIgdCA9IHMuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHQuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgIHZhciBpID0gdC5zdHlsZXNbZV0gfHwge30sIG4gPSB0LmF0dHJpYnV0ZXNbZV0gfHwge30sIG8gPSB0LmVsZW1lbnRzW2VdO1xuICAgICFkdChvKSB8fCAhUnQobykgfHwgKE9iamVjdC5hc3NpZ24oby5zdHlsZSwgaSksIE9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgdmFyIGEgPSBuW3JdO1xuICAgICAgYSA9PT0gITEgPyBvLnJlbW92ZUF0dHJpYnV0ZShyKSA6IG8uc2V0QXR0cmlidXRlKHIsIGEgPT09ICEwID8gXCJcIiA6IGEpO1xuICAgIH0pKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBPZChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiB0Lm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiBcIjBcIixcbiAgICAgIHRvcDogXCIwXCIsXG4gICAgICBtYXJnaW46IFwiMFwiXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fVxuICB9O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0LmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgZS5wb3BwZXIpLCB0LnN0eWxlcyA9IGUsIHQuZWxlbWVudHMuYXJyb3cgJiYgT2JqZWN0LmFzc2lnbih0LmVsZW1lbnRzLmFycm93LnN0eWxlLCBlLmFycm93KSwgZnVuY3Rpb24oKSB7XG4gICAgT2JqZWN0LmtleXModC5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgbiA9IHQuZWxlbWVudHNbaV0sIG8gPSB0LmF0dHJpYnV0ZXNbaV0gfHwge30sIHIgPSBPYmplY3Qua2V5cyh0LnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShpKSA/IHQuc3R5bGVzW2ldIDogZVtpXSksIGEgPSByLnJlZHVjZShmdW5jdGlvbihsLCBwKSB7XG4gICAgICAgIHJldHVybiBsW3BdID0gXCJcIiwgbDtcbiAgICAgIH0sIHt9KTtcbiAgICAgICFkdChuKSB8fCAhUnQobikgfHwgKE9iamVjdC5hc3NpZ24obi5zdHlsZSwgYSksIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24obCkge1xuICAgICAgICBuLnJlbW92ZUF0dHJpYnV0ZShsKTtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfTtcbn1cbmNvbnN0IHVyID0ge1xuICBuYW1lOiBcImFwcGx5U3R5bGVzXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJ3cml0ZVwiLFxuICBmbjogeGQsXG4gIGVmZmVjdDogT2QsXG4gIHJlcXVpcmVzOiBbXCJjb21wdXRlU3R5bGVzXCJdXG59O1xuZnVuY3Rpb24gRXQocykge1xuICByZXR1cm4gcy5zcGxpdChcIi1cIilbMF07XG59XG52YXIgdmUgPSBNYXRoLm1heCwgdW4gPSBNYXRoLm1pbiwgcWUgPSBNYXRoLnJvdW5kO1xuZnVuY3Rpb24gRm8oKSB7XG4gIHZhciBzID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIHJldHVybiBzICE9IG51bGwgJiYgcy5icmFuZHMgJiYgQXJyYXkuaXNBcnJheShzLmJyYW5kcykgPyBzLmJyYW5kcy5tYXAoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0LmJyYW5kICsgXCIvXCIgKyB0LnZlcnNpb247XG4gIH0pLmpvaW4oXCIgXCIpIDogbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cbmZ1bmN0aW9uIEJjKCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoRm8oKSk7XG59XG5mdW5jdGlvbiBaZShzLCB0LCBlKSB7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9ICExKSwgZSA9PT0gdm9pZCAwICYmIChlID0gITEpO1xuICB2YXIgaSA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG4gPSAxLCBvID0gMTtcbiAgdCAmJiBkdChzKSAmJiAobiA9IHMub2Zmc2V0V2lkdGggPiAwICYmIHFlKGkud2lkdGgpIC8gcy5vZmZzZXRXaWR0aCB8fCAxLCBvID0gcy5vZmZzZXRIZWlnaHQgPiAwICYmIHFlKGkuaGVpZ2h0KSAvIHMub2Zmc2V0SGVpZ2h0IHx8IDEpO1xuICB2YXIgciA9IHllKHMpID8gX3QocykgOiB3aW5kb3csIGEgPSByLnZpc3VhbFZpZXdwb3J0LCBsID0gIUJjKCkgJiYgZSwgcCA9IChpLmxlZnQgKyAobCAmJiBhID8gYS5vZmZzZXRMZWZ0IDogMCkpIC8gbiwgdSA9IChpLnRvcCArIChsICYmIGEgPyBhLm9mZnNldFRvcCA6IDApKSAvIG8sIF8gPSBpLndpZHRoIC8gbiwgZiA9IGkuaGVpZ2h0IC8gbztcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogXyxcbiAgICBoZWlnaHQ6IGYsXG4gICAgdG9wOiB1LFxuICAgIHJpZ2h0OiBwICsgXyxcbiAgICBib3R0b206IHUgKyBmLFxuICAgIGxlZnQ6IHAsXG4gICAgeDogcCxcbiAgICB5OiB1XG4gIH07XG59XG5mdW5jdGlvbiBwcihzKSB7XG4gIHZhciB0ID0gWmUocyksIGUgPSBzLm9mZnNldFdpZHRoLCBpID0gcy5vZmZzZXRIZWlnaHQ7XG4gIHJldHVybiBNYXRoLmFicyh0LndpZHRoIC0gZSkgPD0gMSAmJiAoZSA9IHQud2lkdGgpLCBNYXRoLmFicyh0LmhlaWdodCAtIGkpIDw9IDEgJiYgKGkgPSB0LmhlaWdodCksIHtcbiAgICB4OiBzLm9mZnNldExlZnQsXG4gICAgeTogcy5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IGUsXG4gICAgaGVpZ2h0OiBpXG4gIH07XG59XG5mdW5jdGlvbiBIYyhzLCB0KSB7XG4gIHZhciBlID0gdC5nZXRSb290Tm9kZSAmJiB0LmdldFJvb3ROb2RlKCk7XG4gIGlmIChzLmNvbnRhaW5zKHQpKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKGUgJiYgZHIoZSkpIHtcbiAgICB2YXIgaSA9IHQ7XG4gICAgZG8ge1xuICAgICAgaWYgKGkgJiYgcy5pc1NhbWVOb2RlKGkpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBpID0gaS5wYXJlbnROb2RlIHx8IGkuaG9zdDtcbiAgICB9IHdoaWxlIChpKTtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBBdChzKSB7XG4gIHJldHVybiBfdChzKS5nZXRDb21wdXRlZFN0eWxlKHMpO1xufVxuZnVuY3Rpb24gU2Qocykge1xuICByZXR1cm4gW1widGFibGVcIiwgXCJ0ZFwiLCBcInRoXCJdLmluZGV4T2YoUnQocykpID49IDA7XG59XG5mdW5jdGlvbiBpZShzKSB7XG4gIHJldHVybiAoKHllKHMpID8gcy5vd25lckRvY3VtZW50IDogKFxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHMuZG9jdW1lbnRcbiAgKSkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBtbihzKSB7XG4gIHJldHVybiBSdChzKSA9PT0gXCJodG1sXCIgPyBzIDogKFxuICAgIC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHMuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgcy5wYXJlbnROb2RlIHx8IC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgKGRyKHMpID8gcy5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBpZShzKVxuICApO1xufVxuZnVuY3Rpb24gV3Iocykge1xuICByZXR1cm4gIWR0KHMpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIEF0KHMpLnBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBudWxsIDogcy5vZmZzZXRQYXJlbnQ7XG59XG5mdW5jdGlvbiBJZChzKSB7XG4gIHZhciB0ID0gL2ZpcmVmb3gvaS50ZXN0KEZvKCkpLCBlID0gL1RyaWRlbnQvaS50ZXN0KEZvKCkpO1xuICBpZiAoZSAmJiBkdChzKSkge1xuICAgIHZhciBpID0gQXQocyk7XG4gICAgaWYgKGkucG9zaXRpb24gPT09IFwiZml4ZWRcIilcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBuID0gbW4ocyk7XG4gIGZvciAoZHIobikgJiYgKG4gPSBuLmhvc3QpOyBkdChuKSAmJiBbXCJodG1sXCIsIFwiYm9keVwiXS5pbmRleE9mKFJ0KG4pKSA8IDA7ICkge1xuICAgIHZhciBvID0gQXQobik7XG4gICAgaWYgKG8udHJhbnNmb3JtICE9PSBcIm5vbmVcIiB8fCBvLnBlcnNwZWN0aXZlICE9PSBcIm5vbmVcIiB8fCBvLmNvbnRhaW4gPT09IFwicGFpbnRcIiB8fCBbXCJ0cmFuc2Zvcm1cIiwgXCJwZXJzcGVjdGl2ZVwiXS5pbmRleE9mKG8ud2lsbENoYW5nZSkgIT09IC0xIHx8IHQgJiYgby53aWxsQ2hhbmdlID09PSBcImZpbHRlclwiIHx8IHQgJiYgby5maWx0ZXIgJiYgby5maWx0ZXIgIT09IFwibm9uZVwiKVxuICAgICAgcmV0dXJuIG47XG4gICAgbiA9IG4ucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIEtpKHMpIHtcbiAgZm9yICh2YXIgdCA9IF90KHMpLCBlID0gV3Iocyk7IGUgJiYgU2QoZSkgJiYgQXQoZSkucG9zaXRpb24gPT09IFwic3RhdGljXCI7IClcbiAgICBlID0gV3IoZSk7XG4gIHJldHVybiBlICYmIChSdChlKSA9PT0gXCJodG1sXCIgfHwgUnQoZSkgPT09IFwiYm9keVwiICYmIEF0KGUpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiKSA/IHQgOiBlIHx8IElkKHMpIHx8IHQ7XG59XG5mdW5jdGlvbiBfcihzKSB7XG4gIHJldHVybiBbXCJ0b3BcIiwgXCJib3R0b21cIl0uaW5kZXhPZihzKSA+PSAwID8gXCJ4XCIgOiBcInlcIjtcbn1cbmZ1bmN0aW9uIE1pKHMsIHQsIGUpIHtcbiAgcmV0dXJuIHZlKHMsIHVuKHQsIGUpKTtcbn1cbmZ1bmN0aW9uIERkKHMsIHQsIGUpIHtcbiAgdmFyIGkgPSBNaShzLCB0LCBlKTtcbiAgcmV0dXJuIGkgPiBlID8gZSA6IGk7XG59XG5mdW5jdGlvbiBWYygpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIFdjKHMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIFZjKCksIHMpO1xufVxuZnVuY3Rpb24gRmMocywgdCkge1xuICByZXR1cm4gdC5yZWR1Y2UoZnVuY3Rpb24oZSwgaSkge1xuICAgIHJldHVybiBlW2ldID0gcywgZTtcbiAgfSwge30pO1xufVxudmFyICRkID0gZnVuY3Rpb24odCwgZSkge1xuICByZXR1cm4gdCA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQoT2JqZWN0LmFzc2lnbih7fSwgZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogZS5wbGFjZW1lbnRcbiAgfSkpIDogdCwgV2ModHlwZW9mIHQgIT0gXCJudW1iZXJcIiA/IHQgOiBGYyh0LCBuaSkpO1xufTtcbmZ1bmN0aW9uIExkKHMpIHtcbiAgdmFyIHQsIGUgPSBzLnN0YXRlLCBpID0gcy5uYW1lLCBuID0gcy5vcHRpb25zLCBvID0gZS5lbGVtZW50cy5hcnJvdywgciA9IGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLCBhID0gRXQoZS5wbGFjZW1lbnQpLCBsID0gX3IoYSksIHAgPSBbbnQsIHB0XS5pbmRleE9mKGEpID49IDAsIHUgPSBwID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgaWYgKCEoIW8gfHwgIXIpKSB7XG4gICAgdmFyIF8gPSAkZChuLnBhZGRpbmcsIGUpLCBmID0gcHIobyksIGcgPSBsID09PSBcInlcIiA/IHN0IDogbnQsIG0gPSBsID09PSBcInlcIiA/IHV0IDogcHQsIGIgPSBlLnJlY3RzLnJlZmVyZW5jZVt1XSArIGUucmVjdHMucmVmZXJlbmNlW2xdIC0gcltsXSAtIGUucmVjdHMucG9wcGVyW3VdLCB2ID0gcltsXSAtIGUucmVjdHMucmVmZXJlbmNlW2xdLCBUID0gS2kobyksIHkgPSBUID8gbCA9PT0gXCJ5XCIgPyBULmNsaWVudEhlaWdodCB8fCAwIDogVC5jbGllbnRXaWR0aCB8fCAwIDogMCwgQyA9IGIgLyAyIC0gdiAvIDIsIEUgPSBfW2ddLCB3ID0geSAtIGZbdV0gLSBfW21dLCBrID0geSAvIDIgLSBmW3VdIC8gMiArIEMsIEQgPSBNaShFLCBrLCB3KSwgTyA9IGw7XG4gICAgZS5tb2RpZmllcnNEYXRhW2ldID0gKHQgPSB7fSwgdFtPXSA9IEQsIHQuY2VudGVyT2Zmc2V0ID0gRCAtIGssIHQpO1xuICB9XG59XG5mdW5jdGlvbiBOZChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMub3B0aW9ucywgaSA9IGUuZWxlbWVudCwgbiA9IGkgPT09IHZvaWQgMCA/IFwiW2RhdGEtcG9wcGVyLWFycm93XVwiIDogaTtcbiAgaWYgKG4gIT0gbnVsbCAmJiAhKHR5cGVvZiBuID09IFwic3RyaW5nXCIgJiYgKG4gPSB0LmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKG4pLCAhbikpKSB7XG4gICAgaWYgKHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoZHQobikgfHwgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCAobm90IGFuIFNWR0VsZW1lbnQpLicsIFwiVG8gdXNlIGFuIFNWRyBhcnJvdywgd3JhcCBpdCBpbiBhbiBIVE1MRWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCBhc1wiLCBcInRoZSBhcnJvdy5cIl0uam9pbihcIiBcIikpKSwgIUhjKHQuZWxlbWVudHMucG9wcGVyLCBuKSkge1xuICAgICAgKHt9KS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIG1vZGlmaWVyXFwncyBgZWxlbWVudGAgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBwb3BwZXInLCBcImVsZW1lbnQuXCJdLmpvaW4oXCIgXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdC5lbGVtZW50cy5hcnJvdyA9IG47XG4gIH1cbn1cbmNvbnN0IFljID0ge1xuICBuYW1lOiBcImFycm93XCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJtYWluXCIsXG4gIGZuOiBMZCxcbiAgZWZmZWN0OiBOZCxcbiAgcmVxdWlyZXM6IFtcInBvcHBlck9mZnNldHNcIl0sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcInByZXZlbnRPdmVyZmxvd1wiXVxufTtcbmZ1bmN0aW9uIFFlKHMpIHtcbiAgcmV0dXJuIHMuc3BsaXQoXCItXCIpWzFdO1xufVxudmFyIE1kID0ge1xuICB0b3A6IFwiYXV0b1wiLFxuICByaWdodDogXCJhdXRvXCIsXG4gIGJvdHRvbTogXCJhdXRvXCIsXG4gIGxlZnQ6IFwiYXV0b1wiXG59O1xuZnVuY3Rpb24gUmQocywgdCkge1xuICB2YXIgZSA9IHMueCwgaSA9IHMueSwgbiA9IHQuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHFlKGUgKiBuKSAvIG4gfHwgMCxcbiAgICB5OiBxZShpICogbikgLyBuIHx8IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIEZyKHMpIHtcbiAgdmFyIHQsIGUgPSBzLnBvcHBlciwgaSA9IHMucG9wcGVyUmVjdCwgbiA9IHMucGxhY2VtZW50LCBvID0gcy52YXJpYXRpb24sIHIgPSBzLm9mZnNldHMsIGEgPSBzLnBvc2l0aW9uLCBsID0gcy5ncHVBY2NlbGVyYXRpb24sIHAgPSBzLmFkYXB0aXZlLCB1ID0gcy5yb3VuZE9mZnNldHMsIF8gPSBzLmlzRml4ZWQsIGYgPSByLngsIGcgPSBmID09PSB2b2lkIDAgPyAwIDogZiwgbSA9IHIueSwgYiA9IG0gPT09IHZvaWQgMCA/IDAgOiBtLCB2ID0gdHlwZW9mIHUgPT0gXCJmdW5jdGlvblwiID8gdSh7XG4gICAgeDogZyxcbiAgICB5OiBiXG4gIH0pIDoge1xuICAgIHg6IGcsXG4gICAgeTogYlxuICB9O1xuICBnID0gdi54LCBiID0gdi55O1xuICB2YXIgVCA9IHIuaGFzT3duUHJvcGVydHkoXCJ4XCIpLCB5ID0gci5oYXNPd25Qcm9wZXJ0eShcInlcIiksIEMgPSBudCwgRSA9IHN0LCB3ID0gd2luZG93O1xuICBpZiAocCkge1xuICAgIHZhciBrID0gS2koZSksIEQgPSBcImNsaWVudEhlaWdodFwiLCBPID0gXCJjbGllbnRXaWR0aFwiO1xuICAgIGlmIChrID09PSBfdChlKSAmJiAoayA9IGllKGUpLCBBdChrKS5wb3NpdGlvbiAhPT0gXCJzdGF0aWNcIiAmJiBhID09PSBcImFic29sdXRlXCIgJiYgKEQgPSBcInNjcm9sbEhlaWdodFwiLCBPID0gXCJzY3JvbGxXaWR0aFwiKSksIGsgPSBrLCBuID09PSBzdCB8fCAobiA9PT0gbnQgfHwgbiA9PT0gcHQpICYmIG8gPT09IEdlKSB7XG4gICAgICBFID0gdXQ7XG4gICAgICB2YXIgeCA9IF8gJiYgayA9PT0gdyAmJiB3LnZpc3VhbFZpZXdwb3J0ID8gdy52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAoXG4gICAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICBrW0RdXG4gICAgICApO1xuICAgICAgYiAtPSB4IC0gaS5oZWlnaHQsIGIgKj0gbCA/IDEgOiAtMTtcbiAgICB9XG4gICAgaWYgKG4gPT09IG50IHx8IChuID09PSBzdCB8fCBuID09PSB1dCkgJiYgbyA9PT0gR2UpIHtcbiAgICAgIEMgPSBwdDtcbiAgICAgIHZhciBMID0gXyAmJiBrID09PSB3ICYmIHcudmlzdWFsVmlld3BvcnQgPyB3LnZpc3VhbFZpZXdwb3J0LndpZHRoIDogKFxuICAgICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAga1tPXVxuICAgICAgKTtcbiAgICAgIGcgLT0gTCAtIGkud2lkdGgsIGcgKj0gbCA/IDEgOiAtMTtcbiAgICB9XG4gIH1cbiAgdmFyIFMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogYVxuICB9LCBwICYmIE1kKSwgTiA9IHUgPT09ICEwID8gUmQoe1xuICAgIHg6IGcsXG4gICAgeTogYlxuICB9LCBfdChlKSkgOiB7XG4gICAgeDogZyxcbiAgICB5OiBiXG4gIH07XG4gIGlmIChnID0gTi54LCBiID0gTi55LCBsKSB7XG4gICAgdmFyIFA7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIFMsIChQID0ge30sIFBbRV0gPSB5ID8gXCIwXCIgOiBcIlwiLCBQW0NdID0gVCA/IFwiMFwiIDogXCJcIiwgUC50cmFuc2Zvcm0gPSAody5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIGcgKyBcInB4LCBcIiArIGIgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIGcgKyBcInB4LCBcIiArIGIgKyBcInB4LCAwKVwiLCBQKSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIFMsICh0ID0ge30sIHRbRV0gPSB5ID8gYiArIFwicHhcIiA6IFwiXCIsIHRbQ10gPSBUID8gZyArIFwicHhcIiA6IFwiXCIsIHQudHJhbnNmb3JtID0gXCJcIiwgdCkpO1xufVxuZnVuY3Rpb24gUGQocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm9wdGlvbnMsIGkgPSBlLmdwdUFjY2VsZXJhdGlvbiwgbiA9IGkgPT09IHZvaWQgMCA/ICEwIDogaSwgbyA9IGUuYWRhcHRpdmUsIHIgPSBvID09PSB2b2lkIDAgPyAhMCA6IG8sIGEgPSBlLnJvdW5kT2Zmc2V0cywgbCA9IGEgPT09IHZvaWQgMCA/ICEwIDogYTtcbiAgaWYgKHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciBwID0gQXQodC5lbGVtZW50cy5wb3BwZXIpLnRyYW5zaXRpb25Qcm9wZXJ0eSB8fCBcIlwiO1xuICAgIHIgJiYgW1widHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdLnNvbWUoZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIHAuaW5kZXhPZihfKSA+PSAwO1xuICAgIH0pICYmIGNvbnNvbGUud2FybihbXCJQb3BwZXI6IERldGVjdGVkIENTUyB0cmFuc2l0aW9ucyBvbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZ1wiLCAnQ1NTIHByb3BlcnRpZXM6IFwidHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIuJywgYFxuXG5gLCAnRGlzYWJsZSB0aGUgXCJjb21wdXRlU3R5bGVzXCIgbW9kaWZpZXJcXCdzIGBhZGFwdGl2ZWAgb3B0aW9uIHRvIGFsbG93JywgXCJmb3Igc21vb3RoIHRyYW5zaXRpb25zLCBvciByZW1vdmUgdGhlc2UgcHJvcGVydGllcyBmcm9tIHRoZSBDU1NcIiwgXCJ0cmFuc2l0aW9uIGRlY2xhcmF0aW9uIG9uIHRoZSBwb3BwZXIgZWxlbWVudCBpZiBvbmx5IHRyYW5zaXRpb25pbmdcIiwgXCJvcGFjaXR5IG9yIGJhY2tncm91bmQtY29sb3IgZm9yIGV4YW1wbGUuXCIsIGBcblxuYCwgXCJXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXJcIiwgXCJlbGVtZW50IHRoYXQgY2FuIGhhdmUgYW55IENTUyBwcm9wZXJ0eSB0cmFuc2l0aW9uZWQgZm9yIGFuaW1hdGlvbnMuXCJdLmpvaW4oXCIgXCIpKTtcbiAgfVxuICB2YXIgdSA9IHtcbiAgICBwbGFjZW1lbnQ6IEV0KHQucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IFFlKHQucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHQuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHQucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogbixcbiAgICBpc0ZpeGVkOiB0Lm9wdGlvbnMuc3RyYXRlZ3kgPT09IFwiZml4ZWRcIlxuICB9O1xuICB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsICYmICh0LnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCB0LnN0eWxlcy5wb3BwZXIsIEZyKE9iamVjdC5hc3NpZ24oe30sIHUsIHtcbiAgICBvZmZzZXRzOiB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICBwb3NpdGlvbjogdC5vcHRpb25zLnN0cmF0ZWd5LFxuICAgIGFkYXB0aXZlOiByLFxuICAgIHJvdW5kT2Zmc2V0czogbFxuICB9KSkpKSwgdC5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwgJiYgKHQuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgdC5zdHlsZXMuYXJyb3csIEZyKE9iamVjdC5hc3NpZ24oe30sIHUsIHtcbiAgICBvZmZzZXRzOiB0Lm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICBhZGFwdGl2ZTogITEsXG4gICAgcm91bmRPZmZzZXRzOiBsXG4gIH0pKSkpLCB0LmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgdC5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgIFwiZGF0YS1wb3BwZXItcGxhY2VtZW50XCI6IHQucGxhY2VtZW50XG4gIH0pO1xufVxuY29uc3QgZnIgPSB7XG4gIG5hbWU6IFwiY29tcHV0ZVN0eWxlc1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwiYmVmb3JlV3JpdGVcIixcbiAgZm46IFBkLFxuICBkYXRhOiB7fVxufTtcbnZhciBucyA9IHtcbiAgcGFzc2l2ZTogITBcbn07XG5mdW5jdGlvbiBCZChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMuaW5zdGFuY2UsIGkgPSBzLm9wdGlvbnMsIG4gPSBpLnNjcm9sbCwgbyA9IG4gPT09IHZvaWQgMCA/ICEwIDogbiwgciA9IGkucmVzaXplLCBhID0gciA9PT0gdm9pZCAwID8gITAgOiByLCBsID0gX3QodC5lbGVtZW50cy5wb3BwZXIpLCBwID0gW10uY29uY2F0KHQuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHQuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuICByZXR1cm4gbyAmJiBwLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgIHUuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBlLnVwZGF0ZSwgbnMpO1xuICB9KSwgYSAmJiBsLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZS51cGRhdGUsIG5zKSwgZnVuY3Rpb24oKSB7XG4gICAgbyAmJiBwLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgICAgdS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGUudXBkYXRlLCBucyk7XG4gICAgfSksIGEgJiYgbC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGUudXBkYXRlLCBucyk7XG4gIH07XG59XG5jb25zdCBtciA9IHtcbiAgbmFtZTogXCJldmVudExpc3RlbmVyc1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwid3JpdGVcIixcbiAgZm46IGZ1bmN0aW9uKCkge1xuICB9LFxuICBlZmZlY3Q6IEJkLFxuICBkYXRhOiB7fVxufTtcbnZhciBIZCA9IHtcbiAgbGVmdDogXCJyaWdodFwiLFxuICByaWdodDogXCJsZWZ0XCIsXG4gIGJvdHRvbTogXCJ0b3BcIixcbiAgdG9wOiBcImJvdHRvbVwiXG59O1xuZnVuY3Rpb24gV3Mocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBIZFt0XTtcbiAgfSk7XG59XG52YXIgVmQgPSB7XG4gIHN0YXJ0OiBcImVuZFwiLFxuICBlbmQ6IFwic3RhcnRcIlxufTtcbmZ1bmN0aW9uIFlyKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gVmRbdF07XG4gIH0pO1xufVxuZnVuY3Rpb24gZ3Iocykge1xuICB2YXIgdCA9IF90KHMpLCBlID0gdC5wYWdlWE9mZnNldCwgaSA9IHQucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZSxcbiAgICBzY3JvbGxUb3A6IGlcbiAgfTtcbn1cbmZ1bmN0aW9uIGJyKHMpIHtcbiAgcmV0dXJuIFplKGllKHMpKS5sZWZ0ICsgZ3Iocykuc2Nyb2xsTGVmdDtcbn1cbmZ1bmN0aW9uIFdkKHMsIHQpIHtcbiAgdmFyIGUgPSBfdChzKSwgaSA9IGllKHMpLCBuID0gZS52aXN1YWxWaWV3cG9ydCwgbyA9IGkuY2xpZW50V2lkdGgsIHIgPSBpLmNsaWVudEhlaWdodCwgYSA9IDAsIGwgPSAwO1xuICBpZiAobikge1xuICAgIG8gPSBuLndpZHRoLCByID0gbi5oZWlnaHQ7XG4gICAgdmFyIHAgPSBCYygpO1xuICAgIChwIHx8ICFwICYmIHQgPT09IFwiZml4ZWRcIikgJiYgKGEgPSBuLm9mZnNldExlZnQsIGwgPSBuLm9mZnNldFRvcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogbyxcbiAgICBoZWlnaHQ6IHIsXG4gICAgeDogYSArIGJyKHMpLFxuICAgIHk6IGxcbiAgfTtcbn1cbmZ1bmN0aW9uIEZkKHMpIHtcbiAgdmFyIHQsIGUgPSBpZShzKSwgaSA9IGdyKHMpLCBuID0gKHQgPSBzLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiB0LmJvZHksIG8gPSB2ZShlLnNjcm9sbFdpZHRoLCBlLmNsaWVudFdpZHRoLCBuID8gbi5zY3JvbGxXaWR0aCA6IDAsIG4gPyBuLmNsaWVudFdpZHRoIDogMCksIHIgPSB2ZShlLnNjcm9sbEhlaWdodCwgZS5jbGllbnRIZWlnaHQsIG4gPyBuLnNjcm9sbEhlaWdodCA6IDAsIG4gPyBuLmNsaWVudEhlaWdodCA6IDApLCBhID0gLWkuc2Nyb2xsTGVmdCArIGJyKHMpLCBsID0gLWkuc2Nyb2xsVG9wO1xuICByZXR1cm4gQXQobiB8fCBlKS5kaXJlY3Rpb24gPT09IFwicnRsXCIgJiYgKGEgKz0gdmUoZS5jbGllbnRXaWR0aCwgbiA/IG4uY2xpZW50V2lkdGggOiAwKSAtIG8pLCB7XG4gICAgd2lkdGg6IG8sXG4gICAgaGVpZ2h0OiByLFxuICAgIHg6IGEsXG4gICAgeTogbFxuICB9O1xufVxuZnVuY3Rpb24gdnIocykge1xuICB2YXIgdCA9IEF0KHMpLCBlID0gdC5vdmVyZmxvdywgaSA9IHQub3ZlcmZsb3dYLCBuID0gdC5vdmVyZmxvd1k7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3QoZSArIG4gKyBpKTtcbn1cbmZ1bmN0aW9uIGpjKHMpIHtcbiAgcmV0dXJuIFtcImh0bWxcIiwgXCJib2R5XCIsIFwiI2RvY3VtZW50XCJdLmluZGV4T2YoUnQocykpID49IDAgPyBzLm93bmVyRG9jdW1lbnQuYm9keSA6IGR0KHMpICYmIHZyKHMpID8gcyA6IGpjKG1uKHMpKTtcbn1cbmZ1bmN0aW9uIFJpKHMsIHQpIHtcbiAgdmFyIGU7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IFtdKTtcbiAgdmFyIGkgPSBqYyhzKSwgbiA9IGkgPT09ICgoZSA9IHMub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGUuYm9keSksIG8gPSBfdChpKSwgciA9IG4gPyBbb10uY29uY2F0KG8udmlzdWFsVmlld3BvcnQgfHwgW10sIHZyKGkpID8gaSA6IFtdKSA6IGksIGEgPSB0LmNvbmNhdChyKTtcbiAgcmV0dXJuIG4gPyBhIDogKFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxuICAgIGEuY29uY2F0KFJpKG1uKHIpKSlcbiAgKTtcbn1cbmZ1bmN0aW9uIFlvKHMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHMsIHtcbiAgICBsZWZ0OiBzLngsXG4gICAgdG9wOiBzLnksXG4gICAgcmlnaHQ6IHMueCArIHMud2lkdGgsXG4gICAgYm90dG9tOiBzLnkgKyBzLmhlaWdodFxuICB9KTtcbn1cbmZ1bmN0aW9uIFlkKHMsIHQpIHtcbiAgdmFyIGUgPSBaZShzLCAhMSwgdCA9PT0gXCJmaXhlZFwiKTtcbiAgcmV0dXJuIGUudG9wID0gZS50b3AgKyBzLmNsaWVudFRvcCwgZS5sZWZ0ID0gZS5sZWZ0ICsgcy5jbGllbnRMZWZ0LCBlLmJvdHRvbSA9IGUudG9wICsgcy5jbGllbnRIZWlnaHQsIGUucmlnaHQgPSBlLmxlZnQgKyBzLmNsaWVudFdpZHRoLCBlLndpZHRoID0gcy5jbGllbnRXaWR0aCwgZS5oZWlnaHQgPSBzLmNsaWVudEhlaWdodCwgZS54ID0gZS5sZWZ0LCBlLnkgPSBlLnRvcCwgZTtcbn1cbmZ1bmN0aW9uIGpyKHMsIHQsIGUpIHtcbiAgcmV0dXJuIHQgPT09IGNyID8gWW8oV2QocywgZSkpIDogeWUodCkgPyBZZCh0LCBlKSA6IFlvKEZkKGllKHMpKSk7XG59XG5mdW5jdGlvbiBqZChzKSB7XG4gIHZhciB0ID0gUmkobW4ocykpLCBlID0gW1wiYWJzb2x1dGVcIiwgXCJmaXhlZFwiXS5pbmRleE9mKEF0KHMpLnBvc2l0aW9uKSA+PSAwLCBpID0gZSAmJiBkdChzKSA/IEtpKHMpIDogcztcbiAgcmV0dXJuIHllKGkpID8gdC5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgIHJldHVybiB5ZShuKSAmJiBIYyhuLCBpKSAmJiBSdChuKSAhPT0gXCJib2R5XCI7XG4gIH0pIDogW107XG59XG5mdW5jdGlvbiBLZChzLCB0LCBlLCBpKSB7XG4gIHZhciBuID0gdCA9PT0gXCJjbGlwcGluZ1BhcmVudHNcIiA/IGpkKHMpIDogW10uY29uY2F0KHQpLCBvID0gW10uY29uY2F0KG4sIFtlXSksIHIgPSBvWzBdLCBhID0gby5yZWR1Y2UoZnVuY3Rpb24obCwgcCkge1xuICAgIHZhciB1ID0ganIocywgcCwgaSk7XG4gICAgcmV0dXJuIGwudG9wID0gdmUodS50b3AsIGwudG9wKSwgbC5yaWdodCA9IHVuKHUucmlnaHQsIGwucmlnaHQpLCBsLmJvdHRvbSA9IHVuKHUuYm90dG9tLCBsLmJvdHRvbSksIGwubGVmdCA9IHZlKHUubGVmdCwgbC5sZWZ0KSwgbDtcbiAgfSwganIocywgciwgaSkpO1xuICByZXR1cm4gYS53aWR0aCA9IGEucmlnaHQgLSBhLmxlZnQsIGEuaGVpZ2h0ID0gYS5ib3R0b20gLSBhLnRvcCwgYS54ID0gYS5sZWZ0LCBhLnkgPSBhLnRvcCwgYTtcbn1cbmZ1bmN0aW9uIEtjKHMpIHtcbiAgdmFyIHQgPSBzLnJlZmVyZW5jZSwgZSA9IHMuZWxlbWVudCwgaSA9IHMucGxhY2VtZW50LCBuID0gaSA/IEV0KGkpIDogbnVsbCwgbyA9IGkgPyBRZShpKSA6IG51bGwsIHIgPSB0LnggKyB0LndpZHRoIC8gMiAtIGUud2lkdGggLyAyLCBhID0gdC55ICsgdC5oZWlnaHQgLyAyIC0gZS5oZWlnaHQgLyAyLCBsO1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIHN0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogcixcbiAgICAgICAgeTogdC55IC0gZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIHV0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogcixcbiAgICAgICAgeTogdC55ICsgdC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIHB0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogdC54ICsgdC53aWR0aCxcbiAgICAgICAgeTogYVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgbnQ6XG4gICAgICBsID0ge1xuICAgICAgICB4OiB0LnggLSBlLndpZHRoLFxuICAgICAgICB5OiBhXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGwgPSB7XG4gICAgICAgIHg6IHQueCxcbiAgICAgICAgeTogdC55XG4gICAgICB9O1xuICB9XG4gIHZhciBwID0gbiA/IF9yKG4pIDogbnVsbDtcbiAgaWYgKHAgIT0gbnVsbCkge1xuICAgIHZhciB1ID0gcCA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuICAgIHN3aXRjaCAobykge1xuICAgICAgY2FzZSBBZTpcbiAgICAgICAgbFtwXSA9IGxbcF0gLSAodFt1XSAvIDIgLSBlW3VdIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZTpcbiAgICAgICAgbFtwXSA9IGxbcF0gKyAodFt1XSAvIDIgLSBlW3VdIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbDtcbn1cbmZ1bmN0aW9uIEplKHMsIHQpIHtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0ge30pO1xuICB2YXIgZSA9IHQsIGkgPSBlLnBsYWNlbWVudCwgbiA9IGkgPT09IHZvaWQgMCA/IHMucGxhY2VtZW50IDogaSwgbyA9IGUuc3RyYXRlZ3ksIHIgPSBvID09PSB2b2lkIDAgPyBzLnN0cmF0ZWd5IDogbywgYSA9IGUuYm91bmRhcnksIGwgPSBhID09PSB2b2lkIDAgPyB4YyA6IGEsIHAgPSBlLnJvb3RCb3VuZGFyeSwgdSA9IHAgPT09IHZvaWQgMCA/IGNyIDogcCwgXyA9IGUuZWxlbWVudENvbnRleHQsIGYgPSBfID09PSB2b2lkIDAgPyBCZSA6IF8sIGcgPSBlLmFsdEJvdW5kYXJ5LCBtID0gZyA9PT0gdm9pZCAwID8gITEgOiBnLCBiID0gZS5wYWRkaW5nLCB2ID0gYiA9PT0gdm9pZCAwID8gMCA6IGIsIFQgPSBXYyh0eXBlb2YgdiAhPSBcIm51bWJlclwiID8gdiA6IEZjKHYsIG5pKSksIHkgPSBmID09PSBCZSA/IE9jIDogQmUsIEMgPSBzLnJlY3RzLnBvcHBlciwgRSA9IHMuZWxlbWVudHNbbSA/IHkgOiBmXSwgdyA9IEtkKHllKEUpID8gRSA6IEUuY29udGV4dEVsZW1lbnQgfHwgaWUocy5lbGVtZW50cy5wb3BwZXIpLCBsLCB1LCByKSwgayA9IFplKHMuZWxlbWVudHMucmVmZXJlbmNlKSwgRCA9IEtjKHtcbiAgICByZWZlcmVuY2U6IGssXG4gICAgZWxlbWVudDogQyxcbiAgICBzdHJhdGVneTogXCJhYnNvbHV0ZVwiLFxuICAgIHBsYWNlbWVudDogblxuICB9KSwgTyA9IFlvKE9iamVjdC5hc3NpZ24oe30sIEMsIEQpKSwgeCA9IGYgPT09IEJlID8gTyA6IGssIEwgPSB7XG4gICAgdG9wOiB3LnRvcCAtIHgudG9wICsgVC50b3AsXG4gICAgYm90dG9tOiB4LmJvdHRvbSAtIHcuYm90dG9tICsgVC5ib3R0b20sXG4gICAgbGVmdDogdy5sZWZ0IC0geC5sZWZ0ICsgVC5sZWZ0LFxuICAgIHJpZ2h0OiB4LnJpZ2h0IC0gdy5yaWdodCArIFQucmlnaHRcbiAgfSwgUyA9IHMubW9kaWZpZXJzRGF0YS5vZmZzZXQ7XG4gIGlmIChmID09PSBCZSAmJiBTKSB7XG4gICAgdmFyIE4gPSBTW25dO1xuICAgIE9iamVjdC5rZXlzKEwpLmZvckVhY2goZnVuY3Rpb24oUCkge1xuICAgICAgdmFyIG90ID0gW3B0LCB1dF0uaW5kZXhPZihQKSA+PSAwID8gMSA6IC0xLCBydCA9IFtzdCwgdXRdLmluZGV4T2YoUCkgPj0gMCA/IFwieVwiIDogXCJ4XCI7XG4gICAgICBMW1BdICs9IE5bcnRdICogb3Q7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIEw7XG59XG5mdW5jdGlvbiB6ZChzLCB0KSB7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IHt9KTtcbiAgdmFyIGUgPSB0LCBpID0gZS5wbGFjZW1lbnQsIG4gPSBlLmJvdW5kYXJ5LCBvID0gZS5yb290Qm91bmRhcnksIHIgPSBlLnBhZGRpbmcsIGEgPSBlLmZsaXBWYXJpYXRpb25zLCBsID0gZS5hbGxvd2VkQXV0b1BsYWNlbWVudHMsIHAgPSBsID09PSB2b2lkIDAgPyBociA6IGwsIHUgPSBRZShpKSwgXyA9IHUgPyBhID8gV28gOiBXby5maWx0ZXIoZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBRZShtKSA9PT0gdTtcbiAgfSkgOiBuaSwgZiA9IF8uZmlsdGVyKGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gcC5pbmRleE9mKG0pID49IDA7XG4gIH0pO1xuICBmLmxlbmd0aCA9PT0gMCAmJiAoZiA9IF8sIHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFtcIlBvcHBlcjogVGhlIGBhbGxvd2VkQXV0b1BsYWNlbWVudHNgIG9wdGlvbiBkaWQgbm90IGFsbG93IGFueVwiLCBcInBsYWNlbWVudHMuIEVuc3VyZSB0aGUgYHBsYWNlbWVudGAgb3B0aW9uIG1hdGNoZXMgdGhlIHZhcmlhdGlvblwiLCBcIm9mIHRoZSBhbGxvd2VkIHBsYWNlbWVudHMuXCIsICdGb3IgZXhhbXBsZSwgXCJhdXRvXCIgY2Fubm90IGJlIHVzZWQgdG8gYWxsb3cgXCJib3R0b20tc3RhcnRcIi4nLCAnVXNlIFwiYXV0by1zdGFydFwiIGluc3RlYWQuJ10uam9pbihcIiBcIikpKTtcbiAgdmFyIGcgPSBmLnJlZHVjZShmdW5jdGlvbihtLCBiKSB7XG4gICAgcmV0dXJuIG1bYl0gPSBKZShzLCB7XG4gICAgICBwbGFjZW1lbnQ6IGIsXG4gICAgICBib3VuZGFyeTogbixcbiAgICAgIHJvb3RCb3VuZGFyeTogbyxcbiAgICAgIHBhZGRpbmc6IHJcbiAgICB9KVtFdChiKV0sIG07XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGcpLnNvcnQoZnVuY3Rpb24obSwgYikge1xuICAgIHJldHVybiBnW21dIC0gZ1tiXTtcbiAgfSk7XG59XG5mdW5jdGlvbiBVZChzKSB7XG4gIGlmIChFdChzKSA9PT0gamkpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgdCA9IFdzKHMpO1xuICByZXR1cm4gW1lyKHMpLCB0LCBZcih0KV07XG59XG5mdW5jdGlvbiBYZChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMub3B0aW9ucywgaSA9IHMubmFtZTtcbiAgaWYgKCF0Lm1vZGlmaWVyc0RhdGFbaV0uX3NraXApIHtcbiAgICBmb3IgKHZhciBuID0gZS5tYWluQXhpcywgbyA9IG4gPT09IHZvaWQgMCA/ICEwIDogbiwgciA9IGUuYWx0QXhpcywgYSA9IHIgPT09IHZvaWQgMCA/ICEwIDogciwgbCA9IGUuZmFsbGJhY2tQbGFjZW1lbnRzLCBwID0gZS5wYWRkaW5nLCB1ID0gZS5ib3VuZGFyeSwgXyA9IGUucm9vdEJvdW5kYXJ5LCBmID0gZS5hbHRCb3VuZGFyeSwgZyA9IGUuZmxpcFZhcmlhdGlvbnMsIG0gPSBnID09PSB2b2lkIDAgPyAhMCA6IGcsIGIgPSBlLmFsbG93ZWRBdXRvUGxhY2VtZW50cywgdiA9IHQub3B0aW9ucy5wbGFjZW1lbnQsIFQgPSBFdCh2KSwgeSA9IFQgPT09IHYsIEMgPSBsIHx8ICh5IHx8ICFtID8gW1dzKHYpXSA6IFVkKHYpKSwgRSA9IFt2XS5jb25jYXQoQykucmVkdWNlKGZ1bmN0aW9uKE9lLCBWdCkge1xuICAgICAgcmV0dXJuIE9lLmNvbmNhdChFdChWdCkgPT09IGppID8gemQodCwge1xuICAgICAgICBwbGFjZW1lbnQ6IFZ0LFxuICAgICAgICBib3VuZGFyeTogdSxcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiBfLFxuICAgICAgICBwYWRkaW5nOiBwLFxuICAgICAgICBmbGlwVmFyaWF0aW9uczogbSxcbiAgICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBiXG4gICAgICB9KSA6IFZ0KTtcbiAgICB9LCBbXSksIHcgPSB0LnJlY3RzLnJlZmVyZW5jZSwgayA9IHQucmVjdHMucG9wcGVyLCBEID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgTyA9ICEwLCB4ID0gRVswXSwgTCA9IDA7IEwgPCBFLmxlbmd0aDsgTCsrKSB7XG4gICAgICB2YXIgUyA9IEVbTF0sIE4gPSBFdChTKSwgUCA9IFFlKFMpID09PSBBZSwgb3QgPSBbc3QsIHV0XS5pbmRleE9mKE4pID49IDAsIHJ0ID0gb3QgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiLCBHID0gSmUodCwge1xuICAgICAgICBwbGFjZW1lbnQ6IFMsXG4gICAgICAgIGJvdW5kYXJ5OiB1LFxuICAgICAgICByb290Qm91bmRhcnk6IF8sXG4gICAgICAgIGFsdEJvdW5kYXJ5OiBmLFxuICAgICAgICBwYWRkaW5nOiBwXG4gICAgICB9KSwgdnQgPSBvdCA/IFAgPyBwdCA6IG50IDogUCA/IHV0IDogc3Q7XG4gICAgICB3W3J0XSA+IGtbcnRdICYmICh2dCA9IFdzKHZ0KSk7XG4gICAgICB2YXIgSmkgPSBXcyh2dCksIG9lID0gW107XG4gICAgICBpZiAobyAmJiBvZS5wdXNoKEdbTl0gPD0gMCksIGEgJiYgb2UucHVzaChHW3Z0XSA8PSAwLCBHW0ppXSA8PSAwKSwgb2UuZXZlcnkoZnVuY3Rpb24oT2UpIHtcbiAgICAgICAgcmV0dXJuIE9lO1xuICAgICAgfSkpIHtcbiAgICAgICAgeCA9IFMsIE8gPSAhMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBELnNldChTLCBvZSk7XG4gICAgfVxuICAgIGlmIChPKVxuICAgICAgZm9yICh2YXIgdHMgPSBtID8gMyA6IDEsIGtuID0gZnVuY3Rpb24oVnQpIHtcbiAgICAgICAgdmFyIGRpID0gRS5maW5kKGZ1bmN0aW9uKGlzKSB7XG4gICAgICAgICAgdmFyIHJlID0gRC5nZXQoaXMpO1xuICAgICAgICAgIGlmIChyZSlcbiAgICAgICAgICAgIHJldHVybiByZS5zbGljZSgwLCBWdCkuZXZlcnkoZnVuY3Rpb24oeG4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHhuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGkpXG4gICAgICAgICAgcmV0dXJuIHggPSBkaSwgXCJicmVha1wiO1xuICAgICAgfSwgaGkgPSB0czsgaGkgPiAwOyBoaS0tKSB7XG4gICAgICAgIHZhciBlcyA9IGtuKGhpKTtcbiAgICAgICAgaWYgKGVzID09PSBcImJyZWFrXCIpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgdC5wbGFjZW1lbnQgIT09IHggJiYgKHQubW9kaWZpZXJzRGF0YVtpXS5fc2tpcCA9ICEwLCB0LnBsYWNlbWVudCA9IHgsIHQucmVzZXQgPSAhMCk7XG4gIH1cbn1cbmNvbnN0IHpjID0ge1xuICBuYW1lOiBcImZsaXBcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgZm46IFhkLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJvZmZzZXRcIl0sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogITFcbiAgfVxufTtcbmZ1bmN0aW9uIEtyKHMsIHQsIGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSksIHtcbiAgICB0b3A6IHMudG9wIC0gdC5oZWlnaHQgLSBlLnksXG4gICAgcmlnaHQ6IHMucmlnaHQgLSB0LndpZHRoICsgZS54LFxuICAgIGJvdHRvbTogcy5ib3R0b20gLSB0LmhlaWdodCArIGUueSxcbiAgICBsZWZ0OiBzLmxlZnQgLSB0LndpZHRoIC0gZS54XG4gIH07XG59XG5mdW5jdGlvbiB6cihzKSB7XG4gIHJldHVybiBbc3QsIHB0LCB1dCwgbnRdLnNvbWUoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBzW3RdID49IDA7XG4gIH0pO1xufVxuZnVuY3Rpb24gR2Qocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm5hbWUsIGkgPSB0LnJlY3RzLnJlZmVyZW5jZSwgbiA9IHQucmVjdHMucG9wcGVyLCBvID0gdC5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdywgciA9IEplKHQsIHtcbiAgICBlbGVtZW50Q29udGV4dDogXCJyZWZlcmVuY2VcIlxuICB9KSwgYSA9IEplKHQsIHtcbiAgICBhbHRCb3VuZGFyeTogITBcbiAgfSksIGwgPSBLcihyLCBpKSwgcCA9IEtyKGEsIG4sIG8pLCB1ID0genIobCksIF8gPSB6cihwKTtcbiAgdC5tb2RpZmllcnNEYXRhW2VdID0ge1xuICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogbCxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiB1LFxuICAgIGhhc1BvcHBlckVzY2FwZWQ6IF9cbiAgfSwgdC5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHQuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICBcImRhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW5cIjogdSxcbiAgICBcImRhdGEtcG9wcGVyLWVzY2FwZWRcIjogX1xuICB9KTtcbn1cbmNvbnN0IFVjID0ge1xuICBuYW1lOiBcImhpZGVcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgcmVxdWlyZXNJZkV4aXN0czogW1wicHJldmVudE92ZXJmbG93XCJdLFxuICBmbjogR2Rcbn07XG5mdW5jdGlvbiBxZChzLCB0LCBlKSB7XG4gIHZhciBpID0gRXQocyksIG4gPSBbbnQsIHN0XS5pbmRleE9mKGkpID49IDAgPyAtMSA6IDEsIG8gPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlKE9iamVjdC5hc3NpZ24oe30sIHQsIHtcbiAgICBwbGFjZW1lbnQ6IHNcbiAgfSkpIDogZSwgciA9IG9bMF0sIGEgPSBvWzFdO1xuICByZXR1cm4gciA9IHIgfHwgMCwgYSA9IChhIHx8IDApICogbiwgW250LCBwdF0uaW5kZXhPZihpKSA+PSAwID8ge1xuICAgIHg6IGEsXG4gICAgeTogclxuICB9IDoge1xuICAgIHg6IHIsXG4gICAgeTogYVxuICB9O1xufVxuZnVuY3Rpb24gWmQocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm9wdGlvbnMsIGkgPSBzLm5hbWUsIG4gPSBlLm9mZnNldCwgbyA9IG4gPT09IHZvaWQgMCA/IFswLCAwXSA6IG4sIHIgPSBoci5yZWR1Y2UoZnVuY3Rpb24odSwgXykge1xuICAgIHJldHVybiB1W19dID0gcWQoXywgdC5yZWN0cywgbyksIHU7XG4gIH0sIHt9KSwgYSA9IHJbdC5wbGFjZW1lbnRdLCBsID0gYS54LCBwID0gYS55O1xuICB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsICYmICh0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IGwsIHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0gcCksIHQubW9kaWZpZXJzRGF0YVtpXSA9IHI7XG59XG5jb25zdCBYYyA9IHtcbiAgbmFtZTogXCJvZmZzZXRcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgcmVxdWlyZXM6IFtcInBvcHBlck9mZnNldHNcIl0sXG4gIGZuOiBaZFxufTtcbmZ1bmN0aW9uIFFkKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5uYW1lO1xuICB0Lm1vZGlmaWVyc0RhdGFbZV0gPSBLYyh7XG4gICAgcmVmZXJlbmNlOiB0LnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiB0LnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogXCJhYnNvbHV0ZVwiLFxuICAgIHBsYWNlbWVudDogdC5wbGFjZW1lbnRcbiAgfSk7XG59XG5jb25zdCBUciA9IHtcbiAgbmFtZTogXCJwb3BwZXJPZmZzZXRzXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJyZWFkXCIsXG4gIGZuOiBRZCxcbiAgZGF0YToge31cbn07XG5mdW5jdGlvbiBKZChzKSB7XG4gIHJldHVybiBzID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCI7XG59XG5mdW5jdGlvbiB0dShzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMub3B0aW9ucywgaSA9IHMubmFtZSwgbiA9IGUubWFpbkF4aXMsIG8gPSBuID09PSB2b2lkIDAgPyAhMCA6IG4sIHIgPSBlLmFsdEF4aXMsIGEgPSByID09PSB2b2lkIDAgPyAhMSA6IHIsIGwgPSBlLmJvdW5kYXJ5LCBwID0gZS5yb290Qm91bmRhcnksIHUgPSBlLmFsdEJvdW5kYXJ5LCBfID0gZS5wYWRkaW5nLCBmID0gZS50ZXRoZXIsIGcgPSBmID09PSB2b2lkIDAgPyAhMCA6IGYsIG0gPSBlLnRldGhlck9mZnNldCwgYiA9IG0gPT09IHZvaWQgMCA/IDAgOiBtLCB2ID0gSmUodCwge1xuICAgIGJvdW5kYXJ5OiBsLFxuICAgIHJvb3RCb3VuZGFyeTogcCxcbiAgICBwYWRkaW5nOiBfLFxuICAgIGFsdEJvdW5kYXJ5OiB1XG4gIH0pLCBUID0gRXQodC5wbGFjZW1lbnQpLCB5ID0gUWUodC5wbGFjZW1lbnQpLCBDID0gIXksIEUgPSBfcihUKSwgdyA9IEpkKEUpLCBrID0gdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsIEQgPSB0LnJlY3RzLnJlZmVyZW5jZSwgTyA9IHQucmVjdHMucG9wcGVyLCB4ID0gdHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiID8gYihPYmplY3QuYXNzaWduKHt9LCB0LnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiB0LnBsYWNlbWVudFxuICB9KSkgOiBiLCBMID0gdHlwZW9mIHggPT0gXCJudW1iZXJcIiA/IHtcbiAgICBtYWluQXhpczogeCxcbiAgICBhbHRBeGlzOiB4XG4gIH0gOiBPYmplY3QuYXNzaWduKHtcbiAgICBtYWluQXhpczogMCxcbiAgICBhbHRBeGlzOiAwXG4gIH0sIHgpLCBTID0gdC5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHQubW9kaWZpZXJzRGF0YS5vZmZzZXRbdC5wbGFjZW1lbnRdIDogbnVsbCwgTiA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgaWYgKGspIHtcbiAgICBpZiAobykge1xuICAgICAgdmFyIFAsIG90ID0gRSA9PT0gXCJ5XCIgPyBzdCA6IG50LCBydCA9IEUgPT09IFwieVwiID8gdXQgOiBwdCwgRyA9IEUgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIiwgdnQgPSBrW0VdLCBKaSA9IHZ0ICsgdltvdF0sIG9lID0gdnQgLSB2W3J0XSwgdHMgPSBnID8gLU9bR10gLyAyIDogMCwga24gPSB5ID09PSBBZSA/IERbR10gOiBPW0ddLCBoaSA9IHkgPT09IEFlID8gLU9bR10gOiAtRFtHXSwgZXMgPSB0LmVsZW1lbnRzLmFycm93LCBPZSA9IGcgJiYgZXMgPyBwcihlcykgOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH0sIFZ0ID0gdC5tb2RpZmllcnNEYXRhW1wiYXJyb3cjcGVyc2lzdGVudFwiXSA/IHQubW9kaWZpZXJzRGF0YVtcImFycm93I3BlcnNpc3RlbnRcIl0ucGFkZGluZyA6IFZjKCksIGRpID0gVnRbb3RdLCBpcyA9IFZ0W3J0XSwgcmUgPSBNaSgwLCBEW0ddLCBPZVtHXSksIHhuID0gQyA/IERbR10gLyAyIC0gdHMgLSByZSAtIGRpIC0gTC5tYWluQXhpcyA6IGtuIC0gcmUgLSBkaSAtIEwubWFpbkF4aXMsIG5kID0gQyA/IC1EW0ddIC8gMiArIHRzICsgcmUgKyBpcyArIEwubWFpbkF4aXMgOiBoaSArIHJlICsgaXMgKyBMLm1haW5BeGlzLCBPbiA9IHQuZWxlbWVudHMuYXJyb3cgJiYgS2kodC5lbGVtZW50cy5hcnJvdyksIG9kID0gT24gPyBFID09PSBcInlcIiA/IE9uLmNsaWVudFRvcCB8fCAwIDogT24uY2xpZW50TGVmdCB8fCAwIDogMCwgSXIgPSAoUCA9IFMgPT0gbnVsbCA/IHZvaWQgMCA6IFNbRV0pICE9IG51bGwgPyBQIDogMCwgcmQgPSB2dCArIHhuIC0gSXIgLSBvZCwgYWQgPSB2dCArIG5kIC0gSXIsIERyID0gTWkoZyA/IHVuKEppLCByZCkgOiBKaSwgdnQsIGcgPyB2ZShvZSwgYWQpIDogb2UpO1xuICAgICAga1tFXSA9IERyLCBOW0VdID0gRHIgLSB2dDtcbiAgICB9XG4gICAgaWYgKGEpIHtcbiAgICAgIHZhciAkciwgbGQgPSBFID09PSBcInhcIiA/IHN0IDogbnQsIGNkID0gRSA9PT0gXCJ4XCIgPyB1dCA6IHB0LCBhZSA9IGtbd10sIHNzID0gdyA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLCBMciA9IGFlICsgdltsZF0sIE5yID0gYWUgLSB2W2NkXSwgU24gPSBbc3QsIG50XS5pbmRleE9mKFQpICE9PSAtMSwgTXIgPSAoJHIgPSBTID09IG51bGwgPyB2b2lkIDAgOiBTW3ddKSAhPSBudWxsID8gJHIgOiAwLCBSciA9IFNuID8gTHIgOiBhZSAtIERbc3NdIC0gT1tzc10gLSBNciArIEwuYWx0QXhpcywgUHIgPSBTbiA/IGFlICsgRFtzc10gKyBPW3NzXSAtIE1yIC0gTC5hbHRBeGlzIDogTnIsIEJyID0gZyAmJiBTbiA/IERkKFJyLCBhZSwgUHIpIDogTWkoZyA/IFJyIDogTHIsIGFlLCBnID8gUHIgOiBOcik7XG4gICAgICBrW3ddID0gQnIsIE5bd10gPSBCciAtIGFlO1xuICAgIH1cbiAgICB0Lm1vZGlmaWVyc0RhdGFbaV0gPSBOO1xuICB9XG59XG5jb25zdCBHYyA9IHtcbiAgbmFtZTogXCJwcmV2ZW50T3ZlcmZsb3dcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgZm46IHR1LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJvZmZzZXRcIl1cbn07XG5mdW5jdGlvbiBldShzKSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogcy5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogcy5zY3JvbGxUb3BcbiAgfTtcbn1cbmZ1bmN0aW9uIGl1KHMpIHtcbiAgcmV0dXJuIHMgPT09IF90KHMpIHx8ICFkdChzKSA/IGdyKHMpIDogZXUocyk7XG59XG5mdW5jdGlvbiBzdShzKSB7XG4gIHZhciB0ID0gcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZSA9IHFlKHQud2lkdGgpIC8gcy5vZmZzZXRXaWR0aCB8fCAxLCBpID0gcWUodC5oZWlnaHQpIC8gcy5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgcmV0dXJuIGUgIT09IDEgfHwgaSAhPT0gMTtcbn1cbmZ1bmN0aW9uIG51KHMsIHQsIGUpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gITEpO1xuICB2YXIgaSA9IGR0KHQpLCBuID0gZHQodCkgJiYgc3UodCksIG8gPSBpZSh0KSwgciA9IFplKHMsIG4sIGUpLCBhID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH0sIGwgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIHJldHVybiAoaSB8fCAhaSAmJiAhZSkgJiYgKChSdCh0KSAhPT0gXCJib2R5XCIgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gIHZyKG8pKSAmJiAoYSA9IGl1KHQpKSwgZHQodCkgPyAobCA9IFplKHQsICEwKSwgbC54ICs9IHQuY2xpZW50TGVmdCwgbC55ICs9IHQuY2xpZW50VG9wKSA6IG8gJiYgKGwueCA9IGJyKG8pKSksIHtcbiAgICB4OiByLmxlZnQgKyBhLnNjcm9sbExlZnQgLSBsLngsXG4gICAgeTogci50b3AgKyBhLnNjcm9sbFRvcCAtIGwueSxcbiAgICB3aWR0aDogci53aWR0aCxcbiAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBvdShzKSB7XG4gIHZhciB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIGkgPSBbXTtcbiAgcy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICB0LnNldChvLm5hbWUsIG8pO1xuICB9KTtcbiAgZnVuY3Rpb24gbihvKSB7XG4gICAgZS5hZGQoby5uYW1lKTtcbiAgICB2YXIgciA9IFtdLmNvbmNhdChvLnJlcXVpcmVzIHx8IFtdLCBvLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHIuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICBpZiAoIWUuaGFzKGEpKSB7XG4gICAgICAgIHZhciBsID0gdC5nZXQoYSk7XG4gICAgICAgIGwgJiYgbihsKTtcbiAgICAgIH1cbiAgICB9KSwgaS5wdXNoKG8pO1xuICB9XG4gIHJldHVybiBzLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgIGUuaGFzKG8ubmFtZSkgfHwgbihvKTtcbiAgfSksIGk7XG59XG5mdW5jdGlvbiBydShzKSB7XG4gIHZhciB0ID0gb3Uocyk7XG4gIHJldHVybiBkbi5yZWR1Y2UoZnVuY3Rpb24oZSwgaSkge1xuICAgIHJldHVybiBlLmNvbmNhdCh0LmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gbi5waGFzZSA9PT0gaTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIGF1KHMpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdCB8fCAodCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKGUpIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHQgPSB2b2lkIDAsIGUocygpKTtcbiAgICAgIH0pO1xuICAgIH0pKSwgdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIFd0KHMpIHtcbiAgZm9yICh2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGgsIGUgPSBuZXcgQXJyYXkodCA+IDEgPyB0IC0gMSA6IDApLCBpID0gMTsgaSA8IHQ7IGkrKylcbiAgICBlW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgcmV0dXJuIFtdLmNvbmNhdChlKS5yZWR1Y2UoZnVuY3Rpb24obiwgbykge1xuICAgIHJldHVybiBuLnJlcGxhY2UoLyVzLywgbyk7XG4gIH0sIHMpO1xufVxudmFyIGxlID0gJ1BvcHBlcjogbW9kaWZpZXIgXCIlc1wiIHByb3ZpZGVkIGFuIGludmFsaWQgJXMgcHJvcGVydHksIGV4cGVjdGVkICVzIGJ1dCBnb3QgJXMnLCBsdSA9ICdQb3BwZXI6IG1vZGlmaWVyIFwiJXNcIiByZXF1aXJlcyBcIiVzXCIsIGJ1dCBcIiVzXCIgbW9kaWZpZXIgaXMgbm90IGF2YWlsYWJsZScsIFVyID0gW1wibmFtZVwiLCBcImVuYWJsZWRcIiwgXCJwaGFzZVwiLCBcImZuXCIsIFwiZWZmZWN0XCIsIFwicmVxdWlyZXNcIiwgXCJvcHRpb25zXCJdO1xuZnVuY3Rpb24gY3Uocykge1xuICBzLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgIFtdLmNvbmNhdChPYmplY3Qua2V5cyh0KSwgVXIpLmZpbHRlcihmdW5jdGlvbihlLCBpLCBuKSB7XG4gICAgICByZXR1cm4gbi5pbmRleE9mKGUpID09PSBpO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgdHlwZW9mIHQubmFtZSAhPSBcInN0cmluZ1wiICYmIGNvbnNvbGUuZXJyb3IoV3QobGUsIFN0cmluZyh0Lm5hbWUpLCAnXCJuYW1lXCInLCAnXCJzdHJpbmdcIicsICdcIicgKyBTdHJpbmcodC5uYW1lKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVuYWJsZWRcIjpcbiAgICAgICAgICB0eXBlb2YgdC5lbmFibGVkICE9IFwiYm9vbGVhblwiICYmIGNvbnNvbGUuZXJyb3IoV3QobGUsIHQubmFtZSwgJ1wiZW5hYmxlZFwiJywgJ1wiYm9vbGVhblwiJywgJ1wiJyArIFN0cmluZyh0LmVuYWJsZWQpICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicGhhc2VcIjpcbiAgICAgICAgICBkbi5pbmRleE9mKHQucGhhc2UpIDwgMCAmJiBjb25zb2xlLmVycm9yKFd0KGxlLCB0Lm5hbWUsICdcInBoYXNlXCInLCBcImVpdGhlciBcIiArIGRuLmpvaW4oXCIsIFwiKSwgJ1wiJyArIFN0cmluZyh0LnBoYXNlKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImZuXCI6XG4gICAgICAgICAgdHlwZW9mIHQuZm4gIT0gXCJmdW5jdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoV3QobGUsIHQubmFtZSwgJ1wiZm5cIicsICdcImZ1bmN0aW9uXCInLCAnXCInICsgU3RyaW5nKHQuZm4pICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZWZmZWN0XCI6XG4gICAgICAgICAgdC5lZmZlY3QgIT0gbnVsbCAmJiB0eXBlb2YgdC5lZmZlY3QgIT0gXCJmdW5jdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoV3QobGUsIHQubmFtZSwgJ1wiZWZmZWN0XCInLCAnXCJmdW5jdGlvblwiJywgJ1wiJyArIFN0cmluZyh0LmZuKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlcXVpcmVzXCI6XG4gICAgICAgICAgdC5yZXF1aXJlcyAhPSBudWxsICYmICFBcnJheS5pc0FycmF5KHQucmVxdWlyZXMpICYmIGNvbnNvbGUuZXJyb3IoV3QobGUsIHQubmFtZSwgJ1wicmVxdWlyZXNcIicsICdcImFycmF5XCInLCAnXCInICsgU3RyaW5nKHQucmVxdWlyZXMpICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVxdWlyZXNJZkV4aXN0c1wiOlxuICAgICAgICAgIEFycmF5LmlzQXJyYXkodC5yZXF1aXJlc0lmRXhpc3RzKSB8fCBjb25zb2xlLmVycm9yKFd0KGxlLCB0Lm5hbWUsICdcInJlcXVpcmVzSWZFeGlzdHNcIicsICdcImFycmF5XCInLCAnXCInICsgU3RyaW5nKHQucmVxdWlyZXNJZkV4aXN0cykgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvcHRpb25zXCI6XG4gICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5lcnJvcignUG9wcGVySlM6IGFuIGludmFsaWQgcHJvcGVydHkgaGFzIGJlZW4gcHJvdmlkZWQgdG8gdGhlIFwiJyArIHQubmFtZSArICdcIiBtb2RpZmllciwgdmFsaWQgcHJvcGVydGllcyBhcmUgJyArIFVyLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1wiJyArIGkgKyAnXCInO1xuICAgICAgICAgIH0pLmpvaW4oXCIsIFwiKSArICc7IGJ1dCBcIicgKyBlICsgJ1wiIHdhcyBwcm92aWRlZC4nKTtcbiAgICAgIH1cbiAgICAgIHQucmVxdWlyZXMgJiYgdC5yZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcy5maW5kKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gbi5uYW1lID09PSBpO1xuICAgICAgICB9KSA9PSBudWxsICYmIGNvbnNvbGUuZXJyb3IoV3QobHUsIFN0cmluZyh0Lm5hbWUpLCBpLCBpKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBodShzLCB0KSB7XG4gIHZhciBlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcmV0dXJuIHMuZmlsdGVyKGZ1bmN0aW9uKGkpIHtcbiAgICB2YXIgbiA9IHQoaSk7XG4gICAgaWYgKCFlLmhhcyhuKSlcbiAgICAgIHJldHVybiBlLmFkZChuKSwgITA7XG4gIH0pO1xufVxuZnVuY3Rpb24gZHUocykge1xuICB2YXIgdCA9IHMucmVkdWNlKGZ1bmN0aW9uKGUsIGkpIHtcbiAgICB2YXIgbiA9IGVbaS5uYW1lXTtcbiAgICByZXR1cm4gZVtpLm5hbWVdID0gbiA/IE9iamVjdC5hc3NpZ24oe30sIG4sIGksIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIG4ub3B0aW9ucywgaS5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIG4uZGF0YSwgaS5kYXRhKVxuICAgIH0pIDogaSwgZTtcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXModCkubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gdFtlXTtcbiAgfSk7XG59XG52YXIgWHIgPSBcIlBvcHBlcjogSW52YWxpZCByZWZlcmVuY2Ugb3IgcG9wcGVyIGFyZ3VtZW50IHByb3ZpZGVkLiBUaGV5IG11c3QgYmUgZWl0aGVyIGEgRE9NIGVsZW1lbnQgb3IgdmlydHVhbCBlbGVtZW50LlwiLCB1dSA9IFwiUG9wcGVyOiBBbiBpbmZpbml0ZSBsb29wIGluIHRoZSBtb2RpZmllcnMgY3ljbGUgaGFzIGJlZW4gZGV0ZWN0ZWQhIFRoZSBjeWNsZSBoYXMgYmVlbiBpbnRlcnJ1cHRlZCB0byBwcmV2ZW50IGEgYnJvd3NlciBjcmFzaC5cIiwgR3IgPSB7XG4gIHBsYWNlbWVudDogXCJib3R0b21cIixcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6IFwiYWJzb2x1dGVcIlxufTtcbmZ1bmN0aW9uIHFyKCkge1xuICBmb3IgKHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShzKSwgZSA9IDA7IGUgPCBzOyBlKyspXG4gICAgdFtlXSA9IGFyZ3VtZW50c1tlXTtcbiAgcmV0dXJuICF0LnNvbWUoZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiAhKGkgJiYgdHlwZW9mIGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09IFwiZnVuY3Rpb25cIik7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ24ocykge1xuICBzID09PSB2b2lkIDAgJiYgKHMgPSB7fSk7XG4gIHZhciB0ID0gcywgZSA9IHQuZGVmYXVsdE1vZGlmaWVycywgaSA9IGUgPT09IHZvaWQgMCA/IFtdIDogZSwgbiA9IHQuZGVmYXVsdE9wdGlvbnMsIG8gPSBuID09PSB2b2lkIDAgPyBHciA6IG47XG4gIHJldHVybiBmdW5jdGlvbihhLCBsLCBwKSB7XG4gICAgcCA9PT0gdm9pZCAwICYmIChwID0gbyk7XG4gICAgdmFyIHUgPSB7XG4gICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIEdyLCBvKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiBhLFxuICAgICAgICBwb3BwZXI6IGxcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9LCBfID0gW10sIGYgPSAhMSwgZyA9IHtcbiAgICAgIHN0YXRlOiB1LFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24oVCkge1xuICAgICAgICB2YXIgeSA9IHR5cGVvZiBUID09IFwiZnVuY3Rpb25cIiA/IFQodS5vcHRpb25zKSA6IFQ7XG4gICAgICAgIGIoKSwgdS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgbywgdS5vcHRpb25zLCB5KSwgdS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogeWUoYSkgPyBSaShhKSA6IGEuY29udGV4dEVsZW1lbnQgPyBSaShhLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogUmkobClcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIEMgPSBydShkdShbXS5jb25jYXQoaSwgdS5vcHRpb25zLm1vZGlmaWVycykpKTtcbiAgICAgICAgaWYgKHUub3JkZXJlZE1vZGlmaWVycyA9IEMuZmlsdGVyKGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgICByZXR1cm4gUy5lbmFibGVkO1xuICAgICAgICB9KSwge30uTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgdmFyIEUgPSBodShbXS5jb25jYXQoQywgdS5vcHRpb25zLm1vZGlmaWVycyksIGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgICAgIHZhciBOID0gUy5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIE47XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGN1KEUpLCBFdCh1Lm9wdGlvbnMucGxhY2VtZW50KSA9PT0gamkpIHtcbiAgICAgICAgICAgIHZhciB3ID0gdS5vcmRlcmVkTW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24oUykge1xuICAgICAgICAgICAgICB2YXIgTiA9IFMubmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuIE4gPT09IFwiZmxpcFwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3IHx8IGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXV0b1wiIHBsYWNlbWVudHMgcmVxdWlyZSB0aGUgXCJmbGlwXCIgbW9kaWZpZXIgYmUnLCBcInByZXNlbnQgYW5kIGVuYWJsZWQgdG8gd29yay5cIl0uam9pbihcIiBcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgayA9IEF0KGwpLCBEID0gay5tYXJnaW5Ub3AsIE8gPSBrLm1hcmdpblJpZ2h0LCB4ID0gay5tYXJnaW5Cb3R0b20sIEwgPSBrLm1hcmdpbkxlZnQ7XG4gICAgICAgICAgW0QsIE8sIHgsIExdLnNvbWUoZnVuY3Rpb24oUykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoUyk7XG4gICAgICAgICAgfSkgJiYgY29uc29sZS53YXJuKFsnUG9wcGVyOiBDU1MgXCJtYXJnaW5cIiBzdHlsZXMgY2Fubm90IGJlIHVzZWQgdG8gYXBwbHkgcGFkZGluZycsIFwiYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgb3IgYm91bmRhcnkuXCIsIFwiVG8gcmVwbGljYXRlIG1hcmdpbiwgdXNlIHRoZSBgb2Zmc2V0YCBtb2RpZmllciwgYXMgd2VsbCBhc1wiLCBcInRoZSBgcGFkZGluZ2Agb3B0aW9uIGluIHRoZSBgcHJldmVudE92ZXJmbG93YCBhbmQgYGZsaXBgXCIsIFwibW9kaWZpZXJzLlwiXS5qb2luKFwiIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0oKSwgZy51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghZikge1xuICAgICAgICAgIHZhciBUID0gdS5lbGVtZW50cywgeSA9IFQucmVmZXJlbmNlLCBDID0gVC5wb3BwZXI7XG4gICAgICAgICAgaWYgKCFxcih5LCBDKSkge1xuICAgICAgICAgICAgKHt9KS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihYcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHUucmVjdHMgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2U6IG51KHksIEtpKEMpLCB1Lm9wdGlvbnMuc3RyYXRlZ3kgPT09IFwiZml4ZWRcIiksXG4gICAgICAgICAgICBwb3BwZXI6IHByKEMpXG4gICAgICAgICAgfSwgdS5yZXNldCA9ICExLCB1LnBsYWNlbWVudCA9IHUub3B0aW9ucy5wbGFjZW1lbnQsIHUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgICAgIHJldHVybiB1Lm1vZGlmaWVyc0RhdGFbUy5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIFMuZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yICh2YXIgRSA9IDAsIHcgPSAwOyB3IDwgdS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgdysrKSB7XG4gICAgICAgICAgICBpZiAoe30uTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChFICs9IDEsIEUgPiAxMDApKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodXUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1LnJlc2V0ID09PSAhMCkge1xuICAgICAgICAgICAgICB1LnJlc2V0ID0gITEsIHcgPSAtMTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgayA9IHUub3JkZXJlZE1vZGlmaWVyc1t3XSwgRCA9IGsuZm4sIE8gPSBrLm9wdGlvbnMsIHggPSBPID09PSB2b2lkIDAgPyB7fSA6IE8sIEwgPSBrLm5hbWU7XG4gICAgICAgICAgICB0eXBlb2YgRCA9PSBcImZ1bmN0aW9uXCIgJiYgKHUgPSBEKHtcbiAgICAgICAgICAgICAgc3RhdGU6IHUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHgsXG4gICAgICAgICAgICAgIG5hbWU6IEwsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBnXG4gICAgICAgICAgICB9KSB8fCB1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBhdShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICBnLmZvcmNlVXBkYXRlKCksIHYodSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgYigpLCBmID0gITA7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIXFyKGEsIGwpKVxuICAgICAgcmV0dXJuIHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFhyKSwgZztcbiAgICBnLnNldE9wdGlvbnMocCkudGhlbihmdW5jdGlvbih2KSB7XG4gICAgICAhZiAmJiBwLm9uRmlyc3RVcGRhdGUgJiYgcC5vbkZpcnN0VXBkYXRlKHYpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIG0oKSB7XG4gICAgICB1Lm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgIHZhciBUID0gdi5uYW1lLCB5ID0gdi5vcHRpb25zLCBDID0geSA9PT0gdm9pZCAwID8ge30gOiB5LCBFID0gdi5lZmZlY3Q7XG4gICAgICAgIGlmICh0eXBlb2YgRSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB2YXIgdyA9IEUoe1xuICAgICAgICAgICAgc3RhdGU6IHUsXG4gICAgICAgICAgICBuYW1lOiBULFxuICAgICAgICAgICAgaW5zdGFuY2U6IGcsXG4gICAgICAgICAgICBvcHRpb25zOiBDXG4gICAgICAgICAgfSksIGsgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB9O1xuICAgICAgICAgIF8ucHVzaCh3IHx8IGspO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYigpIHtcbiAgICAgIF8uZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2KCk7XG4gICAgICB9KSwgXyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gZztcbiAgfTtcbn1cbnZhciBwdSA9IC8qIEBfX1BVUkVfXyAqLyBnbigpLCBfdSA9IFttciwgVHIsIGZyLCB1cl0sIGZ1ID0gLyogQF9fUFVSRV9fICovIGduKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogX3Vcbn0pLCBtdSA9IFttciwgVHIsIGZyLCB1ciwgWGMsIHpjLCBHYywgWWMsIFVjXSwgc2UgPSAvKiBAX19QVVJFX18gKi8gZ24oe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBtdVxufSk7XG5jb25zdCBxYyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGFmdGVyTWFpbjogTmMsXG4gIGFmdGVyUmVhZDogRGMsXG4gIGFmdGVyV3JpdGU6IFBjLFxuICBhcHBseVN0eWxlczogdXIsXG4gIGFycm93OiBZYyxcbiAgYXV0bzogamksXG4gIGJhc2VQbGFjZW1lbnRzOiBuaSxcbiAgYmVmb3JlTWFpbjogJGMsXG4gIGJlZm9yZVJlYWQ6IFNjLFxuICBiZWZvcmVXcml0ZTogTWMsXG4gIGJvdHRvbTogdXQsXG4gIGNsaXBwaW5nUGFyZW50czogeGMsXG4gIGNvbXB1dGVTdHlsZXM6IGZyLFxuICBjcmVhdGVQb3BwZXI6IHNlLFxuICBjcmVhdGVQb3BwZXJCYXNlOiBwdSxcbiAgY3JlYXRlUG9wcGVyTGl0ZTogZnUsXG4gIGRldGVjdE92ZXJmbG93OiBKZSxcbiAgZW5kOiBHZSxcbiAgZXZlbnRMaXN0ZW5lcnM6IG1yLFxuICBmbGlwOiB6YyxcbiAgaGlkZTogVWMsXG4gIGxlZnQ6IG50LFxuICBtYWluOiBMYyxcbiAgbW9kaWZpZXJQaGFzZXM6IGRuLFxuICBvZmZzZXQ6IFhjLFxuICBwbGFjZW1lbnRzOiBocixcbiAgcG9wcGVyOiBCZSxcbiAgcG9wcGVyR2VuZXJhdG9yOiBnbixcbiAgcG9wcGVyT2Zmc2V0czogVHIsXG4gIHByZXZlbnRPdmVyZmxvdzogR2MsXG4gIHJlYWQ6IEljLFxuICByZWZlcmVuY2U6IE9jLFxuICByaWdodDogcHQsXG4gIHN0YXJ0OiBBZSxcbiAgdG9wOiBzdCxcbiAgdmFyaWF0aW9uUGxhY2VtZW50czogV28sXG4gIHZpZXdwb3J0OiBjcixcbiAgd3JpdGU6IFJjXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpO1xuZnVuY3Rpb24gTG4ocykge1xuICByZXR1cm4gcyA9PT0gXCJ0cnVlXCIgPyAhMCA6IHMgPT09IFwiZmFsc2VcIiA/ICExIDogcyA9PT0gTnVtYmVyKHMpLnRvU3RyaW5nKCkgPyBOdW1iZXIocykgOiBzID09PSBcIlwiIHx8IHMgPT09IFwibnVsbFwiID8gbnVsbCA6IHM7XG59XG5mdW5jdGlvbiBObihzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1tBLVpdL2csICh0KSA9PiBgLSR7dC50b0xvd2VyQ2FzZSgpfWApO1xufVxuY29uc3QgaCA9IHtcbiAgc2V0RGF0YUF0dHJpYnV0ZShzLCB0LCBlKSB7XG4gICAgcy5zZXRBdHRyaWJ1dGUoYGRhdGEtdGUtJHtObih0KX1gLCBlKTtcbiAgfSxcbiAgcmVtb3ZlRGF0YUF0dHJpYnV0ZShzLCB0KSB7XG4gICAgcy5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtdGUtJHtObih0KX1gKTtcbiAgfSxcbiAgZ2V0RGF0YUF0dHJpYnV0ZXMocykge1xuICAgIGlmICghcylcbiAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB0ID0ge307XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHMuZGF0YXNldCkuZmlsdGVyKChlKSA9PiBlLnN0YXJ0c1dpdGgoXCJ0ZVwiKSkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgaWYgKGUuc3RhcnRzV2l0aChcInRlQ2xhc3NcIikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBpID0gZS5yZXBsYWNlKC9edGUvLCBcIlwiKTtcbiAgICAgIGkgPSBpLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgaS5zbGljZSgxLCBpLmxlbmd0aCksIHRbaV0gPSBMbihzLmRhdGFzZXRbZV0pO1xuICAgIH0pLCB0O1xuICB9LFxuICBnZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHMpIHtcbiAgICBpZiAoIXMpXG4gICAgICByZXR1cm4ge307XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLnMuZGF0YXNldFxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLmZpbHRlcigoZSkgPT4gZS5zdGFydHNXaXRoKFwidGVDbGFzc1wiKSkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgbGV0IGkgPSBlLnJlcGxhY2UoL150ZUNsYXNzLywgXCJcIik7XG4gICAgICBpID0gaS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIGkuc2xpY2UoMSwgaS5sZW5ndGgpLCB0W2ldID0gTG4odFtlXSk7XG4gICAgfSksIHQ7XG4gIH0sXG4gIGdldERhdGFBdHRyaWJ1dGUocywgdCkge1xuICAgIHJldHVybiBMbihcbiAgICAgIHMuZ2V0QXR0cmlidXRlKGBkYXRhLXRlLSR7Tm4odCl9YClcbiAgICApO1xuICB9LFxuICBvZmZzZXQocykge1xuICAgIGNvbnN0IHQgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHQudG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICBsZWZ0OiB0LmxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnRcbiAgICB9O1xuICB9LFxuICBwb3NpdGlvbihzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcy5vZmZzZXRUb3AsXG4gICAgICBsZWZ0OiBzLm9mZnNldExlZnRcbiAgICB9O1xuICB9LFxuICBzdHlsZShzLCB0KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzLnN0eWxlLCB0KTtcbiAgfSxcbiAgdG9nZ2xlQ2xhc3MocywgdCkge1xuICAgIHMgJiYgTW4odCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgcy5jbGFzc0xpc3QuY29udGFpbnMoZSkgPyBzLmNsYXNzTGlzdC5yZW1vdmUoZSkgOiBzLmNsYXNzTGlzdC5hZGQoZSk7XG4gICAgfSk7XG4gIH0sXG4gIGFkZENsYXNzKHMsIHQpIHtcbiAgICBNbih0KS5mb3JFYWNoKFxuICAgICAgKGUpID0+ICFzLmNsYXNzTGlzdC5jb250YWlucyhlKSAmJiBzLmNsYXNzTGlzdC5hZGQoZSlcbiAgICApO1xuICB9LFxuICBhZGRTdHlsZShzLCB0KSB7XG4gICAgT2JqZWN0LmtleXModCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgcy5zdHlsZVtlXSA9IHRbZV07XG4gICAgfSk7XG4gIH0sXG4gIHJlbW92ZUNsYXNzKHMsIHQpIHtcbiAgICBNbih0KS5mb3JFYWNoKFxuICAgICAgKGUpID0+IHMuY2xhc3NMaXN0LmNvbnRhaW5zKGUpICYmIHMuY2xhc3NMaXN0LnJlbW92ZShlKVxuICAgICk7XG4gIH0sXG4gIGhhc0NsYXNzKHMsIHQpIHtcbiAgICByZXR1cm4gcy5jbGFzc0xpc3QuY29udGFpbnModCk7XG4gIH0sXG4gIG1heE9mZnNldChzKSB7XG4gICAgY29uc3QgdCA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdC50b3AgKyBNYXRoLm1heChcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICAgIHdpbmRvdy5zY3JvbGxZXG4gICAgICApLFxuICAgICAgbGVmdDogdC5sZWZ0ICsgTWF0aC5tYXgoXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICAgIHdpbmRvdy5zY3JvbGxYXG4gICAgICApXG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIE1uKHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyBzLnNwbGl0KFwiIFwiKSA6IEFycmF5LmlzQXJyYXkocykgPyBzIDogITE7XG59XG5jb25zdCBndSA9IDMsIGQgPSB7XG4gIGNsb3Nlc3QocywgdCkge1xuICAgIHJldHVybiBzLmNsb3Nlc3QodCk7XG4gIH0sXG4gIG1hdGNoZXMocywgdCkge1xuICAgIHJldHVybiBzLm1hdGNoZXModCk7XG4gIH0sXG4gIGZpbmQocywgdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAuLi5FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLmNhbGwodCwgcylcbiAgICApO1xuICB9LFxuICBmaW5kT25lKHMsIHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvci5jYWxsKHQsIHMpO1xuICB9LFxuICBjaGlsZHJlbihzLCB0KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5zLmNoaWxkcmVuKS5maWx0ZXIoKGkpID0+IGkubWF0Y2hlcyh0KSk7XG4gIH0sXG4gIHBhcmVudHMocywgdCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICBsZXQgaSA9IHMucGFyZW50Tm9kZTtcbiAgICBmb3IgKDsgaSAmJiBpLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBpLm5vZGVUeXBlICE9PSBndTsgKVxuICAgICAgdGhpcy5tYXRjaGVzKGksIHQpICYmIGUucHVzaChpKSwgaSA9IGkucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gZTtcbiAgfSxcbiAgcHJldihzLCB0KSB7XG4gICAgbGV0IGUgPSBzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgZm9yICg7IGU7ICkge1xuICAgICAgaWYgKGUubWF0Y2hlcyh0KSlcbiAgICAgICAgcmV0dXJuIFtlXTtcbiAgICAgIGUgPSBlLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgbmV4dChzLCB0KSB7XG4gICAgbGV0IGUgPSBzLm5leHRFbGVtZW50U2libGluZztcbiAgICBmb3IgKDsgZTsgKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaGVzKGUsIHQpKVxuICAgICAgICByZXR1cm4gW2VdO1xuICAgICAgZSA9IGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH0sXG4gIGZvY3VzYWJsZUNoaWxkcmVuKHMpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAgXCJhXCIsXG4gICAgICBcImJ1dHRvblwiLFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgXCJ0ZXh0YXJlYVwiLFxuICAgICAgXCJzZWxlY3RcIixcbiAgICAgIFwiZGV0YWlsc1wiLFxuICAgICAgXCJbdGFiaW5kZXhdXCIsXG4gICAgICAnW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0nXG4gICAgXS5tYXAoKGUpID0+IGAke2V9Om5vdChbdGFiaW5kZXhePVwiLVwiXSlgKS5qb2luKFwiLCBcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluZCh0LCBzKS5maWx0ZXIoXG4gICAgICAoZSkgPT4gIWJlKGUpICYmIE10KGUpXG4gICAgKTtcbiAgfVxufSwgUm4gPSBcImRyb3Bkb3duXCIsIGJ1ID0gXCJ0ZS5kcm9wZG93blwiLCB4ZSA9IGAuJHtidX1gLCBFciA9IFwiLmRhdGEtYXBpXCIsIEZzID0gXCJFc2NhcGVcIiwgWnIgPSBcIlNwYWNlXCIsIFFyID0gXCJUYWJcIiwgam8gPSBcIkFycm93VXBcIiwgWXMgPSBcIkFycm93RG93blwiLCB2dSA9IDIsIFR1ID0gbmV3IFJlZ0V4cChcbiAgYCR7am99fCR7WXN9fCR7RnN9YFxuKSwgRXUgPSBgaGlkZSR7eGV9YCwgQ3UgPSBgaGlkZGVuJHt4ZX1gLCBBdSA9IGBzaG93JHt4ZX1gLCB5dSA9IGBzaG93biR7eGV9YCwgd3UgPSBgY2xpY2ske3hlfSR7RXJ9YCwgSnIgPSBga2V5ZG93biR7eGV9JHtFcn1gLCBrdSA9IGBrZXl1cCR7eGV9JHtFcn1gLCBGdCA9IFwic2hvd1wiLCB4dSA9IFwiZHJvcHVwXCIsIE91ID0gXCJkcm9wZW5kXCIsIFN1ID0gXCJkcm9wc3RhcnRcIiwgSXUgPSBcIltkYXRhLXRlLW5hdmJhci1yZWZdXCIsIG9zID0gXCJbZGF0YS10ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLCBQbiA9IFwiW2RhdGEtdGUtZHJvcGRvd24tbWVudS1yZWZdXCIsIER1ID0gXCJbZGF0YS10ZS1uYXZiYXItbmF2LXJlZl1cIiwgJHUgPSBcIltkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXSBbZGF0YS10ZS1kcm9wZG93bi1pdGVtLXJlZl06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZClcIiwgTHUgPSBXKCkgPyBcInRvcC1lbmRcIiA6IFwidG9wLXN0YXJ0XCIsIE51ID0gVygpID8gXCJ0b3Atc3RhcnRcIiA6IFwidG9wLWVuZFwiLCBNdSA9IFcoKSA/IFwiYm90dG9tLWVuZFwiIDogXCJib3R0b20tc3RhcnRcIiwgUnUgPSBXKCkgPyBcImJvdHRvbS1zdGFydFwiIDogXCJib3R0b20tZW5kXCIsIFB1ID0gVygpID8gXCJsZWZ0LXN0YXJ0XCIgOiBcInJpZ2h0LXN0YXJ0XCIsIEJ1ID0gVygpID8gXCJyaWdodC1zdGFydFwiIDogXCJsZWZ0LXN0YXJ0XCIsIEh1ID0gW3sgb3BhY2l0eTogXCIwXCIgfSwgeyBvcGFjaXR5OiBcIjFcIiB9XSwgVnUgPSBbeyBvcGFjaXR5OiBcIjFcIiB9LCB7IG9wYWNpdHk6IFwiMFwiIH1dLCB0YSA9IHtcbiAgaXRlcmF0aW9uczogMSxcbiAgZWFzaW5nOiBcImVhc2VcIixcbiAgZmlsbDogXCJib3RoXCJcbn0sIFd1ID0ge1xuICBvZmZzZXQ6IFswLCAyXSxcbiAgYm91bmRhcnk6IFwiY2xpcHBpbmdQYXJlbnRzXCIsXG4gIHJlZmVyZW5jZTogXCJ0b2dnbGVcIixcbiAgZGlzcGxheTogXCJkeW5hbWljXCIsXG4gIHBvcHBlckNvbmZpZzogbnVsbCxcbiAgYXV0b0Nsb3NlOiAhMCxcbiAgZHJvcGRvd25BbmltYXRpb246IFwib25cIixcbiAgYW5pbWF0aW9uRHVyYXRpb246IDU1MFxufSwgRnUgPSB7XG4gIG9mZnNldDogXCIoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBib3VuZGFyeTogXCIoc3RyaW5nfGVsZW1lbnQpXCIsXG4gIHJlZmVyZW5jZTogXCIoc3RyaW5nfGVsZW1lbnR8b2JqZWN0KVwiLFxuICBkaXNwbGF5OiBcInN0cmluZ1wiLFxuICBwb3BwZXJDb25maWc6IFwiKG51bGx8b2JqZWN0fGZ1bmN0aW9uKVwiLFxuICBhdXRvQ2xvc2U6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBkcm9wZG93bkFuaW1hdGlvbjogXCJzdHJpbmdcIixcbiAgYW5pbWF0aW9uRHVyYXRpb246IFwibnVtYmVyXCJcbn07XG5jbGFzcyAkdCBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX21lbnUgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpLCB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpLCB0aGlzLl9mYWRlT3V0QW5pbWF0ZSA9IG51bGw7XG4gICAgY29uc3QgaSA9IHdpbmRvdy5tYXRjaE1lZGlhKFxuICAgICAgXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiXG4gICAgKS5tYXRjaGVzO1xuICAgIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgPSB0aGlzLl9jb25maWcuZHJvcGRvd25BbmltYXRpb24gPT09IFwib25cIiAmJiAhaSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIFd1O1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIEZ1O1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gUm47XG4gIH1cbiAgLy8gUHVibGljXG4gIHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgfVxuICBzaG93KCkge1xuICAgIGlmIChiZSh0aGlzLl9lbGVtZW50KSB8fCB0aGlzLl9pc1Nob3duKHRoaXMuX21lbnUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfTtcbiAgICBpZiAoYy50cmlnZ2VyKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIEF1LFxuICAgICAgdFxuICAgICkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gJHQuZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgdGhpcy5faW5OYXZiYXIgPyBoLnNldERhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgXCJwb3BwZXJcIiwgXCJub25lXCIpIDogdGhpcy5fY3JlYXRlUG9wcGVyKGkpLCBcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhaS5jbG9zZXN0KER1KSAmJiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaCgobikgPT4gYy5vbihuLCBcIm1vdXNlb3ZlclwiLCBobikpLCB0aGlzLl9lbGVtZW50LmZvY3VzKCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCAhMCksIHRoaXMuX21lbnUuc2V0QXR0cmlidXRlKGBkYXRhLXRlLWRyb3Bkb3duLSR7RnR9YCwgXCJcIiksIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgJiYgdGhpcy5fbWVudS5hbmltYXRlKEh1LCB7XG4gICAgICAuLi50YSxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLl9jb25maWcuYW5pbWF0aW9uRHVyYXRpb25cbiAgICB9KSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYGRhdGEtdGUtZHJvcGRvd24tJHtGdH1gLCBcIlwiKSwgc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHl1LCB0KTtcbiAgICAgIH0sXG4gICAgICB0aGlzLl9hbmltYXRpb25DYW5QbGF5ID8gdGhpcy5fY29uZmlnLmFuaW1hdGlvbkR1cmF0aW9uIDogMFxuICAgICk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoYmUodGhpcy5fZWxlbWVudCkgfHwgIXRoaXMuX2lzU2hvd24odGhpcy5fbWVudSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9O1xuICAgIHRoaXMuX2NvbXBsZXRlSGlkZSh0KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCksIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8IChjLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBKcixcbiAgICAgIG9zLFxuICAgICAgJHQuZGF0YUFwaUtleWRvd25IYW5kbGVyXG4gICAgKSwgYy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgSnIsXG4gICAgICBQbixcbiAgICAgICR0LmRhdGFBcGlLZXlkb3duSGFuZGxlclxuICAgICksIGMub24oZG9jdW1lbnQsIHd1LCAkdC5jbGVhck1lbnVzKSwgYy5vbihkb2N1bWVudCwga3UsICR0LmNsZWFyTWVudXMpLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9jb21wbGV0ZUhpZGUodCkge1xuICAgIHRoaXMuX2ZhZGVPdXRBbmltYXRlICYmIHRoaXMuX2ZhZGVPdXRBbmltYXRlLnBsYXlTdGF0ZSA9PT0gXCJydW5uaW5nXCIgfHwgYy50cmlnZ2VyKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIEV1LFxuICAgICAgdFxuICAgICkuZGVmYXVsdFByZXZlbnRlZCB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKGkpID0+IGMub2ZmKGksIFwibW91c2VvdmVyXCIsIGhuKSksIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgJiYgKHRoaXMuX2ZhZGVPdXRBbmltYXRlID0gdGhpcy5fbWVudS5hbmltYXRlKFZ1LCB7XG4gICAgICAuLi50YSxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLl9jb25maWcuYW5pbWF0aW9uRHVyYXRpb25cbiAgICB9KSksIHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9tZW51LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10ZS1kcm9wZG93bi0ke0Z0fWApLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10ZS1kcm9wZG93bi0ke0Z0fWApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiKSwgaC5yZW1vdmVEYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsIFwicG9wcGVyXCIpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgQ3UsIHQpO1xuICAgICAgfSxcbiAgICAgIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgPyB0aGlzLl9jb25maWcuYW5pbWF0aW9uRHVyYXRpb24gOiAwXG4gICAgKSk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgaWYgKHQgPSB7XG4gICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH0sIEkoUm4sIHQsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLCB0eXBlb2YgdC5yZWZlcmVuY2UgPT0gXCJvYmplY3RcIiAmJiAhWGUodC5yZWZlcmVuY2UpICYmIHR5cGVvZiB0LnJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYCR7Um4udG9VcHBlckNhc2UoKX06IE9wdGlvbiBcInJlZmVyZW5jZVwiIHByb3ZpZGVkIHR5cGUgXCJvYmplY3RcIiB3aXRob3V0IGEgcmVxdWlyZWQgXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIiBtZXRob2QuYFxuICAgICAgKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBfY3JlYXRlUG9wcGVyKHQpIHtcbiAgICBpZiAodHlwZW9mIHFjID4gXCJ1XCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkJvb3RzdHJhcCdzIGRyb3Bkb3ducyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKVwiXG4gICAgICApO1xuICAgIGxldCBlID0gdGhpcy5fZWxlbWVudDtcbiAgICB0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSBcInBhcmVudFwiID8gZSA9IHQgOiBYZSh0aGlzLl9jb25maWcucmVmZXJlbmNlKSA/IGUgPSBlZSh0aGlzLl9jb25maWcucmVmZXJlbmNlKSA6IHR5cGVvZiB0aGlzLl9jb25maWcucmVmZXJlbmNlID09IFwib2JqZWN0XCIgJiYgKGUgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlKTtcbiAgICBjb25zdCBpID0gdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCksIG4gPSBpLm1vZGlmaWVycy5maW5kKFxuICAgICAgKG8pID0+IG8ubmFtZSA9PT0gXCJhcHBseVN0eWxlc1wiICYmIG8uZW5hYmxlZCA9PT0gITFcbiAgICApO1xuICAgIHRoaXMuX3BvcHBlciA9IHNlKFxuICAgICAgZSxcbiAgICAgIHRoaXMuX21lbnUsXG4gICAgICBpXG4gICAgKSwgbiAmJiBoLnNldERhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgXCJwb3BwZXJcIiwgXCJzdGF0aWNcIik7XG4gIH1cbiAgX2lzU2hvd24odCA9IHRoaXMuX2VsZW1lbnQpIHtcbiAgICByZXR1cm4gdC5kYXRhc2V0W2B0ZURyb3Bkb3duJHtGdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIEZ0LnNsaWNlKDEpfWBdID09PSBcIlwiO1xuICB9XG4gIF9nZXRNZW51RWxlbWVudCgpIHtcbiAgICByZXR1cm4gZC5uZXh0KHRoaXMuX2VsZW1lbnQsIFBuKVswXTtcbiAgfVxuICBfZ2V0UGxhY2VtZW50KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKHQuZGF0YXNldC50ZURyb3Bkb3duUG9zaXRpb24gPT09IE91KVxuICAgICAgcmV0dXJuIFB1O1xuICAgIGlmICh0LmRhdGFzZXQudGVEcm9wZG93blBvc2l0aW9uID09PSBTdSlcbiAgICAgIHJldHVybiBCdTtcbiAgICBjb25zdCBlID0gdC5kYXRhc2V0LnRlRHJvcGRvd25BbGlnbm1lbnQgPT09IFwiZW5kXCI7XG4gICAgcmV0dXJuIHQuZGF0YXNldC50ZURyb3Bkb3duUG9zaXRpb24gPT09IHh1ID8gZSA/IE51IDogTHUgOiBlID8gUnUgOiBNdTtcbiAgfVxuICBfZGV0ZWN0TmF2YmFyKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoSXUpICE9PSBudWxsO1xuICB9XG4gIF9nZXRPZmZzZXQoKSB7XG4gICAgY29uc3QgeyBvZmZzZXQ6IHQgfSA9IHRoaXMuX2NvbmZpZztcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQuc3BsaXQoXCIsXCIpLm1hcCgoZSkgPT4gTnVtYmVyLnBhcnNlSW50KGUsIDEwKSkgOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyAoZSkgPT4gdChlLCB0aGlzLl9lbGVtZW50KSA6IHQ7XG4gIH1cbiAgX2dldFBvcHBlckNvbmZpZygpIHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgcGxhY2VtZW50OiB0aGlzLl9nZXRQbGFjZW1lbnQoKSxcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJwcmV2ZW50T3ZlcmZsb3dcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmRpc3BsYXkgPT09IFwic3RhdGljXCIgJiYgKHQubW9kaWZpZXJzID0gW1xuICAgICAge1xuICAgICAgICBuYW1lOiBcImFwcGx5U3R5bGVzXCIsXG4gICAgICAgIGVuYWJsZWQ6ICExXG4gICAgICB9XG4gICAgXSksIHtcbiAgICAgIC4uLnQsXG4gICAgICAuLi50eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKHQpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZ1xuICAgIH07XG4gIH1cbiAgX3NlbGVjdE1lbnVJdGVtKHsga2V5OiB0LCB0YXJnZXQ6IGUgfSkge1xuICAgIGNvbnN0IGkgPSBkLmZpbmQoXG4gICAgICAkdSxcbiAgICAgIHRoaXMuX21lbnVcbiAgICApLmZpbHRlcihNdCk7XG4gICAgaS5sZW5ndGggJiYgdmMoXG4gICAgICBpLFxuICAgICAgZSxcbiAgICAgIHQgPT09IFlzLFxuICAgICAgIWkuaW5jbHVkZXMoZSlcbiAgICApLmZvY3VzKCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gJHQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGNsZWFyTWVudXModCkge1xuICAgIGlmICh0ICYmICh0LmJ1dHRvbiA9PT0gdnUgfHwgdC50eXBlID09PSBcImtleXVwXCIgJiYgdC5rZXkgIT09IFFyKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gZC5maW5kKG9zKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGUubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjb25zdCBvID0gJHQuZ2V0SW5zdGFuY2UoZVtpXSk7XG4gICAgICBpZiAoIW8gfHwgby5fY29uZmlnLmF1dG9DbG9zZSA9PT0gITEgfHwgIW8uX2lzU2hvd24oKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCByID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBvLl9lbGVtZW50XG4gICAgICB9O1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgY29uc3QgYSA9IHQuY29tcG9zZWRQYXRoKCksIGwgPSBhLmluY2x1ZGVzKG8uX21lbnUpO1xuICAgICAgICBpZiAoYS5pbmNsdWRlcyhvLl9lbGVtZW50KSB8fCBvLl9jb25maWcuYXV0b0Nsb3NlID09PSBcImluc2lkZVwiICYmICFsIHx8IG8uX2NvbmZpZy5hdXRvQ2xvc2UgPT09IFwib3V0c2lkZVwiICYmIGwgfHwgby5fbWVudS5jb250YWlucyh0LnRhcmdldCkgJiYgKHQudHlwZSA9PT0gXCJrZXl1cFwiICYmIHQua2V5ID09PSBRciB8fCAvaW5wdXR8c2VsZWN0fG9wdGlvbnx0ZXh0YXJlYXxmb3JtL2kudGVzdCh0LnRhcmdldC50YWdOYW1lKSkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHQudHlwZSA9PT0gXCJjbGlja1wiICYmIChyLmNsaWNrRXZlbnQgPSB0KTtcbiAgICAgIH1cbiAgICAgIG8uX2NvbXBsZXRlSGlkZShyKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldFBhcmVudEZyb21FbGVtZW50KHQpIHtcbiAgICByZXR1cm4gdGUodCkgfHwgdC5wYXJlbnROb2RlO1xuICB9XG4gIHN0YXRpYyBkYXRhQXBpS2V5ZG93bkhhbmRsZXIodCkge1xuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KHQudGFyZ2V0LnRhZ05hbWUpID8gdC5rZXkgPT09IFpyIHx8IHQua2V5ICE9PSBGcyAmJiAodC5rZXkgIT09IFlzICYmIHQua2V5ICE9PSBqbyB8fCB0LnRhcmdldC5jbG9zZXN0KFBuKSkgOiAhVHUudGVzdCh0LmtleSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuZGF0YXNldFtgdGVEcm9wZG93biR7RnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBGdC5zbGljZSgxKX1gXSA9PT0gXCJcIjtcbiAgICBpZiAoIWUgJiYgdC5rZXkgPT09IEZzIHx8ICh0LnByZXZlbnREZWZhdWx0KCksIHQuc3RvcFByb3BhZ2F0aW9uKCksIGJlKHRoaXMpKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gdGhpcy5tYXRjaGVzKG9zKSA/IHRoaXMgOiBkLnByZXYodGhpcywgb3MpWzBdLCBuID0gJHQuZ2V0T3JDcmVhdGVJbnN0YW5jZShpKTtcbiAgICBpZiAodC5rZXkgPT09IEZzKSB7XG4gICAgICBuLmhpZGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHQua2V5ID09PSBqbyB8fCB0LmtleSA9PT0gWXMpIHtcbiAgICAgIGUgfHwgbi5zaG93KCksIG4uX3NlbGVjdE1lbnVJdGVtKHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoIWUgfHwgdC5rZXkgPT09IFpyKSAmJiAkdC5jbGVhck1lbnVzKCk7XG4gIH1cbn1cbmNvbnN0IEJuID0gXCJjb2xsYXBzZVwiLCBaYyA9IFwidGUuY29sbGFwc2VcIiwgYm4gPSBgLiR7WmN9YCwgZWEgPSB7XG4gIHRvZ2dsZTogITAsXG4gIHBhcmVudDogbnVsbFxufSwgWXUgPSB7XG4gIHRvZ2dsZTogXCJib29sZWFuXCIsXG4gIHBhcmVudDogXCIobnVsbHxlbGVtZW50KVwiXG59LCBqdSA9IGBzaG93JHtibn1gLCBLdSA9IGBzaG93biR7Ym59YCwgenUgPSBgaGlkZSR7Ym59YCwgVXUgPSBgaGlkZGVuJHtibn1gLCBIbiA9IFwiZGF0YS10ZS1jb2xsYXBzZS1zaG93XCIsIGlhID0gXCJkYXRhLXRlLWNvbGxhcHNlLWNvbGxhcHNlZFwiLCBycyA9IFwiZGF0YS10ZS1jb2xsYXBzZS1jb2xsYXBzaW5nXCIsIFh1ID0gXCJkYXRhLXRlLWNvbGxhcHNlLWhvcml6b250YWxcIiwgV2UgPSBcImRhdGEtdGUtY29sbGFwc2UtaXRlbVwiLCBzYSA9IGA6c2NvcGUgWyR7V2V9XSBbJHtXZX1dYCwgR3UgPSBcIndpZHRoXCIsIHF1ID0gXCJoZWlnaHRcIiwgWnUgPSBcIltkYXRhLXRlLWNvbGxhcHNlLWl0ZW1dW2RhdGEtdGUtY29sbGFwc2Utc2hvd10sIFtkYXRhLXRlLWNvbGxhcHNlLWl0ZW1dW2RhdGEtdGUtY29sbGFwc2UtY29sbGFwc2luZ11cIiwgbmEgPSBcIltkYXRhLXRlLWNvbGxhcHNlLWluaXRdXCIsIFF1ID0ge1xuICB2aXNpYmxlOiBcIiF2aXNpYmxlXCIsXG4gIGhpZGRlbjogXCJoaWRkZW5cIixcbiAgYmFzZVRyYW5zaXRpb246IFwib3ZlcmZsb3ctaGlkZGVuIGR1cmF0aW9uLVszNTBtc10gZWFzZS1bY3ViaWMtYmV6aWVyKDAuMjUsMC4xLDAuMjUsMS4wKV0gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIixcbiAgY29sbGFwc2luZzogXCJoLTAgdHJhbnNpdGlvbi1baGVpZ2h0XSBvdmVyZmxvdy1oaWRkZW4gZHVyYXRpb24tWzM1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICBjb2xsYXBzaW5nSG9yaXpvbnRhbDogXCJ3LTAgaC1hdXRvIHRyYW5zaXRpb24tW3dpZHRoXSBvdmVyZmxvdy1oaWRkZW4gZHVyYXRpb24tWzM1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiXG59LCBKdSA9IHtcbiAgdmlzaWJsZTogXCJzdHJpbmdcIixcbiAgaGlkZGVuOiBcInN0cmluZ1wiLFxuICBiYXNlVHJhbnNpdGlvbjogXCJzdHJpbmdcIixcbiAgY29sbGFwc2luZzogXCJzdHJpbmdcIixcbiAgY29sbGFwc2luZ0hvcml6b250YWw6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBRdCBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fdHJpZ2dlckFycmF5ID0gW107XG4gICAgY29uc3QgbiA9IGQuZmluZChuYSk7XG4gICAgZm9yIChsZXQgbyA9IDAsIHIgPSBuLmxlbmd0aDsgbyA8IHI7IG8rKykge1xuICAgICAgY29uc3QgYSA9IG5bb10sIGwgPSBscihhKSwgcCA9IGQuZmluZChsKS5maWx0ZXIoXG4gICAgICAgICh1KSA9PiB1ID09PSB0aGlzLl9lbGVtZW50XG4gICAgICApO1xuICAgICAgbCAhPT0gbnVsbCAmJiBwLmxlbmd0aCAmJiAodGhpcy5fc2VsZWN0b3IgPSBsLCB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChhKSk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxpemVDaGlsZHJlbigpLCB0aGlzLl9jb25maWcucGFyZW50IHx8IHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl90cmlnZ2VyQXJyYXksIHRoaXMuX2lzU2hvd24oKSksIHRoaXMuX2NvbmZpZy50b2dnbGUgJiYgdGhpcy50b2dnbGUoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gZWE7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBCbjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuX2lzU2hvd24oKSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHRoaXMuX2lzU2hvd24oKSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgdCA9IFtdLCBlO1xuICAgIGlmICh0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICBjb25zdCB1ID0gZC5maW5kKFxuICAgICAgICBzYSxcbiAgICAgICAgdGhpcy5fY29uZmlnLnBhcmVudFxuICAgICAgKTtcbiAgICAgIHQgPSBkLmZpbmQoXG4gICAgICAgIFp1LFxuICAgICAgICB0aGlzLl9jb25maWcucGFyZW50XG4gICAgICApLmZpbHRlcigoXykgPT4gIXUuaW5jbHVkZXMoXykpO1xuICAgIH1cbiAgICBjb25zdCBpID0gZC5maW5kT25lKHRoaXMuX3NlbGVjdG9yKTtcbiAgICBpZiAodC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHUgPSB0LmZpbmQoKF8pID0+IGkgIT09IF8pO1xuICAgICAgaWYgKGUgPSB1ID8gUXQuZ2V0SW5zdGFuY2UodSkgOiBudWxsLCBlICYmIGUuX2lzVHJhbnNpdGlvbmluZylcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGp1KS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHQuZm9yRWFjaCgodSkgPT4ge1xuICAgICAgaSAhPT0gdSAmJiBRdC5nZXRPckNyZWF0ZUluc3RhbmNlKHUsIHsgdG9nZ2xlOiAhMSB9KS5oaWRlKCksIGUgfHwgQS5zZXREYXRhKHUsIFpjLCBudWxsKTtcbiAgICB9KTtcbiAgICBjb25zdCBvID0gdGhpcy5fZ2V0RGltZW5zaW9uKCksIHIgPSBvID09PSBcImhlaWdodFwiID8gdGhpcy5fY2xhc3Nlcy5jb2xsYXBzaW5nIDogdGhpcy5fY2xhc3Nlcy5jb2xsYXBzaW5nSG9yaXpvbnRhbDtcbiAgICBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMudmlzaWJsZSksIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5oaWRkZW4pLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShXZSksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKHJzLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zdHlsZVtvXSA9IDAsIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl90cmlnZ2VyQXJyYXksICEwKSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITA7XG4gICAgY29uc3QgYSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaGlkZGVuKSwgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCByKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnZpc2libGUpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShycyksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFdlLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoSG4sIFwiXCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlW29dID0gXCJcIiwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEt1KTtcbiAgICB9LCBwID0gYHNjcm9sbCR7b1swXS50b1VwcGVyQ2FzZSgpICsgby5zbGljZSgxKX1gO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soYSwgdGhpcy5fZWxlbWVudCwgITApLCB0aGlzLl9lbGVtZW50LnN0eWxlW29dID0gYCR7dGhpcy5fZWxlbWVudFtwXX1weGA7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKCkgfHwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHp1KS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXREaW1lbnNpb24oKSwgaSA9IGUgPT09IFwiaGVpZ2h0XCIgPyB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmcgOiB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmdIb3Jpem9udGFsO1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZV0gPSBgJHt0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2VdfXB4YCwgc2kodGhpcy5fZWxlbWVudCksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgaSksIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy52aXNpYmxlKSwgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmhpZGRlbiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKHJzLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoV2UpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShIbik7XG4gICAgY29uc3QgbiA9IHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGg7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBuOyByKyspIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLl90cmlnZ2VyQXJyYXlbcl0sIGwgPSB0ZShhKTtcbiAgICAgIGwgJiYgIXRoaXMuX2lzU2hvd24obCkgJiYgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFthXSwgITEpO1xuICAgIH1cbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMDtcbiAgICBjb25zdCBvID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgaSksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy52aXNpYmxlKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmhpZGRlbiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHJzKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoV2UsIFwiXCIpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgVXUpO1xuICAgIH07XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtlXSA9IFwiXCIsIHRoaXMuX3F1ZXVlQ2FsbGJhY2sobywgdGhpcy5fZWxlbWVudCwgITApO1xuICB9XG4gIF9pc1Nob3duKHQgPSB0aGlzLl9lbGVtZW50KSB7XG4gICAgcmV0dXJuIHQuaGFzQXR0cmlidXRlKEhuKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uZWEsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH0sIHQudG9nZ2xlID0gISF0LnRvZ2dsZSwgdC5wYXJlbnQgPSBlZSh0LnBhcmVudCksIEkoQm4sIHQsIFl1KSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlF1LFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKEJuLCB0LCBKdSksIHQ7XG4gIH1cbiAgX2dldERpbWVuc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoWHUpID8gR3UgOiBxdTtcbiAgfVxuICBfaW5pdGlhbGl6ZUNoaWxkcmVuKCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLnBhcmVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gZC5maW5kKFxuICAgICAgc2EsXG4gICAgICB0aGlzLl9jb25maWcucGFyZW50XG4gICAgKTtcbiAgICBkLmZpbmQobmEsIHRoaXMuX2NvbmZpZy5wYXJlbnQpLmZpbHRlcigoZSkgPT4gIXQuaW5jbHVkZXMoZSkpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSB0ZShlKTtcbiAgICAgIGkgJiYgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFtlXSwgdGhpcy5faXNTaG93bihpKSk7XG4gICAgfSk7XG4gIH1cbiAgX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0LCBlKSB7XG4gICAgdC5sZW5ndGggJiYgdC5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBlID8gaS5yZW1vdmVBdHRyaWJ1dGUoaWEpIDogaS5zZXRBdHRyaWJ1dGUoYCR7aWF9YCwgXCJcIiksIGkuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBlKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSB7fTtcbiAgICAgIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgL3Nob3d8aGlkZS8udGVzdCh0KSAmJiAoZS50b2dnbGUgPSAhMSk7XG4gICAgICBjb25zdCBpID0gUXQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBlKTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IG9hID0gXCIuZml4ZWQtdG9wLCAuZml4ZWQtYm90dG9tLCAuaXMtZml4ZWQsIC5zdGlja3ktdG9wXCIsIHJhID0gXCIuc3RpY2t5LXRvcFwiO1xuY2xhc3MgdGkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcbiAgfVxuICBnZXRXaWR0aCgpIHtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cuaW5uZXJXaWR0aCAtIHQpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICB0aGlzLl9kaXNhYmxlT3ZlckZsb3coKSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJwYWRkaW5nUmlnaHRcIixcbiAgICAgIChlKSA9PiBlICsgdFxuICAgICksIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFxuICAgICAgb2EsXG4gICAgICBcInBhZGRpbmdSaWdodFwiLFxuICAgICAgKGUpID0+IGUgKyB0XG4gICAgKSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoXG4gICAgICByYSxcbiAgICAgIFwibWFyZ2luUmlnaHRcIixcbiAgICAgIChlKSA9PiBlIC0gdFxuICAgICk7XG4gIH1cbiAgX2Rpc2FibGVPdmVyRmxvdygpIHtcbiAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50LCBcIm92ZXJmbG93XCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgfVxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXModCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldFdpZHRoKCksIG8gPSAocikgPT4ge1xuICAgICAgaWYgKHIgIT09IHRoaXMuX2VsZW1lbnQgJiYgd2luZG93LmlubmVyV2lkdGggPiByLmNsaWVudFdpZHRoICsgbilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fc2F2ZUluaXRpYWxBdHRyaWJ1dGUociwgZSk7XG4gICAgICBjb25zdCBhID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocilbZV07XG4gICAgICByLnN0eWxlW2VdID0gYCR7aShcbiAgICAgICAgTnVtYmVyLnBhcnNlRmxvYXQoYSlcbiAgICAgICl9cHhgO1xuICAgIH07XG4gICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCBvKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsIFwib3ZlcmZsb3dcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgXCJwYWRkaW5nUmlnaHRcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMob2EsIFwicGFkZGluZ1JpZ2h0XCIpLCB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHJhLCBcIm1hcmdpblJpZ2h0XCIpO1xuICB9XG4gIF9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0LCBlKSB7XG4gICAgY29uc3QgaSA9IHQuc3R5bGVbZV07XG4gICAgaSAmJiBoLnNldERhdGFBdHRyaWJ1dGUodCwgZSwgaSk7XG4gIH1cbiAgX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModCwgZSkge1xuICAgIGNvbnN0IGkgPSAobikgPT4ge1xuICAgICAgY29uc3QgbyA9IGguZ2V0RGF0YUF0dHJpYnV0ZShuLCBlKTtcbiAgICAgIHR5cGVvZiBvID4gXCJ1XCIgPyBuLnN0eWxlLnJlbW92ZVByb3BlcnR5KGUpIDogKGgucmVtb3ZlRGF0YUF0dHJpYnV0ZShuLCBlKSwgbi5zdHlsZVtlXSA9IG8pO1xuICAgIH07XG4gICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCBpKTtcbiAgfVxuICBfYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCBlKSB7XG4gICAgWGUodCkgPyBlKHQpIDogZC5maW5kKHQsIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goZSk7XG4gIH1cbiAgaXNPdmVyZmxvd2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRXaWR0aCgpID4gMDtcbiAgfVxufVxuY29uc3QgdHAgPSB7XG4gIGlzVmlzaWJsZTogITAsXG4gIC8vIGlmIGZhbHNlLCB3ZSB1c2UgdGhlIGJhY2tkcm9wIGhlbHBlciB3aXRob3V0IGFkZGluZyBhbnkgZWxlbWVudCB0byB0aGUgZG9tXG4gIGlzQW5pbWF0ZWQ6ICExLFxuICByb290RWxlbWVudDogXCJib2R5XCIsXG4gIC8vIGdpdmUgdGhlIGNob2ljZSB0byBwbGFjZSBiYWNrZHJvcCB1bmRlciBkaWZmZXJlbnQgZWxlbWVudHNcbiAgY2xpY2tDYWxsYmFjazogbnVsbCxcbiAgYmFja2Ryb3BDbGFzc2VzOiBudWxsXG59LCBlcCA9IHtcbiAgaXNWaXNpYmxlOiBcImJvb2xlYW5cIixcbiAgaXNBbmltYXRlZDogXCJib29sZWFuXCIsXG4gIHJvb3RFbGVtZW50OiBcIihlbGVtZW50fHN0cmluZylcIixcbiAgY2xpY2tDYWxsYmFjazogXCIoZnVuY3Rpb258bnVsbClcIixcbiAgYmFja2Ryb3BDbGFzc2VzOiBcIihhcnJheXxzdHJpbmd8bnVsbClcIlxufSwgUWMgPSBcImJhY2tkcm9wXCIsIGFhID0gYG1vdXNlZG93bi50ZS4ke1FjfWA7XG5jbGFzcyBDciB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcodCksIHRoaXMuX2lzQXBwZW5kZWQgPSAhMSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgc2hvdyh0KSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XG4gICAgICBnZSh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYXBwZW5kKCksIHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkICYmIHNpKHRoaXMuX2dldEVsZW1lbnQoKSk7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NvbmZpZy5iYWNrZHJvcENsYXNzZXMgfHwgW1xuICAgICAgXCJvcGFjaXR5LTUwXCIsXG4gICAgICBcInRyYW5zaXRpb24tYWxsXCIsXG4gICAgICBcImR1cmF0aW9uLTMwMFwiLFxuICAgICAgXCJlYXNlLWluLW91dFwiLFxuICAgICAgXCJmaXhlZFwiLFxuICAgICAgXCJ0b3AtMFwiLFxuICAgICAgXCJsZWZ0LTBcIixcbiAgICAgIFwiei1bMTA0MF1cIixcbiAgICAgIFwiYmctYmxhY2tcIixcbiAgICAgIFwidy1zY3JlZW5cIixcbiAgICAgIFwiaC1zY3JlZW5cIlxuICAgIF07XG4gICAgaC5yZW1vdmVDbGFzcyh0aGlzLl9nZXRFbGVtZW50KCksIFwib3BhY2l0eS0wXCIpLCBoLmFkZENsYXNzKHRoaXMuX2dldEVsZW1lbnQoKSwgZSksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1iYWNrZHJvcC1zaG93XCIsIFwiXCIpLCB0aGlzLl9lbXVsYXRlQW5pbWF0aW9uKCgpID0+IHtcbiAgICAgIGdlKHQpO1xuICAgIH0pO1xuICB9XG4gIGhpZGUodCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xuICAgICAgZ2UodCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1iYWNrZHJvcC1zaG93XCIpLCB0aGlzLl9nZXRFbGVtZW50KCkuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMFwiKSwgdGhpcy5fZ2V0RWxlbWVudCgpLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTUwXCIpLCB0aGlzLl9lbXVsYXRlQW5pbWF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpLCBnZSh0KTtcbiAgICB9KTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRFbGVtZW50KCkge1xuICAgIGlmICghdGhpcy5fZWxlbWVudCkge1xuICAgICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0LmNsYXNzTmFtZSA9IHRoaXMuX2NvbmZpZy5jbGFzc05hbWUsIHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkICYmIHQuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktNTBcIiksIHRoaXMuX2VsZW1lbnQgPSB0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnRwLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIHQucm9vdEVsZW1lbnQgPSBlZSh0LnJvb3RFbGVtZW50KSwgSShRYywgdCwgZXApLCB0O1xuICB9XG4gIF9hcHBlbmQoKSB7XG4gICAgdGhpcy5faXNBcHBlbmRlZCB8fCAodGhpcy5fY29uZmlnLnJvb3RFbGVtZW50LmFwcGVuZCh0aGlzLl9nZXRFbGVtZW50KCkpLCBjLm9uKHRoaXMuX2dldEVsZW1lbnQoKSwgYWEsICgpID0+IHtcbiAgICAgIGdlKHRoaXMuX2NvbmZpZy5jbGlja0NhbGxiYWNrKTtcbiAgICB9KSwgdGhpcy5faXNBcHBlbmRlZCA9ICEwKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2lzQXBwZW5kZWQgJiYgKGMub2ZmKHRoaXMuX2VsZW1lbnQsIGFhKSwgdGhpcy5fZWxlbWVudC5yZW1vdmUoKSwgdGhpcy5faXNBcHBlbmRlZCA9ICExKTtcbiAgfVxuICBfZW11bGF0ZUFuaW1hdGlvbih0KSB7XG4gICAgYmMoXG4gICAgICB0LFxuICAgICAgdGhpcy5fZ2V0RWxlbWVudCgpLFxuICAgICAgdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWRcbiAgICApO1xuICB9XG59XG5jbGFzcyB6aSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl90b2dnbGVyID0gaSwgdGhpcy5fZXZlbnQgPSBlLmV2ZW50IHx8IFwiYmx1clwiLCB0aGlzLl9jb25kaXRpb24gPSBlLmNvbmRpdGlvbiB8fCAoKCkgPT4gITApLCB0aGlzLl9zZWxlY3RvciA9IGUuc2VsZWN0b3IgfHwgJ2J1dHRvbiwgYSwgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIFt0YWJpbmRleF06bm90KFt0YWJpbmRleD1cIi0xXCJdKScsIHRoaXMuX29ubHlWaXNpYmxlID0gZS5vbmx5VmlzaWJsZSB8fCAhMSwgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMgPSBbXSwgdGhpcy5fZmlyc3RFbGVtZW50ID0gbnVsbCwgdGhpcy5fbGFzdEVsZW1lbnQgPSBudWxsLCB0aGlzLmhhbmRsZXIgPSAobikgPT4ge1xuICAgICAgdGhpcy5fY29uZGl0aW9uKG4pICYmICFuLnNoaWZ0S2V5ICYmIG4udGFyZ2V0ID09PSB0aGlzLl9sYXN0RWxlbWVudCA/IChuLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2ZpcnN0RWxlbWVudC5mb2N1cygpKSA6IHRoaXMuX2NvbmRpdGlvbihuKSAmJiBuLnNoaWZ0S2V5ICYmIG4udGFyZ2V0ID09PSB0aGlzLl9maXJzdEVsZW1lbnQgJiYgKG4ucHJldmVudERlZmF1bHQoKSwgdGhpcy5fbGFzdEVsZW1lbnQuZm9jdXMoKSk7XG4gICAgfTtcbiAgfVxuICB0cmFwKCkge1xuICAgIHRoaXMuX3NldEVsZW1lbnRzKCksIHRoaXMuX2luaXQoKSwgdGhpcy5fc2V0Rm9jdXNUcmFwKCk7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fZXZlbnQsIHRoaXMuaGFuZGxlcik7XG4gICAgfSksIHRoaXMuX3RvZ2dsZXIgJiYgdGhpcy5fdG9nZ2xlci5mb2N1cygpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9zZXRFbGVtZW50cygpLCB0aGlzLl9zZXRGb2N1c1RyYXAoKTtcbiAgfVxuICBfaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gKGUpID0+IHtcbiAgICAgICF0aGlzLl9maXJzdEVsZW1lbnQgfHwgZS5rZXkgIT09IFwiVGFiXCIgfHwgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMuaW5jbHVkZXMoZS50YXJnZXQpIHx8IChlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2ZpcnN0RWxlbWVudC5mb2N1cygpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdCkpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHQpO1xuICB9XG4gIF9maWx0ZXJWaXNpYmxlKHQpIHtcbiAgICByZXR1cm4gdC5maWx0ZXIoKGUpID0+IHtcbiAgICAgIGlmICghTXQoZSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGkgPSBkLnBhcmVudHMoZSwgXCIqXCIpO1xuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBpLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGNvbnN0IG8gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpW25dKTtcbiAgICAgICAgaWYgKG8gJiYgKG8uZGlzcGxheSA9PT0gXCJub25lXCIgfHwgby52aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfSk7XG4gIH1cbiAgX3NldEVsZW1lbnRzKCkge1xuICAgIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzID0gZC5mb2N1c2FibGVDaGlsZHJlbih0aGlzLl9lbGVtZW50KSwgdGhpcy5fb25seVZpc2libGUgJiYgKHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzID0gdGhpcy5fZmlsdGVyVmlzaWJsZSh0aGlzLl9mb2N1c2FibGVFbGVtZW50cykpLCB0aGlzLl9maXJzdEVsZW1lbnQgPSB0aGlzLl9mb2N1c2FibGVFbGVtZW50c1swXSwgdGhpcy5fbGFzdEVsZW1lbnQgPSB0aGlzLl9mb2N1c2FibGVFbGVtZW50c1t0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgfVxuICBfc2V0Rm9jdXNUcmFwKCkge1xuICAgIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzLmZvckVhY2goKHQsIGUpID0+IHtcbiAgICAgIGUgPT09IHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDEgfHwgZSA9PT0gMCA/IHQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9ldmVudCwgdGhpcy5oYW5kbGVyKSA6IHQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9ldmVudCwgdGhpcy5oYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxufVxubGV0IGxhID0gW107XG5jb25zdCB2biA9IChzLCB0ID0gXCJoaWRlXCIpID0+IHtcbiAgY29uc3QgZSA9IGBjbGljay5kaXNtaXNzJHtzLkVWRU5UX0tFWX1gLCBpID0gcy5OQU1FO1xuICBsYS5pbmNsdWRlcyhpKSB8fCAobGEucHVzaChpKSwgYy5vbihcbiAgICBkb2N1bWVudCxcbiAgICBlLFxuICAgIGBbZGF0YS10ZS0ke2l9LWRpc21pc3NdYCxcbiAgICBmdW5jdGlvbihuKSB7XG4gICAgICBpZiAoW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBuLnByZXZlbnREZWZhdWx0KCksIGJlKHRoaXMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBvID0gdGUodGhpcykgfHwgdGhpcy5jbG9zZXN0KGAuJHtpfWApIHx8IHRoaXMuY2xvc2VzdChgW2RhdGEtdGUtJHtpfS1pbml0XWApO1xuICAgICAgaWYgKCFvKVxuICAgICAgICByZXR1cm47XG4gICAgICBzLmdldE9yQ3JlYXRlSW5zdGFuY2UobylbdF0oKTtcbiAgICB9XG4gICkpO1xufSwgY2EgPSBcIm9mZmNhbnZhc1wiLCBpcCA9IFwidGUub2ZmY2FudmFzXCIsIG9pID0gYC4ke2lwfWAsIHNwID0gXCIuZGF0YS1hcGlcIiwgbnAgPSBgbG9hZCR7b2l9JHtzcH1gLCBvcCA9IFwiRXNjYXBlXCIsIGhhID0ge1xuICBiYWNrZHJvcDogITAsXG4gIGtleWJvYXJkOiAhMCxcbiAgc2Nyb2xsOiAhMVxufSwgcnAgPSB7XG4gIGJhY2tkcm9wOiBcImJvb2xlYW5cIixcbiAga2V5Ym9hcmQ6IFwiYm9vbGVhblwiLFxuICBzY3JvbGw6IFwiYm9vbGVhblwiXG59LCBkYSA9IFwic2hvd1wiLCBhcCA9IFwiW2RhdGEtdGUtb2ZmY2FudmFzLWluaXRdW2RhdGEtdGUtb2ZmY2FudmFzLXNob3ddXCIsIGxwID0gYHNob3cke29pfWAsIGNwID0gYHNob3duJHtvaX1gLCBocCA9IGBoaWRlJHtvaX1gLCBkcCA9IGBoaWRkZW4ke29pfWAsIHVwID0gYGtleWRvd24uZGlzbWlzcyR7b2l9YDtcbmNsYXNzIGpzIGV4dGVuZHMgZnQge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpLCB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCksIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBjYTtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIGhhO1xuICB9XG4gIC8vIFB1YmxpY1xuICB0b2dnbGUodCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3codCk7XG4gIH1cbiAgc2hvdyh0KSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGxwLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9pc1Nob3duID0gITAsIHRoaXMuX2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiLCB0aGlzLl9iYWNrZHJvcC5zaG93KCksIHRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgbmV3IHRpKCkuaGlkZSgpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiwgITApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJkaWFsb2dcIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGBkYXRhLXRlLW9mZmNhbnZhcy0ke2RhfWAsIFwiXCIpO1xuICAgIGNvbnN0IGkgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25maWcuc2Nyb2xsIHx8IHRoaXMuX2ZvY3VzdHJhcC50cmFwKCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBjcCwgeyByZWxhdGVkVGFyZ2V0OiB0IH0pO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhpLCB0aGlzLl9lbGVtZW50LCAhMCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGhwKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIHRoaXMuX2VsZW1lbnQuYmx1cigpLCB0aGlzLl9pc1Nob3duID0gITEsIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGBkYXRhLXRlLW9mZmNhbnZhcy0ke2RhfWApLCB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG4gICAgY29uc3QgZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgITApLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicm9sZVwiKSwgdGhpcy5fZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIiwgdGhpcy5fY29uZmlnLnNjcm9sbCB8fCBuZXcgdGkoKS5yZXNldCgpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZHApO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhlLCB0aGlzLl9lbGVtZW50LCAhMCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCksIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKGMub24oXG4gICAgICB3aW5kb3csXG4gICAgICBucCxcbiAgICAgICgpID0+IGQuZmluZChhcCkuZm9yRWFjaChcbiAgICAgICAgKHQpID0+IGpzLmdldE9yQ3JlYXRlSW5zdGFuY2UodCkuc2hvdygpXG4gICAgICApXG4gICAgKSwgdGhpcy5fZGlkSW5pdCA9ICEwLCB2bihqcykpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uaGEsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIEkoY2EsIHQsIHJwKSwgdDtcbiAgfVxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIHJldHVybiBuZXcgQ3Ioe1xuICAgICAgaXNWaXNpYmxlOiB0aGlzLl9jb25maWcuYmFja2Ryb3AsXG4gICAgICBpc0FuaW1hdGVkOiAhMCxcbiAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICBjbGlja0NhbGxiYWNrOiAoKSA9PiB0aGlzLmhpZGUoKVxuICAgIH0pO1xuICB9XG4gIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xuICAgIHJldHVybiBuZXcgemkodGhpcy5fZWxlbWVudCwge1xuICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgY29uZGl0aW9uOiAodCkgPT4gdC5rZXkgPT09IFwiVGFiXCJcbiAgICB9KTtcbiAgfVxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCB1cCwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiB0LmtleSA9PT0gb3AgJiYgdGhpcy5oaWRlKCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0ganMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChlW3RdID09PSB2b2lkIDAgfHwgdC5zdGFydHNXaXRoKFwiX1wiKSB8fCB0ID09PSBcImNvbnN0cnVjdG9yXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFZuID0gXCJhbGVydFwiLCBwcCA9IFwidGUuYWxlcnRcIiwgSmMgPSBgLiR7cHB9YCwgX3AgPSBgY2xvc2Uke0pjfWAsIGZwID0gYGNsb3NlZCR7SmN9YCwgdWkgPSBcImRhdGEtdGUtYWxlcnQtc2hvd1wiLCBtcCA9IHtcbiAgYW5pbWF0aW9uOiBcImJvb2xlYW5cIixcbiAgYXV0b2hpZGU6IFwiYm9vbGVhblwiLFxuICBhdXRvY2xvc2U6IFwiYm9vbGVhblwiLFxuICBkZWxheTogXCJudW1iZXJcIlxufSwgdWEgPSB7XG4gIGFuaW1hdGlvbjogITAsXG4gIGF1dG9oaWRlOiAhMCxcbiAgYXV0b2Nsb3NlOiAhMSxcbiAgZGVsYXk6IDFlM1xufSwgZ3AgPSB7XG4gIGZhZGVJbjogXCJhbmltYXRlLVtmYWRlLWluXzAuM3NfYm90aF0gcC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIixcbiAgZmFkZU91dDogXCJhbmltYXRlLVtmYWRlLW91dF8wLjNzX2JvdGhdIHAtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCJcbn0sIGJwID0ge1xuICBmYWRlSW46IFwic3RyaW5nXCIsXG4gIGZhZGVPdXQ6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBLbyBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBtcDtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHVhO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gVm47XG4gIH1cbiAgLy8gUHVibGljXG4gIGNsb3NlKCkge1xuICAgIGlmIChjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgX3ApLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGUgPSAwO1xuICAgIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgKGUgPSAzMDAsIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHVpKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKFxuICAgICAgICAoKSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudCgpLFxuICAgICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgICB0aGlzLl9jb25maWcuYW5pbWF0aW9uXG4gICAgICApO1xuICAgIH0sIGUpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuYXV0b2hpZGUgJiYgdGhpcy5fc2V0dXBBdXRvaGlkZSgpLCAodGhpcy5fY29uZmlnLmF1dG9jbG9zZSB8fCB0aGlzLl9jb25maWcuYXV0b2Nsb3NlICYmIHRoaXMuX2NvbmZpZy5hdXRvaGlkZSkgJiYgdGhpcy5fc2V0dXBBdXRvY2xvc2UoKSwgIXRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKHVpKSAmJiAoaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBcImhpZGRlblwiKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcImJsb2NrXCIpLCBNdCh0aGlzLl9lbGVtZW50KSkpIHtcbiAgICAgICAgY29uc3QgdCA9IChlKSA9PiB7XG4gICAgICAgICAgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBcImhpZGRlblwiKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcImJsb2NrXCIpLCBjLm9mZihlLnRhcmdldCwgXCJhbmltYXRpb25lbmRcIiwgdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKHVpLCBcIlwiKSwgYy5vbih0aGlzLl9lbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCB0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgKGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVJbikpO1xuICAgIH1cbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50ICYmIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKHVpKSkge1xuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodWkpO1xuICAgICAgY29uc3QgdCA9IChlKSA9PiB7XG4gICAgICAgIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJoaWRkZW5cIiksIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJibG9ja1wiKSwgdGhpcy5fdGltZW91dCAhPT0gbnVsbCAmJiAoY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpLCB0aGlzLl90aW1lb3V0ID0gbnVsbCksIGMub2ZmKGUudGFyZ2V0LCBcImFuaW1hdGlvbmVuZFwiLCB0KTtcbiAgICAgIH07XG4gICAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsIHQpLCBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZUluKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVPdXQpO1xuICAgIH1cbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKHZuKEtvLCBcImNsb3NlXCIpLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4udWEsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgSShWbiwgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5ncCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgSShWbiwgdCwgYnApLCB0O1xuICB9XG4gIF9zZXR1cEF1dG9oaWRlKCkge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheSk7XG4gIH1cbiAgX3NldHVwQXV0b2Nsb3NlKCkge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkpO1xuICB9XG4gIF9kZXN0cm95RWxlbWVudCgpIHtcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZSgpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZnApLCB0aGlzLmRpc3Bvc2UoKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBLby5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGVbdF0gPT09IHZvaWQgMCB8fCB0LnN0YXJ0c1dpdGgoXCJfXCIpIHx8IHQgPT09IFwiY29uc3RydWN0b3JcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgV24gPSBcImNhcm91c2VsXCIsIHZwID0gXCJ0ZS5jYXJvdXNlbFwiLCBtdCA9IGAuJHt2cH1gLCB0aCA9IFwiLmRhdGEtYXBpXCIsIFRwID0gXCJBcnJvd0xlZnRcIiwgRXAgPSBcIkFycm93UmlnaHRcIiwgQ3AgPSA1MDAsIEFwID0gNDAsIHBhID0ge1xuICBpbnRlcnZhbDogNWUzLFxuICBrZXlib2FyZDogITAsXG4gIHJpZGU6ICExLFxuICBwYXVzZTogXCJob3ZlclwiLFxuICB3cmFwOiAhMCxcbiAgdG91Y2g6ICEwXG59LCB5cCA9IHtcbiAgaW50ZXJ2YWw6IFwiKG51bWJlcnxib29sZWFuKVwiLFxuICBrZXlib2FyZDogXCJib29sZWFuXCIsXG4gIHJpZGU6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBwYXVzZTogXCIoc3RyaW5nfGJvb2xlYW4pXCIsXG4gIHdyYXA6IFwiYm9vbGVhblwiLFxuICB0b3VjaDogXCJib29sZWFuXCJcbn0sIHdwID0ge1xuICBwb2ludGVyOiBcInRvdWNoLXBhbi15XCIsXG4gIGJsb2NrOiBcIiFibG9ja1wiLFxuICB2aXNpYmxlOiBcImRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOm9wYWNpdHktMTAwIGRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOnotWzFdXCIsXG4gIGludmlzaWJsZTogXCJkYXRhLVt0ZS1jYXJvdXNlbC1mYWRlXTp6LTAgZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06b3BhY2l0eS0wIGRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOmR1cmF0aW9uLVs2MDBtc10gZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06ZGVsYXktNjAwXCIsXG4gIHNsaWRlUmlnaHQ6IFwidHJhbnNsYXRlLXgtZnVsbFwiLFxuICBzbGlkZUxlZnQ6IFwiLXRyYW5zbGF0ZS14LWZ1bGxcIlxufSwga3AgPSB7XG4gIHBvaW50ZXI6IFwic3RyaW5nXCIsXG4gIGJsb2NrOiBcInN0cmluZ1wiLFxuICB2aXNpYmxlOiBcInN0cmluZ1wiLFxuICBpbnZpc2libGU6IFwic3RyaW5nXCIsXG4gIHNsaWRlUmlnaHQ6IFwic3RyaW5nXCIsXG4gIHNsaWRlTGVmdDogXCJzdHJpbmdcIlxufSwgY2UgPSBcIm5leHRcIiwgaGUgPSBcInByZXZcIiwgZmUgPSBcImxlZnRcIiwgRWkgPSBcInJpZ2h0XCIsIHhwID0ge1xuICBbVHBdOiBFaSxcbiAgW0VwXTogZmVcbn0sIE9wID0gYHNsaWRlJHttdH1gLCBGbiA9IGBzbGlkJHttdH1gLCBTcCA9IGBrZXlkb3duJHttdH1gLCBJcCA9IGBtb3VzZWVudGVyJHttdH1gLCBEcCA9IGBtb3VzZWxlYXZlJHttdH1gLCAkcCA9IGB0b3VjaHN0YXJ0JHttdH1gLCBMcCA9IGB0b3VjaG1vdmUke210fWAsIE5wID0gYHRvdWNoZW5kJHttdH1gLCBNcCA9IGBwb2ludGVyZG93biR7bXR9YCwgUnAgPSBgcG9pbnRlcnVwJHttdH1gLCBQcCA9IGBkcmFnc3RhcnQke210fWAsIEJwID0gYGxvYWQke210fSR7dGh9YCwgSHAgPSBgY2xpY2ske210fSR7dGh9YCwgX2EgPSBcImRhdGEtdGUtY2Fyb3VzZWwtaW5pdFwiLCBkZSA9IFwiZGF0YS10ZS1jYXJvdXNlbC1hY3RpdmVcIiwgVnAgPSBcImRhdGEtdGUtY2Fyb3VzZWwtaXRlbS1lbmRcIiwgWW4gPSBcImRhdGEtdGUtY2Fyb3VzZWwtaXRlbS1zdGFydFwiLCBXcCA9IFwiZGF0YS10ZS1jYXJvdXNlbC1pdGVtLW5leHRcIiwgRnAgPSBcImRhdGEtdGUtY2Fyb3VzZWwtaXRlbS1wcmV2XCIsIFlwID0gXCJkYXRhLXRlLWNhcm91c2VsLXBvaW50ZXItZXZlbnRcIiwganAgPSBcIltkYXRhLXRlLWNhcm91c2VsLWluaXRdXCIsIGVoID0gXCJbZGF0YS10ZS1jYXJvdXNlbC1hY3RpdmVdXCIsIEFyID0gXCJbZGF0YS10ZS1jYXJvdXNlbC1pdGVtXVwiLCBTZSA9IGAke2VofSR7QXJ9YCwgS3AgPSBgJHtBcn0gaW1nYCwgenAgPSBcIltkYXRhLXRlLWNhcm91c2VsLWl0ZW0tbmV4dF0sIFtkYXRhLXRlLWNhcm91c2VsLWl0ZW0tcHJldl1cIiwgVXAgPSBcIltkYXRhLXRlLWNhcm91c2VsLWluZGljYXRvcnNdXCIsIFhwID0gXCJbZGF0YS10ZS10YXJnZXRdXCIsIEdwID0gXCJbZGF0YS10ZS1zbGlkZV0sIFtkYXRhLXRlLXNsaWRlLXRvXVwiLCBxcCA9IFwidG91Y2hcIiwgWnAgPSBcInBlblwiO1xuY2xhc3MgWHQgZXh0ZW5kcyBmdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5faXRlbXMgPSBudWxsLCB0aGlzLl9pbnRlcnZhbCA9IG51bGwsIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsLCB0aGlzLl9pc1BhdXNlZCA9ICExLCB0aGlzLl9pc1NsaWRpbmcgPSAhMSwgdGhpcy50b3VjaFRpbWVvdXQgPSBudWxsLCB0aGlzLnRvdWNoU3RhcnRYID0gMCwgdGhpcy50b3VjaERlbHRhWCA9IDAsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gZC5maW5kT25lKFxuICAgICAgVXAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fdG91Y2hTdXBwb3J0ZWQgPSBcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwLCB0aGlzLl9wb2ludGVyRXZlbnQgPSAhIXdpbmRvdy5Qb2ludGVyRXZlbnQsIHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRDbGFzcygpLCB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKSwgdGhpcy5fY29uZmlnLnJpZGUgPT09IFwiY2Fyb3VzZWxcIiAmJiB0aGlzLmN5Y2xlKCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHBhO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gV247XG4gIH1cbiAgLy8gUHVibGljXG4gIG5leHQoKSB7XG4gICAgdGhpcy5fc2xpZGUoY2UpO1xuICB9XG4gIG5leHRXaGVuVmlzaWJsZSgpIHtcbiAgICAhZG9jdW1lbnQuaGlkZGVuICYmIE10KHRoaXMuX2VsZW1lbnQpICYmIHRoaXMubmV4dCgpO1xuICB9XG4gIHByZXYoKSB7XG4gICAgdGhpcy5fc2xpZGUoaGUpO1xuICB9XG4gIHBhdXNlKHQpIHtcbiAgICB0IHx8ICh0aGlzLl9pc1BhdXNlZCA9ICEwKSwgZC5maW5kT25lKHpwLCB0aGlzLl9lbGVtZW50KSAmJiAoX2ModGhpcy5fZWxlbWVudCksIHRoaXMuY3ljbGUoITApKSwgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCksIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgfVxuICBjeWNsZSh0KSB7XG4gICAgdCB8fCAodGhpcy5faXNQYXVzZWQgPSAhMSksIHRoaXMuX2ludGVydmFsICYmIChjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSwgdGhpcy5faW50ZXJ2YWwgPSBudWxsKSwgdGhpcy5fY29uZmlnICYmIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCAmJiAhdGhpcy5faXNQYXVzZWQgJiYgKHRoaXMuX3VwZGF0ZUludGVydmFsKCksIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoXG4gICAgICAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID8gdGhpcy5uZXh0V2hlblZpc2libGUgOiB0aGlzLm5leHQpLmJpbmQoXG4gICAgICAgIHRoaXNcbiAgICAgICksXG4gICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICApKTtcbiAgfVxuICB0byh0KSB7XG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IGQuZmluZE9uZShcbiAgICAgIFNlLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9hY3RpdmVFbGVtZW50KTtcbiAgICBpZiAodCA+IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgfHwgdCA8IDApXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgYy5vbmUodGhpcy5fZWxlbWVudCwgRm4sICgpID0+IHRoaXMudG8odCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZSA9PT0gdCkge1xuICAgICAgdGhpcy5wYXVzZSgpLCB0aGlzLmN5Y2xlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0ID4gZSA/IGNlIDogaGU7XG4gICAgdGhpcy5fc2xpZGUoaSwgdGhpcy5faXRlbXNbdF0pO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAoYy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgSHAsXG4gICAgICBHcCxcbiAgICAgIFh0LmRhdGFBcGlDbGlja0hhbmRsZXJcbiAgICApLCBjLm9uKHdpbmRvdywgQnAsICgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBkLmZpbmQoanApO1xuICAgICAgZm9yIChsZXQgZSA9IDAsIGkgPSB0Lmxlbmd0aDsgZSA8IGk7IGUrKylcbiAgICAgICAgWHQuY2Fyb3VzZWxJbnRlcmZhY2UoXG4gICAgICAgICAgdFtlXSxcbiAgICAgICAgICBYdC5nZXRJbnN0YW5jZSh0W2VdKVxuICAgICAgICApO1xuICAgIH0pLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ucGEsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIEkoV24sIHQsIHlwKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLndwLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKFduLCB0LCBrcCksIHQ7XG4gIH1cbiAgX2VuYWJsZUN5Y2xlKCkge1xuICAgIGlmICh0aGlzLl9jb25maWcucmlkZSkge1xuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgICBjLm9uZSh0aGlzLl9lbGVtZW50LCBGbiwgKCkgPT4gdGhpcy5jeWNsZSgpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jeWNsZSgpO1xuICAgIH1cbiAgfVxuICBfYXBwbHlJbml0aWFsQ2xhc3NlcygpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgU2UsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICB0LmNsYXNzTGlzdC5hZGQoXG4gICAgICB0aGlzLl9jbGFzc2VzLmJsb2NrLFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy52aXNpYmxlLnNwbGl0KFwiIFwiKVxuICAgICksIHRoaXMuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQodCk7XG4gIH1cbiAgX2hhbmRsZVN3aXBlKCkge1xuICAgIGNvbnN0IHQgPSBNYXRoLmFicyh0aGlzLnRvdWNoRGVsdGFYKTtcbiAgICBpZiAodCA8PSBBcClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdCAvIHRoaXMudG91Y2hEZWx0YVg7XG4gICAgdGhpcy50b3VjaERlbHRhWCA9IDAsIGUgJiYgdGhpcy5fc2xpZGUoZSA+IDAgPyBFaSA6IGZlKTtcbiAgfVxuICBfc2V0QWN0aXZlRWxlbWVudENsYXNzKCkge1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBkLmZpbmRPbmUoXG4gICAgICBTZSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBoLmFkZENsYXNzKHRoaXMuX2FjdGl2ZUVsZW1lbnQsIFwiaGlkZGVuXCIpO1xuICB9XG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBTcCxcbiAgICAgICh0KSA9PiB0aGlzLl9rZXlkb3duKHQpXG4gICAgKSwgdGhpcy5fY29uZmlnLnBhdXNlID09PSBcImhvdmVyXCIgJiYgKGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgSXAsXG4gICAgICAodCkgPT4gdGhpcy5wYXVzZSh0KVxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgRHAsXG4gICAgICAodCkgPT4gdGhpcy5fZW5hYmxlQ3ljbGUodClcbiAgICApKSwgdGhpcy5fY29uZmlnLnRvdWNoICYmIHRoaXMuX3RvdWNoU3VwcG9ydGVkICYmIHRoaXMuX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5fYXBwbHlJbml0aWFsQ2xhc3NlcygpO1xuICB9XG4gIF9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHQgPSAobykgPT4gdGhpcy5fcG9pbnRlckV2ZW50ICYmIChvLnBvaW50ZXJUeXBlID09PSBacCB8fCBvLnBvaW50ZXJUeXBlID09PSBxcCksIGUgPSAobykgPT4ge1xuICAgICAgdChvKSA/IHRoaXMudG91Y2hTdGFydFggPSBvLmNsaWVudFggOiB0aGlzLl9wb2ludGVyRXZlbnQgfHwgKHRoaXMudG91Y2hTdGFydFggPSBvLnRvdWNoZXNbMF0uY2xpZW50WCk7XG4gICAgfSwgaSA9IChvKSA9PiB7XG4gICAgICB0aGlzLnRvdWNoRGVsdGFYID0gby50b3VjaGVzICYmIG8udG91Y2hlcy5sZW5ndGggPiAxID8gMCA6IG8udG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy50b3VjaFN0YXJ0WDtcbiAgICB9LCBuID0gKG8pID0+IHtcbiAgICAgIHQobykgJiYgKHRoaXMudG91Y2hEZWx0YVggPSBvLmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYKSwgdGhpcy5faGFuZGxlU3dpcGUoKSwgdGhpcy5fY29uZmlnLnBhdXNlID09PSBcImhvdmVyXCIgJiYgKHRoaXMucGF1c2UoKSwgdGhpcy50b3VjaFRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMudG91Y2hUaW1lb3V0KSwgdGhpcy50b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAocikgPT4gdGhpcy5fZW5hYmxlQ3ljbGUociksXG4gICAgICAgIENwICsgdGhpcy5fY29uZmlnLmludGVydmFsXG4gICAgICApKTtcbiAgICB9O1xuICAgIGQuZmluZChLcCwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChcbiAgICAgIChvKSA9PiB7XG4gICAgICAgIGMub24oXG4gICAgICAgICAgbyxcbiAgICAgICAgICBQcCxcbiAgICAgICAgICAocikgPT4gci5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKSwgdGhpcy5fcG9pbnRlckV2ZW50ID8gKGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgTXAsXG4gICAgICAobykgPT4gZShvKVxuICAgICksIGMub24odGhpcy5fZWxlbWVudCwgUnAsIChvKSA9PiBuKG8pKSwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuX2NsYXNzZXMucG9pbnRlciksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGAke1lwfWAsIFwiXCIpKSA6IChjLm9uKHRoaXMuX2VsZW1lbnQsICRwLCAobykgPT4gZShvKSksIGMub24odGhpcy5fZWxlbWVudCwgTHAsIChvKSA9PiBpKG8pKSwgYy5vbih0aGlzLl9lbGVtZW50LCBOcCwgKG8pID0+IG4obykpKTtcbiAgfVxuICBfa2V5ZG93bih0KSB7XG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHhwW3Qua2V5XTtcbiAgICBlICYmICh0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX3NsaWRlKGUpKTtcbiAgfVxuICBfZ2V0SXRlbUluZGV4KHQpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMgPSB0ICYmIHQucGFyZW50Tm9kZSA/IGQuZmluZChBciwgdC5wYXJlbnROb2RlKSA6IFtdLCB0aGlzLl9pdGVtcy5pbmRleE9mKHQpO1xuICB9XG4gIF9nZXRJdGVtQnlPcmRlcih0LCBlKSB7XG4gICAgY29uc3QgaSA9IHQgPT09IGNlO1xuICAgIHJldHVybiB2YyhcbiAgICAgIHRoaXMuX2l0ZW1zLFxuICAgICAgZSxcbiAgICAgIGksXG4gICAgICB0aGlzLl9jb25maWcud3JhcFxuICAgICk7XG4gIH1cbiAgX3RyaWdnZXJTbGlkZUV2ZW50KHQsIGUpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fZ2V0SXRlbUluZGV4KHQpLCBuID0gdGhpcy5fZ2V0SXRlbUluZGV4KFxuICAgICAgZC5maW5kT25lKFNlLCB0aGlzLl9lbGVtZW50KVxuICAgICk7XG4gICAgcmV0dXJuIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBPcCwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdCxcbiAgICAgIGRpcmVjdGlvbjogZSxcbiAgICAgIGZyb206IG4sXG4gICAgICB0bzogaVxuICAgIH0pO1xuICB9XG4gIF9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KHQpIHtcbiAgICBpZiAodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoXG4gICAgICAgIGVoLFxuICAgICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudFxuICAgICAgKTtcbiAgICAgIGUucmVtb3ZlQXR0cmlidXRlKGRlKSwgZS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIiksIGUuY2xhc3NMaXN0LnJlbW92ZShcIiFvcGFjaXR5LTEwMFwiKTtcbiAgICAgIGNvbnN0IGkgPSBkLmZpbmQoXG4gICAgICAgIFhwLFxuICAgICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudFxuICAgICAgKTtcbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgaS5sZW5ndGg7IG4rKylcbiAgICAgICAgaWYgKE51bWJlci5wYXJzZUludChcbiAgICAgICAgICBpW25dLmdldEF0dHJpYnV0ZShcImRhdGEtdGUtc2xpZGUtdG9cIiksXG4gICAgICAgICAgMTBcbiAgICAgICAgKSA9PT0gdGhpcy5fZ2V0SXRlbUluZGV4KHQpKSB7XG4gICAgICAgICAgaVtuXS5zZXRBdHRyaWJ1dGUoYCR7ZGV9YCwgXCJcIiksIGlbbl0uc2V0QXR0cmlidXRlKFwiYXJpYS1jdXJyZW50XCIsIFwidHJ1ZVwiKSwgaVtuXS5jbGFzc0xpc3QuYWRkKFwiIW9wYWNpdHktMTAwXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIF91cGRhdGVJbnRlcnZhbCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fYWN0aXZlRWxlbWVudCB8fCBkLmZpbmRPbmUoU2UsIHRoaXMuX2VsZW1lbnQpO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gTnVtYmVyLnBhcnNlSW50KFxuICAgICAgdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLWludGVydmFsXCIpLFxuICAgICAgMTBcbiAgICApO1xuICAgIGUgPyAodGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmludGVydmFsLCB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSBlKSA6IHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmludGVydmFsO1xuICB9XG4gIF9zbGlkZSh0LCBlKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2RpcmVjdGlvblRvT3JkZXIodCksIG4gPSBkLmZpbmRPbmUoXG4gICAgICBTZSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBvID0gdGhpcy5fZ2V0SXRlbUluZGV4KG4pLCByID0gZSB8fCB0aGlzLl9nZXRJdGVtQnlPcmRlcihpLCBuKSwgYSA9IHRoaXMuX2dldEl0ZW1JbmRleChyKSwgbCA9ICEhdGhpcy5faW50ZXJ2YWwsIHAgPSBpID09PSBjZSwgdSA9IHAgPyBZbiA6IFZwLCBfID0gcCA/IFdwIDogRnAsIGYgPSB0aGlzLl9vcmRlclRvRGlyZWN0aW9uKGkpLCBnID0gdSA9PT0gWW4gPyB0aGlzLl9jbGFzc2VzLnNsaWRlTGVmdCA6IHRoaXMuX2NsYXNzZXMuc2xpZGVSaWdodCwgbSA9IHUgIT09IFluID8gdGhpcy5fY2xhc3Nlcy5zbGlkZUxlZnQgOiB0aGlzLl9jbGFzc2VzLnNsaWRlUmlnaHQ7XG4gICAgaWYgKHIgJiYgci5oYXNBdHRyaWJ1dGUoZGUpKSB7XG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSAhMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZyB8fCB0aGlzLl90cmlnZ2VyU2xpZGVFdmVudChyLCBmKS5kZWZhdWx0UHJldmVudGVkIHx8ICFuIHx8ICFyKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2lzU2xpZGluZyA9ICEwLCBsICYmIHRoaXMucGF1c2UoKSwgdGhpcy5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChyKSwgdGhpcy5fYWN0aXZlRWxlbWVudCA9IHI7XG4gICAgY29uc3QgdiA9ICgpID0+IHtcbiAgICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBGbiwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiByLFxuICAgICAgICBkaXJlY3Rpb246IGYsXG4gICAgICAgIGZyb206IG8sXG4gICAgICAgIHRvOiBhXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmICh0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShfYSkpIHtcbiAgICAgIHIuc2V0QXR0cmlidXRlKGAke199YCwgXCJcIiksIHIuY2xhc3NMaXN0LmFkZCh0aGlzLl9jbGFzc2VzLmJsb2NrLCBtKSwgc2kociksIG4uc2V0QXR0cmlidXRlKGAke3V9YCwgXCJcIiksIG4uY2xhc3NMaXN0LmFkZChcbiAgICAgICAgZyxcbiAgICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnZpc2libGUuc3BsaXQoXCIgXCIpXG4gICAgICApLCBuLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy52aXNpYmxlLnNwbGl0KFwiIFwiKSksIHIuc2V0QXR0cmlidXRlKGAke3V9YCwgXCJcIiksIHIuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLnZpc2libGUuc3BsaXQoXCIgXCIpKSwgci5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICB0aGlzLl9jbGFzc2VzLnNsaWRlUmlnaHQsXG4gICAgICAgIHRoaXMuX2NsYXNzZXMuc2xpZGVMZWZ0XG4gICAgICApO1xuICAgICAgY29uc3QgVCA9ICgpID0+IHtcbiAgICAgICAgci5yZW1vdmVBdHRyaWJ1dGUodSksIHIucmVtb3ZlQXR0cmlidXRlKF8pLCByLnNldEF0dHJpYnV0ZShgJHtkZX1gLCBcIlwiKSwgbi5yZW1vdmVBdHRyaWJ1dGUoZGUpLCBuLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgICAgZyxcbiAgICAgICAgICAuLi50aGlzLl9jbGFzc2VzLmludmlzaWJsZS5zcGxpdChcIiBcIiksXG4gICAgICAgICAgdGhpcy5fY2xhc3Nlcy5ibG9ja1xuICAgICAgICApLCBuLnJlbW92ZUF0dHJpYnV0ZShfKSwgbi5yZW1vdmVBdHRyaWJ1dGUodSksIHRoaXMuX2lzU2xpZGluZyA9ICExLCBzZXRUaW1lb3V0KHYsIDApO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soVCwgbiwgITApO1xuICAgIH0gZWxzZVxuICAgICAgbi5yZW1vdmVBdHRyaWJ1dGUoZGUpLCBuLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fY2xhc3Nlcy5ibG9jayksIHIuc2V0QXR0cmlidXRlKGAke2RlfWAsIFwiXCIpLCByLmNsYXNzTGlzdC5hZGQodGhpcy5fY2xhc3Nlcy5ibG9jayksIHRoaXMuX2lzU2xpZGluZyA9ICExLCB2KCk7XG4gICAgbCAmJiB0aGlzLmN5Y2xlKCk7XG4gIH1cbiAgX2RpcmVjdGlvblRvT3JkZXIodCkge1xuICAgIHJldHVybiBbRWksIGZlXS5pbmNsdWRlcyh0KSA/IFcoKSA/IHQgPT09IGZlID8gaGUgOiBjZSA6IHQgPT09IGZlID8gY2UgOiBoZSA6IHQ7XG4gIH1cbiAgX29yZGVyVG9EaXJlY3Rpb24odCkge1xuICAgIHJldHVybiBbY2UsIGhlXS5pbmNsdWRlcyh0KSA/IFcoKSA/IHQgPT09IGhlID8gZmUgOiBFaSA6IHQgPT09IGhlID8gRWkgOiBmZSA6IHQ7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBjYXJvdXNlbEludGVyZmFjZSh0LCBlKSB7XG4gICAgY29uc3QgaSA9IFh0LmdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSk7XG4gICAgbGV0IHsgX2NvbmZpZzogbiB9ID0gaTtcbiAgICB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIChuID0ge1xuICAgICAgLi4ubixcbiAgICAgIC4uLmVcbiAgICB9KTtcbiAgICBjb25zdCBvID0gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGUgOiBlLnNsaWRlO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICBpLnRvKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHR5cGVvZiBpW29dID4gXCJ1XCIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7b31cImApO1xuICAgICAgaVtvXSgpO1xuICAgIH0gZWxzZVxuICAgICAgbi5pbnRlcnZhbCAmJiBuLnJpZGUgPT09ICEwICYmIGkucGF1c2UoKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgWHQuY2Fyb3VzZWxJbnRlcmZhY2UodGhpcywgdCk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGRhdGFBcGlDbGlja0hhbmRsZXIodCkge1xuICAgIGNvbnN0IGUgPSB0ZSh0aGlzKTtcbiAgICBpZiAoIWUgfHwgIWUuaGFzQXR0cmlidXRlKF9hKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0ge1xuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyhlKSxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcylcbiAgICB9LCBuID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXNsaWRlLXRvXCIpO1xuICAgIG4gJiYgKGkuaW50ZXJ2YWwgPSAhMSksIFh0LmNhcm91c2VsSW50ZXJmYWNlKGUsIGkpLCBuICYmIFh0LmdldEluc3RhbmNlKGUpLnRvKG4pLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn1cbmNvbnN0IGpuID0gXCJtb2RhbFwiLCBRcCA9IFwidGUubW9kYWxcIiwgeXQgPSBgLiR7UXB9YCwgZmEgPSBcIkVzY2FwZVwiLCBtYSA9IHtcbiAgYmFja2Ryb3A6ICEwLFxuICBrZXlib2FyZDogITAsXG4gIGZvY3VzOiAhMCxcbiAgbW9kYWxOb25JbnZhc2l2ZTogITFcbn0sIEpwID0ge1xuICBiYWNrZHJvcDogXCIoYm9vbGVhbnxzdHJpbmcpXCIsXG4gIGtleWJvYXJkOiBcImJvb2xlYW5cIixcbiAgZm9jdXM6IFwiYm9vbGVhblwiLFxuICBtb2RhbE5vbkludmFzaXZlOiBcImJvb2xlYW5cIlxufSwgdF8gPSB7XG4gIHNob3c6IFwidHJhbnNmb3JtLW5vbmVcIixcbiAgc3RhdGljOiBcInNjYWxlLVsxLjAyXVwiLFxuICBzdGF0aWNQcm9wZXJ0aWVzOiBcInRyYW5zaXRpb24tc2NhbGUgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0XCIsXG4gIGJhY2tkcm9wOiBcIm9wYWNpdHktNTAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0IGZpeGVkIHRvcC0wIGxlZnQtMCB6LVsxMDQwXSBiZy1ibGFjayB3LXNjcmVlbiBoLXNjcmVlblwiXG59LCBlXyA9IHtcbiAgc2hvdzogXCJzdHJpbmdcIixcbiAgc3RhdGljOiBcInN0cmluZ1wiLFxuICBzdGF0aWNQcm9wZXJ0aWVzOiBcInN0cmluZ1wiLFxuICBiYWNrZHJvcDogXCJzdHJpbmdcIlxufSwgaV8gPSBgaGlkZSR7eXR9YCwgc18gPSBgaGlkZVByZXZlbnRlZCR7eXR9YCwgbl8gPSBgaGlkZGVuJHt5dH1gLCBvXyA9IGBzaG93JHt5dH1gLCByXyA9IGBzaG93biR7eXR9YCwgZ2EgPSBgcmVzaXplJHt5dH1gLCBiYSA9IGBjbGljay5kaXNtaXNzJHt5dH1gLCB2YSA9IGBrZXlkb3duLmRpc21pc3Mke3l0fWAsIGFfID0gYG1vdXNldXAuZGlzbWlzcyR7eXR9YCwgVGEgPSBgbW91c2Vkb3duLmRpc21pc3Mke3l0fWAsIEVhID0gXCJkYXRhLXRlLW1vZGFsLW9wZW5cIiwgQ2EgPSBcImRhdGEtdGUtb3BlblwiLCBwaSA9IFwiW2RhdGEtdGUtbW9kYWwtZGlhbG9nLXJlZl1cIiwgbF8gPSBcIltkYXRhLXRlLW1vZGFsLWJvZHktcmVmXVwiO1xuY2xhc3Mgem8gZXh0ZW5kcyBmdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fZGlhbG9nID0gZC5maW5kT25lKHBpLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9jb25maWcubW9kYWxOb25JbnZhc2l2ZSA/IG51bGwgOiB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKSwgdGhpcy5fZm9jdXN0cmFwID0gdGhpcy5faW5pdGlhbGl6ZUZvY3VzVHJhcCgpLCB0aGlzLl9pc1Nob3duID0gITEsIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIHRoaXMuX3Njcm9sbEJhciA9IG5ldyB0aSgpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gbWE7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBqbjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHQpO1xuICB9XG4gIHNob3codCkge1xuICAgIHRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBvXywge1xuICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgIH0pLmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX2lzU2hvd24gPSAhMCwgdGhpcy5faXNBbmltYXRlZCgpICYmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMCksICF0aGlzLl9jb25maWcubW9kYWxOb25JbnZhc2l2ZSAmJiB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpLCBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZShFYSwgXCJ0cnVlXCIpLCB0aGlzLl9hZGp1c3REaWFsb2coKSwgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKSwgdGhpcy5fc2V0UmVzaXplRXZlbnQoKSwgYy5vbih0aGlzLl9kaWFsb2csIFRhLCAoKSA9PiB7XG4gICAgICBjLm9uZSh0aGlzLl9lbGVtZW50LCBhXywgKGkpID0+IHtcbiAgICAgICAgaS50YXJnZXQgPT09IHRoaXMuX2VsZW1lbnQgJiYgKHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMCk7XG4gICAgICB9KTtcbiAgICB9KSwgdGhpcy5fc2hvd0VsZW1lbnQodCksICF0aGlzLl9jb25maWcubW9kYWxOb25JbnZhc2l2ZSAmJiB0aGlzLl9zaG93QmFja2Ryb3AoKSk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBpXykuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9pc1Nob3duID0gITE7XG4gICAgY29uc3QgZSA9IHRoaXMuX2lzQW5pbWF0ZWQoKTtcbiAgICBlICYmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMCksIHRoaXMuX3NldEVzY2FwZUV2ZW50KCksIHRoaXMuX3NldFJlc2l6ZUV2ZW50KCksIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIGQuZmluZE9uZShwaSwgdGhpcy5fZWxlbWVudCkuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9jbGFzc2VzLnNob3cpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBiYSksIGMub2ZmKHRoaXMuX2RpYWxvZywgVGEpLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHRoaXMuX2hpZGVNb2RhbCgpLCB0aGlzLl9lbGVtZW50LCBlKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoQ2EpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgW3dpbmRvdywgZG9jdW1lbnQsIHRoaXMuX2RpYWxvZ10uZm9yRWFjaChcbiAgICAgICh0KSA9PiBjLm9mZih0LCB5dClcbiAgICApLCB0aGlzLl9iYWNrZHJvcCAmJiB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCksIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICBoYW5kbGVVcGRhdGUoKSB7XG4gICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8ICh2bih6byksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICByZXR1cm4gbmV3IENyKHtcbiAgICAgIGlzVmlzaWJsZTogISF0aGlzLl9jb25maWcuYmFja2Ryb3AsXG4gICAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWVcbiAgICAgIGlzQW5pbWF0ZWQ6IHRoaXMuX2lzQW5pbWF0ZWQoKSxcbiAgICAgIGJhY2tkcm9wQ2xhc3NlczogdGhpcy5fY2xhc3Nlcy5iYWNrZHJvcFxuICAgIH0pO1xuICB9XG4gIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xuICAgIHJldHVybiBuZXcgemkodGhpcy5fZWxlbWVudCwge1xuICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgY29uZGl0aW9uOiAodCkgPT4gdC5rZXkgPT09IFwiVGFiXCJcbiAgICB9KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLm1hLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyB0IDoge31cbiAgICB9LCBJKGpuLCB0LCBKcCksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi50XyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgSShqbiwgdCwgZV8pLCB0O1xuICB9XG4gIF9zaG93RWxlbWVudCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2lzQW5pbWF0ZWQoKSwgaSA9IGQuZmluZE9uZShsXywgdGhpcy5fZGlhbG9nKTtcbiAgICAoIXRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSB8fCB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSAmJiBkb2N1bWVudC5ib2R5LmFwcGVuZCh0aGlzLl9lbGVtZW50KSwgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiLCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1tb2RhbFwiLCAhMCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImRpYWxvZ1wiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYCR7Q2F9YCwgXCJ0cnVlXCIpLCB0aGlzLl9lbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgY29uc3QgbiA9IGQuZmluZE9uZShwaSwgdGhpcy5fZWxlbWVudCk7XG4gICAgbi5jbGFzc0xpc3QuYWRkKHRoaXMuX2NsYXNzZXMuc2hvdyksIG4uY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktMFwiKSwgbi5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0xMDBcIiksIGkgJiYgKGkuc2Nyb2xsVG9wID0gMCksIGUgJiYgc2kodGhpcy5fZWxlbWVudCk7XG4gICAgY29uc3QgbyA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbmZpZy5mb2N1cyAmJiB0aGlzLl9mb2N1c3RyYXAudHJhcCgpLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHJfLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhvLCB0aGlzLl9kaWFsb2csIGUpO1xuICB9XG4gIF9zZXRFc2NhcGVFdmVudCgpIHtcbiAgICB0aGlzLl9pc1Nob3duID8gYy5vbihkb2N1bWVudCwgdmEsICh0KSA9PiB7XG4gICAgICB0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgdC5rZXkgPT09IGZhID8gKHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5oaWRlKCkpIDogIXRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiB0LmtleSA9PT0gZmEgJiYgdGhpcy5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpO1xuICAgIH0pIDogYy5vZmYodGhpcy5fZWxlbWVudCwgdmEpO1xuICB9XG4gIF9zZXRSZXNpemVFdmVudCgpIHtcbiAgICB0aGlzLl9pc1Nob3duID8gYy5vbih3aW5kb3csIGdhLCAoKSA9PiB0aGlzLl9hZGp1c3REaWFsb2coKSkgOiBjLm9mZih3aW5kb3csIGdhKTtcbiAgfVxuICBfaGlkZU1vZGFsKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUocGksIHRoaXMuX2VsZW1lbnQpO1xuICAgIHQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9jbGFzc2VzLnNob3cpLCB0LmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTEwMFwiKSwgdC5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0wXCIpO1xuICAgIGNvbnN0IGUgPSBjbih0KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH0sIGUpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJvbGVcIiksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCB0aGlzLl9iYWNrZHJvcCAmJiB0aGlzLl9iYWNrZHJvcC5oaWRlKCgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKEVhKSwgdGhpcy5fcmVzZXRBZGp1c3RtZW50cygpLCAhdGhpcy5fY29uZmlnLm1vZGFsTm9uSW52YXNpdmUgJiYgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBuXyk7XG4gICAgfSk7XG4gIH1cbiAgX3Nob3dCYWNrZHJvcCh0KSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBiYSwgKGUpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCAmJiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAhMCA/IHRoaXMuaGlkZSgpIDogdGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSBcInN0YXRpY1wiICYmIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKSk7XG4gICAgfSksIHRoaXMuX2JhY2tkcm9wICYmIHRoaXMuX2JhY2tkcm9wLnNob3codCk7XG4gIH1cbiAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuICEhZC5maW5kT25lKHBpLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcbiAgICBpZiAoYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHNfKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgY2xhc3NMaXN0OiBlLCBzY3JvbGxIZWlnaHQ6IGksIHN0eWxlOiBuIH0gPSB0aGlzLl9lbGVtZW50LCBvID0gaSA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgaWYgKCFvICYmIG4ub3ZlcmZsb3dZID09PSBcImhpZGRlblwiIHx8IGUuY29udGFpbnModGhpcy5fY2xhc3Nlcy5zdGF0aWMpKVxuICAgICAgcmV0dXJuO1xuICAgIG8gfHwgKG4ub3ZlcmZsb3dZID0gXCJoaWRkZW5cIiksIGUuYWRkKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljLnNwbGl0KFwiIFwiKSksIGUuYWRkKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljUHJvcGVydGllcy5zcGxpdChcIiBcIikpO1xuICAgIGNvbnN0IHIgPSBjbih0aGlzLl9lbGVtZW50KTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGUucmVtb3ZlKHRoaXMuX2NsYXNzZXMuc3RhdGljKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGUucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljUHJvcGVydGllcy5zcGxpdChcIiBcIikpO1xuICAgICAgfSwgciksIG8gfHwgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIG4ub3ZlcmZsb3dZID0gXCJcIjtcbiAgICAgIH0sIHRoaXMuX2RpYWxvZyk7XG4gICAgfSwgdGhpcy5fZGlhbG9nKSwgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gdGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBfYWRqdXN0RGlhbG9nKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIGUgPSB0aGlzLl9zY3JvbGxCYXIuZ2V0V2lkdGgoKSwgaSA9IGUgPiAwO1xuICAgICghaSAmJiB0ICYmICFXKCkgfHwgaSAmJiAhdCAmJiBXKCkpICYmICh0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gYCR7ZX1weGApLCAoaSAmJiAhdCAmJiAhVygpIHx8ICFpICYmIHQgJiYgVygpKSAmJiAodGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtlfXB4YCk7XG4gIH1cbiAgX3Jlc2V0QWRqdXN0bWVudHMoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IFwiXCIsIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCJcIjtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGkgPSB6by5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGNfID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImJhY2tncm91bmRcIixcbiAgXCJjaXRlXCIsXG4gIFwiaHJlZlwiLFxuICBcIml0ZW10eXBlXCIsXG4gIFwibG9uZ2Rlc2NcIixcbiAgXCJwb3N0ZXJcIixcbiAgXCJzcmNcIixcbiAgXCJ4bGluazpocmVmXCJcbl0pLCBpaCA9IC9eYXJpYS1bXFx3LV0qJC9pLCBoXyA9IC9eZGF0YS10ZS1bXFx3LV0qJC9pLCBkXyA9IC9eKD86KD86aHR0cHM/fG1haWx0b3xmdHB8dGVsfGZpbGV8c21zKTp8W14jJi86P10qKD86WyMvP118JCkpL2ksIHVfID0gL15kYXRhOig/OmltYWdlXFwvKD86Ym1wfGdpZnxqcGVnfGpwZ3xwbmd8dGlmZnx3ZWJwKXx2aWRlb1xcLyg/Om1wZWd8bXA0fG9nZ3x3ZWJtKXxhdWRpb1xcLyg/Om1wM3xvZ2F8b2dnfG9wdXMpKTtiYXNlNjQsW1xcZCsvYS16XSs9KiQvaSwgcF8gPSAocywgdCkgPT4ge1xuICBjb25zdCBlID0gcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAodC5pbmNsdWRlcyhlKSlcbiAgICByZXR1cm4gY18uaGFzKGUpID8gISEoZF8udGVzdChzLm5vZGVWYWx1ZSkgfHwgdV8udGVzdChzLm5vZGVWYWx1ZSkpIDogITA7XG4gIGNvbnN0IGkgPSB0LmZpbHRlcihcbiAgICAobikgPT4gbiBpbnN0YW5jZW9mIFJlZ0V4cFxuICApO1xuICBmb3IgKGxldCBuID0gMCwgbyA9IGkubGVuZ3RoOyBuIDwgbzsgbisrKVxuICAgIGlmIChpW25dLnRlc3QoZSkpXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn0sIHNoID0ge1xuICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxuICBcIipcIjogW1xuICAgIFwiY2xhc3NcIixcbiAgICBcImRpclwiLFxuICAgIFwiaWRcIixcbiAgICBcImxhbmdcIixcbiAgICBcInJvbGVcIixcbiAgICBpaCxcbiAgICBoX1xuICBdLFxuICBhOiBbXCJ0YXJnZXRcIiwgXCJocmVmXCIsIFwidGl0bGVcIiwgXCJyZWxcIl0sXG4gIGFyZWE6IFtdLFxuICBiOiBbXSxcbiAgYnI6IFtdLFxuICBjb2w6IFtdLFxuICBjb2RlOiBbXSxcbiAgZGl2OiBbXSxcbiAgZW06IFtdLFxuICBocjogW10sXG4gIGgxOiBbXSxcbiAgaDI6IFtdLFxuICBoMzogW10sXG4gIGg0OiBbXSxcbiAgaDU6IFtdLFxuICBoNjogW10sXG4gIGk6IFtdLFxuICBpbWc6IFtcInNyY1wiLCBcInNyY3NldFwiLCBcImFsdFwiLCBcInRpdGxlXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl0sXG4gIGxpOiBbXSxcbiAgb2w6IFtdLFxuICBwOiBbXSxcbiAgcHJlOiBbXSxcbiAgczogW10sXG4gIHNtYWxsOiBbXSxcbiAgc3BhbjogW10sXG4gIHN1YjogW10sXG4gIHN1cDogW10sXG4gIHN0cm9uZzogW10sXG4gIHU6IFtdLFxuICB1bDogW11cbn0sIF9fID0ge1xuICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxuICBcIipcIjogW1wiY2xhc3NcIiwgXCJkaXJcIiwgXCJpZFwiLCBcImxhbmdcIiwgXCJyb2xlXCIsIGloXSxcbiAgYTogW1widGFyZ2V0XCIsIFwiaHJlZlwiLCBcInRpdGxlXCIsIFwicmVsXCJdLFxuICBhcmVhOiBbXSxcbiAgYjogW10sXG4gIGJyOiBbXSxcbiAgY29sOiBbXSxcbiAgY29kZTogW10sXG4gIGRpdjogW10sXG4gIGVtOiBbXSxcbiAgaHI6IFtdLFxuICBoMTogW10sXG4gIGgyOiBbXSxcbiAgaDM6IFtdLFxuICBoNDogW10sXG4gIGg1OiBbXSxcbiAgaDY6IFtdLFxuICBpOiBbXSxcbiAgaW1nOiBbXCJzcmNcIiwgXCJzcmNzZXRcIiwgXCJhbHRcIiwgXCJ0aXRsZVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdLFxuICBsaTogW10sXG4gIG9sOiBbXSxcbiAgcDogW10sXG4gIHByZTogW10sXG4gIHM6IFtdLFxuICBzbWFsbDogW10sXG4gIHNwYW46IFtdLFxuICBzdWI6IFtdLFxuICBzdXA6IFtdLFxuICBzdHJvbmc6IFtdLFxuICB1OiBbXSxcbiAgdWw6IFtdXG59O1xuZnVuY3Rpb24gcG4ocywgdCwgZSkge1xuICBpZiAoIXMubGVuZ3RoKVxuICAgIHJldHVybiBzO1xuICBpZiAoZSAmJiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIGUocyk7XG4gIGNvbnN0IG4gPSBuZXcgd2luZG93LkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzLCBcInRleHQvaHRtbFwiKSwgbyA9IFtdLmNvbmNhdCguLi5uLmJvZHkucXVlcnlTZWxlY3RvckFsbChcIipcIikpO1xuICBmb3IgKGxldCByID0gMCwgYSA9IG8ubGVuZ3RoOyByIDwgYTsgcisrKSB7XG4gICAgY29uc3QgbCA9IG9bcl0sIHAgPSBsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0KS5pbmNsdWRlcyhwKSkge1xuICAgICAgbC5yZW1vdmUoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB1ID0gW10uY29uY2F0KC4uLmwuYXR0cmlidXRlcyksIF8gPSBbXS5jb25jYXQoXG4gICAgICB0W1wiKlwiXSB8fCBbXSxcbiAgICAgIHRbcF0gfHwgW11cbiAgICApO1xuICAgIHUuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgcF8oZiwgXykgfHwgbC5yZW1vdmVBdHRyaWJ1dGUoZi5ub2RlTmFtZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG4uYm9keS5pbm5lckhUTUw7XG59XG5jb25zdCBBYSA9IFwidG9vbHRpcFwiLCBmXyA9IFwidGUudG9vbHRpcFwiLCBrdCA9IGAuJHtmX31gLCBtXyA9IFwidGUtdG9vbHRpcFwiLCBnXyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInNhbml0aXplXCIsIFwiYWxsb3dMaXN0XCIsIFwic2FuaXRpemVGblwiXSksIGJfID0ge1xuICBhbmltYXRpb246IFwiYm9vbGVhblwiLFxuICB0ZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgdGl0bGU6IFwiKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKVwiLFxuICB0cmlnZ2VyOiBcInN0cmluZ1wiLFxuICBkZWxheTogXCIobnVtYmVyfG9iamVjdClcIixcbiAgaHRtbDogXCJib29sZWFuXCIsXG4gIHNlbGVjdG9yOiBcIihzdHJpbmd8Ym9vbGVhbilcIixcbiAgcGxhY2VtZW50OiBcIihzdHJpbmd8ZnVuY3Rpb24pXCIsXG4gIG9mZnNldDogXCIoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBjb250YWluZXI6IFwiKHN0cmluZ3xlbGVtZW50fGJvb2xlYW4pXCIsXG4gIGZhbGxiYWNrUGxhY2VtZW50czogXCJhcnJheVwiLFxuICBib3VuZGFyeTogXCIoc3RyaW5nfGVsZW1lbnQpXCIsXG4gIGN1c3RvbUNsYXNzOiBcIihzdHJpbmd8ZnVuY3Rpb24pXCIsXG4gIHNhbml0aXplOiBcImJvb2xlYW5cIixcbiAgc2FuaXRpemVGbjogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgYWxsb3dMaXN0OiBcIm9iamVjdFwiLFxuICBwb3BwZXJDb25maWc6IFwiKG51bGx8b2JqZWN0fGZ1bmN0aW9uKVwiXG59LCB2XyA9IHtcbiAgQVVUTzogXCJhdXRvXCIsXG4gIFRPUDogXCJ0b3BcIixcbiAgUklHSFQ6IFcoKSA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICBCT1RUT006IFwiYm90dG9tXCIsXG4gIExFRlQ6IFcoKSA/IFwicmlnaHRcIiA6IFwibGVmdFwiXG59LCBUXyA9IHtcbiAgYW5pbWF0aW9uOiAhMCxcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwib3BhY2l0eS0wIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi0zMDAgZWFzZS1pbi1vdXQgYWJzb2x1dGUgei1bMTA4MF0gYmxvY2sgbS0wIHRleHQtc20gbm90LWl0YWxpYyBmb250LW5vcm1hbCB0ZXh0LWxlZnQgbm8tdW5kZXJsaW5lIHVuZGVybGluZS1vZmZzZXQtYXV0byBub3JtYWwtY2FzZSBsZWFkaW5nLTYgdHJhY2tpbmctbm9ybWFsIGJyZWFrLW5vcm1hbCB3aGl0ZXNwYWNlLW5vcm1hbFwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBkYXRhLXRlLXRvb2x0aXAtaW5uZXItcmVmIGNsYXNzPVwidG9vbHRpcC1pbm5lciBtYXgtdy1bMjAwcHhdIHRleHQtc20gcHktMS41IHB4LTQgdGV4dC13aGl0ZSB0ZXh0LWNlbnRlciBiZy1bIzZkNmQ2ZF0gcm91bmRlZFwiPjwvZGl2PjwvZGl2PicsXG4gIHRyaWdnZXI6IFwiaG92ZXIgZm9jdXNcIixcbiAgdGl0bGU6IFwiXCIsXG4gIGRlbGF5OiAwLFxuICBodG1sOiAhMSxcbiAgc2VsZWN0b3I6ICExLFxuICBwbGFjZW1lbnQ6IFwidG9wXCIsXG4gIG9mZnNldDogWzAsIDBdLFxuICBjb250YWluZXI6ICExLFxuICBmYWxsYmFja1BsYWNlbWVudHM6IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXSxcbiAgYm91bmRhcnk6IFwiY2xpcHBpbmdQYXJlbnRzXCIsXG4gIGN1c3RvbUNsYXNzOiBcIlwiLFxuICBzYW5pdGl6ZTogITAsXG4gIHNhbml0aXplRm46IG51bGwsXG4gIGFsbG93TGlzdDogX18sXG4gIHBvcHBlckNvbmZpZzogeyBoaWRlOiAhMCB9XG59LCBFXyA9IHtcbiAgSElERTogYGhpZGUke2t0fWAsXG4gIEhJRERFTjogYGhpZGRlbiR7a3R9YCxcbiAgU0hPVzogYHNob3cke2t0fWAsXG4gIFNIT1dOOiBgc2hvd24ke2t0fWAsXG4gIElOU0VSVEVEOiBgaW5zZXJ0ZWQke2t0fWAsXG4gIENMSUNLOiBgY2xpY2ske2t0fWAsXG4gIEZPQ1VTSU46IGBmb2N1c2luJHtrdH1gLFxuICBGT0NVU09VVDogYGZvY3Vzb3V0JHtrdH1gLFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7a3R9YCxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke2t0fWBcbn0sIENfID0gXCJmYWRlXCIsIEFfID0gXCJtb2RhbFwiLCBLbiA9IFwic2hvd1wiLCBfaSA9IFwic2hvd1wiLCB6biA9IFwib3V0XCIsIHlhID0gXCIudG9vbHRpcC1pbm5lclwiLCB3YSA9IGAuJHtBX31gLCBrYSA9IFwiaGlkZS50ZS5tb2RhbFwiLCBmaSA9IFwiaG92ZXJcIiwgVW4gPSBcImZvY3VzXCIsIHlfID0gXCJjbGlja1wiLCB3XyA9IFwibWFudWFsXCI7XG5jbGFzcyByaSBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIGlmICh0eXBlb2YgcWMgPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiQm9vdHN0cmFwJ3MgdG9vbHRpcHMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZylcIlxuICAgICAgKTtcbiAgICBzdXBlcih0KSwgdGhpcy5faXNFbmFibGVkID0gITAsIHRoaXMuX3RpbWVvdXQgPSAwLCB0aGlzLl9ob3ZlclN0YXRlID0gXCJcIiwgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IHt9LCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMudGlwID0gbnVsbCwgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIFRfO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gQWE7XG4gIH1cbiAgc3RhdGljIGdldCBFdmVudCgpIHtcbiAgICByZXR1cm4gRV87XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gYl87XG4gIH1cbiAgLy8gUHVibGljXG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSAhMDtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICExO1xuICB9XG4gIHRvZ2dsZUVuYWJsZWQoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcbiAgfVxuICB0b2dnbGUodCkge1xuICAgIGlmICh0aGlzLl9pc0VuYWJsZWQpXG4gICAgICBpZiAodCkge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KHQpO1xuICAgICAgICBlLl9hY3RpdmVUcmlnZ2VyLmNsaWNrID0gIWUuX2FjdGl2ZVRyaWdnZXIuY2xpY2ssIGUuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSA/IGUuX2VudGVyKG51bGwsIGUpIDogZS5fbGVhdmUobnVsbCwgZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmNvbnRhaW5zKEtuKSkge1xuICAgICAgICAgIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbnRlcihudWxsLCB0aGlzKTtcbiAgICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSwgYy5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LmNsb3Nlc3Qod2EpLFxuICAgICAga2EsXG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyXG4gICAgKSwgdGhpcy50aXAgJiYgdGhpcy50aXAucmVtb3ZlKCksIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKSwgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgdXNlIHNob3cgb24gdmlzaWJsZSBlbGVtZW50c1wiKTtcbiAgICBpZiAoISh0aGlzLmlzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBjLnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XXG4gICAgKSwgZSA9IGZjKHRoaXMuX2VsZW1lbnQpLCBpID0gZSA9PT0gbnVsbCA/IHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy5fZWxlbWVudCkgOiBlLmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpO1xuICAgIGlmICh0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5OQU1FID09PSBcInRvb2x0aXBcIiAmJiB0aGlzLnRpcCAmJiB0aGlzLmdldFRpdGxlKCkgIT09IHRoaXMudGlwLnF1ZXJ5U2VsZWN0b3IoeWEpLmlubmVySFRNTCAmJiAodGhpcy5fZGlzcG9zZVBvcHBlcigpLCB0aGlzLnRpcC5yZW1vdmUoKSwgdGhpcy50aXAgPSBudWxsKTtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRUaXBFbGVtZW50KCksIG8gPSBldCh0aGlzLmNvbnN0cnVjdG9yLk5BTUUpO1xuICAgIG4uc2V0QXR0cmlidXRlKFwiaWRcIiwgbyksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCBvKSwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudGlwLmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTEwMFwiKSwgdGhpcy50aXAuY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktMFwiKTtcbiAgICB9LCAxMDApO1xuICAgIGNvbnN0IHIgPSB0eXBlb2YgdGhpcy5fY29uZmlnLnBsYWNlbWVudCA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucGxhY2VtZW50LmNhbGwodGhpcywgbiwgdGhpcy5fZWxlbWVudCkgOiB0aGlzLl9jb25maWcucGxhY2VtZW50LCBhID0gdGhpcy5fZ2V0QXR0YWNobWVudChyKTtcbiAgICB0aGlzLl9hZGRBdHRhY2htZW50Q2xhc3MoYSk7XG4gICAgY29uc3QgeyBjb250YWluZXI6IGwgfSA9IHRoaXMuX2NvbmZpZztcbiAgICBpZiAoQS5zZXREYXRhKG4sIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpLCB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMudGlwKSB8fCAobC5hcHBlbmQobiksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LklOU0VSVEVEKSksIHRoaXMuX3BvcHBlciA/IHRoaXMuX3BvcHBlci51cGRhdGUoKSA6IHRoaXMuX3BvcHBlciA9IHNlKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9nZXRQb3BwZXJDb25maWcoYSlcbiAgICApLCBuLmdldEF0dHJpYnV0ZShcImlkXCIpLmluY2x1ZGVzKFwidG9vbHRpcFwiKSlcbiAgICAgIHN3aXRjaCAocikge1xuICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgbi5jbGFzc0xpc3QuYWRkKFwicHktWzAuNHJlbV1cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgbi5jbGFzc0xpc3QuYWRkKFwicHgtWzAuNHJlbV1cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB4LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB5LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNvbnN0IHUgPSB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY3VzdG9tQ2xhc3MpO1xuICAgIHUgJiYgbi5jbGFzc0xpc3QuYWRkKC4uLnUuc3BsaXQoXCIgXCIpKSwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKGcpID0+IHtcbiAgICAgIGMub24oZywgXCJtb3VzZW92ZXJcIiwgaG4pO1xuICAgIH0pO1xuICAgIGNvbnN0IF8gPSAoKSA9PiB7XG4gICAgICBjb25zdCBnID0gdGhpcy5faG92ZXJTdGF0ZTtcbiAgICAgIHRoaXMuX2hvdmVyU3RhdGUgPSBudWxsLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XTiksIGcgPT09IHpuICYmIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xuICAgIH0sIGYgPSB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoXCJ0cmFuc2l0aW9uLW9wYWNpdHlcIik7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhfLCB0aGlzLnRpcCwgZik7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX3BvcHBlcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRUaXBFbGVtZW50KCksIGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkgfHwgKHRoaXMuX2hvdmVyU3RhdGUgIT09IF9pICYmIHQucmVtb3ZlKCksIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURERU4pLCB0aGlzLl9kaXNwb3NlUG9wcGVyKCkpO1xuICAgIH07XG4gICAgaWYgKGMudHJpZ2dlcihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJREVcbiAgICApLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdC5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0wXCIpLCB0LmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTEwMFwiKSwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKG8pID0+IGMub2ZmKG8sIFwibW91c2VvdmVyXCIsIGhuKSksIHRoaXMuX2FjdGl2ZVRyaWdnZXJbeV9dID0gITEsIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVW5dID0gITEsIHRoaXMuX2FjdGl2ZVRyaWdnZXJbZmldID0gITE7XG4gICAgY29uc3QgbiA9IHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhcIm9wYWNpdHktMFwiKTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGUsIHRoaXMudGlwLCBuKSwgdGhpcy5faG92ZXJTdGF0ZSA9IFwiXCI7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX3BvcHBlciAhPT0gbnVsbCAmJiB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gIH1cbiAgLy8gUHJvdGVjdGVkXG4gIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRUaXRsZSgpO1xuICB9XG4gIGdldFRpcEVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMudGlwKVxuICAgICAgcmV0dXJuIHRoaXMudGlwO1xuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHQuaW5uZXJIVE1MID0gdGhpcy5fY29uZmlnLnRlbXBsYXRlO1xuICAgIGNvbnN0IGUgPSB0LmNoaWxkcmVuWzBdO1xuICAgIHJldHVybiB0aGlzLnNldENvbnRlbnQoZSksIGUuY2xhc3NMaXN0LnJlbW92ZShDXywgS24pLCB0aGlzLnRpcCA9IGUsIHRoaXMudGlwO1xuICB9XG4gIHNldENvbnRlbnQodCkge1xuICAgIHRoaXMuX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCB0aGlzLmdldFRpdGxlKCksIHlhKTtcbiAgfVxuICBfc2FuaXRpemVBbmRTZXRDb250ZW50KHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gZC5maW5kT25lKGksIHQpO1xuICAgIGlmICghZSAmJiBuKSB7XG4gICAgICBuLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KG4sIGUpO1xuICB9XG4gIHNldEVsZW1lbnRDb250ZW50KHQsIGUpIHtcbiAgICBpZiAodCAhPT0gbnVsbCkge1xuICAgICAgaWYgKFhlKGUpKSB7XG4gICAgICAgIGUgPSBlZShlKSwgdGhpcy5fY29uZmlnLmh0bWwgPyBlLnBhcmVudE5vZGUgIT09IHQgJiYgKHQuaW5uZXJIVE1MID0gXCJcIiwgdC5hcHBlbmQoZSkpIDogdC50ZXh0Q29udGVudCA9IGUudGV4dENvbnRlbnQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbmZpZy5odG1sID8gKHRoaXMuX2NvbmZpZy5zYW5pdGl6ZSAmJiAoZSA9IHBuKFxuICAgICAgICBlLFxuICAgICAgICB0aGlzLl9jb25maWcuYWxsb3dMaXN0LFxuICAgICAgICB0aGlzLl9jb25maWcuc2FuaXRpemVGblxuICAgICAgKSksIHQuaW5uZXJIVE1MID0gZSkgOiB0LnRleHRDb250ZW50ID0gZTtcbiAgICB9XG4gIH1cbiAgZ2V0VGl0bGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZS1vcmlnaW5hbC10aXRsZVwiKSB8fCB0aGlzLl9jb25maWcudGl0bGU7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHQpO1xuICB9XG4gIHVwZGF0ZUF0dGFjaG1lbnQodCkge1xuICAgIHJldHVybiB0ID09PSBcInJpZ2h0XCIgPyBcImVuZFwiIDogdCA9PT0gXCJsZWZ0XCIgPyBcInN0YXJ0XCIgOiB0O1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSB7XG4gICAgcmV0dXJuIGUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5nZXRPckNyZWF0ZUluc3RhbmNlKFxuICAgICAgdC5kZWxlZ2F0ZVRhcmdldCxcbiAgICAgIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKClcbiAgICApO1xuICB9XG4gIF9nZXRPZmZzZXQoKSB7XG4gICAgY29uc3QgeyBvZmZzZXQ6IHQgfSA9IHRoaXMuX2NvbmZpZztcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQuc3BsaXQoXCIsXCIpLm1hcCgoZSkgPT4gTnVtYmVyLnBhcnNlSW50KGUsIDEwKSkgOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyAoZSkgPT4gdChlLCB0aGlzLl9lbGVtZW50KSA6IHQ7XG4gIH1cbiAgX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdC5jYWxsKHRoaXMuX2VsZW1lbnQpIDogdDtcbiAgfVxuICBfZ2V0UG9wcGVyQ29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgcGxhY2VtZW50OiB0LFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImZsaXBcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHRoaXMuX2NvbmZpZy5mYWxsYmFja1BsYWNlbWVudHNcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImFycm93XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZWxlbWVudDogYC4ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXJyb3dgXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvbkNoYW5nZVwiLFxuICAgICAgICAgIGVuYWJsZWQ6ICEwLFxuICAgICAgICAgIHBoYXNlOiBcImFmdGVyV3JpdGVcIixcbiAgICAgICAgICBmbjogKGkpID0+IHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShpKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgb25GaXJzdFVwZGF0ZTogKGkpID0+IHtcbiAgICAgICAgaS5vcHRpb25zLnBsYWNlbWVudCAhPT0gaS5wbGFjZW1lbnQgJiYgdGhpcy5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKGkpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmUsXG4gICAgICAuLi50eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKGUpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZ1xuICAgIH07XG4gIH1cbiAgX2FkZEF0dGFjaG1lbnRDbGFzcyh0KSB7XG4gICAgdGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmFkZChcbiAgICAgIGAke3RoaXMuX2dldEJhc2ljQ2xhc3NQcmVmaXgoKX0tJHt0aGlzLnVwZGF0ZUF0dGFjaG1lbnQodCl9YFxuICAgICk7XG4gIH1cbiAgX2dldEF0dGFjaG1lbnQodCkge1xuICAgIHJldHVybiB2X1t0LnRvVXBwZXJDYXNlKCldO1xuICB9XG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fY29uZmlnLnRyaWdnZXIuc3BsaXQoXCIgXCIpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGlmIChlID09PSBcImNsaWNrXCIpXG4gICAgICAgIGMub24oXG4gICAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkNMSUNLLFxuICAgICAgICAgIHRoaXMuX2NvbmZpZy5zZWxlY3RvcixcbiAgICAgICAgICAoaSkgPT4gdGhpcy50b2dnbGUoaSlcbiAgICAgICAgKTtcbiAgICAgIGVsc2UgaWYgKGUgIT09IHdfKSB7XG4gICAgICAgIGNvbnN0IGkgPSBlID09PSBmaSA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VFTlRFUiA6IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNJTiwgbiA9IGUgPT09IGZpID8gdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFIDogdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU09VVDtcbiAgICAgICAgYy5vbihcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgIGksXG4gICAgICAgICAgdGhpcy5fY29uZmlnLnNlbGVjdG9yLFxuICAgICAgICAgIChvKSA9PiB0aGlzLl9lbnRlcihvKVxuICAgICAgICApLCBjLm9uKFxuICAgICAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgbixcbiAgICAgICAgICB0aGlzLl9jb25maWcuc2VsZWN0b3IsXG4gICAgICAgICAgKG8pID0+IHRoaXMuX2xlYXZlKG8pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSksIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50ICYmIHRoaXMuaGlkZSgpO1xuICAgIH0sIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LmNsb3Nlc3Qod2EpLFxuICAgICAga2EsXG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyXG4gICAgKSwgdGhpcy5fY29uZmlnLnNlbGVjdG9yID8gdGhpcy5fY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5fY29uZmlnLFxuICAgICAgdHJpZ2dlcjogXCJtYW51YWxcIixcbiAgICAgIHNlbGVjdG9yOiBcIlwiXG4gICAgfSA6IHRoaXMuX2ZpeFRpdGxlKCk7XG4gIH1cbiAgX2ZpeFRpdGxlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcInRpdGxlXCIpLCBlID0gdHlwZW9mIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFxuICAgICAgXCJkYXRhLXRlLW9yaWdpbmFsLXRpdGxlXCJcbiAgICApO1xuICAgICh0IHx8IGUgIT09IFwic3RyaW5nXCIpICYmICh0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtb3JpZ2luYWwtdGl0bGVcIiwgdCB8fCBcIlwiKSwgdCAmJiAhdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpICYmICF0aGlzLl9lbGVtZW50LnRleHRDb250ZW50ICYmIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0KSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBcIlwiKSk7XG4gIH1cbiAgX2VudGVyKHQsIGUpIHtcbiAgICBpZiAoZSA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSwgdCAmJiAoZS5fYWN0aXZlVHJpZ2dlclt0LnR5cGUgPT09IFwiZm9jdXNpblwiID8gVW4gOiBmaV0gPSAhMCksIGUuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhLbikgfHwgZS5faG92ZXJTdGF0ZSA9PT0gX2kpIHtcbiAgICAgIGUuX2hvdmVyU3RhdGUgPSBfaTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNsZWFyVGltZW91dChlLl90aW1lb3V0KSwgZS5faG92ZXJTdGF0ZSA9IF9pLCAhZS5fY29uZmlnLmRlbGF5IHx8ICFlLl9jb25maWcuZGVsYXkuc2hvdykge1xuICAgICAgZS5zaG93KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGUuX2hvdmVyU3RhdGUgPT09IF9pICYmIGUuc2hvdygpO1xuICAgIH0sIGUuX2NvbmZpZy5kZWxheS5zaG93KTtcbiAgfVxuICBfbGVhdmUodCwgZSkge1xuICAgIGlmIChlID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KHQsIGUpLCB0ICYmIChlLl9hY3RpdmVUcmlnZ2VyW3QudHlwZSA9PT0gXCJmb2N1c291dFwiID8gVW4gOiBmaV0gPSBlLl9lbGVtZW50LmNvbnRhaW5zKHQucmVsYXRlZFRhcmdldCkpLCAhZS5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICBpZiAoY2xlYXJUaW1lb3V0KGUuX3RpbWVvdXQpLCBlLl9ob3ZlclN0YXRlID0gem4sICFlLl9jb25maWcuZGVsYXkgfHwgIWUuX2NvbmZpZy5kZWxheS5oaWRlKSB7XG4gICAgICAgIGUuaGlkZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGUuX2hvdmVyU3RhdGUgPT09IHpuICYmIGUuaGlkZSgpO1xuICAgICAgfSwgZS5fY29uZmlnLmRlbGF5LmhpZGUpO1xuICAgIH1cbiAgfVxuICBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdGhpcy5fYWN0aXZlVHJpZ2dlcilcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUcmlnZ2VyW3RdKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBnXy5oYXMoaSkgJiYgZGVsZXRlIGVbaV07XG4gICAgfSksIHQgPSB7XG4gICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi5lLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgdC5jb250YWluZXIgPSB0LmNvbnRhaW5lciA9PT0gITEgPyBkb2N1bWVudC5ib2R5IDogZWUodC5jb250YWluZXIpLCB0eXBlb2YgdC5kZWxheSA9PSBcIm51bWJlclwiICYmICh0LmRlbGF5ID0ge1xuICAgICAgc2hvdzogdC5kZWxheSxcbiAgICAgIGhpZGU6IHQuZGVsYXlcbiAgICB9KSwgdHlwZW9mIHQudGl0bGUgPT0gXCJudW1iZXJcIiAmJiAodC50aXRsZSA9IHQudGl0bGUudG9TdHJpbmcoKSksIHR5cGVvZiB0LmNvbnRlbnQgPT0gXCJudW1iZXJcIiAmJiAodC5jb250ZW50ID0gdC5jb250ZW50LnRvU3RyaW5nKCkpLCBJKEFhLCB0LCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSwgdC5zYW5pdGl6ZSAmJiAodC50ZW1wbGF0ZSA9IHBuKFxuICAgICAgdC50ZW1wbGF0ZSxcbiAgICAgIHQuYWxsb3dMaXN0LFxuICAgICAgdC5zYW5pdGl6ZUZuXG4gICAgKSksIHQ7XG4gIH1cbiAgX2dldERlbGVnYXRlQ29uZmlnKCkge1xuICAgIGNvbnN0IHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGUgaW4gdGhpcy5fY29uZmlnKVxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VdICE9PSB0aGlzLl9jb25maWdbZV0gJiYgKHRbZV0gPSB0aGlzLl9jb25maWdbZV0pO1xuICAgIHJldHVybiB0O1xuICB9XG4gIF9jbGVhblRpcENsYXNzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFRpcEVsZW1lbnQoKSwgZSA9IG5ldyBSZWdFeHAoXG4gICAgICBgKF58XFxcXHMpJHt0aGlzLl9nZXRCYXNpY0NsYXNzUHJlZml4KCl9XFxcXFMrYCxcbiAgICAgIFwiZ1wiXG4gICAgKSwgaSA9IHQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikubWF0Y2goZSk7XG4gICAgaSAhPT0gbnVsbCAmJiBpLmxlbmd0aCA+IDAgJiYgaS5tYXAoKG4pID0+IG4udHJpbSgpKS5mb3JFYWNoKChuKSA9PiB0LmNsYXNzTGlzdC5yZW1vdmUobikpO1xuICB9XG4gIF9nZXRCYXNpY0NsYXNzUHJlZml4KCkge1xuICAgIHJldHVybiBtXztcbiAgfVxuICBfaGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKHQpIHtcbiAgICBjb25zdCB7IHN0YXRlOiBlIH0gPSB0O1xuICAgIGUgJiYgKHRoaXMudGlwID0gZS5lbGVtZW50cy5wb3BwZXIsIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKSwgdGhpcy5fYWRkQXR0YWNobWVudENsYXNzKHRoaXMuX2dldEF0dGFjaG1lbnQoZS5wbGFjZW1lbnQpKSk7XG4gIH1cbiAgX2Rpc3Bvc2VQb3BwZXIoKSB7XG4gICAgdGhpcy5fcG9wcGVyICYmICh0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9wb3BwZXIgPSBudWxsKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSByaS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3Qga18gPSBcInBvcG92ZXJcIiwgeF8gPSBcInRlLnBvcG92ZXJcIiwgeHQgPSBgLiR7eF99YCwgT18gPSBcInRlLXBvcG92ZXJcIiwgU18gPSB7XG4gIC4uLnJpLkRlZmF1bHQsXG4gIHBsYWNlbWVudDogXCJyaWdodFwiLFxuICBvZmZzZXQ6IFswLCA4XSxcbiAgdHJpZ2dlcjogXCJjbGlja1wiLFxuICBjb250ZW50OiBcIlwiLFxuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJvcGFjaXR5LTAgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBhYnNvbHV0ZSB0b3AtMCBsZWZ0LTAgei1bMTA3MF0gYmxvY2sgbWF4LXctWzI2N3B4XSBicmVhay13b3JkcyBiZy13aGl0ZSBiZy1jbGlwLXBhZGRpbmcgYm9yZGVyIGJvcmRlci1uZXV0cmFsLTEwMCByb3VuZGVkLWxnIHNoYWRvdy1bMF8wcHhfM3B4XzBfcmdiYSgwLDAsMCwwLjA3KSwwXzJweF8ycHhfMF9yZ2JhKDAsMCwwLDAuMDQpXSB0ZXh0LXNtIG5vdC1pdGFsaWMgZm9udC1ub3JtYWwgdGV4dC1sZWZ0IG5vLXVuZGVybGluZSB1bmRlcmxpbmUtb2Zmc2V0LWF1dG8gbm9ybWFsLWNhc2UgbGVhZGluZy02IHRyYWNraW5nLW5vcm1hbCBicmVhay1ub3JtYWwgd2hpdGVzcGFjZS1ub3JtYWwgZGFyazpiZy1uZXV0cmFsLTcwMCBkYXJrOmJvcmRlci0wIGRhcms6dGV4dC13aGl0ZSBkYXRhLVtwb3BwZXItcmVmZXJlbmNlLWhpZGRlbl06aGlkZGVuXCIgcm9sZT1cInRvb2x0aXBcIj48aDMgY2xhc3M9XCJwb3BvdmVyLWhlYWRlciBweS0yIHB4LTQgbWItMCBib3JkZXItYi0yIGJvcmRlci1uZXV0cmFsLTEwMCByb3VuZGVkLXQtbGcgZm9udC1tZWRpdW0gZW1wdHk6aGlkZGVuIGRhcms6Ym9yZGVyLW5ldXRyYWwtNTAwXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5IHAtNCB0ZXh0LVsjMjEyNTI5XSBkYXJrOnRleHQtd2hpdGVcIj48L2Rpdj48L2Rpdj4nXG59LCBJXyA9IHtcbiAgLi4ucmkuRGVmYXVsdFR5cGUsXG4gIGNvbnRlbnQ6IFwiKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKVwiXG59LCBEXyA9IHtcbiAgSElERTogYGhpZGUke3h0fWAsXG4gIEhJRERFTjogYGhpZGRlbiR7eHR9YCxcbiAgU0hPVzogYHNob3cke3h0fWAsXG4gIFNIT1dOOiBgc2hvd24ke3h0fWAsXG4gIElOU0VSVEVEOiBgaW5zZXJ0ZWQke3h0fWAsXG4gIENMSUNLOiBgY2xpY2ske3h0fWAsXG4gIEZPQ1VTSU46IGBmb2N1c2luJHt4dH1gLFxuICBGT0NVU09VVDogYGZvY3Vzb3V0JHt4dH1gLFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7eHR9YCxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke3h0fWBcbn0sICRfID0gXCIucG9wb3Zlci1oZWFkZXJcIiwgTF8gPSBcIi5wb3BvdmVyLWJvZHlcIjtcbmNsYXNzIG5oIGV4dGVuZHMgcmkge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gU187XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBrXztcbiAgfVxuICBzdGF0aWMgZ2V0IEV2ZW50KCkge1xuICAgIHJldHVybiBEXztcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBJXztcbiAgfVxuICAvLyBPdmVycmlkZXNcbiAgaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpIHx8IHRoaXMuX2dldENvbnRlbnQoKTtcbiAgfVxuICBzZXRDb250ZW50KHQpIHtcbiAgICB0aGlzLl9zYW5pdGl6ZUFuZFNldENvbnRlbnQodCwgdGhpcy5nZXRUaXRsZSgpLCAkXyksIHRoaXMuX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCB0aGlzLl9nZXRDb250ZW50KCksIExfKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY29udGVudCk7XG4gIH1cbiAgX2dldEJhc2ljQ2xhc3NQcmVmaXgoKSB7XG4gICAgcmV0dXJuIE9fO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IG5oLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBYbiA9IFwic2Nyb2xsc3B5XCIsIE5fID0gXCJ0ZS5zY3JvbGxzcHlcIiwgeXIgPSBgLiR7Tl99YCwgeGEgPSB7XG4gIG9mZnNldDogMTAsXG4gIG1ldGhvZDogXCJhdXRvXCIsXG4gIHRhcmdldDogXCJcIlxufSwgTV8gPSB7XG4gIG9mZnNldDogXCJudW1iZXJcIixcbiAgbWV0aG9kOiBcInN0cmluZ1wiLFxuICB0YXJnZXQ6IFwiKHN0cmluZ3xlbGVtZW50KVwiXG59LCBSXyA9IHtcbiAgYWN0aXZlOiBcIiF0ZXh0LXByaW1hcnkgZGFyazohdGV4dC1wcmltYXJ5LTQwMCBmb250LXNlbWlib2xkIGJvcmRlci1sLVswLjEyNXJlbV0gYm9yZGVyLXNvbGlkIGJvcmRlci1wcmltYXJ5IGRhcms6Ym9yZGVyLXByaW1hcnktNDAwXCJcbn0sIFBfID0ge1xuICBhY3RpdmU6IFwic3RyaW5nXCJcbn0sIEJfID0gYGFjdGl2YXRlJHt5cn1gLCBIXyA9IGBzY3JvbGwke3lyfWAsIEduID0gXCJkYXRhLXRlLW5hdi1saW5rLWFjdGl2ZVwiLCBvaCA9IFwiW2RhdGEtdGUtZHJvcGRvd24taXRlbS1yZWZdXCIsIFZfID0gXCJbZGF0YS10ZS1uYXYtbGlzdC1yZWZdXCIsIFVvID0gXCJbZGF0YS10ZS1uYXYtbGluay1yZWZdXCIsIFdfID0gXCJbZGF0YS10ZS1uYXYtaXRlbS1yZWZdXCIsIHJoID0gXCJbZGF0YS10ZS1saXN0LWdyb3VwLWl0ZW0tcmVmXVwiLCBxbiA9IGAke1VvfSwgJHtyaH0sICR7b2h9YCwgRl8gPSBcIltkYXRhLXRlLWRyb3Bkb3duLXJlZl1cIiwgWV8gPSBcIltkYXRhLXRlLWRyb3Bkb3duLXRvZ2dsZS1yZWZdXCIsIGpfID0gXCJtYXhPZmZzZXRcIiwgT2EgPSBcInBvc2l0aW9uXCI7XG5jbGFzcyBhaCBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9zY3JvbGxFbGVtZW50ID0gdGhpcy5fZWxlbWVudC50YWdOYW1lID09PSBcIkJPRFlcIiA/IHdpbmRvdyA6IHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX29mZnNldHMgPSBbXSwgdGhpcy5fdGFyZ2V0cyA9IFtdLCB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsLCB0aGlzLl9zY3JvbGxIZWlnaHQgPSAwLCBjLm9uKHRoaXMuX3Njcm9sbEVsZW1lbnQsIEhfLCAoKSA9PiB0aGlzLl9wcm9jZXNzKCkpLCB0aGlzLnJlZnJlc2goKSwgdGhpcy5fcHJvY2VzcygpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiB4YTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFhuO1xuICB9XG4gIC8vIFB1YmxpY1xuICByZWZyZXNoKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB0aGlzLl9zY3JvbGxFbGVtZW50LndpbmRvdyA/IGpfIDogT2EsIGUgPSB0aGlzLl9jb25maWcubWV0aG9kID09PSBcImF1dG9cIiA/IHQgOiB0aGlzLl9jb25maWcubWV0aG9kLCBpID0gZSA9PT0gT2EgPyB0aGlzLl9nZXRTY3JvbGxUb3AoKSA6IDA7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IFtdLCB0aGlzLl90YXJnZXRzID0gW10sIHRoaXMuX3Njcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpLCBkLmZpbmQoXG4gICAgICBxbixcbiAgICAgIHRoaXMuX2NvbmZpZy50YXJnZXRcbiAgICApLm1hcCgobykgPT4ge1xuICAgICAgY29uc3QgciA9IGxyKG8pLCBhID0gciA/IGQuZmluZE9uZShyKSA6IG51bGw7XG4gICAgICBpZiAoYSkge1xuICAgICAgICBjb25zdCBsID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGwud2lkdGggfHwgbC5oZWlnaHQpXG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGhbZV0oYSkudG9wICsgaSxcbiAgICAgICAgICAgIHJcbiAgICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkuZmlsdGVyKChvKSA9PiBvKS5zb3J0KChvLCByKSA9PiBvWzBdIC0gclswXSkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgdGhpcy5fb2Zmc2V0cy5wdXNoKG9bMF0pLCB0aGlzLl90YXJnZXRzLnB1c2gob1sxXSk7XG4gICAgfSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjLm9mZih0aGlzLl9zY3JvbGxFbGVtZW50LCB5ciksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ueGEsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgdC50YXJnZXQgPSBlZSh0LnRhcmdldCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBJKFhuLCB0LCBNXyksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5SXyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgSShYbiwgdCwgUF8pLCB0O1xuICB9XG4gIF9nZXRTY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvdyA/IHRoaXMuX3Njcm9sbEVsZW1lbnQucGFnZVlPZmZzZXQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxuICBfZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heChcbiAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LFxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgICk7XG4gIH1cbiAgX2dldE9mZnNldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gd2luZG93LmlubmVySGVpZ2h0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gIH1cbiAgX3Byb2Nlc3MoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldFNjcm9sbFRvcCgpICsgdGhpcy5fY29uZmlnLm9mZnNldCwgZSA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpLCBpID0gdGhpcy5fY29uZmlnLm9mZnNldCArIGUgLSB0aGlzLl9nZXRPZmZzZXRIZWlnaHQoKTtcbiAgICBpZiAodGhpcy5fc2Nyb2xsSGVpZ2h0ICE9PSBlICYmIHRoaXMucmVmcmVzaCgpLCB0ID49IGkpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMubGVuZ3RoIC0gMV07XG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IG4gJiYgdGhpcy5fYWN0aXZhdGUobik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgJiYgdCA8IHRoaXMuX29mZnNldHNbMF0gJiYgdGhpcy5fb2Zmc2V0c1swXSA+IDApIHtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGwsIHRoaXMuX2NsZWFyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IG4gPSB0aGlzLl9vZmZzZXRzLmxlbmd0aDsgbi0tOyApXG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRoaXMuX3RhcmdldHNbbl0gJiYgdCA+PSB0aGlzLl9vZmZzZXRzW25dICYmICh0eXBlb2YgdGhpcy5fb2Zmc2V0c1tuICsgMV0gPiBcInVcIiB8fCB0IDwgdGhpcy5fb2Zmc2V0c1tuICsgMV0pICYmIHRoaXMuX2FjdGl2YXRlKHRoaXMuX3RhcmdldHNbbl0pO1xuICB9XG4gIF9hY3RpdmF0ZSh0KSB7XG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdCwgdGhpcy5fY2xlYXIoKTtcbiAgICBjb25zdCBlID0gcW4uc3BsaXQoXCIsXCIpLm1hcChcbiAgICAgIChuKSA9PiBgJHtufVtkYXRhLXRlLXRhcmdldD1cIiR7dH1cIl0sJHtufVtocmVmPVwiJHt0fVwiXWBcbiAgICApLCBpID0gZC5maW5kT25lKGUuam9pbihcIixcIiksIHRoaXMuX2NvbmZpZy50YXJnZXQpO1xuICAgIGkuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpLCBpLnNldEF0dHJpYnV0ZShHbiwgXCJcIiksIGkuZ2V0QXR0cmlidXRlKG9oKSA/IGQuZmluZE9uZShcbiAgICAgIFlfLFxuICAgICAgaS5jbG9zZXN0KEZfKVxuICAgICkuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpIDogZC5wYXJlbnRzKGksIFZfKS5mb3JFYWNoKFxuICAgICAgKG4pID0+IHtcbiAgICAgICAgZC5wcmV2KFxuICAgICAgICAgIG4sXG4gICAgICAgICAgYCR7VW99LCAke3JofWBcbiAgICAgICAgKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgICAgby5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSksIG8uc2V0QXR0cmlidXRlKEduLCBcIlwiKTtcbiAgICAgICAgfSksIGQucHJldihuLCBXXykuZm9yRWFjaChcbiAgICAgICAgICAobykgPT4ge1xuICAgICAgICAgICAgZC5jaGlsZHJlbihvLCBVbykuZm9yRWFjaChcbiAgICAgICAgICAgICAgKHIpID0+IHIuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApLCBjLnRyaWdnZXIodGhpcy5fc2Nyb2xsRWxlbWVudCwgQl8sIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICB9KTtcbiAgfVxuICBfY2xlYXIoKSB7XG4gICAgZC5maW5kKHFuLCB0aGlzLl9jb25maWcudGFyZ2V0KS5maWx0ZXIoXG4gICAgICAodCkgPT4gdC5jbGFzc0xpc3QuY29udGFpbnMoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKVxuICAgICkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdC5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSksIHQucmVtb3ZlQXR0cmlidXRlKEduKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBhaC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgU2EgPSBcInRhYlwiLCBLXyA9IFwidGUudGFiXCIsIFRuID0gYC4ke0tffWAsIHpfID0gYGhpZGUke1RufWAsIFVfID0gYGhpZGRlbiR7VG59YCwgWF8gPSBgc2hvdyR7VG59YCwgR18gPSBgc2hvd24ke1RufWAsIHFfID0gXCJkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXCIsIEhlID0gXCJkYXRhLXRlLXRhYi1hY3RpdmVcIiwgS3MgPSBcImRhdGEtdGUtbmF2LWFjdGl2ZVwiLCBaXyA9IFwiW2RhdGEtdGUtZHJvcGRvd24tcmVmXVwiLCBRXyA9IFwiW2RhdGEtdGUtbmF2LXJlZl1cIiwgSWEgPSBgWyR7SGV9XWAsIEpfID0gYFske0tzfV1gLCBEYSA9IFwiOnNjb3BlID4gbGkgPiAuYWN0aXZlXCIsIHRmID0gXCJbZGF0YS10ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLCBlZiA9IFwiOnNjb3BlID4gW2RhdGEtdGUtZHJvcGRvd24tbWVudS1yZWZdIFtkYXRhLXRlLWRyb3Bkb3duLXNob3ddXCIsIHNmID0ge1xuICBzaG93OiBcIm9wYWNpdHktMTAwXCIsXG4gIGhpZGU6IFwib3BhY2l0eS0wXCJcbn0sIG5mID0ge1xuICBzaG93OiBcInN0cmluZ1wiLFxuICBoaWRlOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgbGggZXh0ZW5kcyBmdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoZSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFNhO1xuICB9XG4gIC8vIFB1YmxpY1xuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgJiYgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShLcykgPT09IFwiXCIpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHQ7XG4gICAgY29uc3QgZSA9IHRlKHRoaXMuX2VsZW1lbnQpLCBpID0gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFFfKSwgbiA9IGQuZmluZE9uZShcbiAgICAgIEpfLFxuICAgICAgaVxuICAgICk7XG4gICAgaWYgKGkpIHtcbiAgICAgIGNvbnN0IGwgPSBpLm5vZGVOYW1lID09PSBcIlVMXCIgfHwgaS5ub2RlTmFtZSA9PT0gXCJPTFwiID8gRGEgOiBJYTtcbiAgICAgIHQgPSBkLmZpbmQobCwgaSksIHQgPSB0W3QubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNvbnN0IG8gPSB0ID8gYy50cmlnZ2VyKHQsIHpfLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfSkgOiBudWxsO1xuICAgIGlmIChjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWF8sIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkIHx8IG8gIT09IG51bGwgJiYgby5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2FjdGl2YXRlKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGksXG4gICAgICBudWxsLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIGNvbnN0IGEgPSAoKSA9PiB7XG4gICAgICBjLnRyaWdnZXIodCwgVV8sIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgICAgfSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBHXywge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGUgPyB0aGlzLl9hY3RpdmF0ZShcbiAgICAgIGUsXG4gICAgICBlLnBhcmVudE5vZGUsXG4gICAgICBhLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApIDogYSgpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5zZixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgSShTYSwgdCwgbmYpLCB0O1xuICB9XG4gIF9hY3RpdmF0ZSh0LCBlLCBpLCBuLCBvKSB7XG4gICAgY29uc3QgYSA9IChlICYmIChlLm5vZGVOYW1lID09PSBcIlVMXCIgfHwgZS5ub2RlTmFtZSA9PT0gXCJPTFwiKSA/IGQuZmluZChEYSwgZSkgOiBkLmNoaWxkcmVuKGUsIElhKSlbMF0sIGwgPSBpICYmIGEgJiYgYS5oYXNBdHRyaWJ1dGUoSGUpLCBwID0gKCkgPT4gdGhpcy5fdHJhbnNpdGlvbkNvbXBsZXRlKFxuICAgICAgdCxcbiAgICAgIGEsXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIG9cbiAgICApO1xuICAgIGEgJiYgbCA/IChoLnJlbW92ZUNsYXNzKGEsIHRoaXMuX2NsYXNzZXMuc2hvdyksIGguYWRkQ2xhc3MoYSwgdGhpcy5fY2xhc3Nlcy5oaWRlKSwgdGhpcy5fcXVldWVDYWxsYmFjayhwLCB0LCAhMCkpIDogcCgpO1xuICB9XG4gIF90cmFuc2l0aW9uQ29tcGxldGUodCwgZSwgaSwgbiwgbykge1xuICAgIGlmIChlICYmIG4pIHtcbiAgICAgIGUucmVtb3ZlQXR0cmlidXRlKEhlKSwgbi5yZW1vdmVBdHRyaWJ1dGUoS3MpO1xuICAgICAgY29uc3QgYSA9IGQuZmluZE9uZShcbiAgICAgICAgZWYsXG4gICAgICAgIGUucGFyZW50Tm9kZVxuICAgICAgKTtcbiAgICAgIGEgJiYgYS5yZW1vdmVBdHRyaWJ1dGUoSGUpLCBlLmdldEF0dHJpYnV0ZShcInJvbGVcIikgPT09IFwidGFiXCIgJiYgZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICExKTtcbiAgICB9XG4gICAgdC5zZXRBdHRyaWJ1dGUoSGUsIFwiXCIpLCBvLnNldEF0dHJpYnV0ZShLcywgXCJcIiksIHQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSA9PT0gXCJ0YWJcIiAmJiB0LnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgITApLCBzaSh0KSwgdC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5fY2xhc3Nlcy5oaWRlKSAmJiAoaC5yZW1vdmVDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLmhpZGUpLCBoLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXMuc2hvdykpO1xuICAgIGxldCByID0gdC5wYXJlbnROb2RlO1xuICAgIGlmIChyICYmIHIubm9kZU5hbWUgPT09IFwiTElcIiAmJiAociA9IHIucGFyZW50Tm9kZSksIHIgJiYgci5oYXNBdHRyaWJ1dGUocV8pKSB7XG4gICAgICBjb25zdCBhID0gdC5jbG9zZXN0KFpfKTtcbiAgICAgIGEgJiYgZC5maW5kKHRmLCBhKS5mb3JFYWNoKFxuICAgICAgICAobCkgPT4gbC5zZXRBdHRyaWJ1dGUoSGUsIFwiXCIpXG4gICAgICApLCB0LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgITApO1xuICAgIH1cbiAgICBpICYmIGkoKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBsaC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgWm4gPSBcInRvYXN0XCIsIG9mID0gXCJ0ZS50b2FzdFwiLCBuZSA9IGAuJHtvZn1gLCByZiA9IGBtb3VzZW92ZXIke25lfWAsIGFmID0gYG1vdXNlb3V0JHtuZX1gLCBsZiA9IGBmb2N1c2luJHtuZX1gLCBjZiA9IGBmb2N1c291dCR7bmV9YCwgaGYgPSBgaGlkZSR7bmV9YCwgZGYgPSBgaGlkZGVuJHtuZX1gLCB1ZiA9IGBzaG93JHtuZX1gLCBwZiA9IGBzaG93biR7bmV9YCwgJGEgPSBcImRhdGEtdGUtdG9hc3QtaGlkZVwiLCBRbiA9IFwiZGF0YS10ZS10b2FzdC1zaG93XCIsIGFzID0gXCJkYXRhLXRlLXRvYXN0LXNob3dpbmdcIiwgX2YgPSB7XG4gIGFuaW1hdGlvbjogXCJib29sZWFuXCIsXG4gIGF1dG9oaWRlOiBcImJvb2xlYW5cIixcbiAgZGVsYXk6IFwibnVtYmVyXCJcbn0sIExhID0ge1xuICBhbmltYXRpb246ICEwLFxuICBhdXRvaGlkZTogITAsXG4gIGRlbGF5OiA1ZTNcbn0sIGZmID0ge1xuICBmYWRlSW46IFwiYW5pbWF0ZS1bZmFkZS1pbl8wLjNzX2JvdGhdIHAtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsXG4gIGZhZGVPdXQ6IFwiYW5pbWF0ZS1bZmFkZS1vdXRfMC4zc19ib3RoXSBwLVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiXG59LCBtZiA9IHtcbiAgZmFkZUluOiBcInN0cmluZ1wiLFxuICBmYWRlT3V0OiBcInN0cmluZ1wiXG59O1xuY2xhc3MgWG8gZXh0ZW5kcyBmdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fdGltZW91dCA9IG51bGwsIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSAhMSwgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9ICExLCB0aGlzLl9zZXRMaXN0ZW5lcnMoKSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBfZjtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIExhO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gWm47XG4gIH1cbiAgLy8gUHVibGljXG4gIHNob3coKSB7XG4gICAgaWYgKGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB1ZikuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKSwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiAoaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVPdXQpLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZUluKSk7XG4gICAgY29uc3QgZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGFzKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHBmKSwgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcbiAgICB9O1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCRhKSwgc2kodGhpcy5fZWxlbWVudCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFFuLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXMsIFwiXCIpLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50IHx8IHRoaXMuX2VsZW1lbnQuZGF0YXNldC50ZVRvYXN0U2hvdyA9PT0gdm9pZCAwIHx8IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBoZikuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gKCkgPT4ge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiAoaSA9IDMwMCwgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVJbiksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgkYSwgXCJcIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGFzKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoUW4pLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZGYpO1xuICAgICAgfSwgaSk7XG4gICAgfTtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShhcywgXCJcIiksIHRoaXMuX3F1ZXVlQ2FsbGJhY2soZSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbik7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKSwgdGhpcy5fZWxlbWVudC5kYXRhc2V0LnRlVG9hc3RTaG93ICE9PSB2b2lkIDAgJiYgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoUW4pLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8ICh2bihYbyksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5MYSxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgPyB0IDoge31cbiAgICB9LCBJKFpuLCB0LCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmZmLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKFpuLCB0LCBtZiksIHQ7XG4gIH1cbiAgX21heWJlU2NoZWR1bGVIaWRlKCkge1xuICAgIHRoaXMuX2NvbmZpZy5hdXRvaGlkZSAmJiAodGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiB8fCB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uIHx8ICh0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkpKSk7XG4gIH1cbiAgX29uSW50ZXJhY3Rpb24odCwgZSkge1xuICAgIHN3aXRjaCAodC50eXBlKSB7XG4gICAgICBjYXNlIFwibW91c2VvdmVyXCI6XG4gICAgICBjYXNlIFwibW91c2VvdXRcIjpcbiAgICAgICAgdGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiA9IGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZvY3VzaW5cIjpcbiAgICAgIGNhc2UgXCJmb2N1c291dFwiOlxuICAgICAgICB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uID0gZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChlKSB7XG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaSA9IHQucmVsYXRlZFRhcmdldDtcbiAgICB0aGlzLl9lbGVtZW50ID09PSBpIHx8IHRoaXMuX2VsZW1lbnQuY29udGFpbnMoaSkgfHwgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcbiAgfVxuICBfc2V0TGlzdGVuZXJzKCkge1xuICAgIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgcmYsXG4gICAgICAodCkgPT4gdGhpcy5fb25JbnRlcmFjdGlvbih0LCAhMClcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGFmLFxuICAgICAgKHQpID0+IHRoaXMuX29uSW50ZXJhY3Rpb24odCwgITEpXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBsZixcbiAgICAgICh0KSA9PiB0aGlzLl9vbkludGVyYWN0aW9uKHQsICEwKVxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgY2YsXG4gICAgICAodCkgPT4gdGhpcy5fb25JbnRlcmFjdGlvbih0LCAhMSlcbiAgICApO1xuICB9XG4gIF9jbGVhclRpbWVvdXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpLCB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBYby5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbigoKSA9PiB7XG4gIHZhciBzID0geyA0NTQ6IChpLCBuLCBvKSA9PiB7XG4gICAgby5kKG4sIHsgWjogKCkgPT4gbCB9KTtcbiAgICB2YXIgciA9IG8oNjQ1KSwgYSA9IG8ubihyKSgpKGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBwWzFdO1xuICAgIH0pO1xuICAgIGEucHVzaChbaS5pZCwgXCJJTlBVVDotd2Via2l0LWF1dG9maWxsLFNFTEVDVDotd2Via2l0LWF1dG9maWxsLFRFWFRBUkVBOi13ZWJraXQtYXV0b2ZpbGx7YW5pbWF0aW9uLW5hbWU6b25hdXRvZmlsbHN0YXJ0fUlOUFVUOm5vdCg6LXdlYmtpdC1hdXRvZmlsbCksU0VMRUNUOm5vdCg6LXdlYmtpdC1hdXRvZmlsbCksVEVYVEFSRUE6bm90KDotd2Via2l0LWF1dG9maWxsKXthbmltYXRpb24tbmFtZTpvbmF1dG9maWxsY2FuY2VsfUBrZXlmcmFtZXMgb25hdXRvZmlsbHN0YXJ0e31Aa2V5ZnJhbWVzIG9uYXV0b2ZpbGxjYW5jZWx7fVwiLCBcIlwiXSk7XG4gICAgY29uc3QgbCA9IGE7XG4gIH0sIDY0NTogKGkpID0+IHtcbiAgICBpLmV4cG9ydHMgPSBmdW5jdGlvbihuKSB7XG4gICAgICB2YXIgbyA9IFtdO1xuICAgICAgcmV0dXJuIG8udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICB2YXIgYSA9IG4ocik7XG4gICAgICAgICAgcmV0dXJuIHJbMl0gPyBcIkBtZWRpYSBcIi5jb25jYXQoclsyXSwgXCIge1wiKS5jb25jYXQoYSwgXCJ9XCIpIDogYTtcbiAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgIH0sIG8uaSA9IGZ1bmN0aW9uKHIsIGEsIGwpIHtcbiAgICAgICAgdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiAmJiAociA9IFtbbnVsbCwgciwgXCJcIl1dKTtcbiAgICAgICAgdmFyIHAgPSB7fTtcbiAgICAgICAgaWYgKGwpXG4gICAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCB0aGlzLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICB2YXIgXyA9IHRoaXNbdV1bMF07XG4gICAgICAgICAgICBfICE9IG51bGwgJiYgKHBbX10gPSAhMCk7XG4gICAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBmID0gMDsgZiA8IHIubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICB2YXIgZyA9IFtdLmNvbmNhdChyW2ZdKTtcbiAgICAgICAgICBsICYmIHBbZ1swXV0gfHwgKGEgJiYgKGdbMl0gPyBnWzJdID0gXCJcIi5jb25jYXQoYSwgXCIgYW5kIFwiKS5jb25jYXQoZ1syXSkgOiBnWzJdID0gYSksIG8ucHVzaChnKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIG87XG4gICAgfTtcbiAgfSwgODEwOiAoKSA9PiB7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIilcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgaSA9IG5ldyB3aW5kb3cuQ3VzdG9tRXZlbnQoXCJ0ZXN0XCIsIHsgY2FuY2VsYWJsZTogITAgfSk7XG4gICAgICAgICAgaWYgKGkucHJldmVudERlZmF1bHQoKSwgaS5kZWZhdWx0UHJldmVudGVkICE9PSAhMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwcmV2ZW50IGRlZmF1bHRcIik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHZhciBuID0gZnVuY3Rpb24ociwgYSkge1xuICAgICAgICAgICAgdmFyIGwsIHA7XG4gICAgICAgICAgICByZXR1cm4gKGEgPSBhIHx8IHt9KS5idWJibGVzID0gISFhLmJ1YmJsZXMsIGEuY2FuY2VsYWJsZSA9ICEhYS5jYW5jZWxhYmxlLCAobCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIikpLmluaXRDdXN0b21FdmVudChyLCBhLmJ1YmJsZXMsIGEuY2FuY2VsYWJsZSwgYS5kZXRhaWwpLCBwID0gbC5wcmV2ZW50RGVmYXVsdCwgbC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBwLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdFByZXZlbnRlZFwiLCB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gITA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBuLnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGUsIHdpbmRvdy5DdXN0b21FdmVudCA9IG47XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICB9LCAzNzk6IChpLCBuLCBvKSA9PiB7XG4gICAgdmFyIHIsIGEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBDID0ge307XG4gICAgICByZXR1cm4gZnVuY3Rpb24oRSkge1xuICAgICAgICBpZiAoQ1tFXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFyIHcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKEUpO1xuICAgICAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgdyBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHcgPSB3LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIENbRV0gPSB3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDW0VdO1xuICAgICAgfTtcbiAgICB9KCksIGwgPSBbXTtcbiAgICBmdW5jdGlvbiBwKEMpIHtcbiAgICAgIGZvciAodmFyIEUgPSAtMSwgdyA9IDA7IHcgPCBsLmxlbmd0aDsgdysrKVxuICAgICAgICBpZiAobFt3XS5pZGVudGlmaWVyID09PSBDKSB7XG4gICAgICAgICAgRSA9IHc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBFO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1KEMsIEUpIHtcbiAgICAgIGZvciAodmFyIHcgPSB7fSwgayA9IFtdLCBEID0gMDsgRCA8IEMubGVuZ3RoOyBEKyspIHtcbiAgICAgICAgdmFyIE8gPSBDW0RdLCB4ID0gRS5iYXNlID8gT1swXSArIEUuYmFzZSA6IE9bMF0sIEwgPSB3W3hdIHx8IDAsIFMgPSBcIlwiLmNvbmNhdCh4LCBcIiBcIikuY29uY2F0KEwpO1xuICAgICAgICB3W3hdID0gTCArIDE7XG4gICAgICAgIHZhciBOID0gcChTKSwgUCA9IHsgY3NzOiBPWzFdLCBtZWRpYTogT1syXSwgc291cmNlTWFwOiBPWzNdIH07XG4gICAgICAgIE4gIT09IC0xID8gKGxbTl0ucmVmZXJlbmNlcysrLCBsW05dLnVwZGF0ZXIoUCkpIDogbC5wdXNoKHsgaWRlbnRpZmllcjogUywgdXBkYXRlcjogeShQLCBFKSwgcmVmZXJlbmNlczogMSB9KSwgay5wdXNoKFMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGs7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF8oQykge1xuICAgICAgdmFyIEUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiksIHcgPSBDLmF0dHJpYnV0ZXMgfHwge307XG4gICAgICBpZiAody5ub25jZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBrID0gby5uYztcbiAgICAgICAgayAmJiAody5ub25jZSA9IGspO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHcpLmZvckVhY2goZnVuY3Rpb24oTykge1xuICAgICAgICBFLnNldEF0dHJpYnV0ZShPLCB3W09dKTtcbiAgICAgIH0pLCB0eXBlb2YgQy5pbnNlcnQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBDLmluc2VydChFKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgRCA9IGEoQy5pbnNlcnQgfHwgXCJoZWFkXCIpO1xuICAgICAgICBpZiAoIUQpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgRC5hcHBlbmRDaGlsZChFKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFO1xuICAgIH1cbiAgICB2YXIgZiwgZyA9IChmID0gW10sIGZ1bmN0aW9uKEMsIEUpIHtcbiAgICAgIHJldHVybiBmW0NdID0gRSwgZi5maWx0ZXIoQm9vbGVhbikuam9pbihgXG5gKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBtKEMsIEUsIHcsIGspIHtcbiAgICAgIHZhciBEID0gdyA/IFwiXCIgOiBrLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KGsubWVkaWEsIFwiIHtcIikuY29uY2F0KGsuY3NzLCBcIn1cIikgOiBrLmNzcztcbiAgICAgIGlmIChDLnN0eWxlU2hlZXQpXG4gICAgICAgIEMuc3R5bGVTaGVldC5jc3NUZXh0ID0gZyhFLCBEKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgTyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKEQpLCB4ID0gQy5jaGlsZE5vZGVzO1xuICAgICAgICB4W0VdICYmIEMucmVtb3ZlQ2hpbGQoeFtFXSksIHgubGVuZ3RoID8gQy5pbnNlcnRCZWZvcmUoTywgeFtFXSkgOiBDLmFwcGVuZENoaWxkKE8pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBiKEMsIEUsIHcpIHtcbiAgICAgIHZhciBrID0gdy5jc3MsIEQgPSB3Lm1lZGlhLCBPID0gdy5zb3VyY2VNYXA7XG4gICAgICBpZiAoRCA/IEMuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgRCkgOiBDLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpLCBPICYmIHR5cGVvZiBidG9hIDwgXCJ1XCIgJiYgKGsgKz0gYFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxgLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShPKSkpKSwgXCIgKi9cIikpLCBDLnN0eWxlU2hlZXQpXG4gICAgICAgIEMuc3R5bGVTaGVldC5jc3NUZXh0ID0gaztcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKDsgQy5maXJzdENoaWxkOyApXG4gICAgICAgICAgQy5yZW1vdmVDaGlsZChDLmZpcnN0Q2hpbGQpO1xuICAgICAgICBDLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGspKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHYgPSBudWxsLCBUID0gMDtcbiAgICBmdW5jdGlvbiB5KEMsIEUpIHtcbiAgICAgIHZhciB3LCBrLCBEO1xuICAgICAgaWYgKEUuc2luZ2xldG9uKSB7XG4gICAgICAgIHZhciBPID0gVCsrO1xuICAgICAgICB3ID0gdiB8fCAodiA9IF8oRSkpLCBrID0gbS5iaW5kKG51bGwsIHcsIE8sICExKSwgRCA9IG0uYmluZChudWxsLCB3LCBPLCAhMCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdyA9IF8oRSksIGsgPSBiLmJpbmQobnVsbCwgdywgRSksIEQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAoZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgaWYgKHgucGFyZW50Tm9kZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgeC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHgpO1xuICAgICAgICAgIH0pKHcpO1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIGsoQyksIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICBpZiAoeC5jc3MgPT09IEMuY3NzICYmIHgubWVkaWEgPT09IEMubWVkaWEgJiYgeC5zb3VyY2VNYXAgPT09IEMuc291cmNlTWFwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGsoQyA9IHgpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBEKCk7XG4gICAgICB9O1xuICAgIH1cbiAgICBpLmV4cG9ydHMgPSBmdW5jdGlvbihDLCBFKSB7XG4gICAgICAoRSA9IEUgfHwge30pLnNpbmdsZXRvbiB8fCB0eXBlb2YgRS5zaW5nbGV0b24gPT0gXCJib29sZWFuXCIgfHwgKEUuc2luZ2xldG9uID0gKHIgPT09IHZvaWQgMCAmJiAociA9ICEhKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKSksIHIpKTtcbiAgICAgIHZhciB3ID0gdShDID0gQyB8fCBbXSwgRSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oaykge1xuICAgICAgICBpZiAoayA9IGsgfHwgW10sIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChrKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgZm9yICh2YXIgRCA9IDA7IEQgPCB3Lmxlbmd0aDsgRCsrKSB7XG4gICAgICAgICAgICB2YXIgTyA9IHAod1tEXSk7XG4gICAgICAgICAgICBsW09dLnJlZmVyZW5jZXMtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgeCA9IHUoaywgRSksIEwgPSAwOyBMIDwgdy5sZW5ndGg7IEwrKykge1xuICAgICAgICAgICAgdmFyIFMgPSBwKHdbTF0pO1xuICAgICAgICAgICAgbFtTXS5yZWZlcmVuY2VzID09PSAwICYmIChsW1NdLnVwZGF0ZXIoKSwgbC5zcGxpY2UoUywgMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3ID0geDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9IH0sIHQgPSB7fTtcbiAgZnVuY3Rpb24gZShpKSB7XG4gICAgdmFyIG4gPSB0W2ldO1xuICAgIGlmIChuICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gbi5leHBvcnRzO1xuICAgIHZhciBvID0gdFtpXSA9IHsgaWQ6IGksIGV4cG9ydHM6IHt9IH07XG4gICAgcmV0dXJuIHNbaV0obywgby5leHBvcnRzLCBlKSwgby5leHBvcnRzO1xuICB9XG4gIGUubiA9IChpKSA9PiB7XG4gICAgdmFyIG4gPSBpICYmIGkuX19lc01vZHVsZSA/ICgpID0+IGkuZGVmYXVsdCA6ICgpID0+IGk7XG4gICAgcmV0dXJuIGUuZChuLCB7IGE6IG4gfSksIG47XG4gIH0sIGUuZCA9IChpLCBuKSA9PiB7XG4gICAgZm9yICh2YXIgbyBpbiBuKVxuICAgICAgZS5vKG4sIG8pICYmICFlLm8oaSwgbykgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIG8sIHsgZW51bWVyYWJsZTogITAsIGdldDogbltvXSB9KTtcbiAgfSwgZS5vID0gKGksIG4pID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLCBuKSwgKCgpID0+IHtcbiAgICB2YXIgaSA9IGUoMzc5KSwgbiA9IGUubihpKSwgbyA9IGUoNDU0KTtcbiAgICBmdW5jdGlvbiByKGwpIHtcbiAgICAgIGlmICghbC5oYXNBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVkXCIpKSB7XG4gICAgICAgIGwuc2V0QXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlZFwiLCBcIlwiKTtcbiAgICAgICAgdmFyIHAgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KFwib25hdXRvY29tcGxldGVcIiwgeyBidWJibGVzOiAhMCwgY2FuY2VsYWJsZTogITAsIGRldGFpbDogbnVsbCB9KTtcbiAgICAgICAgbC5kaXNwYXRjaEV2ZW50KHApIHx8IChsLnZhbHVlID0gXCJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGEobCkge1xuICAgICAgbC5oYXNBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVkXCIpICYmIChsLnJlbW92ZUF0dHJpYnV0ZShcImF1dG9jb21wbGV0ZWRcIiksIGwuZGlzcGF0Y2hFdmVudChuZXcgd2luZG93LkN1c3RvbUV2ZW50KFwib25hdXRvY29tcGxldGVcIiwgeyBidWJibGVzOiAhMCwgY2FuY2VsYWJsZTogITEsIGRldGFpbDogbnVsbCB9KSkpO1xuICAgIH1cbiAgICBuKCkoby5aLCB7IGluc2VydDogXCJoZWFkXCIsIHNpbmdsZXRvbjogITEgfSksIG8uWi5sb2NhbHMsIGUoODEwKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uKGwpIHtcbiAgICAgIGwuYW5pbWF0aW9uTmFtZSA9PT0gXCJvbmF1dG9maWxsc3RhcnRcIiA/IHIobC50YXJnZXQpIDogYShsLnRhcmdldCk7XG4gICAgfSwgITApLCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZnVuY3Rpb24obCkge1xuICAgICAgbC5pbnB1dFR5cGUgIT09IFwiaW5zZXJ0UmVwbGFjZW1lbnRUZXh0XCIgJiYgXCJkYXRhXCIgaW4gbCA/IGEobC50YXJnZXQpIDogcihsLnRhcmdldCk7XG4gICAgfSwgITApO1xuICB9KSgpO1xufSkoKTtcbmNvbnN0IEpuID0gXCJpbnB1dFwiLCBscyA9IFwidGUuaW5wdXRcIiwgY2ggPSBcImRhdGEtdGUtaW5wdXQtd3JhcHBlci1pbml0XCIsIGhoID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLXJlZlwiLCBkaCA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC1sZWFkaW5nLXJlZlwiLCB1aCA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC1taWRkbGUtcmVmXCIsIGdmID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLXRyYWlsaW5nLXJlZlwiLCBiZiA9IFwiZGF0YS10ZS1pbnB1dC1oZWxwZXItcmVmXCIsIHZmID0gXCJkYXRhLXRlLWlucHV0LXBsYWNlaG9sZGVyLWFjdGl2ZVwiLCBZdCA9IFwiZGF0YS10ZS1pbnB1dC1zdGF0ZS1hY3RpdmVcIiwgTmEgPSBcImRhdGEtdGUtaW5wdXQtZm9jdXNlZFwiLCBNYSA9IFwiZGF0YS10ZS1pbnB1dC1mb3JtLWNvdW50ZXJcIiwgY3MgPSBgWyR7Y2h9XSBpbnB1dGAsIGhzID0gYFske2NofV0gdGV4dGFyZWFgLCBJZSA9IGBbJHtoaH1dYCwgUmEgPSBgWyR7ZGh9XWAsIFBhID0gYFske3VofV1gLCBUZiA9IGBbJHtiZn1dYCwgRWYgPSB7XG4gIGlucHV0Rm9ybVdoaXRlOiAhMVxufSwgQ2YgPSB7XG4gIGlucHV0Rm9ybVdoaXRlOiBcIihib29sZWFuKVwiXG59LCBwaCA9IHtcbiAgbm90Y2g6IFwiZ3JvdXAgZmxleCBhYnNvbHV0ZSBsZWZ0LTAgdG9wLTAgdy1mdWxsIG1heC13LWZ1bGwgaC1mdWxsIHRleHQtbGVmdCBwb2ludGVyLWV2ZW50cy1ub25lXCIsXG4gIG5vdGNoTGVhZGluZzogXCJwb2ludGVyLWV2ZW50cy1ub25lIGJvcmRlciBib3JkZXItc29saWQgYm94LWJvcmRlciBiZy10cmFuc3BhcmVudCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbGVmdC0wIHRvcC0wIGgtZnVsbCB3LTIgYm9yZGVyLXItMCByb3VuZGVkLWwtWzAuMjVyZW1dIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1yLTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItci0wXCIsXG4gIG5vdGNoTGVhZGluZ05vcm1hbDogXCJib3JkZXItbmV1dHJhbC0zMDAgZGFyazpib3JkZXItbmV1dHJhbC02MDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVstMXB4XzBfMF8jM2I3MWNhLF8wXzFweF8wXzBfIzNiNzFjYSxfMF8tMXB4XzBfMF8jM2I3MWNhXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItcHJpbWFyeVwiLFxuICBub3RjaExlYWRpbmdXaGl0ZTogXCJib3JkZXItbmV1dHJhbC0yMDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVstMXB4XzBfMF8jZmZmZmZmLF8wXzFweF8wXzBfI2ZmZmZmZixfMF8tMXB4XzBfMF8jZmZmZmZmXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItd2hpdGVcIixcbiAgbm90Y2hNaWRkbGU6IFwicG9pbnRlci1ldmVudHMtbm9uZSBib3JkZXIgYm9yZGVyLXNvbGlkIGJveC1ib3JkZXIgYmctdHJhbnNwYXJlbnQgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGdyb3ctMCBzaHJpbmstMCBiYXNpcy1hdXRvIHctYXV0byBtYXgtdy1bY2FsYygxMDAlLTFyZW0pXSBoLWZ1bGwgYm9yZGVyLXItMCBib3JkZXItbC0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci14LTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXIteC0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci10IGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXNvbGlkIGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXNvbGlkIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci10LXRyYW5zcGFyZW50IGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXQtdHJhbnNwYXJlbnRcIixcbiAgbm90Y2hNaWRkbGVOb3JtYWw6IFwiYm9yZGVyLW5ldXRyYWwtMzAwIGRhcms6Ym9yZGVyLW5ldXRyYWwtNjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMF8xcHhfMF8wXyMzYjcxY2FdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1wcmltYXJ5XCIsXG4gIG5vdGNoTWlkZGxlV2hpdGU6IFwiYm9yZGVyLW5ldXRyYWwtMjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMF8xcHhfMF8wXyNmZmZmZmZdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci13aGl0ZVwiLFxuICBub3RjaFRyYWlsaW5nOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYm9yZGVyIGJvcmRlci1zb2xpZCBib3gtYm9yZGVyIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBncm93IGgtZnVsbCBib3JkZXItbC0wIHJvdW5kZWQtci1bMC4yNXJlbV0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLWwtMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci1sLTBcIixcbiAgbm90Y2hUcmFpbGluZ05vcm1hbDogXCJib3JkZXItbmV1dHJhbC0zMDAgZGFyazpib3JkZXItbmV1dHJhbC02MDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVsxcHhfMF8wXyMzYjcxY2EsXzBfLTFweF8wXzBfIzNiNzFjYSxfMF8xcHhfMF8wXyMzYjcxY2FdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1wcmltYXJ5XCIsXG4gIG5vdGNoVHJhaWxpbmdXaGl0ZTogXCJib3JkZXItbmV1dHJhbC0yMDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVsxcHhfMF8wXyNmZmZmZmYsXzBfLTFweF8wXzBfI2ZmZmZmZixfMF8xcHhfMF8wXyNmZmZmZmZdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci13aGl0ZVwiLFxuICBjb3VudGVyOiBcInRleHQtcmlnaHQgbGVhZGluZy1bMS42XVwiXG59LCBBZiA9IHtcbiAgbm90Y2g6IFwic3RyaW5nXCIsXG4gIG5vdGNoTGVhZGluZzogXCJzdHJpbmdcIixcbiAgbm90Y2hMZWFkaW5nTm9ybWFsOiBcInN0cmluZ1wiLFxuICBub3RjaExlYWRpbmdXaGl0ZTogXCJzdHJpbmdcIixcbiAgbm90Y2hNaWRkbGU6IFwic3RyaW5nXCIsXG4gIG5vdGNoTWlkZGxlTm9ybWFsOiBcInN0cmluZ1wiLFxuICBub3RjaE1pZGRsZVdoaXRlOiBcInN0cmluZ1wiLFxuICBub3RjaFRyYWlsaW5nOiBcInN0cmluZ1wiLFxuICBub3RjaFRyYWlsaW5nTm9ybWFsOiBcInN0cmluZ1wiLFxuICBub3RjaFRyYWlsaW5nV2hpdGU6IFwic3RyaW5nXCIsXG4gIGNvdW50ZXI6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBWIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlLCB0KSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9sYWJlbCA9IG51bGwsIHRoaXMuX2xhYmVsV2lkdGggPSAwLCB0aGlzLl9sYWJlbE1hcmdpbkxlZnQgPSAwLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBudWxsLCB0aGlzLl9ub3RjaE1pZGRsZSA9IG51bGwsIHRoaXMuX25vdGNoVHJhaWxpbmcgPSBudWxsLCB0aGlzLl9pbml0aWF0ZWQgPSAhMSwgdGhpcy5faGVscGVyID0gbnVsbCwgdGhpcy5fY291bnRlciA9ICExLCB0aGlzLl9jb3VudGVyRWxlbWVudCA9IG51bGwsIHRoaXMuX21heExlbmd0aCA9IDAsIHRoaXMuX2xlYWRpbmdJY29uID0gbnVsbCwgdGhpcy5fZWxlbWVudCAmJiAoQS5zZXREYXRhKHQsIGxzLCB0aGlzKSwgdGhpcy5pbml0KCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBKbjtcbiAgfVxuICBnZXQgaW5wdXQoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcImlucHV0XCIsIHRoaXMuX2VsZW1lbnQpIHx8IGQuZmluZE9uZShcInRleHRhcmVhXCIsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX2luaXRpYXRlZCB8fCAodGhpcy5fZ2V0TGFiZWxEYXRhKCksIHRoaXMuX2FwcGx5RGl2cygpLCB0aGlzLl9hcHBseU5vdGNoKCksIHRoaXMuX2FjdGl2YXRlKCksIHRoaXMuX2dldEhlbHBlcigpLCB0aGlzLl9nZXRDb3VudGVyKCksIHRoaXMuX2dldEV2ZW50cygpLCB0aGlzLl9pbml0aWF0ZWQgPSAhMCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX2dldExhYmVsRGF0YSgpLCB0aGlzLl9nZXROb3RjaERhdGEoKSwgdGhpcy5fYXBwbHlOb3RjaCgpLCB0aGlzLl9hY3RpdmF0ZSgpLCB0aGlzLl9nZXRIZWxwZXIoKSwgdGhpcy5fZ2V0Q291bnRlcigpO1xuICB9XG4gIGZvcmNlQWN0aXZlKCkge1xuICAgIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKFl0LCBcIlwiKSwgZC5maW5kT25lKEllLCB0aGlzLmlucHV0LnBhcmVudE5vZGUpLnNldEF0dHJpYnV0ZShcbiAgICAgIFl0LFxuICAgICAgXCJcIlxuICAgICk7XG4gIH1cbiAgZm9yY2VJbmFjdGl2ZSgpIHtcbiAgICB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShZdCksIGQuZmluZE9uZShcbiAgICAgIEllLFxuICAgICAgdGhpcy5pbnB1dC5wYXJlbnROb2RlXG4gICAgKS5yZW1vdmVBdHRyaWJ1dGUoWXQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fcmVtb3ZlQm9yZGVyKCksIEEucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBscyksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldENvbmZpZyh0LCBlKSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5FZixcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXMoZSksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gdCA6IHt9XG4gICAgfSwgSShKbiwgdCwgQ2YpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ucGgsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoSm4sIHQsIEFmKSwgdDtcbiAgfVxuICBfZ2V0TGFiZWxEYXRhKCkge1xuICAgIHRoaXMuX2xhYmVsID0gZC5maW5kT25lKFwibGFiZWxcIiwgdGhpcy5fZWxlbWVudCksIHRoaXMuX2xhYmVsID09PSBudWxsID8gdGhpcy5fc2hvd1BsYWNlaG9sZGVyKCkgOiAodGhpcy5fZ2V0TGFiZWxXaWR0aCgpLCB0aGlzLl9nZXRMYWJlbFBvc2l0aW9uSW5JbnB1dEdyb3VwKCksIHRoaXMuX3RvZ2dsZURlZmF1bHREYXRlUGxhY2Vob2xkZXIoKSk7XG4gIH1cbiAgX2dldEhlbHBlcigpIHtcbiAgICB0aGlzLl9oZWxwZXIgPSBkLmZpbmRPbmUoVGYsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIF9nZXRDb3VudGVyKCkge1xuICAgIHRoaXMuX2NvdW50ZXIgPSBoLmdldERhdGFBdHRyaWJ1dGUoXG4gICAgICB0aGlzLmlucHV0LFxuICAgICAgXCJpbnB1dFNob3djb3VudGVyXCJcbiAgICApLCB0aGlzLl9jb3VudGVyICYmICh0aGlzLl9tYXhMZW5ndGggPSB0aGlzLmlucHV0Lm1heExlbmd0aCwgdGhpcy5fc2hvd0NvdW50ZXIoKSk7XG4gIH1cbiAgX2dldEV2ZW50cygpIHtcbiAgICBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwiZm9jdXNcIixcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgIFYuYWN0aXZhdGUobmV3IFYoKSlcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgIFYuYWN0aXZhdGUobmV3IFYoKSlcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwiYmx1clwiLFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgVi5kZWFjdGl2YXRlKG5ldyBWKCkpXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImZvY3VzXCIsXG4gICAgICBcInRleHRhcmVhXCIsXG4gICAgICBWLmFjdGl2YXRlKG5ldyBWKCkpXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImlucHV0XCIsXG4gICAgICBcInRleHRhcmVhXCIsXG4gICAgICBWLmFjdGl2YXRlKG5ldyBWKCkpXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImJsdXJcIixcbiAgICAgIFwidGV4dGFyZWFcIixcbiAgICAgIFYuZGVhY3RpdmF0ZShuZXcgVigpKVxuICAgICksIGMub24od2luZG93LCBcInNob3duLnRlLm1vZGFsXCIsICh0KSA9PiB7XG4gICAgICBkLmZpbmQoY3MsIHQudGFyZ2V0KS5mb3JFYWNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGkgPSBWLmdldEluc3RhbmNlKGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgaSAmJiBpLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApLCBkLmZpbmQoaHMsIHQudGFyZ2V0KS5mb3JFYWNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGkgPSBWLmdldEluc3RhbmNlKGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgaSAmJiBpLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pLCBjLm9uKHdpbmRvdywgXCJzaG93bi50ZS5kcm9wZG93blwiLCAodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IHQudGFyZ2V0LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcihcbiAgICAgICAgXCJbZGF0YS10ZS1kcm9wZG93bi1tZW51LXJlZl1cIlxuICAgICAgKTtcbiAgICAgIGUgJiYgKGQuZmluZChjcywgZSkuZm9yRWFjaChcbiAgICAgICAgKGkpID0+IHtcbiAgICAgICAgICBjb25zdCBuID0gVi5nZXRJbnN0YW5jZShpLnBhcmVudE5vZGUpO1xuICAgICAgICAgIG4gJiYgbi51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgKSwgZC5maW5kKGhzLCBlKS5mb3JFYWNoKFxuICAgICAgICAoaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG4gPSBWLmdldEluc3RhbmNlKGkucGFyZW50Tm9kZSk7XG4gICAgICAgICAgbiAmJiBuLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApKTtcbiAgICB9KSwgYy5vbih3aW5kb3csIFwic2hvd24udGUudGFiXCIsICh0KSA9PiB7XG4gICAgICBsZXQgZTtcbiAgICAgIHQudGFyZ2V0LmhyZWYgPyBlID0gdC50YXJnZXQuaHJlZi5zcGxpdChcIiNcIilbMV0gOiBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQudGFyZ2V0LCBcInRhcmdldFwiKS5zcGxpdChcbiAgICAgICAgXCIjXCJcbiAgICAgIClbMV07XG4gICAgICBjb25zdCBpID0gZC5maW5kT25lKGAjJHtlfWApO1xuICAgICAgZC5maW5kKGNzLCBpKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSBWLmdldEluc3RhbmNlKG4ucGFyZW50Tm9kZSk7XG4gICAgICAgIG8gJiYgby51cGRhdGUoKTtcbiAgICAgIH0pLCBkLmZpbmQoaHMsIGkpLmZvckVhY2goXG4gICAgICAgIChuKSA9PiB7XG4gICAgICAgICAgY29uc3QgbyA9IFYuZ2V0SW5zdGFuY2Uobi5wYXJlbnROb2RlKTtcbiAgICAgICAgICBvICYmIG8udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSksIGMub24od2luZG93LCBcInJlc2V0XCIsICh0KSA9PiB7XG4gICAgICBkLmZpbmQoY3MsIHQudGFyZ2V0KS5mb3JFYWNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGkgPSBWLmdldEluc3RhbmNlKGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgaSAmJiBpLmZvcmNlSW5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgKSwgZC5maW5kKGhzLCB0LnRhcmdldCkuZm9yRWFjaChcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gVi5nZXRJbnN0YW5jZShlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGkgJiYgaS5mb3JjZUluYWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSksIGMub24od2luZG93LCBcIm9uYXV0b2NvbXBsZXRlXCIsICh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gVi5nZXRJbnN0YW5jZSh0LnRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICFlIHx8ICF0LmNhbmNlbGFibGUgfHwgZS5mb3JjZUFjdGl2ZSgpO1xuICAgIH0pO1xuICB9XG4gIF9zaG93Q291bnRlcigpIHtcbiAgICBpZiAoZC5maW5kKFxuICAgICAgYFske01hfV1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkubGVuZ3RoID4gMClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9jb3VudGVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGguYWRkQ2xhc3ModGhpcy5fY291bnRlckVsZW1lbnQsIHRoaXMuX2NsYXNzZXMuY291bnRlciksIHRoaXMuX2NvdW50ZXJFbGVtZW50LnNldEF0dHJpYnV0ZShNYSwgXCJcIik7XG4gICAgY29uc3QgZSA9IHRoaXMuaW5wdXQudmFsdWUubGVuZ3RoO1xuICAgIHRoaXMuX2NvdW50ZXJFbGVtZW50LmlubmVySFRNTCA9IGAke2V9IC8gJHt0aGlzLl9tYXhMZW5ndGh9YCwgdGhpcy5faGVscGVyLmFwcGVuZENoaWxkKHRoaXMuX2NvdW50ZXJFbGVtZW50KSwgdGhpcy5fYmluZENvdW50ZXIoKTtcbiAgfVxuICBfYmluZENvdW50ZXIoKSB7XG4gICAgYy5vbih0aGlzLmlucHV0LCBcImlucHV0XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmlucHV0LnZhbHVlLmxlbmd0aDtcbiAgICAgIHRoaXMuX2NvdW50ZXJFbGVtZW50LmlubmVySFRNTCA9IGAke3R9IC8gJHt0aGlzLl9tYXhMZW5ndGh9YDtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlRGVmYXVsdERhdGVQbGFjZWhvbGRlcih0ID0gdGhpcy5pbnB1dCkge1xuICAgIGlmICghKHQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PT0gXCJkYXRlXCIpKVxuICAgICAgcmV0dXJuO1xuICAgICEoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdCkgJiYgIXQudmFsdWUgPyB0LnN0eWxlLm9wYWNpdHkgPSAwIDogdC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgfVxuICBfc2hvd1BsYWNlaG9sZGVyKCkge1xuICAgIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKHZmLCBcIlwiKTtcbiAgfVxuICBfZ2V0Tm90Y2hEYXRhKCkge1xuICAgIHRoaXMuX25vdGNoTWlkZGxlID0gZC5maW5kT25lKFxuICAgICAgUGEsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fbm90Y2hMZWFkaW5nID0gZC5maW5kT25lKFxuICAgICAgUmEsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgfVxuICBfZ2V0TGFiZWxXaWR0aCgpIHtcbiAgICB0aGlzLl9sYWJlbFdpZHRoID0gdGhpcy5fbGFiZWwuY2xpZW50V2lkdGggKiAwLjggKyA4O1xuICB9XG4gIF9nZXRMYWJlbFBvc2l0aW9uSW5JbnB1dEdyb3VwKCkge1xuICAgIGlmICh0aGlzLl9sYWJlbE1hcmdpbkxlZnQgPSAwLCAhdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXRlLWlucHV0LWdyb3VwLXJlZlwiKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5pbnB1dCwgZSA9IGQucHJldihcbiAgICAgIHQsXG4gICAgICBcIltkYXRhLXRlLWlucHV0LWdyb3VwLXRleHQtcmVmXVwiXG4gICAgKVswXTtcbiAgICBlID09PSB2b2lkIDAgPyB0aGlzLl9sYWJlbE1hcmdpbkxlZnQgPSAwIDogdGhpcy5fbGFiZWxNYXJnaW5MZWZ0ID0gZS5vZmZzZXRXaWR0aCAtIDE7XG4gIH1cbiAgX2FwcGx5RGl2cygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY29uZmlnLmlucHV0Rm9ybVdoaXRlID8gdGhpcy5fY2xhc3Nlcy5ub3RjaExlYWRpbmdXaGl0ZSA6IHRoaXMuX2NsYXNzZXMubm90Y2hMZWFkaW5nTm9ybWFsLCBlID0gdGhpcy5fY29uZmlnLmlucHV0Rm9ybVdoaXRlID8gdGhpcy5fY2xhc3Nlcy5ub3RjaE1pZGRsZVdoaXRlIDogdGhpcy5fY2xhc3Nlcy5ub3RjaE1pZGRsZU5vcm1hbCwgaSA9IHRoaXMuX2NvbmZpZy5pbnB1dEZvcm1XaGl0ZSA/IHRoaXMuX2NsYXNzZXMubm90Y2hUcmFpbGluZ1doaXRlIDogdGhpcy5fY2xhc3Nlcy5ub3RjaFRyYWlsaW5nTm9ybWFsLCBuID0gZC5maW5kKEllLCB0aGlzLl9lbGVtZW50KSwgbyA9ICQoXCJkaXZcIik7XG4gICAgaC5hZGRDbGFzcyhvLCB0aGlzLl9jbGFzc2VzLm5vdGNoKSwgby5zZXRBdHRyaWJ1dGUoaGgsIFwiXCIpLCB0aGlzLl9ub3RjaExlYWRpbmcgPSAkKFwiZGl2XCIpLCBoLmFkZENsYXNzKFxuICAgICAgdGhpcy5fbm90Y2hMZWFkaW5nLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5ub3RjaExlYWRpbmd9ICR7dH1gXG4gICAgKSwgdGhpcy5fbm90Y2hMZWFkaW5nLnNldEF0dHJpYnV0ZShkaCwgXCJcIiksIHRoaXMuX25vdGNoTWlkZGxlID0gJChcImRpdlwiKSwgaC5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX25vdGNoTWlkZGxlLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5ub3RjaE1pZGRsZX0gJHtlfWBcbiAgICApLCB0aGlzLl9ub3RjaE1pZGRsZS5zZXRBdHRyaWJ1dGUodWgsIFwiXCIpLCB0aGlzLl9ub3RjaFRyYWlsaW5nID0gJChcImRpdlwiKSwgaC5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX25vdGNoVHJhaWxpbmcsXG4gICAgICBgJHt0aGlzLl9jbGFzc2VzLm5vdGNoVHJhaWxpbmd9ICR7aX1gXG4gICAgKSwgdGhpcy5fbm90Y2hUcmFpbGluZy5zZXRBdHRyaWJ1dGUoZ2YsIFwiXCIpLCAhKG4ubGVuZ3RoID49IDEpICYmIChvLmFwcGVuZCh0aGlzLl9ub3RjaExlYWRpbmcpLCBvLmFwcGVuZCh0aGlzLl9ub3RjaE1pZGRsZSksIG8uYXBwZW5kKHRoaXMuX25vdGNoVHJhaWxpbmcpLCB0aGlzLl9lbGVtZW50LmFwcGVuZChvKSk7XG4gIH1cbiAgX2FwcGx5Tm90Y2goKSB7XG4gICAgdGhpcy5fbm90Y2hNaWRkbGUuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9sYWJlbFdpZHRofXB4YCwgdGhpcy5fbm90Y2hMZWFkaW5nLnN0eWxlLndpZHRoID0gYCR7dGhpcy5fbGFiZWxNYXJnaW5MZWZ0ICsgOX1weGAsIHRoaXMuX2xhYmVsICE9PSBudWxsICYmICh0aGlzLl9sYWJlbC5zdHlsZS5tYXJnaW5MZWZ0ID0gYCR7dGhpcy5fbGFiZWxNYXJnaW5MZWZ0fXB4YCk7XG4gIH1cbiAgX3JlbW92ZUJvcmRlcigpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKEllLCB0aGlzLl9lbGVtZW50KTtcbiAgICB0ICYmIHQucmVtb3ZlKCk7XG4gIH1cbiAgX2FjdGl2YXRlKHQpIHtcbiAgICBnYygoKSA9PiB7XG4gICAgICB0aGlzLl9nZXRFbGVtZW50cyh0KTtcbiAgICAgIGNvbnN0IGUgPSB0ID8gdC50YXJnZXQgOiB0aGlzLmlucHV0LCBpID0gZC5maW5kT25lKFxuICAgICAgICBJZSxcbiAgICAgICAgdGhpcy5fZWxlbWVudFxuICAgICAgKTtcbiAgICAgIHQgJiYgdC50eXBlID09PSBcImZvY3VzXCIgJiYgaSAmJiBpLnNldEF0dHJpYnV0ZShOYSwgXCJcIiksIGUudmFsdWUgIT09IFwiXCIgJiYgKGUuc2V0QXR0cmlidXRlKFl0LCBcIlwiKSwgaSAmJiBpLnNldEF0dHJpYnV0ZShZdCwgXCJcIikpLCB0aGlzLl90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKGUpO1xuICAgIH0pO1xuICB9XG4gIF9nZXRFbGVtZW50cyh0KSB7XG4gICAgaWYgKHQgJiYgKHRoaXMuX2VsZW1lbnQgPSB0LnRhcmdldC5wYXJlbnROb2RlLCB0aGlzLl9sYWJlbCA9IGQuZmluZE9uZShcImxhYmVsXCIsIHRoaXMuX2VsZW1lbnQpKSwgdCAmJiB0aGlzLl9sYWJlbCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMuX2xhYmVsV2lkdGg7XG4gICAgICB0aGlzLl9nZXRMYWJlbERhdGEoKSwgZSAhPT0gdGhpcy5fbGFiZWxXaWR0aCAmJiAodGhpcy5fbm90Y2hNaWRkbGUgPSBkLmZpbmRPbmUoXG4gICAgICAgIFBhLFxuICAgICAgICB0LnRhcmdldC5wYXJlbnROb2RlXG4gICAgICApLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBkLmZpbmRPbmUoXG4gICAgICAgIFJhLFxuICAgICAgICB0LnRhcmdldC5wYXJlbnROb2RlXG4gICAgICApLCB0aGlzLl9hcHBseU5vdGNoKCkpO1xuICAgIH1cbiAgfVxuICBfZGVhY3RpdmF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IHQgPyB0LnRhcmdldCA6IHRoaXMuaW5wdXQsIGkgPSBkLmZpbmRPbmUoXG4gICAgICBJZSxcbiAgICAgIGUucGFyZW50Tm9kZVxuICAgICk7XG4gICAgaS5yZW1vdmVBdHRyaWJ1dGUoTmEpLCBlLnZhbHVlID09PSBcIlwiICYmIChlLnJlbW92ZUF0dHJpYnV0ZShZdCksIGkucmVtb3ZlQXR0cmlidXRlKFl0KSksIHRoaXMuX3RvZ2dsZURlZmF1bHREYXRlUGxhY2Vob2xkZXIoZSk7XG4gIH1cbiAgc3RhdGljIGFjdGl2YXRlKHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgdC5fYWN0aXZhdGUoZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVhY3RpdmF0ZSh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHQuX2RlYWN0aXZhdGUoZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSBBLmdldERhdGEodGhpcywgbHMpO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSAmJiAoaSB8fCAoaSA9IG5ldyBWKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIGxzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBCYSA9IFwiYW5pbWF0aW9uXCIsIHRvID0gXCJ0ZS5hbmltYXRpb25cIiwgeWYgPSB7XG4gIGFuaW1hdGlvbjogXCJzdHJpbmdcIixcbiAgYW5pbWF0aW9uU3RhcnQ6IFwic3RyaW5nXCIsXG4gIGFuaW1hdGlvblNob3dPbkxvYWQ6IFwiYm9vbGVhblwiLFxuICBvblN0YXJ0OiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBvbkVuZDogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgb25IaWRlOiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBvblNob3c6IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIGFuaW1hdGlvbk9uU2Nyb2xsOiBcIihzdHJpbmcpXCIsXG4gIGFuaW1hdGlvbldpbmRvd0hlaWdodDogXCJudW1iZXJcIixcbiAgYW5pbWF0aW9uT2Zmc2V0OiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBhbmltYXRpb25EZWxheTogXCIobnVtYmVyfHN0cmluZylcIixcbiAgYW5pbWF0aW9uUmV2ZXJzZTogXCJib29sZWFuXCIsXG4gIGFuaW1hdGlvbkludGVydmFsOiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBhbmltYXRpb25SZXBlYXQ6IFwiKG51bWJlcnxib29sZWFuKVwiLFxuICBhbmltYXRpb25SZXNldDogXCJib29sZWFuXCJcbn0sIHdmID0ge1xuICBhbmltYXRpb246IFwiZmFkZVwiLFxuICBhbmltYXRpb25TdGFydDogXCJvbkNsaWNrXCIsXG4gIGFuaW1hdGlvblNob3dPbkxvYWQ6ICEwLFxuICBvblN0YXJ0OiBudWxsLFxuICBvbkVuZDogbnVsbCxcbiAgb25IaWRlOiBudWxsLFxuICBvblNob3c6IG51bGwsXG4gIGFuaW1hdGlvbk9uU2Nyb2xsOiBcIm9uY2VcIixcbiAgYW5pbWF0aW9uV2luZG93SGVpZ2h0OiAwLFxuICBhbmltYXRpb25PZmZzZXQ6IDAsXG4gIGFuaW1hdGlvbkRlbGF5OiAwLFxuICBhbmltYXRpb25SZXZlcnNlOiAhMSxcbiAgYW5pbWF0aW9uSW50ZXJ2YWw6IDAsXG4gIGFuaW1hdGlvblJlcGVhdDogITEsXG4gIGFuaW1hdGlvblJlc2V0OiAhMVxufTtcbmNsYXNzIHdyIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9hbmltYXRlRWxlbWVudCA9IHRoaXMuX2dldEFuaW1hdGVFbGVtZW50KCksIHRoaXMuX2lzRmlyc3RTY3JvbGwgPSAhMCwgdGhpcy5fcmVwZWF0QW5pbWF0ZU9uU2Nyb2xsID0gITAsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2VsZW1lbnQgJiYgKEEuc2V0RGF0YSh0LCB0bywgdGhpcyksIHRoaXMuX2luaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEJhO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuICBzdGFydEFuaW1hdGlvbigpIHtcbiAgICB0aGlzLl9zdGFydEFuaW1hdGlvbigpO1xuICB9XG4gIHN0b3BBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fY2xlYXJBbmltYXRpb25DbGFzcygpO1xuICB9XG4gIGNoYW5nZUFuaW1hdGlvblR5cGUodCkge1xuICAgIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uID0gdDtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwibW91c2Vkb3duXCIpLCBjLm9mZih0aGlzLl9hbmltYXRlRWxlbWVudCwgXCJhbmltYXRpb25lbmRcIiksIGMub2ZmKHdpbmRvdywgXCJzY3JvbGxcIiksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwibW91c2VvdmVyXCIpLCBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgdG8pLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fYW5pbWF0ZUVsZW1lbnQgPSBudWxsLCB0aGlzLl9pc0ZpcnN0U2Nyb2xsID0gbnVsbCwgdGhpcy5fcmVwZWF0QW5pbWF0ZU9uU2Nyb2xsID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uU3RhcnQpIHtcbiAgICAgIGNhc2UgXCJvbkhvdmVyXCI6XG4gICAgICAgIHRoaXMuX2JpbmRIb3ZlckV2ZW50cygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvbkxvYWRcIjpcbiAgICAgICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib25TY3JvbGxcIjpcbiAgICAgICAgdGhpcy5fYmluZFNjcm9sbEV2ZW50cygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvbkNsaWNrXCI6XG4gICAgICAgIHRoaXMuX2JpbmRDbGlja0V2ZW50cygpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fYmluZFRyaWdnZXJPbkVuZENhbGxiYWNrKCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVzZXQgJiYgdGhpcy5fYmluZFJlc2V0QW5pbWF0aW9uQWZ0ZXJGaW5pc2goKTtcbiAgfVxuICBfZ2V0QW5pbWF0ZUVsZW1lbnQoKSB7XG4gICAgY29uc3QgdCA9IGguZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImFuaW1hdGlvbi10YXJnZXRcIlxuICAgICk7XG4gICAgcmV0dXJuIHQgPyBkLmZpbmQodClbMF0gOiB0aGlzLl9lbGVtZW50O1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2FuaW1hdGVFbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLndmLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKEJhLCB0LCB5ZiksIHQ7XG4gIH1cbiAgX2FuaW1hdGVPblNjcm9sbCgpIHtcbiAgICBjb25zdCB0ID0gaC5vZmZzZXQodGhpcy5fYW5pbWF0ZUVsZW1lbnQpLnRvcCwgZSA9IHRoaXMuX2FuaW1hdGVFbGVtZW50Lm9mZnNldEhlaWdodCwgaSA9IHdpbmRvdy5pbm5lckhlaWdodCwgbiA9IHQgKyB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbk9mZnNldCA8PSBpICYmIHQgKyB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbk9mZnNldCArIGUgPj0gMCwgbyA9IHRoaXMuX2FuaW1hdGVFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPT09IFwidmlzaWJsZVwiO1xuICAgIHN3aXRjaCAoITApIHtcbiAgICAgIGNhc2UgKG4gJiYgdGhpcy5faXNGaXJzdFNjcm9sbCk6XG4gICAgICAgIHRoaXMuX2lzRmlyc3RTY3JvbGwgPSAhMSwgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICghbiAmJiB0aGlzLl9pc0ZpcnN0U2Nyb2xsKTpcbiAgICAgICAgdGhpcy5faXNGaXJzdFNjcm9sbCA9ICExLCB0aGlzLl9oaWRlQW5pbWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIChuICYmICFvICYmIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCk6XG4gICAgICAgIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uT25TY3JvbGwgIT09IFwicmVwZWF0XCIgJiYgKHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCA9ICExKSwgdGhpcy5fY2FsbGJhY2sodGhpcy5fb3B0aW9ucy5vblNob3cpLCB0aGlzLl9zaG93QW5pbWF0ZUVsZW1lbnQoKSwgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICghbiAmJiBvICYmIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCk6XG4gICAgICAgIHRoaXMuX2hpZGVBbmltYXRlRWxlbWVudCgpLCB0aGlzLl9jbGVhckFuaW1hdGlvbkNsYXNzKCksIHRoaXMuX2NhbGxiYWNrKHRoaXMuX29wdGlvbnMub25IaWRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIF9hZGRBbmltYXRlZENsYXNzKCkge1xuICAgIGguYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9hbmltYXRlRWxlbWVudCxcbiAgICAgIGBhbmltYXRlLSR7dGhpcy5fb3B0aW9ucy5hbmltYXRpb259YFxuICAgICk7XG4gIH1cbiAgX2NsZWFyQW5pbWF0aW9uQ2xhc3MoKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShgYW5pbWF0ZS0ke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9ufWApO1xuICB9XG4gIF9zdGFydEFuaW1hdGlvbigpIHtcbiAgICB0aGlzLl9jYWxsYmFjayh0aGlzLl9vcHRpb25zLm9uU3RhcnQpLCB0aGlzLl9hZGRBbmltYXRlZENsYXNzKCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVwZWF0ICYmICF0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkludGVydmFsICYmIHRoaXMuX3NldEFuaW1hdGlvblJlcGVhdCgpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJldmVyc2UgJiYgdGhpcy5fc2V0QW5pbWF0aW9uUmV2ZXJzZSgpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkRlbGF5ICYmIHRoaXMuX3NldEFuaW1hdGlvbkRlbGF5KCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24gJiYgdGhpcy5fc2V0QW5pbWF0aW9uRHVyYXRpb24oKSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25JbnRlcnZhbCAmJiB0aGlzLl9zZXRBbmltYXRpb25JbnRlcnZhbCgpO1xuICB9XG4gIF9zZXRBbmltYXRpb25SZXZlcnNlKCkge1xuICAgIGguc3R5bGUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIHtcbiAgICAgIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJlcGVhdCA9PT0gITAgPyBcImluZmluaXRlXCIgOiBcIjJcIixcbiAgICAgIGFuaW1hdGlvbkRpcmVjdGlvbjogXCJhbHRlcm5hdGVcIlxuICAgIH0pO1xuICB9XG4gIF9zZXRBbmltYXRpb25EdXJhdGlvbigpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7XG4gICAgICBhbmltYXRpb25EdXJhdGlvbjogYCR7dGhpcy5fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbn1tc2BcbiAgICB9KTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uRGVsYXkoKSB7XG4gICAgaC5zdHlsZSh0aGlzLl9hbmltYXRlRWxlbWVudCwge1xuICAgICAgYW5pbWF0aW9uRGVsYXk6IGAke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9uRGVsYXl9bXNgXG4gICAgfSk7XG4gIH1cbiAgX3NldEFuaW1hdGlvblJlcGVhdCgpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7XG4gICAgICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXBlYXQgPT09ICEwID8gXCJpbmZpbml0ZVwiIDogdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXBlYXRcbiAgICB9KTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uSW50ZXJ2YWwoKSB7XG4gICAgYy5vbih0aGlzLl9hbmltYXRlRWxlbWVudCwgXCJhbmltYXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fY2xlYXJBbmltYXRpb25DbGFzcygpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fYWRkQW5pbWF0ZWRDbGFzcygpO1xuICAgICAgfSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25JbnRlcnZhbCk7XG4gICAgfSk7XG4gIH1cbiAgX2hpZGVBbmltYXRlRWxlbWVudCgpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7IHZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfSk7XG4gIH1cbiAgX3Nob3dBbmltYXRlRWxlbWVudCgpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7IHZpc2liaWxpdHk6IFwidmlzaWJsZVwiIH0pO1xuICB9XG4gIF9iaW5kUmVzZXRBbmltYXRpb25BZnRlckZpbmlzaCgpIHtcbiAgICBjLm9uKHRoaXMuX2FuaW1hdGVFbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jbGVhckFuaW1hdGlvbkNsYXNzKCk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRUcmlnZ2VyT25FbmRDYWxsYmFjaygpIHtcbiAgICBjLm9uKHRoaXMuX2FuaW1hdGVFbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jYWxsYmFjayh0aGlzLl9vcHRpb25zLm9uRW5kKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZFNjcm9sbEV2ZW50cygpIHtcbiAgICB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblNob3dPbkxvYWQgfHwgdGhpcy5fYW5pbWF0ZU9uU2Nyb2xsKCksIGMub24od2luZG93LCBcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9hbmltYXRlT25TY3JvbGwoKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZENsaWNrRXZlbnRzKCkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJtb3VzZWRvd25cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZEhvdmVyRXZlbnRzKCkge1xuICAgIGMub25lKHRoaXMuX2VsZW1lbnQsIFwibW91c2VvdmVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgfSksIGMub25lKHRoaXMuX2FuaW1hdGVFbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fYmluZEhvdmVyRXZlbnRzKCk7XG4gICAgICB9LCAxMDApO1xuICAgIH0pO1xuICB9XG4gIF9jYWxsYmFjayh0KSB7XG4gICAgdCBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIHQoKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGF1dG9Jbml0KHQpIHtcbiAgICB0Ll9pbml0KCk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgbmV3IHdyKHRoaXNbMF0sIHQpLmluaXQoKTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgdG8pO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IGtmID0ge1xuICBwcm9wZXJ0eTogXCJjb2xvclwiLFxuICBkZWZhdWx0VmFsdWU6IG51bGwsXG4gIGluaGVyaXQ6ICEwXG59LCBEZSA9IChzLCB0KSA9PiB7XG4gIGNvbnN0IHsgcHJvcGVydHk6IGUsIGRlZmF1bHRWYWx1ZTogaSwgaW5oZXJpdDogbiB9ID0geyAuLi5rZiwgLi4udCB9LCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgby5jbGFzc0xpc3QuYWRkKHMpLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG8pO1xuICBjb25zdCBhID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobylbZV0gfHwgaSwgcCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG8ucGFyZW50RWxlbWVudClbZV07XG4gIHJldHVybiBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG8pLCAhbiAmJiBwICYmIGEgPT09IHAgPyBpIDogYSB8fCBpO1xufSwgZW8gPSBcInJpcHBsZVwiLCBkcyA9IFwidGUucmlwcGxlXCIsIHhmID0gXCJyZ2JhKHt7Y29sb3J9fSwgMC4yKSAwLCByZ2JhKHt7Y29sb3J9fSwgMC4zKSA0MCUsIHJnYmEoe3tjb2xvcn19LCAwLjQpIDUwJSwgcmdiYSh7e2NvbG9yfX0sIDAuNSkgNjAlLCByZ2JhKHt7Y29sb3J9fSwgMCkgNzAlXCIsIE9mID0gW1wiW2RhdGEtdGUtcmlwcGxlLWluaXRdXCJdLCB1cyA9IFswLCAwLCAwXSwgU2YgPSBbXG4gIHtcbiAgICBuYW1lOiBcInByaW1hcnlcIixcbiAgICBncmFkaWVudENvbG9yOiBEZShcInRleHQtcHJpbWFyeVwiLCB7IGRlZmF1bHRWYWx1ZTogXCIjM0I3MUNBXCIsIGluaGVyaXQ6ICExIH0pXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcInNlY29uZGFyeVwiLFxuICAgIGdyYWRpZW50Q29sb3I6IERlKFwidGV4dC1zZWNvbmRhcnlcIiwgeyBkZWZhdWx0VmFsdWU6IFwiIzlGQTZCMlwiLCBpbmhlcml0OiAhMSB9KVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJzdWNjZXNzXCIsXG4gICAgZ3JhZGllbnRDb2xvcjogRGUoXCJ0ZXh0LXN1Y2Nlc3NcIiwgeyBkZWZhdWx0VmFsdWU6IFwiIzE0QTQ0RFwiLCBpbmhlcml0OiAhMSB9KVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJkYW5nZXJcIixcbiAgICBncmFkaWVudENvbG9yOiBEZShcInRleHQtZGFuZ2VyXCIsIHsgZGVmYXVsdFZhbHVlOiBcIiNEQzRDNjRcIiwgaW5oZXJpdDogITEgfSlcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwid2FybmluZ1wiLFxuICAgIGdyYWRpZW50Q29sb3I6IERlKFwidGV4dC13YXJuaW5nXCIsIHsgZGVmYXVsdFZhbHVlOiBcIiNFNEExMUJcIiwgaW5oZXJpdDogITEgfSlcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiaW5mb1wiLFxuICAgIGdyYWRpZW50Q29sb3I6IERlKFwidGV4dC1pbmZvXCIsIHsgZGVmYXVsdFZhbHVlOiBcIiM1NEI0RDNcIiwgaW5oZXJpdDogITEgfSlcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwibGlnaHRcIixcbiAgICBncmFkaWVudENvbG9yOiBcIiNmYmZiZmJcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJkYXJrXCIsXG4gICAgZ3JhZGllbnRDb2xvcjogXCIjMjYyNjI2XCJcbiAgfVxuXSwgSGEgPSAwLjUsIElmID0ge1xuICByaXBwbGVDZW50ZXJlZDogITEsXG4gIHJpcHBsZUNvbG9yOiBcIlwiLFxuICByaXBwbGVDb2xvckRhcms6IFwiXCIsXG4gIHJpcHBsZUR1cmF0aW9uOiBcIjUwMG1zXCIsXG4gIHJpcHBsZVJhZGl1czogMCxcbiAgcmlwcGxlVW5ib3VuZDogITFcbn0sIERmID0ge1xuICByaXBwbGVDZW50ZXJlZDogXCJib29sZWFuXCIsXG4gIHJpcHBsZUNvbG9yOiBcInN0cmluZ1wiLFxuICByaXBwbGVDb2xvckRhcms6IFwic3RyaW5nXCIsXG4gIHJpcHBsZUR1cmF0aW9uOiBcInN0cmluZ1wiLFxuICByaXBwbGVSYWRpdXM6IFwibnVtYmVyXCIsXG4gIHJpcHBsZVVuYm91bmQ6IFwiYm9vbGVhblwiXG59LCAkZiA9IHtcbiAgcmlwcGxlOiBcInJlbGF0aXZlIG92ZXJmbG93LWhpZGRlbiBpbmxpbmUtYmxvY2sgYWxpZ24tYm90dG9tXCIsXG4gIHJpcHBsZVdhdmU6IFwicm91bmRlZC1bNTAlXSBvcGFjaXR5LTUwIHBvaW50ZXItZXZlbnRzLW5vbmUgYWJzb2x1dGUgdG91Y2gtbm9uZSBzY2FsZS0wIHRyYW5zaXRpb24tW3RyYW5zZm9ybSxfb3BhY2l0eV0gZWFzZS1bY3ViaWMtYmV6aWVyKDAsMCwwLjE1LDEpLF9jdWJpYy1iZXppZXIoMCwwLDAuMTUsMSldIHotWzk5OV1cIixcbiAgdW5ib3VuZDogXCJvdmVyZmxvdy12aXNpYmxlXCJcbn0sIExmID0ge1xuICByaXBwbGU6IFwic3RyaW5nXCIsXG4gIHJpcHBsZVdhdmU6IFwic3RyaW5nXCIsXG4gIHVuYm91bmQ6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBlaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2VsZW1lbnQgJiYgKEEuc2V0RGF0YSh0LCBkcywgdGhpcyksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5yaXBwbGUpKSwgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5fY3JlYXRlUmlwcGxlLmJpbmQodGhpcyksIHRoaXMuX3JpcHBsZVRpbWVyID0gbnVsbCwgdGhpcy5faXNNaW5XaWR0aFNldCA9ICExLCB0aGlzLl9pbml0aWFsQ2xhc3NlcyA9IG51bGwsIHRoaXMuaW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBlbztcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9hZGRDbGlja0V2ZW50KHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIGRzKSwgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfYXV0b0luaXQodCkge1xuICAgIE9mLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGQuY2xvc2VzdCh0LnRhcmdldCwgZSkgJiYgKHRoaXMuX2VsZW1lbnQgPSBkLmNsb3Nlc3QodC50YXJnZXQsIGUpKTtcbiAgICB9KSwgdGhpcy5fZWxlbWVudC5zdHlsZS5taW5XaWR0aCB8fCAoaC5zdHlsZSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICBcIm1pbi13aWR0aFwiOiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpLndpZHRoXG4gICAgfSksIHRoaXMuX2lzTWluV2lkdGhTZXQgPSAhMCksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoKSwgdGhpcy5faW5pdGlhbENsYXNzZXMgPSBbLi4udGhpcy5fZWxlbWVudC5jbGFzc0xpc3RdLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMucmlwcGxlKSwgdGhpcy5fY3JlYXRlUmlwcGxlKHQpO1xuICB9XG4gIF9hZGRDbGlja0V2ZW50KHQpIHtcbiAgICBjLm9uKHQsIFwibW91c2Vkb3duXCIsIHRoaXMuX2NsaWNrSGFuZGxlcik7XG4gIH1cbiAgX2NyZWF0ZVJpcHBsZSh0KSB7XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZih0aGlzLl9jbGFzc2VzLnJpcHBsZSkgPCAwICYmIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5yaXBwbGUpO1xuICAgIGNvbnN0IHsgbGF5ZXJYOiBlLCBsYXllclk6IGkgfSA9IHQsIG4gPSB0Lm9mZnNldFggfHwgZSwgbyA9IHQub2Zmc2V0WSB8fCBpLCByID0gdGhpcy5fZWxlbWVudC5vZmZzZXRIZWlnaHQsIGEgPSB0aGlzLl9lbGVtZW50Lm9mZnNldFdpZHRoLCBsID0gdGhpcy5fZHVyYXRpb25Ub01zTnVtYmVyKHRoaXMuX29wdGlvbnMucmlwcGxlRHVyYXRpb24pLCBwID0ge1xuICAgICAgb2Zmc2V0WDogdGhpcy5fb3B0aW9ucy5yaXBwbGVDZW50ZXJlZCA/IHIgLyAyIDogbixcbiAgICAgIG9mZnNldFk6IHRoaXMuX29wdGlvbnMucmlwcGxlQ2VudGVyZWQgPyBhIC8gMiA6IG8sXG4gICAgICBoZWlnaHQ6IHIsXG4gICAgICB3aWR0aDogYVxuICAgIH0sIHUgPSB0aGlzLl9nZXREaWFtZXRlcihwKSwgXyA9IHRoaXMuX29wdGlvbnMucmlwcGxlUmFkaXVzIHx8IHUgLyAyLCBmID0ge1xuICAgICAgZGVsYXk6IGwgKiBIYSxcbiAgICAgIGR1cmF0aW9uOiBsIC0gbCAqIEhhXG4gICAgfSwgZyA9IHtcbiAgICAgIGxlZnQ6IHRoaXMuX29wdGlvbnMucmlwcGxlQ2VudGVyZWQgPyBgJHthIC8gMiAtIF99cHhgIDogYCR7biAtIF99cHhgLFxuICAgICAgdG9wOiB0aGlzLl9vcHRpb25zLnJpcHBsZUNlbnRlcmVkID8gYCR7ciAvIDIgLSBffXB4YCA6IGAke28gLSBffXB4YCxcbiAgICAgIGhlaWdodDogYCR7dGhpcy5fb3B0aW9ucy5yaXBwbGVSYWRpdXMgKiAyIHx8IHV9cHhgLFxuICAgICAgd2lkdGg6IGAke3RoaXMuX29wdGlvbnMucmlwcGxlUmFkaXVzICogMiB8fCB1fXB4YCxcbiAgICAgIHRyYW5zaXRpb25EZWxheTogYDBzLCAke2YuZGVsYXl9bXNgLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBgJHtsfW1zLCAke2YuZHVyYXRpb259bXNgXG4gICAgfSwgbSA9ICQoXCJkaXZcIik7XG4gICAgdGhpcy5fY3JlYXRlSFRNTFJpcHBsZSh7XG4gICAgICB3cmFwcGVyOiB0aGlzLl9lbGVtZW50LFxuICAgICAgcmlwcGxlOiBtLFxuICAgICAgc3R5bGVzOiBnXG4gICAgfSksIHRoaXMuX3JlbW92ZUhUTUxSaXBwbGUoeyByaXBwbGU6IG0sIGR1cmF0aW9uOiBsIH0pO1xuICB9XG4gIF9jcmVhdGVIVE1MUmlwcGxlKHsgd3JhcHBlcjogdCwgcmlwcGxlOiBlLCBzdHlsZXM6IGkgfSkge1xuICAgIE9iamVjdC5rZXlzKGkpLmZvckVhY2goXG4gICAgICAobikgPT4gZS5zdHlsZVtuXSA9IGlbbl1cbiAgICApLCBoLmFkZENsYXNzKGUsIHRoaXMuX2NsYXNzZXMucmlwcGxlV2F2ZSksIGUuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1yaXBwbGUtcmVmXCIsIFwiXCIpLCB0aGlzLl9hZGRDb2xvcihlLCB0KSwgdGhpcy5fdG9nZ2xlVW5ib3VuZCh0KSwgdGhpcy5fYXBwZW5kUmlwcGxlKGUsIHQpO1xuICB9XG4gIF9yZW1vdmVIVE1MUmlwcGxlKHsgcmlwcGxlOiB0LCBkdXJhdGlvbjogZSB9KSB7XG4gICAgdGhpcy5fcmlwcGxlVGltZXIgJiYgKGNsZWFyVGltZW91dCh0aGlzLl9yaXBwbGVUaW1lciksIHRoaXMuX3JpcHBsZVRpbWVyID0gbnVsbCksIHQgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0LmNsYXNzTGlzdC5hZGQoXCIhb3BhY2l0eS0wXCIpO1xuICAgIH0sIDEwKSwgdGhpcy5fcmlwcGxlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0ICYmICh0LnJlbW92ZSgpLCB0aGlzLl9lbGVtZW50KSkge1xuICAgICAgICBkLmZpbmQoXCJbZGF0YS10ZS1yaXBwbGUtcmVmXVwiLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKFxuICAgICAgICAgIChuKSA9PiB7XG4gICAgICAgICAgICBuLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSwgdGhpcy5faXNNaW5XaWR0aFNldCAmJiAoaC5zdHlsZSh0aGlzLl9lbGVtZW50LCB7IFwibWluLXdpZHRoXCI6IFwiXCIgfSksIHRoaXMuX2lzTWluV2lkdGhTZXQgPSAhMSk7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl9pbml0aWFsQ2xhc3NlcyA/IHRoaXMuX2FkZGVkTmV3UmlwcGxlQ2xhc3NlcyhcbiAgICAgICAgICB0aGlzLl9jbGFzc2VzLnJpcHBsZSxcbiAgICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3Nlc1xuICAgICAgICApIDogdGhpcy5fY2xhc3Nlcy5yaXBwbGUuc3BsaXQoXCIgXCIpO1xuICAgICAgICBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIGkpO1xuICAgICAgfVxuICAgIH0sIGUpO1xuICB9XG4gIF9hZGRlZE5ld1JpcHBsZUNsYXNzZXModCwgZSkge1xuICAgIHJldHVybiB0LnNwbGl0KFwiIFwiKS5maWx0ZXIoXG4gICAgICAoaSkgPT4gZS5maW5kSW5kZXgoKG4pID0+IGkgPT09IG4pID09PSAtMVxuICAgICk7XG4gIH1cbiAgX2R1cmF0aW9uVG9Nc051bWJlcih0KSB7XG4gICAgcmV0dXJuIE51bWJlcih0LnJlcGxhY2UoXCJtc1wiLCBcIlwiKS5yZXBsYWNlKFwic1wiLCBcIjAwMFwiKSk7XG4gIH1cbiAgX2dldENvbmZpZyh0ID0ge30pIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLklmLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKGVvLCB0LCBEZiksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCA9IHt9KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLiRmLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKGVvLCB0LCBMZiksIHQ7XG4gIH1cbiAgX2dldERpYW1ldGVyKHsgb2Zmc2V0WDogdCwgb2Zmc2V0WTogZSwgaGVpZ2h0OiBpLCB3aWR0aDogbiB9KSB7XG4gICAgY29uc3QgbyA9IGUgPD0gaSAvIDIsIHIgPSB0IDw9IG4gLyAyLCBhID0gKGYsIGcpID0+IE1hdGguc3FydChmICoqIDIgKyBnICoqIDIpLCBsID0gZSA9PT0gaSAvIDIgJiYgdCA9PT0gbiAvIDIsIHAgPSB7XG4gICAgICBmaXJzdDogbyA9PT0gITAgJiYgciA9PT0gITEsXG4gICAgICBzZWNvbmQ6IG8gPT09ICEwICYmIHIgPT09ICEwLFxuICAgICAgdGhpcmQ6IG8gPT09ICExICYmIHIgPT09ICEwLFxuICAgICAgZm91cnRoOiBvID09PSAhMSAmJiByID09PSAhMVxuICAgIH0sIHUgPSB7XG4gICAgICB0b3BMZWZ0OiBhKHQsIGUpLFxuICAgICAgdG9wUmlnaHQ6IGEobiAtIHQsIGUpLFxuICAgICAgYm90dG9tTGVmdDogYSh0LCBpIC0gZSksXG4gICAgICBib3R0b21SaWdodDogYShuIC0gdCwgaSAtIGUpXG4gICAgfTtcbiAgICBsZXQgXyA9IDA7XG4gICAgcmV0dXJuIGwgfHwgcC5mb3VydGggPyBfID0gdS50b3BMZWZ0IDogcC50aGlyZCA/IF8gPSB1LnRvcFJpZ2h0IDogcC5zZWNvbmQgPyBfID0gdS5ib3R0b21SaWdodCA6IHAuZmlyc3QgJiYgKF8gPSB1LmJvdHRvbUxlZnQpLCBfICogMjtcbiAgfVxuICBfYXBwZW5kUmlwcGxlKHQsIGUpIHtcbiAgICBlLmFwcGVuZENoaWxkKHQpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGguYWRkQ2xhc3ModCwgXCJvcGFjaXR5LTAgc2NhbGUtMTAwXCIpO1xuICAgIH0sIDUwKTtcbiAgfVxuICBfdG9nZ2xlVW5ib3VuZCh0KSB7XG4gICAgdGhpcy5fb3B0aW9ucy5yaXBwbGVVbmJvdW5kID09PSAhMCA/IGguYWRkQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy51bmJvdW5kKSA6IGgucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy51bmJvdW5kKTtcbiAgfVxuICBfYWRkQ29sb3IodCkge1xuICAgIGxldCBlID0gdGhpcy5fb3B0aW9ucy5yaXBwbGVDb2xvciB8fCBcInJnYigwLDAsMClcIjtcbiAgICAobG9jYWxTdG9yYWdlLnRoZW1lID09PSBcImRhcmtcIiB8fCAhKFwidGhlbWVcIiBpbiBsb2NhbFN0b3JhZ2UpICYmIHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzKSAmJiAoZSA9IHRoaXMuX29wdGlvbnMucmlwcGxlQ29sb3JEYXJrIHx8IHRoaXMuX29wdGlvbnMucmlwcGxlQ29sb3IpO1xuICAgIGNvbnN0IGkgPSBTZi5maW5kKFxuICAgICAgKHIpID0+IHIubmFtZSA9PT0gZS50b0xvd2VyQ2FzZSgpXG4gICAgKSwgbiA9IGkgPyB0aGlzLl9jb2xvclRvUkdCKGkuZ3JhZGllbnRDb2xvcikuam9pbihcIixcIikgOiB0aGlzLl9jb2xvclRvUkdCKGUpLmpvaW4oXCIsXCIpLCBvID0geGYuc3BsaXQoXCJ7e2NvbG9yfX1cIikuam9pbihgJHtufWApO1xuICAgIHQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHJhZGlhbC1ncmFkaWVudChjaXJjbGUsICR7b30pYDtcbiAgfVxuICBfY29sb3JUb1JHQih0KSB7XG4gICAgZnVuY3Rpb24gZShvKSB7XG4gICAgICByZXR1cm4gby5sZW5ndGggPCA3ICYmIChvID0gYCMke29bMV19JHtvWzFdfSR7b1syXX0ke29bMl19JHtvWzNdfSR7b1szXX1gKSwgW1xuICAgICAgICBwYXJzZUludChvLnN1YnN0cigxLCAyKSwgMTYpLFxuICAgICAgICBwYXJzZUludChvLnN1YnN0cigzLCAyKSwgMTYpLFxuICAgICAgICBwYXJzZUludChvLnN1YnN0cig1LCAyKSwgMTYpXG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpKG8pIHtcbiAgICAgIGNvbnN0IHIgPSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKFxuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmljdHVtXCIpXG4gICAgICApLCBhID0gXCJyZ2IoMSwgMiwgMylcIjtcbiAgICAgIHJldHVybiByLnN0eWxlLmNvbG9yID0gYSwgci5zdHlsZS5jb2xvciAhPT0gYSB8fCAoci5zdHlsZS5jb2xvciA9IG8sIHIuc3R5bGUuY29sb3IgPT09IGEgfHwgci5zdHlsZS5jb2xvciA9PT0gXCJcIikgPyB1cyA6IChvID0gZ2V0Q29tcHV0ZWRTdHlsZShyKS5jb2xvciwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChyKSwgbyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG4obykge1xuICAgICAgcmV0dXJuIG8gPSBvLm1hdGNoKC9bLlxcZF0rL2cpLm1hcCgocikgPT4gK051bWJlcihyKSksIG8ubGVuZ3RoID0gMywgbztcbiAgICB9XG4gICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cmFuc3BhcmVudFwiID8gdXMgOiB0WzBdID09PSBcIiNcIiA/IGUodCkgOiAodC5pbmRleE9mKFwicmdiXCIpID09PSAtMSAmJiAodCA9IGkodCkpLCB0LmluZGV4T2YoXCJyZ2JcIikgPT09IDAgPyBuKHQpIDogdXMpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgYXV0b0luaXRpYWwodCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICB0Ll9hdXRvSW5pdChlKTtcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQS5nZXREYXRhKHRoaXMsIGRzKSA/IG51bGwgOiBuZXcgZWkodGhpcywgdCk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIGRzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5mdW5jdGlvbiB0dChzKSB7XG4gIHJldHVybiBzLmdldERhdGUoKTtcbn1cbmZ1bmN0aW9uIHpzKHMpIHtcbiAgcmV0dXJuIHMuZ2V0RGF5KCk7XG59XG5mdW5jdGlvbiBZKHMpIHtcbiAgcmV0dXJuIHMuZ2V0TW9udGgoKTtcbn1cbmZ1bmN0aW9uIEIocykge1xuICByZXR1cm4gcy5nZXRGdWxsWWVhcigpO1xufVxuZnVuY3Rpb24gTmYocywgdCwgZSkge1xuICBjb25zdCBpID0gZS5zdGFydERheSwgbiA9IGkgPiAwID8gNyAtIGkgOiAwLCByID0gbmV3IERhdGUocywgdCkuZ2V0RGF5KCkgKyBuO1xuICByZXR1cm4gciA+PSA3ID8gciAtIDcgOiByO1xufVxuZnVuY3Rpb24gR28ocykge1xuICByZXR1cm4gTWYocykuZ2V0RGF0ZSgpO1xufVxuZnVuY3Rpb24gTWYocykge1xuICByZXR1cm4gQ3Qocy5nZXRGdWxsWWVhcigpLCBzLmdldE1vbnRoKCkgKyAxLCAwKTtcbn1cbmZ1bmN0aW9uIGplKCkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG59XG5mdW5jdGlvbiBhdChzLCB0KSB7XG4gIHJldHVybiBsdChzLCB0ICogMTIpO1xufVxuZnVuY3Rpb24gbHQocywgdCkge1xuICBjb25zdCBlID0gQ3QoXG4gICAgcy5nZXRGdWxsWWVhcigpLFxuICAgIHMuZ2V0TW9udGgoKSArIHQsXG4gICAgcy5nZXREYXRlKClcbiAgKSwgaSA9IHR0KHMpLCBuID0gdHQoZSk7XG4gIHJldHVybiBpICE9PSBuICYmIGUuc2V0RGF0ZSgwKSwgZTtcbn1cbmZ1bmN0aW9uICRlKHMsIHQpIHtcbiAgcmV0dXJuIEN0KHMuZ2V0RnVsbFllYXIoKSwgcy5nZXRNb250aCgpLCBzLmdldERhdGUoKSArIHQpO1xufVxuZnVuY3Rpb24gQ3QocywgdCwgZSkge1xuICBjb25zdCBpID0gbmV3IERhdGUocywgdCwgZSk7XG4gIHJldHVybiBzID49IDAgJiYgcyA8IDEwMCAmJiBpLnNldEZ1bGxZZWFyKGkuZ2V0RnVsbFllYXIoKSAtIDE5MDApLCBpO1xufVxuZnVuY3Rpb24gVmEocykge1xuICBjb25zdCB0ID0gcy5zcGxpdChcIi1cIiksIGUgPSB0WzBdLCBpID0gdFsxXSwgbiA9IHRbMl07XG4gIHJldHVybiBDdChlLCBpLCBuKTtcbn1cbmZ1bmN0aW9uIFJmKHMpIHtcbiAgcmV0dXJuICFOdW1iZXIuaXNOYU4ocy5nZXRUaW1lKCkpO1xufVxuZnVuY3Rpb24gRmUocywgdCkge1xuICByZXR1cm4gQihzKSAtIEIodCkgfHwgWShzKSAtIFkodCkgfHwgdHQocykgLSB0dCh0KTtcbn1cbmZ1bmN0aW9uIG1lKHMsIHQpIHtcbiAgcmV0dXJuIHMuc2V0SG91cnMoMCwgMCwgMCwgMCksIHQuc2V0SG91cnMoMCwgMCwgMCwgMCksIHMuZ2V0VGltZSgpID09PSB0LmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uIFVzKHMsIHQpIHtcbiAgY29uc3QgaSA9IEIocykgLSBCZigpO1xuICByZXR1cm4gUGYoaSwgdCk7XG59XG5mdW5jdGlvbiBQZihzLCB0KSB7XG4gIHJldHVybiAocyAlIHQgKyB0KSAlIHQ7XG59XG5mdW5jdGlvbiBCZihzLCB0LCBlKSB7XG4gIGxldCBpID0gMDtcbiAgcmV0dXJuIGUgPyBpID0gQihlKSAtIHMgKyAxIDogdCAmJiAoaSA9IEIodCkpLCBpO1xufVxuZnVuY3Rpb24gX24ocywgdCwgZSwgaSwgbiwgbykge1xuICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIHIuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIGNvbnN0IGEgPSB0ICYmIEZlKHMsIHQpIDw9IC0xLCBsID0gZSAmJiBGZShzLCBlKSA+PSAxLCBwID0gbiAmJiBGZShzLCByKSA8PSAtMSwgdSA9IG8gJiYgRmUocywgcikgPj0gMSwgXyA9IGkgJiYgaShzKSA9PT0gITE7XG4gIHJldHVybiBhIHx8IGwgfHwgXyB8fCBwIHx8IHU7XG59XG5mdW5jdGlvbiBfaChzLCB0LCBlLCBpLCBuLCBvKSB7XG4gIGNvbnN0IHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgYSA9IGkgJiYgQihpKSwgbCA9IGkgJiYgWShpKSwgcCA9IGUgJiYgQihlKSwgdSA9IGUgJiYgWShlKSwgXyA9IEIociksIGYgPSBZKHIpLCBnID0gbCAmJiBhICYmICh0ID4gYSB8fCB0ID09PSBhICYmIHMgPiBsKSwgbSA9IHUgJiYgcCAmJiAodCA8IHAgfHwgdCA9PT0gcCAmJiBzIDwgdSksIGIgPSBuICYmICh0IDwgXyB8fCB0ID09PSBfICYmIHMgPCBmKSwgdiA9IG8gJiYgKHQgPiBfIHx8IHQgPT09IF8gJiYgcyA+IGYpO1xuICByZXR1cm4gZyB8fCBtIHx8IGIgfHwgdjtcbn1cbmZ1bmN0aW9uIHFvKHMsIHQsIGUsIGksIG4pIHtcbiAgY29uc3QgbyA9IHQgJiYgQih0KSwgciA9IGUgJiYgQihlKSwgYSA9IEIoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLCBsID0gciAmJiBzID4gciwgcCA9IG8gJiYgcyA8IG8sIHUgPSBpICYmIHMgPCBhLCBfID0gbiAmJiBzID4gYTtcbiAgcmV0dXJuIGwgfHwgcCB8fCB1IHx8IF87XG59XG5mdW5jdGlvbiBIZihzLCB0LCBlLCBpLCBuLCBvLCByLCBhKSB7XG4gIGNvbnN0IGwgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgcmV0dXJuIGwuc2V0SG91cnMoMCwgMCwgMCwgMCksIChzICYmIG8gJiYgRmUobywgbCkgPCAwIHx8IHMpICYmIChvID0gbCksIG8gJiYgUGkoXG4gICAgdCxcbiAgICBvLFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhXG4gICk7XG59XG5mdW5jdGlvbiBWZihzLCB0LCBlLCBpLCBuLCBvLCByLCBhKSB7XG4gIGNvbnN0IGwgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgcmV0dXJuIGwuc2V0SG91cnMoMCwgMCwgMCwgMCksIChzICYmIG4gJiYgRmUobiwgbCkgPCAwIHx8IHMpICYmIChuID0gbCksIG4gJiYgUGkoXG4gICAgdCxcbiAgICBuLFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhXG4gICk7XG59XG5mdW5jdGlvbiBQaShzLCB0LCBlLCBpLCBuLCBvLCByLCBhKSB7XG4gIHJldHVybiBlID09PSBcImRheXNcIiA/IEIocykgPT09IEIodCkgJiYgWShzKSA9PT0gWSh0KSA6IGUgPT09IFwibW9udGhzXCIgPyBCKHMpID09PSBCKHQpIDogZSA9PT0gXCJ5ZWFyc1wiID8gQih0KSA+PSBhICYmIEIodCkgPD0gciA6ICExO1xufVxuY29uc3QgV2YgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1tb2RhbC1jb250YWluZXItcmVmXCIsIEZmID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItZHJvcGRvd24tY29udGFpbmVyLXJlZlwiLCBZZiA9IFwiZGF0YS10ZS1kcm9wZG93bi1iYWNrZHJvcC1yZWZcIiwgamYgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1kYXRlLXRleHQtcmVmXCIsIFdhID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItdmlldy1yZWZcIiwgS2YgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1wcmV2aW91cy1idXR0b24tcmVmXCIsIHpmID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItbmV4dC1idXR0b24tcmVmXCIsIFVmID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItb2stYnV0dG9uLXJlZlwiLCBYZiA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNhbmNlbC1idXR0b24tcmVmXCIsIEdmID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2xlYXItYnV0dG9uLXJlZlwiLCBxZiA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLXZpZXctY2hhbmdlLWJ1dHRvbi1yZWZcIjtcbmZ1bmN0aW9uIFpmKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEsIGwsIHApIHtcbiAgY29uc3QgdSA9IFkocyksIF8gPSBCKHMpLCBmID0gdHQocyksIGcgPSB6cyhzKSwgbSA9ICQoXCJkaXZcIiksIGIgPSBgXG4gICAgICAgICR7RmEoXG4gICAgcyxcbiAgICB1LFxuICAgIF8sXG4gICAgdCxcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYSxcbiAgICBwXG4gICl9XG4gICAgYCwgdiA9IGBcbiAgICAgICR7SmYoZiwgZywgdSwgbiwgcCl9XG4gICAgICAke0ZhKFxuICAgIHMsXG4gICAgdSxcbiAgICBfLFxuICAgIHQsXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGEsXG4gICAgcFxuICApfVxuICAgIGA7XG4gIHJldHVybiBuLmlubGluZSA/IChoLmFkZENsYXNzKG0sIHAuZGF0ZXBpY2tlckRyb3Bkb3duQ29udGFpbmVyKSwgbS5zZXRBdHRyaWJ1dGUoRmYsIGwpLCBtLmlubmVySFRNTCA9IGIpIDogKGguYWRkQ2xhc3MobSwgcC5tb2RhbENvbnRhaW5lciksIG0uc2V0QXR0cmlidXRlKFdmLCBsKSwgbS5pbm5lckhUTUwgPSB2KSwgbTtcbn1cbmZ1bmN0aW9uIFFmKHMpIHtcbiAgY29uc3QgdCA9ICQoXCJkaXZcIik7XG4gIHJldHVybiBoLmFkZENsYXNzKHQsIHMpLCB0LnNldEF0dHJpYnV0ZShZZiwgXCJcIiksIHQ7XG59XG5mdW5jdGlvbiBKZihzLCB0LCBlLCBpLCBuKSB7XG4gIHJldHVybiBgXG4gICAgICA8ZGl2IGNsYXNzPVwiJHtuLmRhdGVwaWNrZXJIZWFkZXJ9XCIgZGF0YS10ZS1kYXRlcGlja2VyLWhlYWRlcj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7bi5kYXRlcGlja2VyVGl0bGV9XCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCIke24uZGF0ZXBpY2tlclRpdGxlVGV4dH1cIj4ke2kudGl0bGV9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7bi5kYXRlcGlja2VyRGF0ZX1cIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7bi5kYXRlcGlja2VyRGF0ZVRleHR9XCIgJHtqZn0gPiR7aS53ZWVrZGF5c1Nob3J0W3RdfSwgJHtpLm1vbnRoc1Nob3J0W2VdfSAke3N9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG59XG5mdW5jdGlvbiBGYShzLCB0LCBlLCBpLCBuLCBvLCByLCBhLCBsLCBwLCB1KSB7XG4gIGxldCBfO1xuICByZXR1cm4gci5pbmxpbmUgPyBfID0gYFxuICAgIDxkaXYgY2xhc3M9XCIke3UuZGF0ZXBpY2tlck1haW59XCI+XG4gICAgICAke2phKHQsIGUsIHIsIHUpfVxuICAgICAgPGRpdiBjbGFzcz1cIiR7dS5kYXRlcGlja2VyVmlld31cIiAke1dhfSB0YWJpbmRleD1cIjBcIj5cbiAgICAgICAgJHtZYShcbiAgICBzLFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhLFxuICAgIGwsXG4gICAgcCxcbiAgICB1XG4gICl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYCA6IF8gPSBgXG4gICAgPGRpdiBjbGFzcz1cIiR7dS5kYXRlcGlja2VyTWFpbn1cIj5cbiAgICAgICR7amEodCwgZSwgciwgdSl9XG4gICAgICA8ZGl2IGNsYXNzPVwiJHt1LmRhdGVwaWNrZXJWaWV3fVwiICR7V2F9IHRhYmluZGV4PVwiMFwiPlxuICAgICAgICAke1lhKFxuICAgIHMsXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGEsXG4gICAgbCxcbiAgICBwLFxuICAgIHVcbiAgKX1cbiAgICAgIDwvZGl2PlxuICAgICAgJHt0bShyLCB1KX1cbiAgICA8L2Rpdj5cbiAgYCwgXztcbn1cbmZ1bmN0aW9uIFlhKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEsIGwsIHApIHtcbiAgbGV0IHU7XG4gIHJldHVybiBvLnZpZXcgPT09IFwiZGF5c1wiID8gdSA9IFhzKHMsIGUsIG8sIHApIDogby52aWV3ID09PSBcIm1vbnRoc1wiID8gdSA9IEdzKFxuICAgIHQsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBwXG4gICkgOiB1ID0gcXMoXG4gICAgcyxcbiAgICBpLFxuICAgIG8sXG4gICAgYSxcbiAgICBsLFxuICAgIHBcbiAgKSwgdTtcbn1cbmZ1bmN0aW9uIGphKHMsIHQsIGUsIGkpIHtcbiAgcmV0dXJuIGBcbiAgICA8ZGl2IGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJEYXRlQ29udHJvbHN9XCI+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJWaWV3Q2hhbmdlQnV0dG9ufVwiIGFyaWEtbGFiZWw9XCIke2Uuc3dpdGNoVG9NdWx0aVllYXJWaWV3TGFiZWx9XCIgJHtxZn0+XG4gICAgICAgICR7ZS5tb250aHNGdWxsW3NdfSAke3R9ICR7THQoXG4gICAgZSxcbiAgICBpXG4gICl9XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxkaXYgY2xhc3M9XCIke2kuZGF0ZXBpY2tlckFycm93Q29udHJvbHN9XCI+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCIke2kuZGF0ZXBpY2tlclByZXZpb3VzQnV0dG9ufVwiIGFyaWEtbGFiZWw9XCIke2UucHJldk1vbnRoTGFiZWx9XCIgJHtLZn0+JHtlLmNoYW5nZU1vbnRoSWNvblRlbXBsYXRlfTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJOZXh0QnV0dG9ufVwiIGFyaWEtbGFiZWw9XCIke2UubmV4dE1vbnRoTGFiZWx9XCIgJHt6Zn0+JHtlLmNoYW5nZU1vbnRoSWNvblRlbXBsYXRlfTwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgYDtcbn1cbmZ1bmN0aW9uIEx0KHMsIHQpIHtcbiAgcmV0dXJuIGBcbiAgPHNwYW4gY2xhc3M9XCIke3QuZGF0ZXBpY2tlclZpZXdDaGFuZ2VJY29ufVwiPlxuICAke3Mudmlld0NoYW5nZUljb25UZW1wbGF0ZX1cbiAgPC9zcGFuPlxuICBgO1xufVxuZnVuY3Rpb24gdG0ocywgdCkge1xuICBjb25zdCBlID0gYDxidXR0b24gY2xhc3M9XCIke3QuZGF0ZXBpY2tlckZvb3RlckJ0bn1cIiBhcmlhLWxhYmVsPVwiJHtzLm9rQnRuTGFiZWx9XCIgJHtVZn0+JHtzLm9rQnRuVGV4dH08L2J1dHRvbj5gLCBpID0gYDxidXR0b24gY2xhc3M9XCIke3QuZGF0ZXBpY2tlckZvb3RlckJ0bn1cIiBhcmlhLWxhYmVsPVwiJHtzLmNhbmNlbEJ0bkxhYmVsfVwiICR7WGZ9PiR7cy5jYW5jZWxCdG5UZXh0fTwvYnV0dG9uPmAsIG4gPSBgPGJ1dHRvbiBjbGFzcz1cIiR7dC5kYXRlcGlja2VyRm9vdGVyQnRufSAke3QuZGF0ZXBpY2tlckNsZWFyQnRufVwiIGFyaWEtbGFiZWw9XCIke3MuY2xlYXJCdG5MYWJlbH1cIiAke0dmfT4ke3MuY2xlYXJCdG5UZXh0fTwvYnV0dG9uPmA7XG4gIHJldHVybiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCIke3QuZGF0ZXBpY2tlckZvb3Rlcn1cIj5cbiAgICAgICAgICBcbiAgICAgICAgJHtzLnJlbW92ZUNsZWFyQnRuID8gXCJcIiA6IG59XG4gICAgICAgICR7cy5yZW1vdmVDYW5jZWxCdG4gPyBcIlwiIDogaX1cbiAgICAgICAgJHtzLnJlbW92ZU9rQnRuID8gXCJcIiA6IGV9XG4gICAgICAgIDwvZGl2PlxuICAgICAgYDtcbn1cbmZ1bmN0aW9uIFhzKHMsIHQsIGUsIGkpIHtcbiAgY29uc3QgbiA9IGVtKHMsIHQsIGUpLCByID0gYFxuICAgICAgPHRyPlxuICAgICAgICAke2Uud2Vla2RheXNOYXJyb3cubWFwKChsLCBwKSA9PiBgPHRoIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJEYXlIZWFkaW5nfVwiIHNjb3BlPVwiY29sXCIgYXJpYS1sYWJlbD1cIiR7ZS53ZWVrZGF5c0Z1bGxbcF19XCI+JHtsfTwvdGg+YCkuam9pbihcIlwiKX1cbiAgICAgIDwvdHI+XG4gICAgYCwgYSA9IG4ubWFwKChsKSA9PiBgXG4gICAgICAgIDx0cj5cbiAgICAgICAgICAke2wubWFwKChwKSA9PiBgXG4gICAgICAgICAgICAgIDx0ZFxuICAgICAgICAgICAgICBjbGFzcz1cIiR7aS5kYXRlcGlja2VyQ2VsbH0gJHtpLmRhdGVwaWNrZXJDZWxsU21hbGx9XCJcbiAgICAgICAgICAgICAgZGF0YS10ZS1kYXRlPVwiJHtCKHAuZGF0ZSl9LSR7WShcbiAgICBwLmRhdGVcbiAgKX0tJHt0dChwLmRhdGUpfVwiXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCIke3AuZGF0ZX1cIlxuICAgICAgICAgICAgICBhcmlhLXNlbGVjdGVkPVwiJHtwLmlzU2VsZWN0ZWR9XCJcbiAgICAgICAgICAgICAgJHtwLmlzU2VsZWN0ZWQgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIgOiBcIlwifVxuICAgICAgICAgICAgICAkeyFwLmN1cnJlbnRNb250aCB8fCBwLmRpc2FibGVkID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgJHtwLmlzVG9kYXkgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICBjbGFzcz1cIiR7aS5kYXRlcGlja2VyQ2VsbENvbnRlbnR9ICR7aS5kYXRlcGlja2VyQ2VsbENvbnRlbnRTbWFsbH1cIlxuICAgICAgICAgICAgICAgICAgc3R5bGU9XCIke3AuY3VycmVudE1vbnRoID8gXCJkaXNwbGF5OiBibG9ja1wiIDogXCJkaXNwbGF5OiBub25lXCJ9XCJcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICR7cC5kYXlOdW1iZXJ9XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIGApLmpvaW4oXCJcIil9XG4gICAgICAgIDwvdHI+XG4gICAgICBgKS5qb2luKFwiXCIpO1xuICByZXR1cm4gYFxuICAgICAgPHRhYmxlIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJUYWJsZX1cIj5cbiAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICR7cn1cbiAgICAgICAgPC90aGVhZD5cbiAgICAgICAgPHRib2R5PlxuICAgICAgICAgJHthfVxuICAgICAgICA8L3Rib2R5PlxuICAgICAgPC90YWJsZT5cbiAgICBgO1xufVxuZnVuY3Rpb24gZW0ocywgdCwgZSkge1xuICBjb25zdCBpID0gW10sIG4gPSBZKHMpLCBvID0gWShsdChzLCAtMSkpLCByID0gWShsdChzLCAxKSksIGEgPSBCKHMpLCBsID0gTmYoYSwgbiwgZSksIHAgPSBHbyhzKSwgdSA9IEdvKGx0KHMsIC0xKSksIF8gPSA3O1xuICBsZXQgZiA9IDEsIGcgPSAhMTtcbiAgZm9yIChsZXQgbSA9IDE7IG0gPCBfOyBtKyspIHtcbiAgICBjb25zdCBiID0gW107XG4gICAgaWYgKG0gPT09IDEpIHtcbiAgICAgIGNvbnN0IHYgPSB1IC0gbCArIDE7XG4gICAgICBmb3IgKGxldCB5ID0gdjsgeSA8PSB1OyB5KyspIHtcbiAgICAgICAgY29uc3QgQyA9IEN0KGEsIG8sIHkpO1xuICAgICAgICBiLnB1c2goe1xuICAgICAgICAgIGRhdGU6IEMsXG4gICAgICAgICAgY3VycmVudE1vbnRoOiBnLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IHQgJiYgbWUoQywgdCksXG4gICAgICAgICAgaXNUb2RheTogbWUoQywgamUoKSksXG4gICAgICAgICAgZGF5TnVtYmVyOiB0dChDKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGcgPSAhMDtcbiAgICAgIGNvbnN0IFQgPSBfIC0gYi5sZW5ndGg7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IFQ7IHkrKykge1xuICAgICAgICBjb25zdCBDID0gQ3QoYSwgbiwgZik7XG4gICAgICAgIGIucHVzaCh7XG4gICAgICAgICAgZGF0ZTogQyxcbiAgICAgICAgICBjdXJyZW50TW9udGg6IGcsXG4gICAgICAgICAgaXNTZWxlY3RlZDogdCAmJiBtZShDLCB0KSxcbiAgICAgICAgICBpc1RvZGF5OiBtZShDLCBqZSgpKSxcbiAgICAgICAgICBkYXlOdW1iZXI6IHR0KEMpLFxuICAgICAgICAgIGRpc2FibGVkOiBfbihcbiAgICAgICAgICAgIEMsXG4gICAgICAgICAgICBlLm1pbixcbiAgICAgICAgICAgIGUubWF4LFxuICAgICAgICAgICAgZS5maWx0ZXIsXG4gICAgICAgICAgICBlLmRpc2FibGVQYXN0LFxuICAgICAgICAgICAgZS5kaXNhYmxlRnV0dXJlXG4gICAgICAgICAgKVxuICAgICAgICB9KSwgZisrO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgZm9yIChsZXQgdiA9IDE7IHYgPCA4OyB2KyspIHtcbiAgICAgICAgZiA+IHAgJiYgKGYgPSAxLCBnID0gITEpO1xuICAgICAgICBjb25zdCBUID0gQ3QoXG4gICAgICAgICAgYSxcbiAgICAgICAgICBnID8gbiA6IHIsXG4gICAgICAgICAgZlxuICAgICAgICApO1xuICAgICAgICBiLnB1c2goe1xuICAgICAgICAgIGRhdGU6IFQsXG4gICAgICAgICAgY3VycmVudE1vbnRoOiBnLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IHQgJiYgbWUoVCwgdCksXG4gICAgICAgICAgaXNUb2RheTogbWUoVCwgamUoKSksXG4gICAgICAgICAgZGF5TnVtYmVyOiB0dChUKSxcbiAgICAgICAgICBkaXNhYmxlZDogX24oXG4gICAgICAgICAgICBULFxuICAgICAgICAgICAgZS5taW4sXG4gICAgICAgICAgICBlLm1heCxcbiAgICAgICAgICAgIGUuZmlsdGVyLFxuICAgICAgICAgICAgZS5kaXNhYmxlUGFzdCxcbiAgICAgICAgICAgIGUuZGlzYWJsZUZ1dHVyZVxuICAgICAgICAgIClcbiAgICAgICAgfSksIGYrKztcbiAgICAgIH1cbiAgICBpLnB1c2goYik7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBHcyhzLCB0LCBlLCBpLCBuLCBvKSB7XG4gIGNvbnN0IHIgPSBpbShpLCBuKSwgYSA9IFkoamUoKSksIGwgPSBCKGplKCkpLCBwID0gYFxuICAgICAgJHtyLm1hcCgodSkgPT4gYFxuICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICR7dS5tYXAoKF8pID0+IHtcbiAgICBjb25zdCBmID0gaS5tb250aHNTaG9ydC5pbmRleE9mKF8pO1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwiJHtvLmRhdGVwaWNrZXJDZWxsfSAke28uZGF0ZXBpY2tlckNlbGxMYXJnZX1cIlxuICAgICAgICAgICAgICAgICR7X2goXG4gICAgICBmLFxuICAgICAgcyxcbiAgICAgIGkubWluLFxuICAgICAgaS5tYXgsXG4gICAgICBpLmRpc2FibGVQYXN0LFxuICAgICAgaS5kaXNhYmxlRnV0dXJlXG4gICAgKSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZGF0YS10ZS1tb250aD1cIiR7Zn1cIiBkYXRhLXRlLXllYXI9XCIke3N9XCIgYXJpYS1sYWJlbD1cIiR7X30sICR7c31cIlxuICAgICAgICAgICAgICAgICR7ZiA9PT0gZSAmJiBzID09PSB0ID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgICAke2YgPT09IGEgJiYgcyA9PT0gbCA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudFwiIDogXCJcIn1cIiBkYXRhLXRlLW1vbnRoPVwiJHtmfVwiIGRhdGEtdGUteWVhcj1cIiR7c31cIiBhcmlhLWxhYmVsPVwiJHtffSwgJHtzfVwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7by5kYXRlcGlja2VyQ2VsbENvbnRlbnR9ICR7by5kYXRlcGlja2VyQ2VsbENvbnRlbnRMYXJnZX1cIj4ke199PC9kaXY+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgYDtcbiAgfSkuam9pbihcIlwiKX1cbiAgICAgICAgICA8L3RyPlxuICAgICAgICBgKS5qb2luKFwiXCIpfVxuICAgIGA7XG4gIHJldHVybiBgXG4gICAgICA8dGFibGUgY2xhc3M9XCIke28uZGF0ZXBpY2tlclRhYmxlfVwiPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICAke3B9XG4gICAgICAgIDwvdGJvZHk+XG4gICAgICA8L3RhYmxlPlxuICAgIGA7XG59XG5mdW5jdGlvbiBpbShzLCB0KSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgbGV0IGkgPSBbXTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBzLm1vbnRoc1Nob3J0Lmxlbmd0aDsgbisrKVxuICAgIGlmIChpLnB1c2gocy5tb250aHNTaG9ydFtuXSksIGkubGVuZ3RoID09PSB0KSB7XG4gICAgICBjb25zdCBvID0gaTtcbiAgICAgIGUucHVzaChvKSwgaSA9IFtdO1xuICAgIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBxcyhzLCB0LCBlLCBpLCBuLCBvKSB7XG4gIGNvbnN0IHIgPSBzbShzLCBpLCBuKSwgYSA9IEIoamUoKSksIGwgPSBgXG4gICAgJHtyLm1hcCgocCkgPT4gYFxuICAgICAgICA8dHI+XG4gICAgICAgICAgJHtwLm1hcCgodSkgPT4gYFxuICAgICAgICAgICAgICA8dGQgY2xhc3M9XCIke28uZGF0ZXBpY2tlckNlbGx9ICR7by5kYXRlcGlja2VyQ2VsbExhcmdlfVwiICBhcmlhLWxhYmVsPVwiJHt1fVwiIGRhdGEtdGUteWVhcj1cIiR7dX1cIlxuICAgICAgICAgICAgICAke3FvKFxuICAgIHUsXG4gICAgZS5taW4sXG4gICAgZS5tYXgsXG4gICAgZS5kaXNhYmxlUGFzdCxcbiAgICBlLmRpc2FibGVGdXR1cmVcbiAgKSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7dSA9PT0gdCA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7dSA9PT0gYSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke28uZGF0ZXBpY2tlckNlbGxDb250ZW50fSAke28uZGF0ZXBpY2tlckNlbGxDb250ZW50TGFyZ2V9XCI+JHt1fTwvZGl2PlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgYCkuam9pbihcIlwiKX1cbiAgICAgICAgPC90cj5cbiAgICAgIGApLmpvaW4oXCJcIil9XG4gIGA7XG4gIHJldHVybiBgXG4gICAgICA8dGFibGUgY2xhc3M9XCIke28uZGF0ZXBpY2tlclRhYmxlfVwiPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICR7bH1cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG4gICAgYDtcbn1cbmZ1bmN0aW9uIHNtKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9IFtdLCBuID0gQihzKSwgbyA9IFVzKHMsIHQpLCByID0gbiAtIG87XG4gIGxldCBhID0gW107XG4gIGZvciAobGV0IGwgPSAwOyBsIDwgdDsgbCsrKVxuICAgIGlmIChhLnB1c2gociArIGwpLCBhLmxlbmd0aCA9PT0gZSkge1xuICAgICAgY29uc3QgcCA9IGE7XG4gICAgICBpLnB1c2gocCksIGEgPSBbXTtcbiAgICB9XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gbm0ocywgdCkge1xuICByZXR1cm4gYFxuICAgIDxidXR0b24gaWQ9XCIke3N9XCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHt0fVwiIGRhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtYnV0dG9uLXJlZiBkYXRhLXRlLWRhdGVwaWNrZXItdG9nZ2xlLXJlZj5cbiAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+XG4gICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk02Ljc1IDIuMjVBLjc1Ljc1IDAgMDE3LjUgM3YxLjVoOVYzQS43NS43NSAwIDAxMTggM3YxLjVoLjc1YTMgMyAwIDAxMyAzdjExLjI1YTMgMyAwIDAxLTMgM0g1LjI1YTMgMyAwIDAxLTMtM1Y3LjVhMyAzIDAgMDEzLTNINlYzYS43NS43NSAwIDAxLjc1LS43NXptMTMuNSA5YTEuNSAxLjUgMCAwMC0xLjUtMS41SDUuMjVhMS41IDEuNSAwIDAwLTEuNSAxLjV2Ny41YTEuNSAxLjUgMCAwMDEuNSAxLjVoMTMuNWExLjUgMS41IDAgMDAxLjUtMS41di03LjV6XCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgICA8L3N2Zz4gIFxuICAgIDwvYnV0dG9uPlxuICBgO1xufVxuY29uc3QgS2UgPSAzNywgVSA9IDM4LCB6ZSA9IDM5LCB6ID0gNDAsIFRlID0gMzYsIEVlID0gMzUsIGlvID0gMzMsIHNvID0gMzQsIGl0ID0gMTMsIFpzID0gMzIsIHdlID0gMjcsIGtlID0gOSwgb20gPSA4LCBybSA9IDQ2LCBUdCA9IDI0LCBwcyA9IDQsIF9zID0gNCwgbm8gPSBcImRhdGVwaWNrZXJcIiwgUXMgPSBcInRlLmRhdGVwaWNrZXJcIiwgRW4gPSBgLiR7UXN9YCwgYW0gPSBcIi5kYXRhLWFwaVwiLCBsbSA9IGBjbG9zZSR7RW59YCwgY20gPSBgb3BlbiR7RW59YCwgaG0gPSBgZGF0ZUNoYW5nZSR7RW59YCwgZnMgPSBgY2xpY2ske0VufSR7YW19YCwgZmggPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1tb2RhbC1jb250YWluZXItcmVmXCIsIG1oID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItZHJvcGRvd24tY29udGFpbmVyLXJlZlwiLCBtcyA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtcmVmXVwiLCBkbSA9IGBbJHtmaH1dYCwgdW0gPSBgWyR7bWh9XWAsIHBtID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLXZpZXctY2hhbmdlLWJ1dHRvbi1yZWZdXCIsIF9tID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLXByZXZpb3VzLWJ1dHRvbi1yZWZdXCIsIGZtID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLW5leHQtYnV0dG9uLXJlZl1cIiwgbW0gPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItb2stYnV0dG9uLXJlZl1cIiwgZ20gPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItY2FuY2VsLWJ1dHRvbi1yZWZdXCIsIGJtID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLWNsZWFyLWJ1dHRvbi1yZWZdXCIsIHZtID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLXZpZXctcmVmXVwiLCBUbSA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtYnV0dG9uLXJlZl1cIiwgRW0gPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItZGF0ZS10ZXh0LXJlZl1cIiwgQ20gPSBcIltkYXRhLXRlLWRyb3Bkb3duLWJhY2tkcm9wLXJlZl1cIiwgQW0gPSBcImFuaW1hdGUtW2ZhZGUtaW5fMC4zc19ib3RoXSBweC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIiwgeW0gPSBcImFuaW1hdGUtW2ZhZGUtb3V0XzAuM3NfYm90aF0gcHgtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsIHdtID0gXCJhbmltYXRlLVtmYWRlLWluXzAuMTVzX2JvdGhdIHB4LVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiLCBrbSA9IFwiYW5pbWF0ZS1bZmFkZS1vdXRfMC4xNXNfYm90aF0gcHgtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsIHhtID0gXCJmbGV4IGZsZXgtY29sIGZpeGVkIHRvcC0xLzIgbGVmdC0xLzIgLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIHctWzMyOHB4XSBoLVs1MTJweF0gYmctd2hpdGUgcm91bmRlZC1bMC42cmVtXSBzaGFkb3ctbGcgei1bMTA2Nl0geHM6bWF4LW1kOmxhbmRzY2FwZTp3LVs0NzVweF0geHM6bWF4LW1kOmxhbmRzY2FwZTpoLVszNjBweF0geHM6bWF4LW1kOmxhbmRzY2FwZTpmbGV4LXJvdyBkYXJrOmJnLXppbmMtNzAwXCIsIE9tID0gXCJ3LWZ1bGwgaC1mdWxsIGZpeGVkIHRvcC0wIHJpZ2h0LTAgbGVmdC0wIGJvdHRvbS0wIGJnLWJsYWNrLzQwIHotWzEwNjVdXCIsIFNtID0gXCJyZWxhdGl2ZSBoLWZ1bGxcIiwgSW0gPSBcInhzOm1heC1tZDpsYW5kc2NhcGU6aC1mdWxsIGgtWzEyMHB4XSBweC02IGJnLXByaW1hcnkgZmxleCBmbGV4LWNvbCByb3VuZGVkLXQtbGcgZGFyazpiZy16aW5jLTgwMFwiLCBEbSA9IFwiaC04IGZsZXggZmxleC1jb2wganVzdGlmeS1lbmRcIiwgJG0gPSBcInRleHQtWzEwcHhdIGZvbnQtbm9ybWFsIHVwcGVyY2FzZSB0cmFja2luZy1bMS43cHhdIHRleHQtd2hpdGVcIiwgTG0gPSBcInhzOm1heC1tZDpsYW5kc2NhcGU6bXQtMjQgaC1bNzJweF0gZmxleCBmbGV4LWNvbCBqdXN0aWZ5LWVuZFwiLCBObSA9IFwidGV4dC1bMzRweF0gZm9udC1ub3JtYWwgdGV4dC13aGl0ZVwiLCBNbSA9IFwib3V0bGluZS1ub25lIHB4LTNcIiwgUm0gPSBcInB4LTMgcHQtMi41IHBiLTAgZmxleCBqdXN0aWZ5LWJldHdlZW4gdGV4dC1ibGFjay9bNjRdXCIsIFBtID0gXCJmbGV4IGl0ZW1zLWNlbnRlciBvdXRsaW5lLW5vbmUgcC0yLjUgdGV4dC1uZXV0cmFsLTUwMCBmb250LW1lZGl1bSB0ZXh0LVswLjlyZW1dIHJvdW5kZWQteGwgc2hhZG93LW5vbmUgYmctdHJhbnNwYXJlbnQgbS0wIGJvcmRlci1ub25lIGhvdmVyOmJnLW5ldXRyYWwtMjAwIGZvY3VzOmJnLW5ldXRyYWwtMjAwICBkYXJrOnRleHQtd2hpdGUgZGFyazpob3ZlcjpiZy13aGl0ZS8xMCBkYXJrOmZvY3VzOmJnLXdoaXRlLzEwXCIsIEJtID0gXCJtdC0yLjVcIiwgSG0gPSBcInAtMCB3LTEwIGgtMTAgbGVhZGluZy0xMCBib3JkZXItbm9uZSBvdXRsaW5lLW5vbmUgbS0wIHRleHQtZ3JheS02MDAgYmctdHJhbnNwYXJlbnQgbXItNiBob3ZlcjpiZy1uZXV0cmFsLTIwMCBob3Zlcjpyb3VuZGVkLVs1MCVdIGZvY3VzOmJnLW5ldXRyYWwtMjAwIGZvY3VzOnJvdW5kZWQtWzUwJV0gZGFyazp0ZXh0LXdoaXRlIGRhcms6aG92ZXI6Ymctd2hpdGUvMTAgZGFyazpmb2N1czpiZy13aGl0ZS8xMCBbJj5zdmddOnctNCBbJj5zdmddOmgtNCBbJj5zdmddOm14LWF1dG9cIiwgVm0gPSBcInAtMCB3LTEwIGgtMTAgbGVhZGluZy0xMCBib3JkZXItbm9uZSBvdXRsaW5lLW5vbmUgbS0wIHRleHQtZ3JheS02MDAgYmctdHJhbnNwYXJlbnQgaG92ZXI6YmctbmV1dHJhbC0yMDAgaG92ZXI6cm91bmRlZC1bNTAlXSBmb2N1czpiZy1uZXV0cmFsLTIwMCBmb2N1czpyb3VuZGVkLVs1MCVdIGRhcms6dGV4dC13aGl0ZSBkYXJrOmhvdmVyOmJnLXdoaXRlLzEwIGRhcms6Zm9jdXM6Ymctd2hpdGUvMTAgWyY+c3ZnXTp3LTQgWyY+c3ZnXTpoLTQgWyY+c3ZnXTpyb3RhdGUtMTgwIFsmPnN2Z106bXgtYXV0b1wiLCBXbSA9IFwiaC0xNCBmbGV4IGFic29sdXRlIHctZnVsbCBib3R0b20tMCBqdXN0aWZ5LWVuZCBpdGVtcy1jZW50ZXIgcHgtM1wiLCBGbSA9IFwib3V0bGluZS1ub25lIGJnLXdoaXRlIHRleHQtcHJpbWFyeSBib3JkZXItbm9uZSBjdXJzb3ItcG9pbnRlciBweS0wIHB4LTIuNSB1cHBlcmNhc2UgdGV4dC1bMC44cmVtXSBsZWFkaW5nLTEwIGZvbnQtbWVkaXVtIGgtMTAgdHJhY2tpbmctWy4xcmVtXSByb3VuZGVkLVsxMHB4XSBtYi0yLjUgaG92ZXI6YmctbmV1dHJhbC0yMDAgZm9jdXM6YmctbmV1dHJhbC0yMDAgZGFyazpiZy10cmFuc3BhcmVudCBkYXJrOnRleHQtd2hpdGUgZGFyazpob3ZlcjpiZy13aGl0ZS8xMCBkYXJrOmZvY3VzOmJnLXdoaXRlLzEwXCIsIFltID0gXCJtci1hdXRvXCIsIGptID0gXCJ3LTEwIGgtMTAgdGV4dC1jZW50ZXIgdGV4dC1bMTJweF0gZm9udC1ub3JtYWwgZGFyazp0ZXh0LXdoaXRlXCIsIEttID0gXCJ0ZXh0LWNlbnRlciBkYXRhLVt0ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdOnRleHQtbmV1dHJhbC0zMDAgZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXTpjdXJzb3ItZGVmYXVsdCBkYXRhLVt0ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdOnBvaW50ZXItZXZlbnRzLW5vbmUgZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXTpob3ZlcjpjdXJzb3ItZGVmYXVsdCBob3ZlcjpjdXJzb3ItcG9pbnRlciBncm91cFwiLCB6bSA9IFwidy0xMCBoLTEwIHhzOm1heC1tZDpsYW5kc2NhcGU6dy04IHhzOm1heC1tZDpsYW5kc2NhcGU6aC04XCIsIFVtID0gXCJ3LVs3NnB4XSBoLVs0MnB4XVwiLCBYbSA9IFwibXgtYXV0byBncm91cC1bOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdKTpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXSk6aG92ZXJdOmJnLW5ldXRyYWwtMzAwIGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdXTpiZy1wcmltYXJ5IGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdXTp0ZXh0LXdoaXRlIGdyb3VwLVs6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF0pW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRdXTpiZy1uZXV0cmFsLTEwMCBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRdXTpkYXRhLVt0ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdOmJnLXByaW1hcnkgZ3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XV06Ym9yZGVyLXNvbGlkIGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudF1dOmJvcmRlci1ibGFjayBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRdXTpib3JkZXIgZGFyazpncm91cC1bOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdKTpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXSk6aG92ZXJdOmJnLXdoaXRlLzEwIGRhcms6Z3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XV06Ym9yZGVyLXdoaXRlIGRhcms6dGV4dC13aGl0ZSBkYXJrOmdyb3VwLVs6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF0pW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRdXTpiZy13aGl0ZS8xMCBkYXJrOmdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdXTp0ZXh0LW5ldXRyYWwtNTAwXCIsIEdtID0gXCJ3LTkgaC05IGxlYWRpbmctOSByb3VuZGVkLVs1MCVdIHRleHQtWzEzcHhdXCIsIHFtID0gXCJ3LVs3MnB4XSBoLTEwIGxlYWRpbmctMTAgcHktWzFweF0gcHgtMC41IHJvdW5kZWQtWzk5OXB4XVwiLCBabSA9IFwibXgtYXV0byB3LVszMDRweF1cIiwgUW0gPSBcImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY29udGVudC1jZW50ZXIgWyY+c3ZnXTp3LTUgWyY+c3ZnXTpoLTUgYWJzb2x1dGUgb3V0bGluZS1ub25lIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHJpZ2h0LTAuNSB0b3AtMS8yIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiBob3Zlcjp0ZXh0LXByaW1hcnkgZm9jdXM6dGV4dC1wcmltYXJ5IGRhcms6aG92ZXI6dGV4dC1wcmltYXJ5LTQwMCBkYXJrOmZvY3VzOnRleHQtcHJpbWFyeS00MDAgZGFyazp0ZXh0LW5ldXRyYWwtMjAwXCIsIEptID0gXCJpbmxpbmUtYmxvY2sgcG9pbnRlci1ldmVudHMtbm9uZSBtbC1bM3B4XSBbJj5zdmddOnctNCBbJj5zdmddOmgtNCBbJj5zdmddOmZpbGwtbmV1dHJhbC01MDAgZGFyazpbJj5zdmddOmZpbGwtd2hpdGVcIiwgdGcgPSBcInctWzMyOHB4XSBoLVszODBweF0gYmctd2hpdGUgcm91bmRlZC1sZyBzaGFkb3ctWzBweF8ycHhfMTVweF8tM3B4X3JnYmEoMCwwLDAsLjA3KSxfMHB4XzEwcHhfMjBweF8tMnB4X3JnYmEoMCwwLDAsLjA0KV0gei1bMTA2Nl0gZGFyazpiZy16aW5jLTcwMFwiLCBlZyA9IHtcbiAgdGl0bGU6IFwiU2VsZWN0IGRhdGVcIixcbiAgY29udGFpbmVyOiBcImJvZHlcIixcbiAgZGlzYWJsZVBhc3Q6ICExLFxuICBkaXNhYmxlRnV0dXJlOiAhMSxcbiAgbW9udGhzRnVsbDogW1xuICAgIFwiSmFudWFyeVwiLFxuICAgIFwiRmVicnVhcnlcIixcbiAgICBcIk1hcmNoXCIsXG4gICAgXCJBcHJpbFwiLFxuICAgIFwiTWF5XCIsXG4gICAgXCJKdW5lXCIsXG4gICAgXCJKdWx5XCIsXG4gICAgXCJBdWd1c3RcIixcbiAgICBcIlNlcHRlbWJlclwiLFxuICAgIFwiT2N0b2JlclwiLFxuICAgIFwiTm92ZW1iZXJcIixcbiAgICBcIkRlY2VtYmVyXCJcbiAgXSxcbiAgbW9udGhzU2hvcnQ6IFtcbiAgICBcIkphblwiLFxuICAgIFwiRmViXCIsXG4gICAgXCJNYXJcIixcbiAgICBcIkFwclwiLFxuICAgIFwiTWF5XCIsXG4gICAgXCJKdW5cIixcbiAgICBcIkp1bFwiLFxuICAgIFwiQXVnXCIsXG4gICAgXCJTZXBcIixcbiAgICBcIk9jdFwiLFxuICAgIFwiTm92XCIsXG4gICAgXCJEZWNcIlxuICBdLFxuICB3ZWVrZGF5c0Z1bGw6IFtcbiAgICBcIlN1bmRheVwiLFxuICAgIFwiTW9uZGF5XCIsXG4gICAgXCJUdWVzZGF5XCIsXG4gICAgXCJXZWRuZXNkYXlcIixcbiAgICBcIlRodXJzZGF5XCIsXG4gICAgXCJGcmlkYXlcIixcbiAgICBcIlNhdHVyZGF5XCJcbiAgXSxcbiAgd2Vla2RheXNTaG9ydDogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICB3ZWVrZGF5c05hcnJvdzogW1wiU1wiLCBcIk1cIiwgXCJUXCIsIFwiV1wiLCBcIlRcIiwgXCJGXCIsIFwiU1wiXSxcbiAgb2tCdG5UZXh0OiBcIk9rXCIsXG4gIGNsZWFyQnRuVGV4dDogXCJDbGVhclwiLFxuICBjYW5jZWxCdG5UZXh0OiBcIkNhbmNlbFwiLFxuICBva0J0bkxhYmVsOiBcIkNvbmZpcm0gc2VsZWN0aW9uXCIsXG4gIGNsZWFyQnRuTGFiZWw6IFwiQ2xlYXIgc2VsZWN0aW9uXCIsXG4gIGNhbmNlbEJ0bkxhYmVsOiBcIkNhbmNlbCBzZWxlY3Rpb25cIixcbiAgbmV4dE1vbnRoTGFiZWw6IFwiTmV4dCBtb250aFwiLFxuICBwcmV2TW9udGhMYWJlbDogXCJQcmV2aW91cyBtb250aFwiLFxuICBuZXh0WWVhckxhYmVsOiBcIk5leHQgeWVhclwiLFxuICBwcmV2WWVhckxhYmVsOiBcIlByZXZpb3VzIHllYXJcIixcbiAgY2hhbmdlTW9udGhJY29uVGVtcGxhdGU6IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTYgaC02XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTUuNzUgMTkuNUw4LjI1IDEybDcuNS03LjVcIiAvPlxuICA8L3N2Zz5cbiAgYCxcbiAgbmV4dE11bHRpWWVhckxhYmVsOiBcIk5leHQgMjQgeWVhcnNcIixcbiAgcHJldk11bHRpWWVhckxhYmVsOiBcIlByZXZpb3VzIDI0IHllYXJzXCIsXG4gIHN3aXRjaFRvTXVsdGlZZWFyVmlld0xhYmVsOiBcIkNob29zZSB5ZWFyIGFuZCBtb250aFwiLFxuICBzd2l0Y2hUb01vbnRoVmlld0xhYmVsOiBcIkNob29zZSBkYXRlXCIsXG4gIHN3aXRjaFRvRGF5Vmlld0xhYmVsOiBcIkNob29zZSBkYXRlXCIsXG4gIHN0YXJ0RGF0ZTogbnVsbCxcbiAgc3RhcnREYXk6IDAsXG4gIGZvcm1hdDogXCJkZC9tbS95eXl5XCIsXG4gIHZpZXc6IFwiZGF5c1wiLFxuICB2aWV3Q2hhbmdlSWNvblRlbXBsYXRlOiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMFwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy02IGgtNlwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE5LjUgOC4yNWwtNy41IDcuNS03LjUtNy41XCIgLz5cbiAgPC9zdmc+XG4gIGAsXG4gIG1pbjogbnVsbCxcbiAgbWF4OiBudWxsLFxuICBmaWx0ZXI6IG51bGwsXG4gIGlubGluZTogITEsXG4gIHRvZ2dsZUJ1dHRvbjogITAsXG4gIGRpc2FibGVUb2dnbGVCdXR0b246ICExLFxuICBkaXNhYmxlSW5wdXQ6ICExLFxuICBhbmltYXRpb25zOiAhMCxcbiAgY29uZmlybURhdGVPblNlbGVjdDogITEsXG4gIHJlbW92ZU9rQnRuOiAhMSxcbiAgcmVtb3ZlQ2FuY2VsQnRuOiAhMSxcbiAgcmVtb3ZlQ2xlYXJCdG46ICExXG59LCBpZyA9IHtcbiAgdGl0bGU6IFwic3RyaW5nXCIsXG4gIGNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgZGlzYWJsZVBhc3Q6IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlRnV0dXJlOiBcImJvb2xlYW5cIixcbiAgbW9udGhzRnVsbDogXCJhcnJheVwiLFxuICBtb250aHNTaG9ydDogXCJhcnJheVwiLFxuICB3ZWVrZGF5c0Z1bGw6IFwiYXJyYXlcIixcbiAgd2Vla2RheXNTaG9ydDogXCJhcnJheVwiLFxuICB3ZWVrZGF5c05hcnJvdzogXCJhcnJheVwiLFxuICBva0J0blRleHQ6IFwic3RyaW5nXCIsXG4gIGNsZWFyQnRuVGV4dDogXCJzdHJpbmdcIixcbiAgY2FuY2VsQnRuVGV4dDogXCJzdHJpbmdcIixcbiAgb2tCdG5MYWJlbDogXCJzdHJpbmdcIixcbiAgY2xlYXJCdG5MYWJlbDogXCJzdHJpbmdcIixcbiAgY2FuY2VsQnRuTGFiZWw6IFwic3RyaW5nXCIsXG4gIG5leHRNb250aExhYmVsOiBcInN0cmluZ1wiLFxuICBwcmV2TW9udGhMYWJlbDogXCJzdHJpbmdcIixcbiAgbmV4dFllYXJMYWJlbDogXCJzdHJpbmdcIixcbiAgcHJldlllYXJMYWJlbDogXCJzdHJpbmdcIixcbiAgbmV4dE11bHRpWWVhckxhYmVsOiBcInN0cmluZ1wiLFxuICBwcmV2TXVsdGlZZWFyTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNoYW5nZU1vbnRoSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBzd2l0Y2hUb011bHRpWWVhclZpZXdMYWJlbDogXCJzdHJpbmdcIixcbiAgc3dpdGNoVG9Nb250aFZpZXdMYWJlbDogXCJzdHJpbmdcIixcbiAgc3dpdGNoVG9EYXlWaWV3TGFiZWw6IFwic3RyaW5nXCIsXG4gIHN0YXJ0RGF0ZTogXCIobnVsbHxzdHJpbmd8ZGF0ZSlcIixcbiAgc3RhcnREYXk6IFwibnVtYmVyXCIsXG4gIGZvcm1hdDogXCJzdHJpbmdcIixcbiAgdmlldzogXCJzdHJpbmdcIixcbiAgdmlld0NoYW5nZUljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgbWluOiBcIihudWxsfHN0cmluZ3xkYXRlKVwiLFxuICBtYXg6IFwiKG51bGx8c3RyaW5nfGRhdGUpXCIsXG4gIGZpbHRlcjogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgaW5saW5lOiBcImJvb2xlYW5cIixcbiAgdG9nZ2xlQnV0dG9uOiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZVRvZ2dsZUJ1dHRvbjogXCJib29sZWFuXCIsXG4gIGRpc2FibGVJbnB1dDogXCJib29sZWFuXCIsXG4gIGFuaW1hdGlvbnM6IFwiYm9vbGVhblwiLFxuICBjb25maXJtRGF0ZU9uU2VsZWN0OiBcImJvb2xlYW5cIixcbiAgcmVtb3ZlT2tCdG46IFwiYm9vbGVhblwiLFxuICByZW1vdmVDYW5jZWxCdG46IFwiYm9vbGVhblwiLFxuICByZW1vdmVDbGVhckJ0bjogXCJib29sZWFuXCJcbn0sIHNnID0ge1xuICBmYWRlSW46IEFtLFxuICBmYWRlT3V0OiB5bSxcbiAgZmFkZUluU2hvcnQ6IHdtLFxuICBmYWRlT3V0U2hvcnQ6IGttLFxuICBtb2RhbENvbnRhaW5lcjogeG0sXG4gIGRhdGVwaWNrZXJCYWNrZHJvcDogT20sXG4gIGRhdGVwaWNrZXJNYWluOiBTbSxcbiAgZGF0ZXBpY2tlckhlYWRlcjogSW0sXG4gIGRhdGVwaWNrZXJUaXRsZTogRG0sXG4gIGRhdGVwaWNrZXJUaXRsZVRleHQ6ICRtLFxuICBkYXRlcGlja2VyRGF0ZTogTG0sXG4gIGRhdGVwaWNrZXJEYXRlVGV4dDogTm0sXG4gIGRhdGVwaWNrZXJWaWV3OiBNbSxcbiAgZGF0ZXBpY2tlckRhdGVDb250cm9sczogUm0sXG4gIGRhdGVwaWNrZXJWaWV3Q2hhbmdlQnV0dG9uOiBQbSxcbiAgZGF0ZXBpY2tlclZpZXdDaGFuZ2VJY29uOiBKbSxcbiAgZGF0ZXBpY2tlckFycm93Q29udHJvbHM6IEJtLFxuICBkYXRlcGlja2VyUHJldmlvdXNCdXR0b246IEhtLFxuICBkYXRlcGlja2VyTmV4dEJ1dHRvbjogVm0sXG4gIGRhdGVwaWNrZXJGb290ZXI6IFdtLFxuICBkYXRlcGlja2VyRm9vdGVyQnRuOiBGbSxcbiAgZGF0ZXBpY2tlckNsZWFyQnRuOiBZbSxcbiAgZGF0ZXBpY2tlckRheUhlYWRpbmc6IGptLFxuICBkYXRlcGlja2VyQ2VsbDogS20sXG4gIGRhdGVwaWNrZXJDZWxsU21hbGw6IHptLFxuICBkYXRlcGlja2VyQ2VsbExhcmdlOiBVbSxcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50OiBYbSxcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50U21hbGw6IEdtLFxuICBkYXRlcGlja2VyQ2VsbENvbnRlbnRMYXJnZTogcW0sXG4gIGRhdGVwaWNrZXJUYWJsZTogWm0sXG4gIGRhdGVwaWNrZXJUb2dnbGVCdXR0b246IFFtLFxuICBkYXRlcGlja2VyRHJvcGRvd25Db250YWluZXI6IHRnXG59LCBuZyA9IHtcbiAgZmFkZUluOiBcInN0cmluZ1wiLFxuICBmYWRlT3V0OiBcInN0cmluZ1wiLFxuICBmYWRlSW5TaG9ydDogXCJzdHJpbmdcIixcbiAgZmFkZU91dFNob3J0OiBcInN0cmluZ1wiLFxuICBtb2RhbENvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckJhY2tkcm9wOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyTWFpbjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckhlYWRlcjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclRpdGxlOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyVGl0bGVUZXh0OiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRGF0ZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRhdGVUZXh0OiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyVmlldzogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRhdGVDb250cm9sczogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclZpZXdDaGFuZ2VCdXR0b246IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJBcnJvd0NvbnRyb2xzOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyUHJldmlvdXNCdXR0b246IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJOZXh0QnV0dG9uOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRm9vdGVyOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRm9vdGVyQnRuOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2xlYXJCdG46IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJEYXlIZWFkaW5nOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2VsbDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxTbWFsbDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxMYXJnZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50OiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2VsbENvbnRlbnRTbWFsbDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50TGFyZ2U6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJUYWJsZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclRvZ2dsZUJ1dHRvbjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRyb3Bkb3duQ29udGFpbmVyOiBcInN0cmluZ1wiXG59O1xuY2xhc3Mgb2cge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2lucHV0ID0gZC5maW5kT25lKFwiaW5wdXRcIiwgdGhpcy5fZWxlbWVudCksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9hY3RpdmVEYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLl9oZWFkZXJEYXRlID0gbnVsbCwgdGhpcy5faGVhZGVyWWVhciA9IG51bGwsIHRoaXMuX2hlYWRlck1vbnRoID0gbnVsbCwgdGhpcy5fdmlldyA9IHRoaXMuX29wdGlvbnMudmlldywgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCwgdGhpcy5faXNPcGVuID0gITEsIHRoaXMuX3RvZ2dsZUJ1dHRvbklkID0gZXQoXCJkYXRlcGlja2VyLXRvZ2dsZS1cIiksIHRoaXMuX2FuaW1hdGlvbnMgPSAhd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiKS5tYXRjaGVzICYmIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9ucywgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IHRpKCksIHRoaXMuX2VsZW1lbnQgJiYgQS5zZXREYXRhKHQsIFFzLCB0aGlzKSwgdGhpcy5faW5pdCgpLCB0aGlzLnRvZ2dsZUJ1dHRvbiAmJiB0aGlzLl9vcHRpb25zLmRpc2FibGVUb2dnbGUgJiYgKHRoaXMudG9nZ2xlQnV0dG9uLmRpc2FibGVkID0gXCJ0cnVlXCIpLCB0aGlzLl9vcHRpb25zLmRpc2FibGVJbnB1dCAmJiAodGhpcy5faW5wdXQuZGlzYWJsZWQgPSBcInRydWVcIik7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIG5vO1xuICB9XG4gIGdldCBjb250YWluZXIoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcbiAgICAgIGBbJHtmaH09JyR7dGhpcy5fdG9nZ2xlQnV0dG9uSWR9J11gXG4gICAgKSB8fCBkLmZpbmRPbmUoXG4gICAgICBgWyR7bWh9PScke3RoaXMuX3RvZ2dsZUJ1dHRvbklkfSddYFxuICAgICk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbiAgZ2V0IGFjdGl2ZUNlbGwoKSB7XG4gICAgbGV0IHQ7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiICYmICh0ID0gdGhpcy5fZ2V0QWN0aXZlRGF5Q2VsbCgpKSwgdGhpcy5fdmlldyA9PT0gXCJtb250aHNcIiAmJiAodCA9IHRoaXMuX2dldEFjdGl2ZU1vbnRoQ2VsbCgpKSwgdGhpcy5fdmlldyA9PT0gXCJ5ZWFyc1wiICYmICh0ID0gdGhpcy5fZ2V0QWN0aXZlWWVhckNlbGwoKSksIHQ7XG4gIH1cbiAgZ2V0IGFjdGl2ZURheSgpIHtcbiAgICByZXR1cm4gdHQodGhpcy5fYWN0aXZlRGF0ZSk7XG4gIH1cbiAgZ2V0IGFjdGl2ZU1vbnRoKCkge1xuICAgIHJldHVybiBZKHRoaXMuX2FjdGl2ZURhdGUpO1xuICB9XG4gIGdldCBhY3RpdmVZZWFyKCkge1xuICAgIHJldHVybiBCKHRoaXMuX2FjdGl2ZURhdGUpO1xuICB9XG4gIGdldCBmaXJzdFllYXJJblZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlWWVhciAtIFVzKHRoaXMuX2FjdGl2ZURhdGUsIFR0KTtcbiAgfVxuICBnZXQgbGFzdFllYXJJblZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3RZZWFySW5WaWV3ICsgVHQgLSAxO1xuICB9XG4gIGdldCB2aWV3Q2hhbmdlQnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUocG0sIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgcHJldmlvdXNCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShfbSwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBuZXh0QnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoZm0sIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgb2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShtbSwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBjYW5jZWxCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShnbSwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBjbGVhckJ1dHRvbigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKGJtLCB0aGlzLmNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IGRhdGVzQ29udGFpbmVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUodm0sIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgdG9nZ2xlQnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoVG0sIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIHVwZGF0ZSh0ID0ge30pIHtcbiAgICB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKHsgLi4udGhpcy5fb3B0aW9ucywgLi4udCB9KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAodCA9IHtcbiAgICAgIC4uLmVnLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKG5vLCB0LCBpZyksIHQubWF4ICYmIHR5cGVvZiB0Lm1heCA9PSBcInN0cmluZ1wiICYmICh0Lm1heCA9IG5ldyBEYXRlKHQubWF4KSksIHQubWluICYmIHR5cGVvZiB0Lm1pbiA9PSBcInN0cmluZ1wiICYmICh0Lm1pbiA9IG5ldyBEYXRlKHQubWluKSksIHQuc3RhcnREYXkgJiYgdC5zdGFydERheSAhPT0gMCkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2dldE5ld0RheXNPcmRlckFycmF5KHQpO1xuICAgICAgdC53ZWVrZGF5c05hcnJvdyA9IGk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uc2csXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkobm8sIHQsIG5nKSwgdDtcbiAgfVxuICBfZ2V0Q29udGFpbmVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUodGhpcy5fb3B0aW9ucy5jb250YWluZXIpO1xuICB9XG4gIF9nZXROZXdEYXlzT3JkZXJBcnJheSh0KSB7XG4gICAgY29uc3QgZSA9IHQuc3RhcnREYXksIGkgPSB0LndlZWtkYXlzTmFycm93O1xuICAgIHJldHVybiBpLnNsaWNlKGUpLmNvbmNhdChpLnNsaWNlKDAsIGUpKTtcbiAgfVxuICBfaW5pdCgpIHtcbiAgICAhdGhpcy50b2dnbGVCdXR0b24gJiYgdGhpcy5fb3B0aW9ucy50b2dnbGVCdXR0b24gJiYgKHRoaXMuX2FwcGVuZFRvZ2dsZUJ1dHRvbigpLCAodGhpcy5faW5wdXQucmVhZE9ubHkgfHwgdGhpcy5faW5wdXQuZGlzYWJsZWQpICYmICh0aGlzLnRvZ2dsZUJ1dHRvbi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCIpKSwgdGhpcy5fbGlzdGVuVG9Vc2VySW5wdXQoKSwgdGhpcy5fbGlzdGVuVG9Ub2dnbGVDbGljaygpLCB0aGlzLl9saXN0ZW5Ub1RvZ2dsZUtleWRvd24oKTtcbiAgfVxuICBfYXBwZW5kVG9nZ2xlQnV0dG9uKCkge1xuICAgIGNvbnN0IHQgPSBubShcbiAgICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbklkLFxuICAgICAgdGhpcy5fY2xhc3Nlcy5kYXRlcGlja2VyVG9nZ2xlQnV0dG9uXG4gICAgKTtcbiAgICB0aGlzLl9lbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCB0KTtcbiAgfVxuICBvcGVuKCkge1xuICAgIGlmICh0aGlzLl9pbnB1dC5yZWFkT25seSB8fCB0aGlzLl9pbnB1dC5kaXNhYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGNtKTtcbiAgICBpZiAodGhpcy5faXNPcGVuIHx8IHQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9zZXRJbml0aWFsRGF0ZSgpO1xuICAgIGNvbnN0IGUgPSBRZih0aGlzLl9jbGFzc2VzLmRhdGVwaWNrZXJCYWNrZHJvcCksIGkgPSBaZihcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl9zZWxlY3RlZERhdGUsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZE1vbnRoLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIF9zLFxuICAgICAgVHQsXG4gICAgICBwcyxcbiAgICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbklkLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5fb3B0aW9ucy5pbmxpbmUgPyB0aGlzLl9vcGVuRHJvcGRvd24oaSkgOiAodGhpcy5fb3Blbk1vZGFsKGUsIGkpLCB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpKSwgdGhpcy5fYW5pbWF0aW9ucyAmJiAoaC5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lciwgdGhpcy5fY2xhc3Nlcy5mYWRlSW4pLCBoLmFkZENsYXNzKGUsIHRoaXMuX2NsYXNzZXMuZmFkZUluU2hvcnQpKSwgdGhpcy5fc2V0Rm9jdXNUcmFwKHRoaXMuY29udGFpbmVyKSwgdGhpcy5fbGlzdGVuVG9EYXRlU2VsZWN0aW9uKCksIHRoaXMuX2FkZENvbnRyb2xzTGlzdGVuZXJzKCksIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpLCB0aGlzLl9saXN0ZW5Ub0VzY2FwZUNsaWNrKCksIHRoaXMuX2xpc3RlblRvS2V5Ym9hcmROYXZpZ2F0aW9uKCksIHRoaXMuX2xpc3RlblRvRGF0ZXNDb250YWluZXJGb2N1cygpLCB0aGlzLl9saXN0ZW5Ub0RhdGVzQ29udGFpbmVyQmx1cigpLCB0aGlzLl9hc3luY0ZvY3VzRGF0ZXNDb250YWluZXIoKSwgdGhpcy5fdXBkYXRlVmlld0NvbnRyb2xzQW5kQXR0cmlidXRlcyh0aGlzLl92aWV3KSwgdGhpcy5faXNPcGVuID0gITAsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fbGlzdGVuVG9PdXRzaWRlQ2xpY2soKTtcbiAgICB9LCAwKTtcbiAgfVxuICBfb3BlbkRyb3Bkb3duKHQpIHtcbiAgICB0aGlzLl9wb3BwZXIgPSBzZSh0aGlzLl9pbnB1dCwgdCwge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiXG4gICAgfSksIHRoaXMuX2dldENvbnRhaW5lcigpLmFwcGVuZENoaWxkKHQpO1xuICB9XG4gIF9vcGVuTW9kYWwodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICBpLmFwcGVuZENoaWxkKHQpLCBpLmFwcGVuZENoaWxkKGUpO1xuICB9XG4gIF9zZXRGb2N1c1RyYXAodCkge1xuICAgIHRoaXMuX2ZvY3VzVHJhcCA9IG5ldyB6aSh0LCB7XG4gICAgICBldmVudDogXCJrZXlkb3duXCIsXG4gICAgICBjb25kaXRpb246IChlKSA9PiBlLmtleSA9PT0gXCJUYWJcIlxuICAgIH0pLCB0aGlzLl9mb2N1c1RyYXAudHJhcCgpO1xuICB9XG4gIF9saXN0ZW5Ub1VzZXJJbnB1dCgpIHtcbiAgICBjLm9uKHRoaXMuX2lucHV0LCBcImlucHV0XCIsICh0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVVc2VySW5wdXQodC50YXJnZXQudmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub1RvZ2dsZUNsaWNrKCkge1xuICAgIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgZnMsXG4gICAgICBtcyxcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5vcGVuKCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfbGlzdGVuVG9Ub2dnbGVLZXlkb3duKCkge1xuICAgIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICBtcyxcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHQua2V5Q29kZSA9PT0gaXQgJiYgIXRoaXMuX2lzT3BlbiAmJiB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9saXN0ZW5Ub0RhdGVTZWxlY3Rpb24oKSB7XG4gICAgYy5vbih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImNsaWNrXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVEYXRlU2VsZWN0aW9uKHQpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVEYXRlU2VsZWN0aW9uKHQpIHtcbiAgICBjb25zdCBlID0gdC50YXJnZXQubm9kZU5hbWUgPT09IFwiRElWXCIgPyB0LnRhcmdldC5wYXJlbnROb2RlLmRhdGFzZXQgOiB0LnRhcmdldC5kYXRhc2V0LCBpID0gdC50YXJnZXQubm9kZU5hbWUgPT09IFwiRElWXCIgPyB0LnRhcmdldC5wYXJlbnROb2RlIDogdC50YXJnZXQ7XG4gICAgaWYgKGUudGVEYXRlICYmIHRoaXMuX3BpY2tEYXkoZS50ZURhdGUsIGkpLCBlLnRlTW9udGggJiYgZS50ZVllYXIpIHtcbiAgICAgIGNvbnN0IG4gPSBwYXJzZUludChlLnRlTW9udGgsIDEwKSwgbyA9IHBhcnNlSW50KGUudGVZZWFyLCAxMCk7XG4gICAgICB0aGlzLl9waWNrTW9udGgobiwgbyk7XG4gICAgfVxuICAgIGlmIChlLnRlWWVhciAmJiAhZS50ZU1vbnRoKSB7XG4gICAgICBjb25zdCBuID0gcGFyc2VJbnQoZS50ZVllYXIsIDEwKTtcbiAgICAgIHRoaXMuX3BpY2tZZWFyKG4pO1xuICAgIH1cbiAgICB0aGlzLl9vcHRpb25zLmlubGluZSB8fCB0aGlzLl91cGRhdGVIZWFkZXJEYXRlKFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMubW9udGhzU2hvcnQsXG4gICAgICB0aGlzLl9vcHRpb25zLndlZWtkYXlzU2hvcnRcbiAgICApO1xuICB9XG4gIF91cGRhdGVIZWFkZXJEYXRlKHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gZC5maW5kT25lKFxuICAgICAgRW0sXG4gICAgICB0aGlzLmNvbnRhaW5lclxuICAgICksIG8gPSBZKHQpLCByID0gdHQodCksIGEgPSB6cyh0KTtcbiAgICBuLmlubmVySFRNTCA9IGAke2lbYV19LCAke2Vbb119ICR7cn1gO1xuICB9XG4gIF9hZGRDb250cm9sc0xpc3RlbmVycygpIHtcbiAgICBjLm9uKHRoaXMubmV4dEJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl92aWV3ID09PSBcImRheXNcIiA/IHRoaXMubmV4dE1vbnRoKCkgOiB0aGlzLl92aWV3ID09PSBcInllYXJzXCIgPyB0aGlzLm5leHRZZWFycygpIDogdGhpcy5uZXh0WWVhcigpLCB0aGlzLl91cGRhdGVDb250cm9sc0Rpc2FibGVkU3RhdGUoKTtcbiAgICB9KSwgYy5vbih0aGlzLnByZXZpb3VzQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiID8gdGhpcy5wcmV2aW91c01vbnRoKCkgOiB0aGlzLl92aWV3ID09PSBcInllYXJzXCIgPyB0aGlzLnByZXZpb3VzWWVhcnMoKSA6IHRoaXMucHJldmlvdXNZZWFyKCksIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpO1xuICAgIH0pLCBjLm9uKHRoaXMudmlld0NoYW5nZUJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl92aWV3ID09PSBcImRheXNcIiA/IHRoaXMuX2NoYW5nZVZpZXcoXCJ5ZWFyc1wiKSA6ICh0aGlzLl92aWV3ID09PSBcInllYXJzXCIgfHwgdGhpcy5fdmlldyA9PT0gXCJtb250aHNcIikgJiYgdGhpcy5fY2hhbmdlVmlldyhcImRheXNcIik7XG4gICAgfSksIHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX2xpc3RlblRvRm9vdGVyQnV0dG9uc0NsaWNrKCk7XG4gIH1cbiAgX2xpc3RlblRvRm9vdGVyQnV0dG9uc0NsaWNrKCkge1xuICAgIGMub24odGhpcy5va0J1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB0aGlzLmhhbmRsZU9rKCkpLCBjLm9uKHRoaXMuY2FuY2VsQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHRoaXMuaGFuZGxlQ2FuY2VsKCkpLCBjLm9uKHRoaXMuY2xlYXJCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5oYW5kbGVDbGVhcigpKTtcbiAgfVxuICBfbGlzdGVuVG9PdXRzaWRlQ2xpY2soKSB7XG4gICAgYy5vbihkb2N1bWVudCwgZnMsICh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gdC50YXJnZXQgPT09IHRoaXMuY29udGFpbmVyLCBpID0gdGhpcy5jb250YWluZXIgJiYgdGhpcy5jb250YWluZXIuY29udGFpbnModC50YXJnZXQpO1xuICAgICAgIWUgJiYgIWkgJiYgdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0VzY2FwZUNsaWNrKCkge1xuICAgIGMub24oZG9jdW1lbnQsIFwia2V5ZG93blwiLCAodCkgPT4ge1xuICAgICAgdC5rZXlDb2RlID09PSB3ZSAmJiB0aGlzLl9pc09wZW4gJiYgdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0tleWJvYXJkTmF2aWdhdGlvbigpIHtcbiAgICBjLm9uKHRoaXMuZGF0ZXNDb250YWluZXIsIFwia2V5ZG93blwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5faGFuZGxlS2V5ZG93bih0KTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9EYXRlc0NvbnRhaW5lckZvY3VzKCkge1xuICAgIGMub24odGhpcy5kYXRlc0NvbnRhaW5lciwgXCJmb2N1c1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9mb2N1c0FjdGl2ZUNlbGwodGhpcy5hY3RpdmVDZWxsKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9EYXRlc0NvbnRhaW5lckJsdXIoKSB7XG4gICAgYy5vbih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImJsdXJcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVtb3ZlQ3VycmVudEZvY3VzU3R5bGVzKCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUtleWRvd24odCkge1xuICAgIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiICYmIHRoaXMuX2hhbmRsZURheXNWaWV3S2V5ZG93bih0KSwgdGhpcy5fdmlldyA9PT0gXCJtb250aHNcIiAmJiB0aGlzLl9oYW5kbGVNb250aHNWaWV3S2V5ZG93bih0KSwgdGhpcy5fdmlldyA9PT0gXCJ5ZWFyc1wiICYmIHRoaXMuX2hhbmRsZVllYXJzVmlld0tleWRvd24odCk7XG4gIH1cbiAgX2hhbmRsZURheXNWaWV3S2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2FjdGl2ZURhdGUsIGkgPSB0aGlzLmFjdGl2ZUNlbGw7XG4gICAgc3dpdGNoICh0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgS2U6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSAkZSh0aGlzLl9hY3RpdmVEYXRlLCBXKCkgPyAxIDogLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgemU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSAkZSh0aGlzLl9hY3RpdmVEYXRlLCBXKCkgPyAtMSA6IDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9ICRlKHRoaXMuX2FjdGl2ZURhdGUsIC03KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHo6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSAkZSh0aGlzLl9hY3RpdmVEYXRlLCA3KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gJGUoXG4gICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICAxIC0gdHQodGhpcy5fYWN0aXZlRGF0ZSlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gJGUoXG4gICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICBHbyh0aGlzLl9hY3RpdmVEYXRlKSAtIHR0KHRoaXMuX2FjdGl2ZURhdGUpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpbzpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGx0KHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHNvOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbHQodGhpcy5fYWN0aXZlRGF0ZSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpdDpcbiAgICAgIGNhc2UgWnM6XG4gICAgICAgIHRoaXMuX3NlbGVjdERhdGUodGhpcy5fYWN0aXZlRGF0ZSksIHRoaXMuX2hhbmRsZURhdGVTZWxlY3Rpb24odCksIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBQaShcbiAgICAgIGUsXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fdmlldyxcbiAgICAgIFR0LFxuICAgICAgdGhpcy5fb3B0aW9ucy5taW4sXG4gICAgICB0aGlzLl9vcHRpb25zLm1heFxuICAgICkgfHwgdGhpcy5fY2hhbmdlVmlldyhcImRheXNcIiksIHRoaXMuX3JlbW92ZUhpZ2hsaWdodEZyb21DZWxsKGkpLCB0aGlzLl9mb2N1c0FjdGl2ZUNlbGwodGhpcy5hY3RpdmVDZWxsKSwgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIF9hc3luY0ZvY3VzRGF0ZXNDb250YWluZXIoKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmRhdGVzQ29udGFpbmVyLmZvY3VzKCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgX2ZvY3VzQWN0aXZlQ2VsbCh0KSB7XG4gICAgdCAmJiB0LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRcIiwgXCJcIik7XG4gIH1cbiAgX3JlbW92ZUhpZ2hsaWdodEZyb21DZWxsKHQpIHtcbiAgICB0ICYmIHQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZm9jdXNlZFwiKTtcbiAgfVxuICBfZ2V0QWN0aXZlRGF5Q2VsbCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKFwidGRcIiwgdGhpcy5kYXRlc0NvbnRhaW5lcik7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odCkuZmluZCgoaSkgPT4ge1xuICAgICAgY29uc3QgbiA9IFZhKGkuZGF0YXNldC50ZURhdGUpO1xuICAgICAgcmV0dXJuIG1lKG4sIHRoaXMuX2FjdGl2ZURhdGUpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVNb250aHNWaWV3S2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2FjdGl2ZURhdGUsIGkgPSB0aGlzLmFjdGl2ZUNlbGw7XG4gICAgc3dpdGNoICh0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgS2U6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBsdCh0aGlzLl9hY3RpdmVEYXRlLCBXKCkgPyAxIDogLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgemU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBsdCh0aGlzLl9hY3RpdmVEYXRlLCBXKCkgPyAtMSA6IDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGx0KHRoaXMuX2FjdGl2ZURhdGUsIC00KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHo6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBsdCh0aGlzLl9hY3RpdmVEYXRlLCA0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbHQodGhpcy5fYWN0aXZlRGF0ZSwgLXRoaXMuYWN0aXZlTW9udGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRWU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBsdCh0aGlzLl9hY3RpdmVEYXRlLCAxMSAtIHRoaXMuYWN0aXZlTW9udGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaW86XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBhdCh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzbzpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGF0KHRoaXMuX2FjdGl2ZURhdGUsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXQ6XG4gICAgICBjYXNlIFpzOlxuICAgICAgICB0aGlzLl9zZWxlY3RNb250aCh0aGlzLmFjdGl2ZU1vbnRoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBQaShcbiAgICAgIGUsXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fdmlldyxcbiAgICAgIFR0LFxuICAgICAgdGhpcy5fb3B0aW9ucy5taW4sXG4gICAgICB0aGlzLl9vcHRpb25zLm1heFxuICAgICkgfHwgdGhpcy5fY2hhbmdlVmlldyhcIm1vbnRoc1wiKSwgdGhpcy5fcmVtb3ZlSGlnaGxpZ2h0RnJvbUNlbGwoaSksIHRoaXMuX2ZvY3VzQWN0aXZlQ2VsbCh0aGlzLmFjdGl2ZUNlbGwpLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX2dldEFjdGl2ZU1vbnRoQ2VsbCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKFwidGRcIiwgdGhpcy5kYXRlc0NvbnRhaW5lcik7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odCkuZmluZCgoaSkgPT4ge1xuICAgICAgY29uc3QgbiA9IHBhcnNlSW50KGkuZGF0YXNldC50ZVllYXIsIDEwKSwgbyA9IHBhcnNlSW50KGkuZGF0YXNldC50ZU1vbnRoLCAxMCk7XG4gICAgICByZXR1cm4gbiA9PT0gdGhpcy5hY3RpdmVZZWFyICYmIG8gPT09IHRoaXMuYWN0aXZlTW9udGg7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVllYXJzVmlld0tleWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9hY3RpdmVEYXRlLCBpID0gdGhpcy5hY3RpdmVDZWxsLCBuID0gNCwgbyA9IDI0O1xuICAgIHN3aXRjaCAodC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIEtlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gYXQodGhpcy5fYWN0aXZlRGF0ZSwgVygpID8gMSA6IC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHplOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gYXQodGhpcy5fYWN0aXZlRGF0ZSwgVygpID8gLTEgOiAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBhdCh0aGlzLl9hY3RpdmVEYXRlLCAtbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB6OlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gYXQodGhpcy5fYWN0aXZlRGF0ZSwgbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGF0KFxuICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgLVVzKHRoaXMuX2FjdGl2ZURhdGUsIG8pXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGF0KFxuICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgbyAtIFVzKHRoaXMuX2FjdGl2ZURhdGUsIG8pIC0gMVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaW86XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBhdCh0aGlzLl9hY3RpdmVEYXRlLCAtbyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzbzpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGF0KHRoaXMuX2FjdGl2ZURhdGUsIG8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXQ6XG4gICAgICBjYXNlIFpzOlxuICAgICAgICB0aGlzLl9zZWxlY3RZZWFyKHRoaXMuYWN0aXZlWWVhcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgUGkoXG4gICAgICBlLFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICBUdCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXhcbiAgICApIHx8IHRoaXMuX2NoYW5nZVZpZXcoXCJ5ZWFyc1wiKSwgdGhpcy5fcmVtb3ZlSGlnaGxpZ2h0RnJvbUNlbGwoaSksIHRoaXMuX2ZvY3VzQWN0aXZlQ2VsbCh0aGlzLmFjdGl2ZUNlbGwpLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX2dldEFjdGl2ZVllYXJDZWxsKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmQoXCJ0ZFwiLCB0aGlzLmRhdGVzQ29udGFpbmVyKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0KS5maW5kKChpKSA9PiBwYXJzZUludChpLmRhdGFzZXQudGVZZWFyLCAxMCkgPT09IHRoaXMuYWN0aXZlWWVhcik7XG4gIH1cbiAgX3NldEluaXRpYWxEYXRlKCkge1xuICAgIHRoaXMuX2lucHV0LnZhbHVlID8gdGhpcy5faGFuZGxlVXNlcklucHV0KHRoaXMuX2lucHV0LnZhbHVlKSA6IHRoaXMuX29wdGlvbnMuc3RhcnREYXRlID8gdGhpcy5fYWN0aXZlRGF0ZSA9IG5ldyBEYXRlKHRoaXMuX29wdGlvbnMuc3RhcnREYXRlKSA6IHRoaXMuX2FjdGl2ZURhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBjb25zdCB0ID0gYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGxtKTtcbiAgICAhdGhpcy5faXNPcGVuIHx8IHQuZGVmYXVsdFByZXZlbnRlZCB8fCAodGhpcy5fcmVtb3ZlRGF0ZXBpY2tlckxpc3RlbmVycygpLCB0aGlzLl9hbmltYXRpb25zICYmIGguYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIHRoaXMuX2NsYXNzZXMuZmFkZU91dCksIHRoaXMuX29wdGlvbnMuaW5saW5lID8gdGhpcy5fY2xvc2VEcm9wZG93bigpIDogdGhpcy5fY2xvc2VNb2RhbCgpLCB0aGlzLl9pc09wZW4gPSAhMSwgdGhpcy5fdmlldyA9IHRoaXMuX29wdGlvbnMudmlldywgdGhpcy50b2dnbGVCdXR0b24gPyB0aGlzLnRvZ2dsZUJ1dHRvbi5mb2N1cygpIDogdGhpcy5faW5wdXQuZm9jdXMoKSk7XG4gIH1cbiAgX2Nsb3NlRHJvcGRvd24oKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZSh1bSksIGUgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCIpLm1hdGNoZXMgJiYgKHQgJiYgZS5yZW1vdmVDaGlsZCh0KSwgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci5kZXN0cm95KCkpLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgdCAmJiBlLnJlbW92ZUNoaWxkKHQpLCB0aGlzLl9wb3BwZXIgJiYgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICB9KSwgdGhpcy5fcmVtb3ZlRm9jdXNUcmFwKCk7XG4gIH1cbiAgX2Nsb3NlTW9kYWwoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShDbSksIGUgPSBkLmZpbmRPbmUoZG0pO1xuICAgICFlIHx8ICF0IHx8ICh0aGlzLl9hbmltYXRpb25zID8gKGguYWRkQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0U2hvcnQpLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVtb3ZlUGlja2VyKHQsIGUpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgICB9KSkgOiAodGhpcy5fcmVtb3ZlUGlja2VyKHQsIGUpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKSkpO1xuICB9XG4gIF9yZW1vdmVQaWNrZXIodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICBpLnJlbW92ZUNoaWxkKHQpLCBpLnJlbW92ZUNoaWxkKGUpO1xuICB9XG4gIF9yZW1vdmVGb2N1c1RyYXAoKSB7XG4gICAgdGhpcy5fZm9jdXNUcmFwICYmICh0aGlzLl9mb2N1c1RyYXAuZGlzYWJsZSgpLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsKTtcbiAgfVxuICBfcmVtb3ZlRGF0ZXBpY2tlckxpc3RlbmVycygpIHtcbiAgICBjLm9mZih0aGlzLm5leHRCdXR0b24sIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMucHJldmlvdXNCdXR0b24sIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMudmlld0NoYW5nZUJ1dHRvbiwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy5va0J1dHRvbiwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy5jYW5jZWxCdXR0b24sIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMuY2xlYXJCdXR0b24sIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMuZGF0ZXNDb250YWluZXIsIFwia2V5ZG93blwiKSwgYy5vZmYodGhpcy5kYXRlc0NvbnRhaW5lciwgXCJmb2N1c1wiKSwgYy5vZmYodGhpcy5kYXRlc0NvbnRhaW5lciwgXCJibHVyXCIpLCBjLm9mZihkb2N1bWVudCwgZnMpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5faXNPcGVuICYmIHRoaXMuY2xvc2UoKSwgdGhpcy5fcmVtb3ZlSW5wdXRBbmRUb2dnbGVMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgYCMke3RoaXMuX3RvZ2dsZUJ1dHRvbklkfWBcbiAgICApO1xuICAgIHQgJiYgdGhpcy5fZWxlbWVudC5yZW1vdmVDaGlsZCh0KSwgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIFFzKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX2lucHV0ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHRoaXMuX2FjdGl2ZURhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZERhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gbnVsbCwgdGhpcy5faGVhZGVyRGF0ZSA9IG51bGwsIHRoaXMuX2hlYWRlclllYXIgPSBudWxsLCB0aGlzLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX3ZpZXcgPSBudWxsLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsO1xuICB9XG4gIF9yZW1vdmVJbnB1dEFuZFRvZ2dsZUxpc3RlbmVycygpIHtcbiAgICBjLm9mZih0aGlzLl9pbnB1dCwgXCJpbnB1dFwiKSwgYy5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgZnMsXG4gICAgICBtc1xuICAgICksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwia2V5ZG93blwiLCBtcyk7XG4gIH1cbiAgaGFuZGxlT2soKSB7XG4gICAgdGhpcy5fY29uZmlybVNlbGVjdGlvbih0aGlzLl9oZWFkZXJEYXRlKSwgdGhpcy5jbG9zZSgpO1xuICB9XG4gIF9zZWxlY3REYXRlKHQsIGUgPSB0aGlzLmFjdGl2ZUNlbGwpIHtcbiAgICBjb25zdCB7IG1pbjogaSwgbWF4OiBuLCBmaWx0ZXI6IG8sIGRpc2FibGVQYXN0OiByLCBkaXNhYmxlRnV0dXJlOiBhIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIF9uKHQsIGksIG4sIG8sIHIsIGEpIHx8ICh0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX3JlbW92ZUN1cnJlbnRGb2N1c1N0eWxlcygpLCB0aGlzLl9hZGRTZWxlY3RlZFN0eWxlcyhlKSwgdGhpcy5fc2VsZWN0ZWREYXRlID0gdCwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gQih0KSwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IFkodCksIHRoaXMuX2hlYWRlckRhdGUgPSB0LCAodGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5vcHRpb25zLmNvbmZpcm1EYXRlT25TZWxlY3QpICYmICh0aGlzLl9jb25maXJtU2VsZWN0aW9uKHQpLCB0aGlzLmNsb3NlKCkpKTtcbiAgfVxuICBfc2VsZWN0WWVhcih0LCBlID0gdGhpcy5hY3RpdmVDZWxsKSB7XG4gICAgdGhpcy5fcmVtb3ZlQ3VycmVudFNlbGVjdGlvblN0eWxlcygpLCB0aGlzLl9yZW1vdmVDdXJyZW50Rm9jdXNTdHlsZXMoKSwgdGhpcy5fYWRkU2VsZWN0ZWRTdHlsZXMoZSksIHRoaXMuX2hlYWRlclllYXIgPSB0LCB0aGlzLl9hc3luY0NoYW5nZVZpZXcoXCJtb250aHNcIik7XG4gIH1cbiAgX3NlbGVjdE1vbnRoKHQsIGUgPSB0aGlzLmFjdGl2ZUNlbGwpIHtcbiAgICB0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX3JlbW92ZUN1cnJlbnRGb2N1c1N0eWxlcygpLCB0aGlzLl9hZGRTZWxlY3RlZFN0eWxlcyhlKSwgdGhpcy5faGVhZGVyTW9udGggPSB0LCB0aGlzLl9hc3luY0NoYW5nZVZpZXcoXCJkYXlzXCIpO1xuICB9XG4gIF9yZW1vdmVTZWxlY3RlZFN0eWxlcyh0KSB7XG4gICAgdCAmJiB0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIpO1xuICB9XG4gIF9hZGRTZWxlY3RlZFN0eWxlcyh0KSB7XG4gICAgdCAmJiB0LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIsIFwiXCIpO1xuICB9XG4gIF9jb25maXJtU2VsZWN0aW9uKHQpIHtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMuZm9ybWF0RGF0ZSh0KTtcbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gZSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGhtLCB7IGRhdGU6IHQgfSksIGMudHJpZ2dlcih0aGlzLl9pbnB1dCwgXCJpbnB1dFwiKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlQ2FuY2VsKCkge1xuICAgIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgaGFuZGxlQ2xlYXIoKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWREYXRlID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX2hlYWRlckRhdGUgPSBudWxsLCB0aGlzLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX2hlYWRlclllYXIgPSBudWxsLCB0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX2lucHV0LnZhbHVlID0gXCJcIiwgdGhpcy5fc2V0SW5pdGlhbERhdGUoKSwgdGhpcy5fY2hhbmdlVmlldyhcImRheXNcIiksIHRoaXMuX3VwZGF0ZUhlYWRlckRhdGUoXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tb250aHNTaG9ydCxcbiAgICAgIHRoaXMuX29wdGlvbnMud2Vla2RheXNTaG9ydFxuICAgICk7XG4gIH1cbiAgX3JlbW92ZUN1cnJlbnRTZWxlY3Rpb25TdHlsZXMoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgIFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXVwiLFxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICApO1xuICAgIHQgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiKTtcbiAgfVxuICBfcmVtb3ZlQ3VycmVudEZvY3VzU3R5bGVzKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICBcIltkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXVwiLFxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICApO1xuICAgIHQgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXCIpO1xuICB9XG4gIGZvcm1hdERhdGUodCkge1xuICAgIGNvbnN0IGUgPSB0dCh0KSwgaSA9IHRoaXMuX2FkZExlYWRpbmdaZXJvKHR0KHQpKSwgbiA9IHRoaXMuX29wdGlvbnMud2Vla2RheXNTaG9ydFt6cyh0KV0sIG8gPSB0aGlzLl9vcHRpb25zLndlZWtkYXlzRnVsbFt6cyh0KV0sIHIgPSBZKHQpICsgMSwgYSA9IHRoaXMuX2FkZExlYWRpbmdaZXJvKFkodCkgKyAxKSwgbCA9IHRoaXMuX29wdGlvbnMubW9udGhzU2hvcnRbWSh0KV0sIHAgPSB0aGlzLl9vcHRpb25zLm1vbnRoc0Z1bGxbWSh0KV0sIHUgPSBCKHQpLnRvU3RyaW5nKCkubGVuZ3RoID09PSAyID8gQih0KSA6IEIodCkudG9TdHJpbmcoKS5zbGljZSgyLCA0KSwgXyA9IEIodCksIGYgPSB0aGlzLl9vcHRpb25zLmZvcm1hdC5zcGxpdChcbiAgICAgIC8oZHsxLDR9fG17MSw0fXx5ezR9fHl5fCEuKS9nXG4gICAgKTtcbiAgICBsZXQgZyA9IFwiXCI7XG4gICAgcmV0dXJuIGYuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgc3dpdGNoIChtKSB7XG4gICAgICAgIGNhc2UgXCJkZGRkXCI6XG4gICAgICAgICAgbSA9IG0ucmVwbGFjZShtLCBvKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRkZFwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgaSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgbSA9IG0ucmVwbGFjZShtLCBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1tbW1cIjpcbiAgICAgICAgICBtID0gbS5yZXBsYWNlKG0sIHApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibW1tXCI6XG4gICAgICAgICAgbSA9IG0ucmVwbGFjZShtLCBsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgICAgbSA9IG0ucmVwbGFjZShtLCBhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICBtID0gbS5yZXBsYWNlKG0sIHIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieXl5eVwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgXyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ5eVwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgdSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBnICs9IG07XG4gICAgfSksIGc7XG4gIH1cbiAgX2FkZExlYWRpbmdaZXJvKHQpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodCwgMTApIDwgMTAgPyBgMCR7dH1gIDogdDtcbiAgfVxuICBfcGlja0RheSh0LCBlKSB7XG4gICAgY29uc3QgaSA9IFZhKHQpLCB7IG1pbjogbiwgbWF4OiBvLCBmaWx0ZXI6IHIsIGRpc2FibGVQYXN0OiBhLCBkaXNhYmxlRnV0dXJlOiBsIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIF9uKGksIG4sIG8sIHIsIGEsIGwpIHx8ICh0aGlzLl9hY3RpdmVEYXRlID0gaSwgdGhpcy5fc2VsZWN0RGF0ZShpLCBlKSk7XG4gIH1cbiAgX3BpY2tZZWFyKHQpIHtcbiAgICBjb25zdCB7IG1pbjogZSwgbWF4OiBpLCBkaXNhYmxlUGFzdDogbiwgZGlzYWJsZUZ1dHVyZTogbyB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBpZiAocW8odCwgZSwgaSwgbiwgbykpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IEN0KHQsIHRoaXMuYWN0aXZlTW9udGgsIHRoaXMuYWN0aXZlRGF5KTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gciwgdGhpcy5fc2VsZWN0ZWREYXRlID0gciwgdGhpcy5fc2VsZWN0WWVhcih0KTtcbiAgfVxuICBfcGlja01vbnRoKHQsIGUpIHtcbiAgICBjb25zdCB7IG1pbjogaSwgbWF4OiBuLCBkaXNhYmxlUGFzdDogbywgZGlzYWJsZUZ1dHVyZTogciB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBpZiAoX2godCwgZSwgaSwgbiwgbywgcikgfHwgcW8oZSwgaSwgbiwgbywgcikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYSA9IEN0KGUsIHQsIHRoaXMuYWN0aXZlRGF5KTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gYSwgdGhpcy5fc2VsZWN0TW9udGgodCk7XG4gIH1cbiAgbmV4dE1vbnRoKCkge1xuICAgIGNvbnN0IHQgPSBsdCh0aGlzLl9hY3RpdmVEYXRlLCAxKSwgZSA9IFhzKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX2hlYWRlckRhdGUsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuX29wdGlvbnMubW9udGhzRnVsbFt0aGlzLmFjdGl2ZU1vbnRoXX0gJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBMdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIHByZXZpb3VzTW9udGgoKSB7XG4gICAgY29uc3QgdCA9IGx0KHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdDtcbiAgICBjb25zdCBlID0gWHMoXG4gICAgICB0LFxuICAgICAgdGhpcy5faGVhZGVyRGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLl9vcHRpb25zLm1vbnRoc0Z1bGxbdGhpcy5hY3RpdmVNb250aF19ICR7dGhpcy5hY3RpdmVZZWFyfWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0gTHQoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZTtcbiAgfVxuICBuZXh0WWVhcigpIHtcbiAgICBjb25zdCB0ID0gYXQodGhpcy5fYWN0aXZlRGF0ZSwgMSk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IEx0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIGNvbnN0IGUgPSBHcyhcbiAgICAgIHRoaXMuYWN0aXZlWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkTW9udGgsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgX3MsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgcHJldmlvdXNZZWFyKCkge1xuICAgIGNvbnN0IHQgPSBhdCh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IEx0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIGNvbnN0IGUgPSBHcyhcbiAgICAgIHRoaXMuYWN0aXZlWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkTW9udGgsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgX3MsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgbmV4dFllYXJzKCkge1xuICAgIGNvbnN0IHQgPSBhdCh0aGlzLl9hY3RpdmVEYXRlLCAyNCk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQ7XG4gICAgY29uc3QgZSA9IHFzKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICBUdCxcbiAgICAgIHBzLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5maXJzdFllYXJJblZpZXd9IC0gJHt0aGlzLmxhc3RZZWFySW5WaWV3fWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0gTHQoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZTtcbiAgfVxuICBwcmV2aW91c1llYXJzKCkge1xuICAgIGNvbnN0IHQgPSBhdCh0aGlzLl9hY3RpdmVEYXRlLCAtMjQpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0O1xuICAgIGNvbnN0IGUgPSBxcyhcbiAgICAgIHQsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgVHQsXG4gICAgICBwcyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuZmlyc3RZZWFySW5WaWV3fSAtICR7dGhpcy5sYXN0WWVhckluVmlld31gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IEx0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgX2FzeW5jQ2hhbmdlVmlldyh0KSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9jaGFuZ2VWaWV3KHQpO1xuICAgIH0sIDApO1xuICB9XG4gIF9jaGFuZ2VWaWV3KHQpIHtcbiAgICB0aGlzLl92aWV3ID0gdCwgdGhpcy5kYXRlc0NvbnRhaW5lci5ibHVyKCksIHQgPT09IFwiZGF5c1wiICYmICh0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IFhzKFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX2hlYWRlckRhdGUsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICkpLCB0ID09PSBcIm1vbnRoc1wiICYmICh0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IEdzKFxuICAgICAgdGhpcy5hY3RpdmVZZWFyLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRZZWFyLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRNb250aCxcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICBfcyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApKSwgdCA9PT0gXCJ5ZWFyc1wiICYmICh0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IHFzKFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICBUdCxcbiAgICAgIHBzLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICkpLCB0aGlzLmRhdGVzQ29udGFpbmVyLmZvY3VzKCksIHRoaXMuX3VwZGF0ZVZpZXdDb250cm9sc0FuZEF0dHJpYnV0ZXModCksIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpO1xuICB9XG4gIF91cGRhdGVWaWV3Q29udHJvbHNBbmRBdHRyaWJ1dGVzKHQpIHtcbiAgICB0ID09PSBcImRheXNcIiAmJiAodGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5fb3B0aW9ucy5tb250aHNGdWxsW3RoaXMuYWN0aXZlTW9udGhdfSAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IEx0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN3aXRjaFRvTXVsdGlZZWFyVmlld0xhYmVsXG4gICAgKSwgdGhpcy5wcmV2aW91c0J1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMucHJldk1vbnRoTGFiZWxcbiAgICApLCB0aGlzLm5leHRCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLl9vcHRpb25zLm5leHRNb250aExhYmVsKSksIHQgPT09IFwibW9udGhzXCIgJiYgKHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IEx0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN3aXRjaFRvRGF5Vmlld0xhYmVsXG4gICAgKSwgdGhpcy5wcmV2aW91c0J1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMucHJldlllYXJMYWJlbFxuICAgICksIHRoaXMubmV4dEJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMuX29wdGlvbnMubmV4dFllYXJMYWJlbCkpLCB0ID09PSBcInllYXJzXCIgJiYgKHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuZmlyc3RZZWFySW5WaWV3fSAtICR7dGhpcy5sYXN0WWVhckluVmlld31gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IEx0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN3aXRjaFRvTW9udGhWaWV3TGFiZWxcbiAgICApLCB0aGlzLnByZXZpb3VzQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5wcmV2TXVsdGlZZWFyTGFiZWxcbiAgICApLCB0aGlzLm5leHRCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLm5leHRNdWx0aVllYXJMYWJlbFxuICAgICkpO1xuICB9XG4gIF91cGRhdGVDb250cm9sc0Rpc2FibGVkU3RhdGUoKSB7XG4gICAgSGYoXG4gICAgICB0aGlzLl9vcHRpb25zLmRpc2FibGVGdXR1cmUsXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fdmlldyxcbiAgICAgIFR0LFxuICAgICAgdGhpcy5fb3B0aW9ucy5taW4sXG4gICAgICB0aGlzLl9vcHRpb25zLm1heCxcbiAgICAgIHRoaXMubGFzdFllYXJJblZpZXcsXG4gICAgICB0aGlzLmZpcnN0WWVhckluVmlld1xuICAgICkgPyB0aGlzLm5leHRCdXR0b24uZGlzYWJsZWQgPSAhMCA6IHRoaXMubmV4dEJ1dHRvbi5kaXNhYmxlZCA9ICExLCBWZihcbiAgICAgIHRoaXMuX29wdGlvbnMuZGlzYWJsZVBhc3QsXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fdmlldyxcbiAgICAgIFR0LFxuICAgICAgdGhpcy5fb3B0aW9ucy5taW4sXG4gICAgICB0aGlzLl9vcHRpb25zLm1heCxcbiAgICAgIHRoaXMubGFzdFllYXJJblZpZXcsXG4gICAgICB0aGlzLmZpcnN0WWVhckluVmlld1xuICAgICkgPyB0aGlzLnByZXZpb3VzQnV0dG9uLmRpc2FibGVkID0gITAgOiB0aGlzLnByZXZpb3VzQnV0dG9uLmRpc2FibGVkID0gITE7XG4gIH1cbiAgX2hhbmRsZVVzZXJJbnB1dCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldERlbGltZXRlcnModGhpcy5fb3B0aW9ucy5mb3JtYXQpLCBpID0gdGhpcy5fcGFyc2VEYXRlKHQsIHRoaXMuX29wdGlvbnMuZm9ybWF0LCBlKTtcbiAgICBSZihpKSA/ICh0aGlzLl9hY3RpdmVEYXRlID0gaSwgdGhpcy5fc2VsZWN0ZWREYXRlID0gaSwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gQihpKSwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IFkoaSksIHRoaXMuX2hlYWRlckRhdGUgPSBpKSA6ICh0aGlzLl9hY3RpdmVEYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9oZWFkZXJEYXRlID0gbnVsbCwgdGhpcy5faGVhZGVyTW9udGggPSBudWxsLCB0aGlzLl9oZWFkZXJZZWFyID0gbnVsbCk7XG4gIH1cbiAgX2dldERlbGltZXRlcnModCkge1xuICAgIHJldHVybiB0Lm1hdGNoKC9bXihkbXkpXXsxLH0vZyk7XG4gIH1cbiAgX3BhcnNlRGF0ZSh0LCBlLCBpKSB7XG4gICAgbGV0IG47XG4gICAgaVswXSAhPT0gaVsxXSA/IG4gPSBpWzBdICsgaVsxXSA6IG4gPSBpWzBdO1xuICAgIGNvbnN0IG8gPSBuZXcgUmVnRXhwKGBbJHtufV1gKSwgciA9IHQuc3BsaXQobyksIGEgPSBlLnNwbGl0KG8pLCBsID0gZS5pbmRleE9mKFwibW1tXCIpICE9PSAtMSwgcCA9IFtdO1xuICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYS5sZW5ndGg7IGIrKylcbiAgICAgIGFbYl0uaW5kZXhPZihcInl5XCIpICE9PSAtMSAmJiAocFswXSA9IHsgdmFsdWU6IHJbYl0sIGZvcm1hdDogYVtiXSB9KSwgYVtiXS5pbmRleE9mKFwibVwiKSAhPT0gLTEgJiYgKHBbMV0gPSB7IHZhbHVlOiByW2JdLCBmb3JtYXQ6IGFbYl0gfSksIGFbYl0uaW5kZXhPZihcImRcIikgIT09IC0xICYmIGFbYl0ubGVuZ3RoIDw9IDIgJiYgKHBbMl0gPSB7IHZhbHVlOiByW2JdLCBmb3JtYXQ6IGFbYl0gfSk7XG4gICAgbGV0IHU7XG4gICAgZS5pbmRleE9mKFwibW1tbVwiKSAhPT0gLTEgPyB1ID0gdGhpcy5fb3B0aW9ucy5tb250aHNGdWxsIDogdSA9IHRoaXMuX29wdGlvbnMubW9udGhzU2hvcnQ7XG4gICAgY29uc3QgXyA9IE51bWJlcihwWzBdLnZhbHVlKSwgZiA9IGwgPyB0aGlzLmdldE1vbnRoTnVtYmVyQnlNb250aE5hbWUocFsxXS52YWx1ZSwgdSkgOiBOdW1iZXIocFsxXS52YWx1ZSkgLSAxLCBnID0gTnVtYmVyKHBbMl0udmFsdWUpO1xuICAgIHJldHVybiBDdChfLCBmLCBnKTtcbiAgfVxuICBnZXRNb250aE51bWJlckJ5TW9udGhOYW1lKHQsIGUpIHtcbiAgICByZXR1cm4gZS5maW5kSW5kZXgoKGkpID0+IGkgPT09IHQpO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEEuZ2V0RGF0YSh0LCBRcyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgcmcgPSAoe1xuICBmb3JtYXQyNDogcyxcbiAgb2tMYWJlbDogdCxcbiAgY2FuY2VsTGFiZWw6IGUsXG4gIGhlYWRJRDogaSxcbiAgZm9vdGVySUQ6IG4sXG4gIGJvZHlJRDogbyxcbiAgcGlja2VySUQ6IHIsXG4gIGNsZWFyTGFiZWw6IGEsXG4gIGlubGluZTogbCxcbiAgc2hvd0NsZWFyQnRuOiBwLFxuICBhbUxhYmVsOiB1LFxuICBwbUxhYmVsOiBfXG59LCBmKSA9PiB7XG4gIGNvbnN0IGcgPSBgPGRpdiBpZD0nJHtyfScgY2xhc3M9JyR7Zi50aW1lcGlja2VyV3JhcHBlcn0nIGRhdGEtdGUtdGltZXBpY2tlci13cmFwcGVyPlxuICAgICAgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyQ29udGFpbmVyfVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJFbGVtZW50c31cIiBkYXRhLXRlLXRpbWVwaWNrZXItZWxlbWVudHMtd3JhcHBlcj5cbiAgICAgICAgPGRpdiBpZD0nJHtpfScgY2xhc3M9JyR7Zi50aW1lcGlja2VySGVhZH0nIHN0eWxlPSdwYWRkaW5nLXJpZ2h0OiR7cyA/IDUwIDogMTB9cHgnPlxuICAgICAgICA8ZGl2IGNsYXNzPScke2YudGltZXBpY2tlckhlYWRDb250ZW50fSc+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJDdXJyZW50V3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlckN1cnJlbnRCdXR0b25XcmFwcGVyfVwiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJDdXJyZW50QnV0dG9ufScgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS10aW1lcGlja2VyLWFjdGl2ZSBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudCBkYXRhLXRlLXRpbWVwaWNrZXItaG91ciBkYXRhLXRlLXJpcHBsZS1pbml0PjIxPC9idXR0b24+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlckRvdH0nIGRpc2FibGVkPjo8L2J1dHRvbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJDdXJyZW50QnV0dG9uV3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlckN1cnJlbnRCdXR0b259JyB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudCBkYXRhLXRlLXRpbWVwaWNrZXItbWludXRlIGRhdGEtdGUtcmlwcGxlLWluaXQ+MjE8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgJHtzID8gXCJcIiA6IGA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJNb2RlV3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz1cIiR7Zi50aW1lcGlja2VyTW9kZUFtfVwiIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtdGltZXBpY2tlci1hbSBkYXRhLXRlLXRpbWVwaWNrZXItaG91ci1tb2RlIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHt1fTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyTW9kZVBtfVwiIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtdGltZXBpY2tlci1wbSBkYXRhLXRlLXRpbWVwaWNrZXItaG91ci1tb2RlIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHtffTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PmB9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICAke2wgPyBcIlwiIDogYDxkaXYgaWQ9JyR7b30nIGNsYXNzPScke2YudGltZXBpY2tlckNsb2NrV3JhcHBlcn0nIGRhdGEtdGUtdGltZXBpY2tlci1jbG9jay13cmFwcGVyPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz0nJHtmLnRpbWVwaWNrZXJDbG9ja30nIGRhdGEtdGUtdGltZXBpY2tlci1jbG9jaz5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9JyR7Zi50aW1lcGlja2VyTWlkZGxlRG90fScgZGF0YS10ZS10aW1lcGlja2VyLW1pZGRsZS1kb3Q+PC9zcGFuPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPScke2YudGltZXBpY2tlckhhbmRQb2ludGVyfScgZGF0YS10ZS10aW1lcGlja2VyLWhhbmQtcG9pbnRlcj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPScke2YudGltZXBpY2tlclBvaW50ZXJDaXJjbGV9JyBkYXRhLXRlLXRpbWVwaWNrZXItY2lyY2xlPjwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgJHtzID8gJzxkaXYgY2xhc3M9XCInICsgZi50aW1lcGlja2VyQ2xvY2tJbm5lciArICdcIiBkYXRhLXRlLXRpbWVwaWNrZXItY2xvY2staW5uZXI+PC9kaXY+JyA6IFwiXCJ9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5gfVxuICAgIDwvZGl2PlxuICAgIDxkaXYgaWQ9JyR7bn0nIGNsYXNzPScke2YudGltZXBpY2tlckZvb3RlcldyYXBwZXJ9Jz5cbiAgICAgIDxkaXYgY2xhc3M9XCIke2YudGltZXBpY2tlckZvb3Rlcn1cIj5cbiAgICAgICAgJHtwID8gYDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJGb290ZXJCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItY2xlYXIgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke2F9PC9idXR0b24+YCA6IFwiXCJ9XG4gICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJGb290ZXJCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItY2FuY2VsIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHtlfTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VyRm9vdGVyQnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLXN1Ym1pdCB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7dH08L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PmAsIG0gPSBgPGRpdiBpZD0nJHtyfScgY2xhc3M9JyR7Zi50aW1lcGlja2VySW5saW5lV3JhcHBlcn0nIGRhdGEtdGUtdGltZXBpY2tlci13cmFwcGVyPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVDb250YWluZXJ9XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lRWxlbWVudHN9XCIgZGF0YS10ZS10aW1lcGlja2VyLWVsZW1lbnRzLXdyYXBwZXI+XG4gICAgICAgICAgPGRpdiBpZD0nJHtpfScgY2xhc3M9JyR7Zi50aW1lcGlja2VySW5saW5lSGVhZH0nXG4gICAgICAgICAgc3R5bGU9J3BhZGRpbmctcmlnaHQ6MTBweCc+XG4gICAgICAgICAgPGRpdiBjbGFzcz0nJHtmLnRpbWVwaWNrZXJJbmxpbmVIZWFkQ29udGVudH0nPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJDdXJyZW50V3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSG91cldyYXBwZXJ9XCIgZGF0YS10ZS10aW1lcGlja2VyLWlubGluZS1ob3VyLWljb25zPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25VcH1cIiBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi11cCBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1pbmxpbmUtaG91cj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25Tdmd9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTUgaC01XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk00LjUgMTUuNzVsNy41LTcuNSA3LjUgNy41XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz4gICBcbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZUN1cnJlbnRCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItaG91ciBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudCBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudC1pbmxpbmUgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4yMTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25Eb3dufVwiIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWlubGluZS1ob3VyIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWRvd24+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnfVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy01IGgtNVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTkuNSA4LjI1bC03LjUgNy41LTcuNS03LjVcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPiAgXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZURvdH0nIGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50LWlubGluZSBkaXNhYmxlZD46PC9idXR0b24+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJDdXJyZW50TWludXRlV3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSWNvblVwfVwiIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLXVwIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWlubGluZS1taW51dGU+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSWNvblN2Z31cIj5cbiAgICAgICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTUgaC01XCI+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNC41IDE1Ljc1bDcuNS03LjUgNy41IDcuNVwiIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VySW5saW5lQ3VycmVudEJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1taW51dGUgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQtaW5saW5lIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+MjE8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSWNvbkRvd259XCIgZGF0YS10ZS10aW1lcGlja2VyLWljb24taW5saW5lLW1pbnV0ZSBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1kb3duPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25Tdmd9XCI+XG4gICAgICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy01IGgtNVwiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE5LjUgOC4yNWwtNy41IDcuNS03LjUtNy41XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+IFxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgJHtzID8gXCJcIiA6IGA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVNb2RlV3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZU1vZGVBbX1cIiBkYXRhLXRlLXRpbWVwaWNrZXItYW0gZGF0YS10ZS10aW1lcGlja2VyLWhvdXItbW9kZSB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7dX08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVNb2RlUG19XCIgZGF0YS10ZS10aW1lcGlja2VyLWhvdXItbW9kZSBkYXRhLXRlLXRpbWVwaWNrZXItcG0gdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke199PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZVN1Ym1pdEJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1zdWJtaXQgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke3R9PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PmB9XG4gICAgICAgICAgICAgICR7cyA/IGA8YnV0dG9uIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZVN1Ym1pdEJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1zdWJtaXQgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke3R9PC9idXR0b24+YCA6IFwiXCJ9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5gO1xuICByZXR1cm4gbCA/IG0gOiBnO1xufSwgYWcgPSAocywgdCwgZSkgPT4ge1xuICBjb25zdCB7IGljb25TVkc6IGkgfSA9IHM7XG4gIHJldHVybiBgXG4gIDxidXR0b24gaWQ9XCIke3R9XCIgdGFiaW5kZXg9XCIwXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtlLnRpbWVwaWNrZXJUb2dnbGVCdXR0b259XCIgZGF0YS10ZS10b2dnbGU9XCJ0aW1lcGlja2VyXCIgZGF0YS10ZS10aW1lcGlja2VyLXRvZ2dsZS1idXR0b24gZGF0YS10ZS10aW1lcGlja2VyLWljb24+XG4gICAgJHtpfVxuICA8L2J1dHRvbj5cbmA7XG59LCBDbiA9IFwiZGF0YS10ZS10aW1lcGlja2VyLWRpc2FibGVkXCIsIGdzID0gXCJkYXRhLXRlLXRpbWVwaWNrZXItYWN0aXZlXCIsIENlID0gKHMpID0+IHtcbiAgaWYgKHMgPT09IFwiXCIpXG4gICAgcmV0dXJuO1xuICBsZXQgdCwgZSwgaSwgbjtcbiAgcmV0dXJuIGdoKHMpID8gKHQgPSBzLmdldEhvdXJzKCksIG4gPSB0LCBlID0gcy5nZXRNaW51dGVzKCksIHQgJT0gMTIsIG4gPT09IDAgJiYgdCA9PT0gMCAmJiAoaSA9IFwiQU1cIiksIHQgPSB0IHx8IDEyLCBpID09PSB2b2lkIDAgJiYgKGkgPSBOdW1iZXIobikgPj0gMTIgPyBcIlBNXCIgOiBcIkFNXCIpLCBlID0gZSA8IDEwID8gYDAke2V9YCA6IGUpIDogKFt0LCBlLCBpXSA9IFIocywgITEpLCBuID0gdCwgdCAlPSAxMiwgbiA9PT0gMCAmJiB0ID09PSAwICYmIChpID0gXCJBTVwiKSwgdCA9IHQgfHwgMTIsIGkgPT09IHZvaWQgMCAmJiAoaSA9IE51bWJlcihuKSA+PSAxMiA/IFwiUE1cIiA6IFwiQU1cIikpLCB7XG4gICAgaG91cnM6IHQsXG4gICAgbWludXRlczogZSxcbiAgICBhbU9yUG06IGlcbiAgfTtcbn0sIGdoID0gKHMpID0+IHMgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHMpID09PSBcIltvYmplY3QgRGF0ZV1cIiAmJiAhTnVtYmVyLmlzTmFOKHMpLCBLYSA9IChzKSA9PiB7XG4gIGlmIChzID09PSBcIlwiKVxuICAgIHJldHVybjtcbiAgbGV0IHQsIGU7XG4gIHJldHVybiBnaChzKSA/ICh0ID0gcy5nZXRIb3VycygpLCBlID0gcy5nZXRNaW51dGVzKCkpIDogW3QsIGVdID0gUihzLCAhMSksIGUgPSBOdW1iZXIoZSkgPCAxMCA/IGAwJHtOdW1iZXIoZSl9YCA6IGUsIHtcbiAgICBob3VyczogdCxcbiAgICBtaW51dGVzOiBlXG4gIH07XG59LCBsZyA9IChzLCB0LCBlKSA9PiBjLm9uKGRvY3VtZW50LCBzLCB0LCAoeyB0YXJnZXQ6IGkgfSkgPT4ge1xuICBpZiAoaS5oYXNBdHRyaWJ1dGUoZ3MpKVxuICAgIHJldHVybjtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0KS5mb3JFYWNoKChvKSA9PiB7XG4gICAgby5oYXNBdHRyaWJ1dGUoZ3MpICYmIChoLnJlbW92ZUNsYXNzKG8sIGUub3BhY2l0eSksIG8ucmVtb3ZlQXR0cmlidXRlKGdzKSk7XG4gIH0pLCBoLmFkZENsYXNzKGksIGUub3BhY2l0eSksIGkuc2V0QXR0cmlidXRlKGdzLCBcIlwiKTtcbn0pLCB6YSA9ICh7IGNsaWVudFg6IHMsIGNsaWVudFk6IHQsIHRvdWNoZXM6IGUgfSwgaSwgbiA9ICExKSA9PiB7XG4gIGNvbnN0IHsgbGVmdDogbywgdG9wOiByIH0gPSBpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBsZXQgYSA9IHt9O1xuICByZXR1cm4gIW4gfHwgIWUgPyBhID0ge1xuICAgIHg6IHMgLSBvLFxuICAgIHk6IHQgLSByXG4gIH0gOiBuICYmIE9iamVjdC5rZXlzKGUpLmxlbmd0aCA+IDAgJiYgKGEgPSB7XG4gICAgeDogZVswXS5jbGllbnRYIC0gbyxcbiAgICB5OiBlWzBdLmNsaWVudFkgLSByXG4gIH0pLCBhO1xufSwgYnMgPSAoKSA9PiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMiAmJiAvTWFjSW50ZWwvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSB8fCAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QoXG4gIG5hdmlnYXRvci51c2VyQWdlbnRcbiksIFIgPSAocywgdCA9ICEwKSA9PiB0ID8gcy52YWx1ZS5yZXBsYWNlKC86L2dpLCBcIiBcIikuc3BsaXQoXCIgXCIpIDogcy5yZXBsYWNlKC86L2dpLCBcIiBcIikuc3BsaXQoXCIgXCIpLCBiaCA9IChzLCB0KSA9PiB7XG4gIGNvbnN0IFtlLCBpLCBuXSA9IFIocywgITEpLCBbbywgciwgYV0gPSBSKHQsICExKTtcbiAgcmV0dXJuIG4gPT09IFwiUE1cIiAmJiBhID09PSBcIkFNXCIgfHwgbiA9PT0gYSAmJiBlID4gbyB8fCBpID4gcjtcbn0sIHZoID0gKCkgPT4ge1xuICBjb25zdCBzID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHQgPSBzLmdldEhvdXJzKCksIGUgPSBzLmdldE1pbnV0ZXMoKTtcbiAgcmV0dXJuIGAke3R9OiR7ZSA8IDEwID8gYDAke2V9YCA6IGV9YDtcbn0sIEd0ID0gKHMsIHQsIGUpID0+IHtcbiAgaWYgKCF0KVxuICAgIHJldHVybiBzO1xuICBsZXQgaSA9IHZoKCk7XG4gIHJldHVybiBlICYmIChpID0gYCR7Q2UoaSkuaG91cnN9OiR7Q2UoaSkubWludXRlc30gJHtDZShpKS5hbU9yUG19YCksIChzICE9PSBcIlwiICYmIGJoKGksIHMpIHx8IHMgPT09IFwiXCIpICYmIChzID0gaSksIHM7XG59LCBxdCA9IChzLCB0LCBlKSA9PiB7XG4gIGlmICghdClcbiAgICByZXR1cm4gcztcbiAgbGV0IGkgPSB2aCgpO1xuICByZXR1cm4gZSAmJiAoaSA9IGAke0NlKGkpLmhvdXJzfToke0NlKGkpLm1pbnV0ZXN9ICR7Q2UoaSkuYW1PclBtfWApLCAocyAhPT0gXCJcIiAmJiAhYmgoaSwgcykgfHwgcyA9PT0gXCJcIikgJiYgKHMgPSBpKSwgcztcbn0sIGNnID0gKHsgZm9ybWF0MTI6IHMsIG1heFRpbWU6IHQsIG1pblRpbWU6IGUsIGRpc2FibGVQYXN0OiBpLCBkaXNhYmxlRnV0dXJlOiBuIH0sIG8sIHIpID0+IHtcbiAgY29uc3QgYSA9IFIobylbMV07XG4gIGUgPSBHdChlLCBpLCBzKSwgdCA9IHF0KHQsIG4sIHMpO1xuICBjb25zdCBbbCwgcCwgdV0gPSBSKHQsICExKSwgW18sIGYsIGddID0gUihlLCAhMSk7XG4gIGlmICh1ICE9PSB2b2lkIDAgfHwgZyAhPT0gdm9pZCAwKVxuICAgIHJldHVybiBbciwgYV07XG4gIGlmICghKGwgIT09IFwiXCIgJiYgXyA9PT0gXCJcIiAmJiBOdW1iZXIocikgPiBOdW1iZXIobCkpICYmICEobCA9PT0gXCJcIiAmJiBfICE9PSBcIlwiICYmIHAgPT09IHZvaWQgMCAmJiBmICE9PSBcIlwiICYmIE51bWJlcihyKSA8IE51bWJlcihfKSkpXG4gICAgcmV0dXJuIFtyLCBhXTtcbn0sIFVhID0gKHMsIHQsIGUsIGkpID0+IHtcbiAgcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgdCA9IHQgPT09IFwiMTJcIiAmJiBpID8gXCIwXCIgOiB0LCAobi50ZXh0Q29udGVudCA9PT0gXCIwMFwiIHx8IE51bWJlcihuLnRleHRDb250ZW50ID09PSBcIjEyXCIgJiYgaSA/IFwiMFwiIDogbi50ZXh0Q29udGVudCkgPiB0KSAmJiAoaC5hZGRDbGFzcyhuLCBlLnRpcHNEaXNhYmxlZCksIG4uc2V0QXR0cmlidXRlKENuLCBcIlwiKSk7XG4gIH0pO1xufSwgWGEgPSAocywgdCwgZSwgaSkgPT4ge1xuICBzLmZvckVhY2goKG4pID0+IHtcbiAgICB0ID0gdCA9PT0gXCIxMlwiICYmIGkgPyBcIjBcIiA6IHQsIG4udGV4dENvbnRlbnQgIT09IFwiMDBcIiAmJiBOdW1iZXIobi50ZXh0Q29udGVudCA9PT0gXCIxMlwiICYmIGkgPyBcIjBcIiA6IG4udGV4dENvbnRlbnQpIDwgTnVtYmVyKHQpICYmIChoLmFkZENsYXNzKG4sIGUudGlwc0Rpc2FibGVkKSwgbi5zZXRBdHRyaWJ1dGUoQ24sIFwiXCIpKTtcbiAgfSk7XG59LCBUaCA9IChzLCB0LCBlLCBpKSA9PiB7XG4gIGlmICh0ID09PSBcIjEyXCIgfHwgdCA9PT0gXCIyNFwiKVxuICAgIHJldHVybjtcbiAgY29uc3QgbiA9IGUgPyAxMiA6IDI0O1xuICByZXR1cm4gaSA9PT0gXCJtYXhcIiA/IChOdW1iZXIocykgPT09IG4gPyAwIDogTnVtYmVyKHMpKSA+IE51bWJlcih0KSA6IChOdW1iZXIocykgPT09IG4gPyAwIDogTnVtYmVyKHMpKSA8IE51bWJlcih0KTtcbn0sIGhnID0gKHMsIHQsIGUsIGksIG4sIG8pID0+IHtcbiAgcy5mb3JFYWNoKChyKSA9PiB7XG4gICAgKFRoKGksIGUsIG8sIFwibWF4XCIpIHx8IE51bWJlcihyLnRleHRDb250ZW50KSA+IHQgJiYgTnVtYmVyKGkpID09PSBOdW1iZXIoZSkpICYmIChoLmFkZENsYXNzKHIsIG4udGlwc0Rpc2FibGVkKSwgci5zZXRBdHRyaWJ1dGUoQ24sIFwiXCIpKTtcbiAgfSk7XG59LCBkZyA9IChzLCB0LCBlLCBpLCBuLCBvKSA9PiB7XG4gIHMuZm9yRWFjaCgocikgPT4ge1xuICAgIChUaChpLCBlLCBvLCBcIm1pblwiKSB8fCBOdW1iZXIoci50ZXh0Q29udGVudCkgPCB0ICYmIE51bWJlcihpKSA9PT0gTnVtYmVyKGUpKSAmJiAoaC5hZGRDbGFzcyhyLCBuLnRpcHNEaXNhYmxlZCksIHIuc2V0QXR0cmlidXRlKENuLCBcIlwiKSk7XG4gIH0pO1xufSwgdWcgPSAocykgPT4gcy5zdGFydHNXaXRoKFwiMFwiKSA/IE51bWJlcihzLnNsaWNlKDEpKSA6IE51bWJlcihzKSwgQmkgPSBcInRpbWVwaWNrZXJcIiwgTSA9IGBkYXRhLXRlLSR7Qml9YCwgR2EgPSBcIltkYXRhLXRlLXRvZ2dsZV1cIiwgSnMgPSBgdGUuJHtCaX1gLCBQdCA9IGAuJHtKc31gLCBCdCA9IFwiLmRhdGEtYXBpXCIsIHFhID0gYGNsaWNrJHtQdH0ke0J0fWAsIHZzID0gYGtleWRvd24ke1B0fSR7QnR9YCwgWmEgPSBgbW91c2Vkb3duJHtQdH0ke0J0fWAsIFFhID0gYG1vdXNldXAke1B0fSR7QnR9YCwgSmEgPSBgbW91c2Vtb3ZlJHtQdH0ke0J0fWAsIHRsID0gYG1vdXNlbGVhdmUke1B0fSR7QnR9YCwgZWwgPSBgbW91c2VvdmVyJHtQdH0ke0J0fWAsIGlsID0gYHRvdWNobW92ZSR7UHR9JHtCdH1gLCBzbCA9IGB0b3VjaGVuZCR7UHR9JHtCdH1gLCBubCA9IGB0b3VjaHN0YXJ0JHtQdH0ke0J0fWAsIHBnID0gYFske019LWFtXWAsIF9nID0gYFske019LXBtXWAsIGZnID0gYFske019LWZvcm1hdDI0XWAsIFRzID0gYFske019LWN1cnJlbnRdYCwgRXMgPSBgWyR7TX0taG91ci1tb2RlXWAsIG1nID0gYFske019LXRvZ2dsZS1idXR0b25dYCwgb28gPSBgJHtNfS1jYW5jZWxgLCBvbCA9IGAke019LWNsZWFyYCwgcm8gPSBgJHtNfS1zdWJtaXRgLCBnZyA9IGAke019LWljb25gLCBhbyA9IGAke019LWljb24tdXBgLCBsbyA9IGAke019LWljb24tZG93bmAsIGJnID0gYCR7TX0taWNvbi1pbmxpbmUtaG91cmAsIHZnID0gYCR7TX0taWNvbi1pbmxpbmUtbWludXRlYCwgcmwgPSBgJHtNfS1pbmxpbmUtaG91ci1pY29uc2AsIFRnID0gYCR7TX0tY3VycmVudC1pbmxpbmVgLCBFZyA9IFwicmVhZG9ubHlcIiwgQ2cgPSBgJHtNfS1pbnZhbGlkLWZlZWRiYWNrYCwgY28gPSBgJHtNfS1pcy1pbnZhbGlkYCwganQgPSBgJHtNfS1kaXNhYmxlZGAsIEggPSBgJHtNfS1hY3RpdmVgLCBBZyA9IGAke019LWlucHV0YCwgdWUgPSBgJHtNfS1jbG9ja2AsIG1pID0gYCR7TX0tY2xvY2staW5uZXJgLCBobyA9IGAke019LXdyYXBwZXJgLCBhbCA9IGAke019LWNsb2NrLXdyYXBwZXJgLCBDcyA9IGAke019LWhvdXJgLCB1byA9IGAke019LW1pbnV0ZWAsIEFzID0gYCR7TX0tdGlwcy1lbGVtZW50YCwgWCA9IGAke019LXRpcHMtaG91cnNgLCBxID0gYCR7TX0tdGlwcy1taW51dGVzYCwgaHQgPSBgJHtNfS10aXBzLWlubmVyYCwgeXMgPSBgJHtNfS10aXBzLWlubmVyLWVsZW1lbnRgLCBsbCA9IGAke019LW1pZGRsZS1kb3RgLCBwbyA9IGAke019LWhhbmQtcG9pbnRlcmAsIF9vID0gYCR7TX0tY2lyY2xlYCwgY2wgPSBgJHtNfS1tb2RhbGAsIHlnID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTEyIDZ2Nmg0LjVtNC41IDBhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6XCIgLz5cbjwvc3ZnPmAsIHdnID0ge1xuICBhcHBlbmRWYWxpZGF0aW9uSW5mbzogITAsXG4gIGJvZHlJRDogXCJcIixcbiAgY2FuY2VsTGFiZWw6IFwiQ2FuY2VsXCIsXG4gIGNsZWFyTGFiZWw6IFwiQ2xlYXJcIixcbiAgY2xvc2VNb2RhbE9uQmFja2Ryb3BDbGljazogITAsXG4gIGNsb3NlTW9kYWxPbk1pbnV0ZXNDbGljazogITEsXG4gIGNvbnRhaW5lcjogXCJib2R5XCIsXG4gIGRlZmF1bHRUaW1lOiBcIlwiLFxuICBkaXNhYmxlZDogITEsXG4gIGRpc2FibGVQYXN0OiAhMSxcbiAgZGlzYWJsZUZ1dHVyZTogITEsXG4gIGVuYWJsZVZhbGlkYXRpb246ICEwLFxuICBmb2N1c0lucHV0QWZ0ZXJBcHByb3ZlOiAhMSxcbiAgZm9vdGVySUQ6IFwiXCIsXG4gIGZvcm1hdDEyOiAhMCxcbiAgZm9ybWF0MjQ6ICExLFxuICBoZWFkSUQ6IFwiXCIsXG4gIGluY3JlbWVudDogITEsXG4gIGlubGluZTogITEsXG4gIGludmFsaWRMYWJlbDogXCJJbnZhbGlkIFRpbWUgRm9ybWF0XCIsXG4gIG1heFRpbWU6IFwiXCIsXG4gIG1pblRpbWU6IFwiXCIsXG4gIG1vZGFsSUQ6IFwiXCIsXG4gIG9rTGFiZWw6IFwiT2tcIixcbiAgb3ZlcmZsb3dIaWRkZW46ICEwLFxuICBwaWNrZXJJRDogXCJcIixcbiAgcmVhZE9ubHk6ICExLFxuICBzaG93Q2xlYXJCdG46ICEwLFxuICBzd2l0Y2hIb3Vyc1RvTWludXRlc09uQ2xpY2s6ICEwLFxuICBpY29uU1ZHOiB5ZyxcbiAgd2l0aEljb246ICEwLFxuICBwbUxhYmVsOiBcIlBNXCIsXG4gIGFtTGFiZWw6IFwiQU1cIixcbiAgYW5pbWF0aW9uczogITBcbn0sIGtnID0ge1xuICBhcHBlbmRWYWxpZGF0aW9uSW5mbzogXCJib29sZWFuXCIsXG4gIGJvZHlJRDogXCJzdHJpbmdcIixcbiAgY2FuY2VsTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNsZWFyTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNsb3NlTW9kYWxPbkJhY2tkcm9wQ2xpY2s6IFwiYm9vbGVhblwiLFxuICBjbG9zZU1vZGFsT25NaW51dGVzQ2xpY2s6IFwiYm9vbGVhblwiLFxuICBjb250YWluZXI6IFwic3RyaW5nXCIsXG4gIGRpc2FibGVkOiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZVBhc3Q6IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlRnV0dXJlOiBcImJvb2xlYW5cIixcbiAgZW5hYmxlVmFsaWRhdGlvbjogXCJib29sZWFuXCIsXG4gIGZvb3RlcklEOiBcInN0cmluZ1wiLFxuICBmb3JtYXQxMjogXCJib29sZWFuXCIsXG4gIGZvcm1hdDI0OiBcImJvb2xlYW5cIixcbiAgaGVhZElEOiBcInN0cmluZ1wiLFxuICBpbmNyZW1lbnQ6IFwiYm9vbGVhblwiLFxuICBpbmxpbmU6IFwiYm9vbGVhblwiLFxuICBpbnZhbGlkTGFiZWw6IFwic3RyaW5nXCIsXG4gIG1vZGFsSUQ6IFwic3RyaW5nXCIsXG4gIG9rTGFiZWw6IFwic3RyaW5nXCIsXG4gIG92ZXJmbG93SGlkZGVuOiBcImJvb2xlYW5cIixcbiAgcGlja2VySUQ6IFwic3RyaW5nXCIsXG4gIHJlYWRPbmx5OiBcImJvb2xlYW5cIixcbiAgc2hvd0NsZWFyQnRuOiBcImJvb2xlYW5cIixcbiAgc3dpdGNoSG91cnNUb01pbnV0ZXNPbkNsaWNrOiBcImJvb2xlYW5cIixcbiAgZGVmYXVsdFRpbWU6IFwiKHN0cmluZ3xkYXRlfG51bWJlcilcIixcbiAgaWNvblNWRzogXCJzdHJpbmdcIixcbiAgd2l0aEljb246IFwiYm9vbGVhblwiLFxuICBwbUxhYmVsOiBcInN0cmluZ1wiLFxuICBhbUxhYmVsOiBcInN0cmluZ1wiLFxuICBhbmltYXRpb25zOiBcImJvb2xlYW5cIlxufSwgeGcgPSB7XG4gIHRpcHM6IFwiYWJzb2x1dGUgcm91bmRlZC1bMTAwJV0gdy1bMzJweF0gaC1bMzJweF0gdGV4dC1jZW50ZXIgY3Vyc29yLXBvaW50ZXIgdGV4dC1bMS4xcmVtXSByb3VuZGVkLVsxMDAlXSBiZy10cmFuc3BhcmVudCBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBmb250LWxpZ2h0IGZvY3VzOm91dGxpbmUtbm9uZSBzZWxlY3Rpb246YmctdHJhbnNwYXJlbnRcIixcbiAgdGlwc0FjdGl2ZTogXCJ0ZXh0LXdoaXRlIGJnLVsjM2I3MWNhXSBmb250LW5vcm1hbFwiLFxuICB0aXBzRGlzYWJsZWQ6IFwidGV4dC1bI2IzYWZhZl0gcG9pbnRlci1ldmVudHMtbm9uZSBiZy10cmFuc3BhcmVudFwiLFxuICB0cmFuc2Zvcm06IFwidHJhbnNpdGlvbi1bdHJhbnNmb3JtLGhlaWdodF0gZWFzZS1pbi1vdXQgZHVyYXRpb24tWzQwMG1zXVwiLFxuICBtb2RhbDogXCJ6LVsxMDY1XVwiLFxuICBjbG9ja0FuaW1hdGlvbjogXCJhbmltYXRlLVtzaG93LXVwLWNsb2NrXzM1MG1zX2xpbmVhcl1cIixcbiAgb3BhY2l0eTogXCIhb3BhY2l0eS0xMDBcIixcbiAgdGltZXBpY2tlcldyYXBwZXI6IFwidG91Y2gtbm9uZSBvcGFjaXR5LTEwMCB6LVsxMDY1XSBpbnNldC0wIGJnLVsjMDAwMDAwNjZdIGgtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBmbGV4LWNvbCBmaXhlZFwiLFxuICB0aW1lcGlja2VyQ29udGFpbmVyOiBcImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGZsZXgtY29sIG1heC1oLVtjYWxjKDEwMCUtNjRweCldIG92ZXJmbG93LXktYXV0byBzaGFkb3ctWzBfMTBweF8xNXB4Xy0zcHhfcmdiYSgwLDAsMCwwLjA3KSwwXzRweF82cHhfLTJweF9yZ2JhKDAsMCwwLDAuMDUpXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC1sZ1wiLFxuICB0aW1lcGlja2VyRWxlbWVudHM6IFwiZmxleCBmbGV4LWNvbCBtaW4tdy1bMzEwcHhdIG1pbi1oLVszMjVweF0gYmctd2hpdGUgcm91bmRlZC10LVswLjZyZW1dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohZmxleC1yb3cgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm1pbi13LVthdXRvXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6bWluLWgtW2F1dG9dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpvdmVyZmxvdy15LWF1dG8ganVzdGlmeS1hcm91bmRcIixcbiAgdGltZXBpY2tlckhlYWQ6IFwiYmctWyMzYjcxY2FdIGRhcms6YmctemluYy03MDAgaC1bMTAwcHhdIHJvdW5kZWQtdC1sZyBwci1bMjRweF0gcGwtWzUwcHhdIHB5LVsxMHB4XSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC10ci1ub25lIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLWJsLW5vbmUgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnAtWzEwcHhdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpwci1bMTBweF0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmgtYXV0byBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6bWluLWgtWzMwNXB4XSBmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiLFxuICB0aW1lcGlja2VySGVhZENvbnRlbnQ6IFwibWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZsZXgtY29sIGZsZXggdy1mdWxsIGp1c3RpZnktZXZlbmx5XCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50V3JhcHBlcjogXCJbZGlyZWN0aW9uOmx0cl0gcnRsOltkaXJlY3Rpb246cnRsXVwiLFxuICB0aW1lcGlja2VyQ3VycmVudEJ1dHRvbldyYXBwZXI6IFwicmVsYXRpdmUgaC1mdWxsXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50QnV0dG9uOiBcInRleHQtWzMuNzVyZW1dIGZvbnQtbGlnaHQgbGVhZGluZy1bMS4yXSB0cmFja2luZy1bLTAuMDA4MzNlbV0gdGV4dC13aGl0ZSBvcGFjaXR5LVsuNTRdIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHAtMCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6dGV4dC01eGwgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZvbnQtbm9ybWFsIGN1cnNvci1wb2ludGVyIGhvdmVyOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpiZy1bIzAwMDAwMDI2XSBmb2N1czpvdXRsaW5lLW5vbmUgXCIsXG4gIHRpbWVwaWNrZXJEb3Q6IFwiZm9udC1saWdodCBsZWFkaW5nLVsxLjJdIHRyYWNraW5nLVstMC4wMDgzM2VtXSB0ZXh0LVszLjc1cmVtXSBvcGFjaXR5LVsuNTRdIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHAtMCB0ZXh0LXdoaXRlIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTp0ZXh0LVszcmVtXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6Zm9udC1ub3JtYWxcIixcbiAgdGltZXBpY2tlck1vZGVXcmFwcGVyOiBcImZsZXggZmxleC1jb2wganVzdGlmeS1jZW50ZXIgdGV4dC1bMThweF0gdGV4dC1bI2ZmZmZmZjhhXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWp1c3RpZnktYXJvdW5kIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohZmxleC1yb3dcIixcbiAgdGltZXBpY2tlck1vZGVBbTogXCJwLTAgYmctdHJhbnNwYXJlbnQgYm9yZGVyLW5vbmUgdGV4dC13aGl0ZSBvcGFjaXR5LVsuNTRdIGN1cnNvci1wb2ludGVyIGhvdmVyOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpiZy1bIzAwMDAwMDI2XSBmb2N1czpvdXRsaW5lLW5vbmVcIixcbiAgdGltZXBpY2tlck1vZGVQbTogXCJwLTAgYmctdHJhbnNwYXJlbnQgYm9yZGVyLW5vbmUgdGV4dC13aGl0ZSBvcGFjaXR5LVsuNTRdIGN1cnNvci1wb2ludGVyIGhvdmVyOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpiZy1bIzAwMDAwMDI2XSBmb2N1czpvdXRsaW5lLW5vbmVcIixcbiAgdGltZXBpY2tlckNsb2NrV3JhcHBlcjogXCJtaW4tdy1bMzEwcHhdIG1heC13LVszMjVweF0gbWluLWgtWzMwNXB4XSBvdmVyZmxvdy14LWhpZGRlbiBoLWZ1bGwgZmxleCBqdXN0aWZ5LWNlbnRlciBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgZGFyazpiZy16aW5jLTUwMFwiLFxuICB0aW1lcGlja2VyQ2xvY2s6IFwicmVsYXRpdmUgcm91bmRlZC1bMTAwJV0gdy1bMjYwcHhdIGgtWzI2MHB4XSBjdXJzb3ItZGVmYXVsdCBteS0wIG14LWF1dG8gYmctWyMwMDAwMDAxMl0gZGFyazpiZy16aW5jLTYwMC81MFwiLFxuICB0aW1lcGlja2VyTWlkZGxlRG90OiBcInRvcC0xLzIgbGVmdC0xLzIgdy1bNnB4XSBoLVs2cHhdIC10cmFuc2xhdGUteS0xLzIgLXRyYW5zbGF0ZS14LTEvMiByb3VuZGVkLVs1MCVdIGJnLVsjM2I3MWNhXSBhYnNvbHV0ZVwiLFxuICB0aW1lcGlja2VySGFuZFBvaW50ZXI6IFwiYmctWyMzYjcxY2FdIGJvdHRvbS0xLzIgaC0yLzUgbGVmdC1bY2FsYyg1MCUtMXB4KV0gcnRsOiFsZWZ0LWF1dG8gb3JpZ2luLVtjZW50ZXJfYm90dG9tXzBdIHJ0bDohb3JpZ2luLVs1MCVfNTAlXzBdIHctWzJweF0gYWJzb2x1dGVcIixcbiAgdGltZXBpY2tlclBvaW50ZXJDaXJjbGU6IFwiLXRvcC1bMjFweF0gLWxlZnQtWzE1cHhdIHctWzRweF0gYm9yZGVyLVsxNHB4XSBib3JkZXItc29saWQgYm9yZGVyLVsjM2I3MWNhXSBoLVs0cHhdIGJveC1jb250ZW50IHJvdW5kZWQtWzEwMCVdIGFic29sdXRlXCIsXG4gIHRpbWVwaWNrZXJDbG9ja0lubmVyOiBcImFic29sdXRlIHRvcC0xLzIgbGVmdC0xLzIgLXRyYW5zbGF0ZS15LTEvMiAtdHJhbnNsYXRlLXgtMS8yIHctWzE2MHB4XSBoLVsxNjBweF0gcm91bmRlZC1bMTAwJV1cIixcbiAgdGltZXBpY2tlckZvb3RlcldyYXBwZXI6IFwicm91bmRlZC1iLWxnIGZsZXgganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlciB3LWZ1bGwgaC1bNTZweF0gcHgtWzEycHhdIGJnLXdoaXRlIGRhcms6YmctemluYy01MDBcIixcbiAgdGltZXBpY2tlckZvb3RlcjogXCJ3LWZ1bGwgZmxleCBqdXN0aWZ5LWJldHdlZW5cIixcbiAgdGltZXBpY2tlckZvb3RlckJ1dHRvbjogXCJ0ZXh0LVswLjhyZW1dIG1pbi13LVs2NHB4XSBib3gtYm9yZGVyIGZvbnQtbWVkaXVtIGxlYWRpbmctWzQwcHhdIHJvdW5kZWQtWzEwcHhdIHRyYWNraW5nLVswLjFyZW1dIHVwcGVyY2FzZSB0ZXh0LVsjM2I3MWNhXSBkYXJrOnRleHQtd2hpdGUgYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdHJhbnNpdGlvbi1bYmFja2dyb3VuZC1jb2xvcixib3gtc2hhZG93LGJvcmRlcl0gZHVyYXRpb24tWzI1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC40LDAsMC4yLDEpXSBkZWxheS1bMG1zXSBvdXRsaW5lLW5vbmUgcHktMCBweC1bMTBweF0gaC1bNDBweF0gbWItWzEwcHhdIGhvdmVyOmJnLVsjMDAwMDAwMTRdIGZvY3VzOmJnLVsjMDAwMDAwMTRdIGZvY3VzOm91dGxpbmUtbm9uZVwiLFxuICB0aW1lcGlja2VySW5saW5lV3JhcHBlcjogXCJ0b3VjaC1ub25lIG9wYWNpdHktMTAwIHotWzEwNjVdIGluc2V0LTAgYmctWyMwMDAwMDA2Nl0gaC1mdWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGZsZXgtY29sIHJvdW5kZWQtbGdcIixcbiAgdGltZXBpY2tlcklubGluZUNvbnRhaW5lcjogXCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBmbGV4LWNvbCBtYXgtaC1bY2FsYygxMDAlLTY0cHgpXSBvdmVyZmxvdy15LWF1dG8gc2hhZG93LVswXzEwcHhfMTVweF8tM3B4X3JnYmEoMCwwLDAsMC4wNyksMF80cHhfNnB4Xy0ycHhfcmdiYSgwLDAsMCwwLjA1KV1cIixcbiAgdGltZXBpY2tlcklubGluZUVsZW1lbnRzOiBcImZsZXggZmxleC1jb2wgbWluLWgtW2F1dG9dIG1pbi13LVszMTBweF0gYmctd2hpdGUgcm91bmRlZC1bMC42cmVtXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWZsZXgtcm93IG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLWJsLWxnIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTptaW4tdy1bYXV0b10gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOjptaW4taC1bYXV0b10gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm92ZXJmbG93LXktYXV0byBqdXN0aWZ5LWFyb3VuZFwiLFxuICB0aW1lcGlja2VySW5saW5lSGVhZDogXCJiZy1bIzNiNzFjYV0gZGFyazpiZy16aW5jLTcwMCBoLVsxMDBweF0gcm91bmRlZC10LWxnIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLXRyLW5vbmUgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnJvdW5kZWQtYmwtbm9uZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cC1bMTBweF0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnByLVsxMHB4XSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6aC1hdXRvIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTptaW4taC1bMzA1cHhdIGZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHAtMCByb3VuZGVkLWItbGdcIixcbiAgdGltZXBpY2tlcklubGluZUhlYWRDb250ZW50OiBcIm1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpmbGV4LWNvbCBmbGV4IHctZnVsbCBqdXN0aWZ5LWV2ZW5seSBpdGVtcy1jZW50ZXJcIixcbiAgdGltZXBpY2tlcklubGluZUhvdXJXcmFwcGVyOiBcInJlbGF0aXZlIGgtZnVsbCAhb3BhY2l0eS0xMDBcIixcbiAgdGltZXBpY2tlckN1cnJlbnRNaW51dGVXcmFwcGVyOiBcInJlbGF0aXZlIGgtZnVsbFwiLFxuICB0aW1lcGlja2VySW5saW5lSWNvblVwOiBcImFic29sdXRlIHRleHQtd2hpdGUgLXRvcC1bMzVweF0gb3BhY2l0eS0wIGhvdmVyOm9wYWNpdHktMTAwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLVtlYXNlXSBjdXJzb3ItcG9pbnRlciAtdHJhbnNsYXRlLXgtMS8yIC10cmFuc2xhdGUteS0xLzIgbGVmdC0xLzIgdy1bMzBweF0gaC1bMzBweF0gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXJcIixcbiAgdGltZXBpY2tlcklubGluZUljb25Tdmc6IFwiaC00IHctNFwiLFxuICB0aW1lcGlja2VySW5saW5lQ3VycmVudEJ1dHRvbjogXCJmb250LWxpZ2h0IGxlYWRpbmctWzEuMl0gdHJhY2tpbmctWy0wLjAwODMzZW1dIHRleHQtd2hpdGUgYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgcC0wIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTp0ZXh0LTV4bCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6Zm9udC1ub3JtYWwgIW9wYWNpdHktMTAwIGN1cnNvci1wb2ludGVyIGZvY3VzOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpvdXRsaW5lLW5vbmUgdGV4dC1bMi41cmVtXSBob3ZlcjpiZy1bdW5zZXRdXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uRG93bjogXCJhYnNvbHV0ZSB0ZXh0LXdoaXRlIC1ib3R0b20tWzQ3cHhdIG9wYWNpdHktMCBob3ZlcjpvcGFjaXR5LTEwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1bZWFzZV0gY3Vyc29yLXBvaW50ZXIgLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIGxlZnQtMS8yIHctWzMwcHhdIGgtWzMwcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVEb3Q6IFwiZm9udC1saWdodCBsZWFkaW5nLVsxLjJdIHRyYWNraW5nLVstMC4wMDgzM2VtXSBvcGFjaXR5LVsuNTRdIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHAtMCB0ZXh0LXdoaXRlIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTp0ZXh0LVszcmVtXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6Zm9udC1ub3JtYWwgdGV4dC1bMi41cmVtXVwiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZVdyYXBwZXI6IFwiZmxleCBqdXN0aWZ5LWNlbnRlciB0ZXh0LVsxOHB4XSB0ZXh0LVsjZmZmZmZmOGFdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohanVzdGlmeS1hcm91bmQgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOiFmbGV4LXJvd1wiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZUFtOiBcImhvdmVyOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpiZy1bIzAwMDAwMDI2XSBmb2N1czpvdXRsaW5lLW5vbmUgcC0wIGJnLXRyYW5zcGFyZW50IGJvcmRlci1ub25lIHRleHQtd2hpdGUgb3BhY2l0eS1bLjU0XSBjdXJzb3ItcG9pbnRlciBtci0yIG1sLTZcIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVQbTogXCJob3ZlcjpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6YmctWyMwMDAwMDAyNl0gZm9jdXM6b3V0bGluZS1ub25lIHAtMCBiZy10cmFuc3BhcmVudCBib3JkZXItbm9uZSB0ZXh0LXdoaXRlIG9wYWNpdHktWy41NF0gY3Vyc29yLXBvaW50ZXJcIixcbiAgdGltZXBpY2tlcklubGluZVN1Ym1pdEJ1dHRvbjogXCJob3ZlcjpiZy1bIzAwMDAwMDE0XSBmb2N1czpiZy1bIzAwMDAwMDE0XSBmb2N1czpvdXRsaW5lLW5vbmUgdGV4dC1bMC44cmVtXSBib3gtYm9yZGVyIGZvbnQtbWVkaXVtIGxlYWRpbmctWzQwcHhdIHRyYWNraW5nLVsuMXJlbV0gdXBwZXJjYXNlIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IFt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3JfMjUwbXNfY3ViaWMtYmV6aWVyKDAuNCwwLDAuMiwxKV8wbXMsYm94LXNoYWRvd18yNTBtc19jdWJpYy1iZXppZXIoMC40LDAsMC4yLDEpXzBtcyxib3JkZXJfMjUwbXNfY3ViaWMtYmV6aWVyKDAuNCwwLDAuMiwxKV8wbXNdIG91dGxpbmUtbm9uZSByb3VuZGVkLVsxMDAlXSBoLVs0OHB4XSBtaW4tdy1bNDhweF0gaW5saW5lLWJsb2NrIG1sLVszMHB4XSB0ZXh0LXdoaXRlIHB5LTEgcHgtMiBtYi0wXCIsXG4gIHRpbWVwaWNrZXJUb2dnbGVCdXR0b246IFwiaC00IHctNCBtbC1hdXRvIGFic29sdXRlIG91dGxpbmUtbm9uZSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCByaWdodC0xLjUgdG9wLTEvMiAtdHJhbnNsYXRlLXgtMS8yIC10cmFuc2xhdGUteS0xLzIgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwIGVhc2UtW2N1YmljLWJlemllcigwLjI1LDAuMSwwLjI1LDEpXSBjdXJzb3ItcG9pbnRlciBob3Zlcjp0ZXh0LVsjM2I3MWNhXSBmb2N1czp0ZXh0LVsjM2I3MWNhXSBkYXJrOmhvdmVyOnRleHQtWyMzYjcxY2FdIGRhcms6Zm9jdXM6dGV4dC1bIzNiNzFjYV0gZGFyazp0ZXh0LXdoaXRlXCJcbn0sIE9nID0ge1xuICB0aXBzOiBcInN0cmluZ1wiLFxuICB0aXBzQWN0aXZlOiBcInN0cmluZ1wiLFxuICB0aXBzRGlzYWJsZWQ6IFwic3RyaW5nXCIsXG4gIHRyYW5zZm9ybTogXCJzdHJpbmdcIixcbiAgbW9kYWw6IFwic3RyaW5nXCIsXG4gIGNsb2NrQW5pbWF0aW9uOiBcInN0cmluZ1wiLFxuICBvcGFjaXR5OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckVsZW1lbnRzOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySGVhZDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckhlYWRDb250ZW50OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ3VycmVudFdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50QnV0dG9uV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckN1cnJlbnRCdXR0b246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJEb3Q6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJNb2RlV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlck1vZGVBbTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlck1vZGVQbTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckNsb2NrV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckNsb2NrOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyTWlkZGxlRG90OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySGFuZFBvaW50ZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJQb2ludGVyQ2lyY2xlOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ2xvY2tJbm5lcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckZvb3RlcldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJGb290ZXJCdXR0b246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lQ29udGFpbmVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lRWxlbWVudHM6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIZWFkOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSGVhZENvbnRlbnQ6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIb3VyV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckN1cnJlbnRNaW51dGVXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSWNvblVwOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSWNvblN2ZzogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUN1cnJlbnRCdXR0b246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uRG93bjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZURvdDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZUFtOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZVBtOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lU3VibWl0QnV0dG9uOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyVG9nZ2xlQnV0dG9uOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgU2cge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30sIGkpIHtcbiAgICB3dCh0aGlzLCBcIl90b2dnbGVBbVBtXCIsICh0KSA9PiB7XG4gICAgICB0ID09PSBcIlBNXCIgPyAodGhpcy5faXNQbUVuYWJsZWQgPSAhMCwgdGhpcy5faXNBbUVuYWJsZWQgPSAhMSkgOiB0ID09PSBcIkFNXCIgJiYgKHRoaXMuX2lzUG1FbmFibGVkID0gITEsIHRoaXMuX2lzQW1FbmFibGVkID0gITApO1xuICAgIH0pO1xuICAgIHd0KHRoaXMsIFwiX3RvZ2dsZUJhY2tncm91bmRDb2xvckNpcmNsZVwiLCAodCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX21vZGFsLnF1ZXJ5U2VsZWN0b3IoYCR7dH1bJHtIfV1gKSAhPT0gbnVsbCkge1xuICAgICAgICBoLmFkZFN0eWxlKHRoaXMuX2NpcmNsZSwge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMTk3NmQyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGguYWRkU3R5bGUodGhpcy5fY2lyY2xlLCB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB3dCh0aGlzLCBcIl90b2dnbGVDbGFzc0FjdGl2ZVwiLCAodCwgeyB0ZXh0Q29udGVudDogZSB9LCBpKSA9PiB7XG4gICAgICBjb25zdCBuID0gWy4uLnRdLmZpbmQoXG4gICAgICAgIChvKSA9PiBOdW1iZXIobykgPT09IE51bWJlcihlKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBpLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgaWYgKCFvLmhhc0F0dHJpYnV0ZShqdCkpIHtcbiAgICAgICAgICBpZiAoby50ZXh0Q29udGVudCA9PT0gbikge1xuICAgICAgICAgICAgaC5hZGRDbGFzcyhvLCB0aGlzLl9jbGFzc2VzLnRpcHNBY3RpdmUpLCBvLnNldEF0dHJpYnV0ZShILCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaC5yZW1vdmVDbGFzcyhvLCB0aGlzLl9jbGFzc2VzLnRpcHNBY3RpdmUpLCBvLnJlbW92ZUF0dHJpYnV0ZShIKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgd3QodGhpcywgXCJfbWFrZU1pbnV0ZXNEZWdyZWVzXCIsICh0LCBlKSA9PiB7XG4gICAgICBjb25zdCB7IGluY3JlbWVudDogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgIHJldHVybiB0IDwgMCA/IChlID0gTWF0aC5yb3VuZCgzNjAgKyB0IC8gNikgJSA2MCwgdCA9IDM2MCArIE1hdGgucm91bmQodCAvIDYpICogNikgOiAoZSA9IE1hdGgucm91bmQodCAvIDYpICUgNjAsIHQgPSBNYXRoLnJvdW5kKHQgLyA2KSAqIDYpLCBpICYmICh0ID0gTWF0aC5yb3VuZCh0IC8gMzApICogMzAsIGUgPSBNYXRoLnJvdW5kKHQgLyA2KSAqIDYgLyA2LCBlID09PSA2MCAmJiAoZSA9IFwiMDBcIikpLCB0ID49IDM2MCAmJiAodCA9IDApLCB7XG4gICAgICAgIGRlZ3JlZXM6IHQsXG4gICAgICAgIG1pbnV0ZTogZSxcbiAgICAgICAgYWRkRGVncmVlczogaSA/IDMwIDogNlxuICAgICAgfTtcbiAgICB9KTtcbiAgICB3dCh0aGlzLCBcIl9tYWtlSG91ckRlZ3JlZXNcIiwgKHQsIGUsIGkpID0+IHtcbiAgICAgIGlmICh0KVxuICAgICAgICByZXR1cm4gdGhpcy5faGFzVGFyZ2V0SW5uZXJDbGFzcyh0KSA/IGUgPCAwID8gKGkgPSBNYXRoLnJvdW5kKDM2MCArIGUgLyAzMCkgJSAyNCwgZSA9IDM2MCArIGUpIDogKGkgPSBNYXRoLnJvdW5kKGUgLyAzMCkgKyAxMiwgaSA9PT0gMTIgJiYgKGkgPSBcIjAwXCIpKSA6IGUgPCAwID8gKGkgPSBNYXRoLnJvdW5kKDM2MCArIGUgLyAzMCkgJSAxMiwgZSA9IDM2MCArIGUpIDogKGkgPSBNYXRoLnJvdW5kKGUgLyAzMCkgJSAxMiwgKGkgPT09IDAgfHwgaSA+IDEyKSAmJiAoaSA9IDEyKSksIGUgPj0gMzYwICYmIChlID0gMCksIHtcbiAgICAgICAgICBkZWdyZWVzOiBlLFxuICAgICAgICAgIGhvdXI6IGksXG4gICAgICAgICAgYWRkRGVncmVlczogMzBcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICB3dCh0aGlzLCBcIl9tYWtlSW5uZXJIb3Vyc0RlZ3JlZXNcIiwgKHQsIGUpID0+ICh0IDwgMCA/IChlID0gTWF0aC5yb3VuZCgzNjAgKyB0IC8gMzApICUgMjQsIHQgPSAzNjAgKyB0KSA6IChlID0gTWF0aC5yb3VuZCh0IC8gMzApICsgMTIsIGUgPT09IDEyICYmIChlID0gXCIwMFwiKSksIHtcbiAgICAgIGRlZ3JlZXM6IHQsXG4gICAgICBob3VyOiBlLFxuICAgICAgYWRkRGVncmVlczogMzBcbiAgICB9KSk7XG4gICAgd3QodGhpcywgXCJfZ2V0QXBwZW5kQ2xvY2tcIiwgKHQgPSBbXSwgZSA9IGBbJHt1ZX1dYCwgaSkgPT4ge1xuICAgICAgbGV0IHsgbWluVGltZTogbiwgbWF4VGltZTogbyB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgIGNvbnN0IHsgaW5saW5lOiByLCBmb3JtYXQxMjogYSwgZGlzYWJsZVBhc3Q6IGwsIGRpc2FibGVGdXR1cmU6IHAgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICBuID0gR3QobiwgbCwgYSksIG8gPSBxdChvLCBwLCBhKTtcbiAgICAgIGNvbnN0IFt1LCBfLCBmXSA9IFIoXG4gICAgICAgIG8sXG4gICAgICAgICExXG4gICAgICApLCBbZywgbSwgYl0gPSBSKFxuICAgICAgICBuLFxuICAgICAgICAhMVxuICAgICAgKTtcbiAgICAgICFyICYmIGEgJiYgdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCAmJiAhdGhpcy5fQU0uaGFzQXR0cmlidXRlKEgpICYmIChoLmFkZENsYXNzKHRoaXMuX1BNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9QTS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpO1xuICAgICAgY29uc3QgdiA9IGQuZmluZE9uZShlKSwgVCA9IDM2MCAvIHQubGVuZ3RoO1xuICAgICAgZnVuY3Rpb24geShrKSB7XG4gICAgICAgIHJldHVybiBrICogKE1hdGguUEkgLyAxODApO1xuICAgICAgfVxuICAgICAgaWYgKHYgPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IEMgPSAodi5vZmZzZXRXaWR0aCAtIDMyKSAvIDIsIEUgPSAodi5vZmZzZXRIZWlnaHQgLSAzMikgLyAyLCB3ID0gQyAtIDQ7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbGV0IGs7XG4gICAgICAgIGEgJiYgKGsgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYCR7RXN9WyR7SH1dYFxuICAgICAgICApLnRleHRDb250ZW50KSwgdGhpcy5faGFuZGxlRGlzYWJsaW5nVGlwc01pblRpbWUoXG4gICAgICAgICAgayxcbiAgICAgICAgICBiLFxuICAgICAgICAgIG0sXG4gICAgICAgICAgZ1xuICAgICAgICApLCB0aGlzLl9oYW5kbGVEaXNhYmxpbmdUaXBzTWF4VGltZShcbiAgICAgICAgICBrLFxuICAgICAgICAgIGYsXG4gICAgICAgICAgXyxcbiAgICAgICAgICB1XG4gICAgICAgICk7XG4gICAgICB9LCAwKSwgWy4uLnRdLmZvckVhY2goKGssIEQpID0+IHtcbiAgICAgICAgY29uc3QgTyA9IHkoRCAqIFQpLCB4ID0gJChcInNwYW5cIiksIEwgPSAkKFwic3BhblwiKTtcbiAgICAgICAgTC5pbm5lckhUTUwgPSBrLCBoLmFkZENsYXNzKHgsIHRoaXMuX2NsYXNzZXMudGlwcyksIHguc2V0QXR0cmlidXRlKGksIFwiXCIpO1xuICAgICAgICBjb25zdCBTID0geC5vZmZzZXRXaWR0aCwgTiA9IHgub2Zmc2V0SGVpZ2h0O1xuICAgICAgICByZXR1cm4gaC5hZGRTdHlsZSh4LCB7XG4gICAgICAgICAgbGVmdDogYCR7QyArIE1hdGguc2luKE8pICogdyAtIFN9cHhgLFxuICAgICAgICAgIGJvdHRvbTogYCR7RSArIE1hdGguY29zKE8pICogdyAtIE59cHhgXG4gICAgICAgIH0pLCB0LmluY2x1ZGVzKFwiMDVcIikgJiYgeC5zZXRBdHRyaWJ1dGUocSwgXCJcIiksIHQuaW5jbHVkZXMoXCIxM1wiKSA/IEwuc2V0QXR0cmlidXRlKHlzLCBcIlwiKSA6IEwuc2V0QXR0cmlidXRlKEFzLCBcIlwiKSwgeC5hcHBlbmRDaGlsZChMKSwgdi5hcHBlbmRDaGlsZCh4KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9lbGVtZW50ICYmIEEuc2V0RGF0YSh0LCBKcywgdGhpcyksIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9jdXJyZW50VGltZSA9IG51bGwsIHRoaXMuX3RvZ2dsZUJ1dHRvbklkID0gZXQoXCJ0aW1lcGlja2VyLXRvZ2dsZS1cIiksIHRoaXMuaG91cnNBcnJheSA9IFtcbiAgICAgIFwiMTJcIixcbiAgICAgIFwiMVwiLFxuICAgICAgXCIyXCIsXG4gICAgICBcIjNcIixcbiAgICAgIFwiNFwiLFxuICAgICAgXCI1XCIsXG4gICAgICBcIjZcIixcbiAgICAgIFwiN1wiLFxuICAgICAgXCI4XCIsXG4gICAgICBcIjlcIixcbiAgICAgIFwiMTBcIixcbiAgICAgIFwiMTFcIlxuICAgIF0sIHRoaXMuaW5uZXJIb3VycyA9IFtcbiAgICAgIFwiMDBcIixcbiAgICAgIFwiMTNcIixcbiAgICAgIFwiMTRcIixcbiAgICAgIFwiMTVcIixcbiAgICAgIFwiMTZcIixcbiAgICAgIFwiMTdcIixcbiAgICAgIFwiMThcIixcbiAgICAgIFwiMTlcIixcbiAgICAgIFwiMjBcIixcbiAgICAgIFwiMjFcIixcbiAgICAgIFwiMjJcIixcbiAgICAgIFwiMjNcIlxuICAgIF0sIHRoaXMubWludXRlc0FycmF5ID0gW1xuICAgICAgXCIwMFwiLFxuICAgICAgXCIwNVwiLFxuICAgICAgXCIxMFwiLFxuICAgICAgXCIxNVwiLFxuICAgICAgXCIyMFwiLFxuICAgICAgXCIyNVwiLFxuICAgICAgXCIzMFwiLFxuICAgICAgXCIzNVwiLFxuICAgICAgXCI0MFwiLFxuICAgICAgXCI0NVwiLFxuICAgICAgXCI1MFwiLFxuICAgICAgXCI1NVwiXG4gICAgXSwgdGhpcy5pbnB1dCA9IGQuZmluZE9uZShcImlucHV0XCIsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLmRhdGFXaXRoSWNvbiA9IHQuZGF0YXNldC53aXRoSWNvbiwgdGhpcy5kYXRhVG9nZ2xlID0gdC5kYXRhc2V0LnRvZ2dsZSwgdGhpcy5jdXN0b21JY29uID0gZC5maW5kT25lKFxuICAgICAgbWcsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fY2hlY2tUb2dnbGVCdXR0b24oKSwgdGhpcy5pbnB1dEZvcm1hdFNob3cgPSBkLmZpbmRPbmUoXG4gICAgICBmZyxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLmlucHV0Rm9ybWF0ID0gdGhpcy5pbnB1dEZvcm1hdFNob3cgPT09IG51bGwgPyBcIlwiIDogT2JqZWN0LnZhbHVlcyh0aGlzLmlucHV0Rm9ybWF0U2hvdy5kYXRhc2V0KVswXSwgdGhpcy5lbGVtZW50VG9nZ2xlID0gZC5maW5kT25lKFxuICAgICAgR2EsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy50b2dnbGVFbGVtZW50ID0gT2JqZWN0LnZhbHVlcyhcbiAgICAgIHQucXVlcnlTZWxlY3RvcihHYSkuZGF0YXNldFxuICAgIClbMF0sIHRoaXMuX2hvdXIgPSBudWxsLCB0aGlzLl9taW51dGVzID0gbnVsbCwgdGhpcy5fQU0gPSBudWxsLCB0aGlzLl9QTSA9IG51bGwsIHRoaXMuX3dyYXBwZXIgPSBudWxsLCB0aGlzLl9tb2RhbCA9IG51bGwsIHRoaXMuX2hhbmQgPSBudWxsLCB0aGlzLl9jaXJjbGUgPSBudWxsLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9pbnRlcnZhbCA9IG51bGwsIHRoaXMuX3RpbWVvdXRJbnRlcnZhbCA9IG51bGwsIHRoaXMuX2lucHV0VmFsdWUgPSB0aGlzLl9vcHRpb25zLmRlZmF1bHRUaW1lICE9PSBcIlwiID8gdGhpcy5fb3B0aW9ucy5kZWZhdWx0VGltZSA6IHRoaXMuaW5wdXQudmFsdWUsIHRoaXMuX29wdGlvbnMuZm9ybWF0MjQgJiYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MTIgPSAhMSwgdGhpcy5fY3VycmVudFRpbWUgPSBLYSh0aGlzLl9pbnB1dFZhbHVlKSksIHRoaXMuX29wdGlvbnMuZm9ybWF0MTIgJiYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MjQgPSAhMSwgdGhpcy5fY3VycmVudFRpbWUgPSBDZSh0aGlzLl9pbnB1dFZhbHVlKSksIHRoaXMuX29wdGlvbnMucmVhZE9ubHkgJiYgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoRWcsICEwKSwgdGhpcy5pbnB1dEZvcm1hdCA9PT0gXCJ0cnVlXCIgJiYgdGhpcy5pbnB1dEZvcm1hdCAhPT0gXCJcIiAmJiAodGhpcy5fb3B0aW9ucy5mb3JtYXQxMiA9ICExLCB0aGlzLl9vcHRpb25zLmZvcm1hdDI0ID0gITAsIHRoaXMuX2N1cnJlbnRUaW1lID0gS2EodGhpcy5faW5wdXRWYWx1ZSkpLCB0aGlzLl9hbmltYXRpb25zID0gIXdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIikubWF0Y2hlcyAmJiB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbnMsIHRoaXMuaW5pdCgpLCB0aGlzLl9pc0hvdXJzID0gITAsIHRoaXMuX2lzTWludXRlcyA9ICExLCB0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0ID0gITEsIHRoaXMuX2lzTW91c2VNb3ZlID0gITEsIHRoaXMuX2lzSW5uZXIgPSAhMSwgdGhpcy5faXNBbUVuYWJsZWQgPSAhMSwgdGhpcy5faXNQbUVuYWJsZWQgPSAhMSwgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMiAmJiAhdGhpcy5fb3B0aW9ucy5kZWZhdWx0VGltZSAmJiAodGhpcy5faXNQbUVuYWJsZWQgPSAhMCksIHRoaXMuX29ialdpdGhEYXRhT25DaGFuZ2UgPSB7IGRlZ3JlZXM6IG51bGwgfSwgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IHRpKCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEJpO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIGNvbnN0IHsgZm9ybWF0MTI6IHQsIGZvcm1hdDI0OiBlLCBlbmFibGVWYWxpZGF0aW9uOiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGxldCBuLCBvLCByO1xuICAgIGlmICh0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShBZywgXCJcIiksIHRoaXMuX2N1cnJlbnRUaW1lICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHsgaG91cnM6IGEsIG1pbnV0ZXM6IGwsIGFtT3JQbTogcCB9ID0gdGhpcy5fY3VycmVudFRpbWU7XG4gICAgICBuID0gTnVtYmVyKGEpIDwgMTAgPyAwIDogXCJcIiwgbyA9IGAke259JHtOdW1iZXIoYSl9OiR7bH1gLCByID0gcCwgdCA/IHRoaXMuaW5wdXQudmFsdWUgPSBgJHtvfSAke3J9YCA6IGUgJiYgKHRoaXMuaW5wdXQudmFsdWUgPSBgJHtvfWApO1xuICAgIH0gZWxzZVxuICAgICAgbiA9IFwiXCIsIG8gPSBcIlwiLCByID0gXCJcIiwgdGhpcy5pbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgdGhpcy5pbnB1dC52YWx1ZS5sZW5ndGggPiAwICYmIHRoaXMuaW5wdXQudmFsdWUgIT09IFwiXCIgJiYgKHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKEgsIFwiXCIpLCBjLnRyaWdnZXIodGhpcy5pbnB1dCwgXCJpbnB1dFwiKSksICEodGhpcy5fb3B0aW9ucyA9PT0gbnVsbCAmJiB0aGlzLl9lbGVtZW50ID09PSBudWxsKSAmJiAoaSAmJiB0aGlzLl9nZXRWYWxpZGF0ZShcImtleWRvd24gY2hhbmdlIGJsdXIgZm9jdXNcIiksIHRoaXMuX2hhbmRsZU9wZW4oKSwgdGhpcy5fbGlzdGVuVG9Ub2dnbGVLZXlkb3duKCkpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fcmVtb3ZlTW9kYWwoKSwgdGhpcy5fZWxlbWVudCAhPT0gbnVsbCAmJiBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgSnMpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9vcHRpb25zID0gbnVsbCwgdGhpcy5pbnB1dCA9IG51bGwsIHRoaXMuX2ZvY3VzVHJhcCA9IG51bGw7XG4gICAgfSwgMzUwKSwgYy5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgYFtkYXRhLXRlLXRvZ2dsZT0nJHt0aGlzLnRvZ2dsZUVsZW1lbnR9J11gXG4gICAgKSwgYy5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICBgW2RhdGEtdGUtdG9nZ2xlPScke3RoaXMudG9nZ2xlRWxlbWVudH0nXWBcbiAgICApO1xuICB9XG4gIHVwZGF0ZSh0ID0ge30pIHtcbiAgICB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKHsgLi4udGhpcy5fb3B0aW9ucywgLi4udCB9KTtcbiAgfVxuICAvLyBwcml2YXRlXG4gIF9jaGVja1RvZ2dsZUJ1dHRvbigpIHtcbiAgICB0aGlzLmN1c3RvbUljb24gPT09IG51bGwgJiYgKHRoaXMuZGF0YVdpdGhJY29uICE9PSB2b2lkIDAgJiYgKHRoaXMuX29wdGlvbnMud2l0aEljb24gPSBudWxsLCB0aGlzLmRhdGFXaXRoSWNvbiA9PT0gXCJ0cnVlXCIgJiYgdGhpcy5fYXBwZW5kVG9nZ2xlQnV0dG9uKHRoaXMuX29wdGlvbnMpKSwgdGhpcy5fb3B0aW9ucy53aXRoSWNvbiAmJiB0aGlzLl9hcHBlbmRUb2dnbGVCdXR0b24odGhpcy5fb3B0aW9ucykpO1xuICB9XG4gIF9hcHBlbmRUb2dnbGVCdXR0b24oKSB7XG4gICAgY29uc3QgdCA9IGFnKFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbklkLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5pbnB1dC5pbnNlcnRBZGphY2VudEhUTUwoXCJhZnRlcmVuZFwiLCB0KTtcbiAgfVxuICBfZ2V0RG9tRWxlbWVudHMoKSB7XG4gICAgdGhpcy5faG91ciA9IGQuZmluZE9uZShgWyR7Q3N9XWApLCB0aGlzLl9taW51dGVzID0gZC5maW5kT25lKGBbJHt1b31dYCksIHRoaXMuX0FNID0gZC5maW5kT25lKHBnKSwgdGhpcy5fUE0gPSBkLmZpbmRPbmUoX2cpLCB0aGlzLl93cmFwcGVyID0gZC5maW5kT25lKGBbJHtob31dYCksIHRoaXMuX21vZGFsID0gZC5maW5kT25lKGBbJHtjbH1dYCksIHRoaXMuX2hhbmQgPSBkLmZpbmRPbmUoYFske3BvfV1gKSwgdGhpcy5fY2lyY2xlID0gZC5maW5kT25lKGBbJHtfb31dYCksIHRoaXMuX2Nsb2NrID0gZC5maW5kT25lKGBbJHt1ZX1dYCksIHRoaXMuX2Nsb2NrSW5uZXIgPSBkLmZpbmRPbmUoXG4gICAgICBgWyR7bWl9XWBcbiAgICApO1xuICB9XG4gIF9oYW5kbGVyTWF4TWluSG91cnNPcHRpb25zKHQsIGUsIGksIG4sIG8sIHIpIHtcbiAgICBpZiAoIWUgJiYgIWkpXG4gICAgICByZXR1cm4gITA7XG4gICAgY29uc3QgeyBmb3JtYXQyNDogYSwgZm9ybWF0MTI6IGwsIGRpc2FibGVQYXN0OiBwLCBkaXNhYmxlRnV0dXJlOiB1IH0gPSB0aGlzLl9vcHRpb25zLCB7IF9pc0FtRW5hYmxlZDogXywgX2lzUG1FbmFibGVkOiBmIH0gPSB0aGlzLCBnID0gci5rZXlDb2RlLCBtID0gci50YXJnZXQuaGFzQXR0cmlidXRlKG1pKSB8fCByLnRhcmdldC5oYXNBdHRyaWJ1dGUoaHQpIHx8IHIudGFyZ2V0Lmhhc0F0dHJpYnV0ZSh5cyk7XG4gICAgaSA9IEd0KGksIHAsIGwpLCBlID0gcXQoZSwgdSwgbCksIHR5cGVvZiBlICE9IFwibnVtYmVyXCIgJiYgKGUgPSBSKGUsICExKVswXSk7XG4gICAgY29uc3QgYiA9IGUgIT09IFwiXCIgPyBlICogMzAgOiBcIlwiLCB2ID0gaSAhPT0gXCJcIiA/IGkgKiAzMCA6IFwiXCI7XG4gICAgdCA8IDAgJiYgKHQgPSAzNjAgKyB0KSwgdCA9IHQgPT09IDM2MCA/IDAgOiB0O1xuICAgIGNvbnN0IFQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBEID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgYFske0FzfV1gXG4gICAgICApLCBPID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgYFske3lzfV1gXG4gICAgICApLCB4ID0gdWcodGhpcy5faG91ci5pbm5lclRleHQpO1xuICAgICAgbGV0IEwsIFMsIE47XG4gICAgICByZXR1cm4gZyA9PT0gVSA/IFMgPSAxIDogZyA9PT0geiAmJiAoUyA9IC0xKSwgeCA9PT0gMTIgJiYgZyA9PT0gVSA/IE4gPSAxIDogeCA9PT0gMCAmJiBnID09PSBVID8gTiA9IDEzIDogeCA9PT0gMCAmJiBnID09PSB6ID8gTiA9IDIzIDogeCA9PT0gMTMgJiYgZyA9PT0geiA/IE4gPSAwIDogeCA9PT0gMSAmJiBnID09PSB6ID8gTiA9IDEyIDogTiA9IHggKyBTLCBELmZvckVhY2goKFApID0+IHtcbiAgICAgICAgTnVtYmVyKFAudGV4dENvbnRlbnQpID09PSBOICYmIChMID0gUCk7XG4gICAgICB9KSwgTy5mb3JFYWNoKChQKSA9PiB7XG4gICAgICAgIE51bWJlcihQLnRleHRDb250ZW50KSA9PT0gTiAmJiAoTCA9IFApO1xuICAgICAgfSksICFMLnBhcmVudEVsZW1lbnQuaGFzQXR0cmlidXRlKGp0KTtcbiAgICB9LCB5ID0gKCkgPT4ge1xuICAgICAgY29uc3QgRCA9IGkgIT09IFwiXCIgJiYgaSA+IDEyID8gKGkgLSAxMikgKiAzMCA6IFwiXCIsIE8gPSBlICE9PSBcIlwiICYmIGUgPiAxMiA/IChlIC0gMTIpICogMzAgOiBcIlwiO1xuICAgICAgaWYgKCEoRCAmJiB0IDwgRCB8fCBPICYmIHQgPiBPIHx8IGUgJiYgZSA8IDEyKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH07XG4gICAgaWYgKGEgJiYgci50eXBlICE9PSBcImtleWRvd25cIiAmJiBtKVxuICAgICAgcmV0dXJuIHkoKTtcbiAgICBpZiAoci50eXBlID09PSBcImtleWRvd25cIilcbiAgICAgIHJldHVybiBUKCk7XG4gICAgY29uc3QgQyA9ICFvIHx8IG8gPT09IFwiUE1cIiAmJiBmIHx8IGkgIT09IFwiXCIgJiYgbyA9PT0gXCJBTVwiICYmIF8sIEUgPSAhbiB8fCBuID09PSBcIlBNXCIgJiYgZiB8fCBlICE9PSBcIlwiICYmIG4gPT09IFwiQU1cIiAmJiBfLCB3ID0gKCkgPT4ge1xuICAgICAgY29uc3QgRCA9IHYgPT09IDM2MCAmJiBsID8gMCA6IHY7XG4gICAgICBpZiAoaSkge1xuICAgICAgICBpZiAobyA9PT0gXCJQTVwiICYmIF8gfHwgQyAmJiB0IDwgRClcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIGsgPSAoKSA9PiB7XG4gICAgICBjb25zdCBEID0gYiA9PT0gMzYwICYmIGwgPyAwIDogYjtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGlmIChuID09PSBcIkFNXCIgJiYgZiB8fCBFICYmIHQgPiBEKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICByZXR1cm4gITA7XG4gICAgfTtcbiAgICByZXR1cm4gdygpICYmIGsoKTtcbiAgfVxuICBfaGFuZGxlS2V5Ym9hcmQoKSB7XG4gICAgYy5vbih0aGlzLl9kb2N1bWVudCwgdnMsIFwiXCIsICh0KSA9PiB7XG4gICAgICBsZXQgZSwgaSwgbjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5jcmVtZW50OiBvLFxuICAgICAgICBtYXhUaW1lOiByLFxuICAgICAgICBtaW5UaW1lOiBhLFxuICAgICAgICBmb3JtYXQxMjogbCxcbiAgICAgICAgZGlzYWJsZVBhc3Q6IHAsXG4gICAgICAgIGRpc2FibGVGdXR1cmU6IHVcbiAgICAgIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgbGV0IF8gPSBSKGEsICExKVswXSwgZiA9IFIociwgITEpWzBdO1xuICAgICAgY29uc3QgZyA9IFIoYSwgITEpWzJdLCBtID0gUihyLCAhMSlbMl07XG4gICAgICBfID0gR3QoXywgcCwgbCksIGYgPSBxdChmLCB1LCBsKSwgdHlwZW9mIGYgIT0gXCJudW1iZXJcIiAmJiAoZiA9IFIoZiwgITEpWzBdKTtcbiAgICAgIGNvbnN0IGIgPSBkLmZpbmRPbmUoYFske3F9XWApID09PSBudWxsLCB2ID0gZC5maW5kT25lKGBbJHtodH1dYCkgIT09IG51bGwsIFQgPSBOdW1iZXIodGhpcy5faGFuZC5zdHlsZS50cmFuc2Zvcm0ucmVwbGFjZSgvW15cXGQtXS9nLCBcIlwiKSksIHkgPSBkLmZpbmQoXG4gICAgICAgIGBbJHtxfV1gLFxuICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgKSwgQyA9IGQuZmluZChcbiAgICAgICAgYFske1h9XWAsXG4gICAgICAgIHRoaXMuX21vZGFsXG4gICAgICApLCBFID0gZC5maW5kKFxuICAgICAgICBgWyR7aHR9XWAsXG4gICAgICAgIHRoaXMuX21vZGFsXG4gICAgICApO1xuICAgICAgbGV0IHcgPSB0aGlzLl9tYWtlSG91ckRlZ3JlZXModC50YXJnZXQsIFQsIGUpLmhvdXI7XG4gICAgICBjb25zdCB7IGRlZ3JlZXM6IGssIGFkZERlZ3JlZXM6IEQgfSA9IHRoaXMuX21ha2VIb3VyRGVncmVlcyhcbiAgICAgICAgdC50YXJnZXQsXG4gICAgICAgIFQsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgICBsZXQgeyBtaW51dGU6IE8sIGRlZ3JlZXM6IHggfSA9IHRoaXMuX21ha2VNaW51dGVzRGVncmVlcyhULCBpKTtcbiAgICAgIGNvbnN0IEwgPSB0aGlzLl9tYWtlTWludXRlc0RlZ3JlZXMoXG4gICAgICAgIFQsXG4gICAgICAgIGlcbiAgICAgICkuYWRkRGVncmVlcztcbiAgICAgIGxldCB7IGhvdXI6IFMgfSA9IHRoaXMuX21ha2VJbm5lckhvdXJzRGVncmVlcyhcbiAgICAgICAgVCxcbiAgICAgICAgblxuICAgICAgKTtcbiAgICAgIGlmICh0LmtleUNvZGUgPT09IHdlKSB7XG4gICAgICAgIGNvbnN0IE4gPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske29vfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICk7XG4gICAgICAgIGMudHJpZ2dlcihOLCBcImNsaWNrXCIpO1xuICAgICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICAgIGlmICh2ICYmICh0LmtleUNvZGUgPT09IHplICYmICh0aGlzLl9pc0lubmVyID0gITEsIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgIGhlaWdodDogXCJjYWxjKDQwJSArIDFweClcIlxuICAgICAgICB9KSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShcbiAgICAgICAgICB3ID4gMTIgPyAxIDogd1xuICAgICAgICApLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmhvdXJzQXJyYXksIHRoaXMuX2hvdXIsIEMpLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmlubmVySG91cnMsIHRoaXMuX2hvdXIsIEUpKSwgdC5rZXlDb2RlID09PSBLZSAmJiAodGhpcy5faXNJbm5lciA9ICEwLCBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICBoZWlnaHQ6IFwiMjEuNSVcIlxuICAgICAgICB9KSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShcbiAgICAgICAgICBTID49IDI0IHx8IFMgPT09IFwiMDBcIiA/IDAgOiBTXG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaW5uZXJIb3VycywgdGhpcy5faG91ciwgRSksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKFxuICAgICAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgICAgICB0aGlzLl9ob3VyIC0gMSxcbiAgICAgICAgICBDXG4gICAgICAgICkpKSwgdC5rZXlDb2RlID09PSBVKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyTWF4TWluSG91cnNPcHRpb25zKFxuICAgICAgICAgICAgayArIDMwLFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIF8sXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIHRcbiAgICAgICAgICApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke2sgKyBEfWRlZylgXG4gICAgICAgICAgfSksIHRoaXMuX2lzSW5uZXIgPyAoUyArPSAxLCBTID09PSAyNCA/IFMgPSAwIDogKFMgPT09IDI1IHx8IFMgPT09IFwiMDAxXCIpICYmIChTID0gMTMpLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFMpLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmlubmVySG91cnMsIHRoaXMuX2hvdXIsIEUpKSA6ICh3ICs9IDEsIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoXG4gICAgICAgICAgICB3ID4gMTIgPyAxIDogd1xuICAgICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgQykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0LmtleUNvZGUgPT09IHopIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJNYXhNaW5Ib3Vyc09wdGlvbnMoXG4gICAgICAgICAgICBrIC0gMzAsXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgXyxcbiAgICAgICAgICAgIG0sXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgdFxuICAgICAgICAgICkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7ayAtIER9ZGVnKWBcbiAgICAgICAgICB9KSwgdGhpcy5faXNJbm5lciA/IChTIC09IDEsIFMgPT09IDEyID8gUyA9IDAgOiBTID09PSAtMSAmJiAoUyA9IDIzKSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShTKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5pbm5lckhvdXJzLCB0aGlzLl9ob3VyLCBFKSkgOiAodyAtPSAxLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgICAgdyA9PT0gMCA/IDEyIDogd1xuICAgICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgQykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgdC5rZXlDb2RlID09PSBVICYmICh4ICs9IEwsIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt4fWRlZylgXG4gICAgICAgIH0pLCBPICs9IDEsIG8gJiYgKE8gKz0gNCwgTyA9PT0gXCIwMDE0XCIgJiYgKE8gPSA1KSksIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoXG4gICAgICAgICAgTyA+IDU5ID8gMCA6IE9cbiAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUoXG4gICAgICAgICAgdGhpcy5taW51dGVzQXJyYXksXG4gICAgICAgICAgdGhpcy5fbWludXRlcyxcbiAgICAgICAgICB5XG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUJhY2tncm91bmRDb2xvckNpcmNsZShcbiAgICAgICAgICBgWyR7cX1dYFxuICAgICAgICApKSwgdC5rZXlDb2RlID09PSB6ICYmICh4IC09IEwsIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt4fWRlZylgXG4gICAgICAgIH0pLCBvID8gTyAtPSA1IDogTyAtPSAxLCBPID09PSAtMSA/IE8gPSA1OSA6IE8gPT09IC01ICYmIChPID0gNTUpLCB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKE8pLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZShcbiAgICAgICAgICB0aGlzLm1pbnV0ZXNBcnJheSxcbiAgICAgICAgICB0aGlzLl9taW51dGVzLFxuICAgICAgICAgIHlcbiAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQmFja2dyb3VuZENvbG9yQ2lyY2xlKFxuICAgICAgICAgIGBbJHtxfV1gXG4gICAgICAgICkpO1xuICAgIH0pO1xuICB9XG4gIF9zZXRBY3RpdmVDbGFzc1RvVGlwc09uT3Blbih0LCAuLi5lKSB7XG4gICAgaWYgKCF0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0KVxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MjQpIHtcbiAgICAgICAgY29uc3QgaSA9IGQuZmluZChcbiAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBuID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtodH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKGksIHQpLCB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKG4sIHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWy4uLmVdLmZpbHRlcigobikgPT4gKG4udG9Mb3dlckNhc2UoKSA9PT0gXCJwbVwiID8gKGguYWRkQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX1BNLnNldEF0dHJpYnV0ZShILCBcIlwiKSkgOiBuLnRvTG93ZXJDYXNlKCkgPT09IFwiYW1cIiA/IChoLmFkZENsYXNzKHRoaXMuX0FNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9BTS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpIDogKGgucmVtb3ZlQ2xhc3ModGhpcy5fQU0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIGgucmVtb3ZlQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX0FNLnJlbW92ZUF0dHJpYnV0ZShIKSwgdGhpcy5fUE0ucmVtb3ZlQXR0cmlidXRlKEgpKSwgbikpO1xuICAgICAgICBjb25zdCBpID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtYfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoaSwgdCk7XG4gICAgICB9XG4gIH1cbiAgX3NldFRpcHNBbmRUaW1lc0RlcGVuZE9uSW5wdXRWYWx1ZSh0LCBlKSB7XG4gICAgY29uc3QgeyBpbmxpbmU6IGksIGZvcm1hdDEyOiBuIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGlmICh0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0KVxuICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IFwiMTJcIiwgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IFwiMDBcIiwgaSB8fCBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBcInJvdGF0ZVooMGRlZylcIlxuICAgICAgfSksIG4gJiYgKGguYWRkQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX1BNLnNldEF0dHJpYnV0ZShILCBcIlwiKSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBvID0gdCA+IDEyID8gdCAqIDMwIC0gMzYwIDogdCAqIDMwO1xuICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHQsIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSBlLCBpIHx8IChoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke299ZGVnKWBcbiAgICAgIH0pLCBoLmFkZFN0eWxlKHRoaXMuX2NpcmNsZSwge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzE5NzZkMlwiXG4gICAgICB9KSwgKE51bWJlcih0KSA+IDEyIHx8IHQgPT09IFwiMDBcIikgJiYgaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIF9saXN0ZW5Ub1RvZ2dsZUtleWRvd24oKSB7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIGBbZGF0YS10ZS10b2dnbGU9JyR7dGhpcy50b2dnbGVFbGVtZW50fSddYCxcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHQua2V5Q29kZSA9PT0gaXQgJiYgKHQucHJldmVudERlZmF1bHQoKSwgYy50cmlnZ2VyKHRoaXMuZWxlbWVudFRvZ2dsZSwgXCJjbGlja1wiKSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlT3BlbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZ2V0Q29udGFpbmVyKCk7XG4gICAgSy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBgW2RhdGEtdGUtdG9nZ2xlPScke3RoaXMudG9nZ2xlRWxlbWVudH0nXWAsXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGkgPSBoLmdldERhdGFBdHRyaWJ1dGUodGhpcy5pbnB1dCwgXCJ0b2dnbGVcIikgIT09IG51bGwgPyAyMDAgOiAwO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBoLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICAgICAgICB9KSwgdGhpcy5lbGVtZW50VG9nZ2xlLmJsdXIoKTtcbiAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICBSKHRoaXMuaW5wdXQpWzBdID09PSBcIlwiID8gbiA9IFtcIjEyXCIsIFwiMDBcIiwgXCJQTVwiXSA6IG4gPSBSKHRoaXMuaW5wdXQpO1xuICAgICAgICAgIGNvbnN0IHsgbW9kYWxJRDogbywgaW5saW5lOiByLCBmb3JtYXQxMjogYSB9ID0gdGhpcy5fb3B0aW9ucywgW2wsIHAsIHVdID0gbiwgXyA9ICQoXCJkaXZcIik7XG4gICAgICAgICAgaWYgKChOdW1iZXIobCkgPiAxMiB8fCBsID09PSBcIjAwXCIpICYmICh0aGlzLl9pc0lubmVyID0gITApLCB0aGlzLmlucHV0LmJsdXIoKSwgZS50YXJnZXQuYmx1cigpLCBfLmlubmVySFRNTCA9IHJnKHRoaXMuX29wdGlvbnMsIHRoaXMuX2NsYXNzZXMpLCBoLmFkZENsYXNzKF8sIHRoaXMuX2NsYXNzZXMubW9kYWwpLCBfLnNldEF0dHJpYnV0ZShjbCwgXCJcIiksIF8uc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImRpYWxvZ1wiKSwgXy5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCBcIi0xXCIpLCBfLnNldEF0dHJpYnV0ZShcImlkXCIsIG8pLCByID8gKHRoaXMuX3BvcHBlciA9IHNlKHRoaXMuaW5wdXQsIF8sIHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogXCJib3R0b20tc3RhcnRcIlxuICAgICAgICAgIH0pLCB0LmFwcGVuZENoaWxkKF8pKSA6ICh0LmFwcGVuZENoaWxkKF8pLCB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpKSwgdGhpcy5fZ2V0RG9tRWxlbWVudHMoKSwgdGhpcy5fYW5pbWF0aW9ucyA/IHRoaXMuX3RvZ2dsZUJhY2tkcm9wQW5pbWF0aW9uKCkgOiBoLmFkZENsYXNzKHRoaXMuX3dyYXBwZXIsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX3NldEFjdGl2ZUNsYXNzVG9UaXBzT25PcGVuKGwsIHAsIHUpLCB0aGlzLl9hcHBlbmRUaW1lcygpLCB0aGlzLl9zZXRBY3RpdmVDbGFzc1RvVGlwc09uT3BlbihsLCBwLCB1KSwgdGhpcy5fc2V0VGlwc0FuZFRpbWVzRGVwZW5kT25JbnB1dFZhbHVlKGwsIHApLCB0aGlzLmlucHV0LnZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gZC5maW5kKFxuICAgICAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhICYmIChoLmFkZENsYXNzKHRoaXMuX1BNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9QTS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gXCIxMlwiLCB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gXCIwMFwiLCB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKFxuICAgICAgICAgICAgICBmLFxuICAgICAgICAgICAgICBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVTd2l0Y2hUaW1lTW9kZSgpLCB0aGlzLl9oYW5kbGVPa0J1dHRvbigpLCB0aGlzLl9oYW5kbGVDbG9zZSgpLCByKVxuICAgICAgICAgICAgdGhpcy5faGFuZGxlSG92ZXJJbmxpbmVCdG4oKSwgdGhpcy5faGFuZGxlRG9jdW1lbnRDbGlja0lubGluZSgpLCB0aGlzLl9oYW5kbGVJbmxpbmVDbGlja3MoKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVN3aXRjaEhvdXJNaW51dGUoKSwgdGhpcy5faGFuZGxlQ2xvY2tDbGljaygpLCB0aGlzLl9oYW5kbGVLZXlib2FyZCgpO1xuICAgICAgICAgICAgY29uc3QgZiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAgIGAke1RzfVske0h9XWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBoLmFkZENsYXNzKGYsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIGguYWRkU3R5bGUodGhpcy5faG91ciwge1xuICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgICAgICAgICAgfSksIGguYWRkU3R5bGUodGhpcy5fbWludXRlcywge1xuICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZm9jdXNUcmFwID0gbmV3IHppKHRoaXMuX3dyYXBwZXIsIHtcbiAgICAgICAgICAgIGV2ZW50OiBcImtleWRvd25cIixcbiAgICAgICAgICAgIGNvbmRpdGlvbjogKHsga2V5OiBmIH0pID0+IGYgPT09IFwiVGFiXCJcbiAgICAgICAgICB9KSwgdGhpcy5fZm9jdXNUcmFwLnRyYXAoKTtcbiAgICAgICAgfSwgaSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlSW5saW5lQ2xpY2tzKCkge1xuICAgIGxldCB0LCBlO1xuICAgIGNvbnN0IGkgPSAoZykgPT4ge1xuICAgICAgbGV0IG0gPSBnO1xuICAgICAgcmV0dXJuIG0gPiA1OSA/IG0gPSAwIDogbSA8IDAgJiYgKG0gPSA1OSksIG07XG4gICAgfSwgbiA9IChnKSA9PiB7XG4gICAgICBsZXQgbSA9IGc7XG4gICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5mb3JtYXQyNCA/IChtID4gMjQgPyBtID0gMSA6IG0gPCAwICYmIChtID0gMjMpLCBtID4gMjMgJiYgKG0gPSAwKSkgOiAobSA+IDEyID8gbSA9IDEgOiBtIDwgMSAmJiAobSA9IDEyKSwgbSA+IDEyICYmIChtID0gMSkpLCBtO1xuICAgIH0sIG8gPSAoZykgPT4ge1xuICAgICAgY29uc3QgbSA9IG4oZyk7XG4gICAgICB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKG0pO1xuICAgIH0sIHIgPSAoZykgPT4ge1xuICAgICAgY29uc3QgbSA9IGkoZyk7XG4gICAgICB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKG0pO1xuICAgIH0sIGEgPSAoKSA9PiB7XG4gICAgICB0ID0gbih0KSArIDEsIG8odCk7XG4gICAgfSwgbCA9ICgpID0+IHtcbiAgICAgIGUgPSBpKGUpICsgMSwgcihlKTtcbiAgICB9LCBwID0gKCkgPT4ge1xuICAgICAgdCA9IG4odCkgLSAxLCBvKHQpO1xuICAgIH0sIHUgPSAoKSA9PiB7XG4gICAgICBlID0gaShlKSAtIDEsIHIoZSk7XG4gICAgfSwgXyA9ICgpID0+IHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLCBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dEludGVydmFsKTtcbiAgICB9LCBmID0gKGcpID0+IHtcbiAgICAgIF8oKSwgdGhpcy5fdGltZW91dEludGVydmFsID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoZywgMTAwKTtcbiAgICAgIH0sIDUwMCk7XG4gICAgfTtcbiAgICBLLm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcImNsaWNrIG1vdXNlZG93biBtb3VzZXVwIHRvdWNoc3RhcnQgdG91Y2hlbmQgY29udGV4dG1lbnVcIixcbiAgICAgIGBbJHthb31dLCBbJHtsb31dYCxcbiAgICAgIChnKSA9PiB7XG4gICAgICAgIHQgPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIGUgPSBOdW1iZXIodGhpcy5fbWludXRlcy50ZXh0Q29udGVudCk7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0OiBtLCB0eXBlOiBiIH0gPSBnLCB2ID0gYiA9PT0gXCJtb3VzZWRvd25cIiB8fCBiID09PSBcInRvdWNoc3RhcnRcIjtcbiAgICAgICAgbS5jbG9zZXN0KGBbJHthb31dYCkgPyBtLmNsb3Nlc3QoYFske2FvfV1gKS5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZShybCkgPyB2ID8gZihhKSA6IGIgPT09IFwibW91c2V1cFwiIHx8IGIgPT09IFwidG91Y2hlbmRcIiB8fCBiID09PSBcImNvbnRleHRtZW51XCIgPyBfKCkgOiBhKCkgOiB2ID8gZihsKSA6IGIgPT09IFwibW91c2V1cFwiIHx8IGIgPT09IFwidG91Y2hlbmRcIiB8fCBiID09PSBcImNvbnRleHRtZW51XCIgPyBfKCkgOiBsKCkgOiBtLmNsb3Nlc3QoYFske2xvfV1gKSAmJiAobS5jbG9zZXN0KGBbJHtsb31dYCkucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUocmwpID8gdiA/IGYocCkgOiBiID09PSBcIm1vdXNldXBcIiB8fCBiID09PSBcInRvdWNoZW5kXCIgPyBfKCkgOiBwKCkgOiB2ID8gZih1KSA6IGIgPT09IFwibW91c2V1cFwiIHx8IGIgPT09IFwidG91Y2hlbmRcIiA/IF8oKSA6IHUoKSk7XG4gICAgICB9XG4gICAgKSwgYy5vbih3aW5kb3csIHZzLCAoZykgPT4ge1xuICAgICAgY29uc3QgbSA9IGcuY29kZSwgYiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKENzKSwgdiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKFxuICAgICAgICB1b1xuICAgICAgKSwgVCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHk7XG4gICAgICBzd2l0Y2ggKHQgPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIGUgPSBOdW1iZXIodGhpcy5fbWludXRlcy50ZXh0Q29udGVudCksIG0pIHtcbiAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgICBnLnByZXZlbnREZWZhdWx0KCksIFQgfHwgYiA/ICh0aGlzLl9ob3VyLmZvY3VzKCksIGEoKSkgOiB2ICYmIGwoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICAgIGcucHJldmVudERlZmF1bHQoKSwgVCB8fCBiID8gKHRoaXMuX2hvdXIuZm9jdXMoKSwgcCgpKSA6IHYgJiYgdSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVDbG9zZSgpIHtcbiAgICBjLm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBgWyR7aG99XSwgWyR7b299XSwgWyR7b2x9XWAsXG4gICAgICAoeyB0YXJnZXQ6IHQgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IGNsb3NlTW9kYWxPbkJhY2tkcm9wQ2xpY2s6IGUgfSA9IHRoaXMuX29wdGlvbnMsIGkgPSAoKSA9PiB7XG4gICAgICAgICAgdmFyIG47XG4gICAgICAgICAgaC5hZGRTdHlsZSh0aGlzLmVsZW1lbnRUb2dnbGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgICAgICAgfSksIHRoaXMuX2FuaW1hdGlvbnMgJiYgdGhpcy5fdG9nZ2xlQmFja2Ryb3BBbmltYXRpb24oITApLCB0aGlzLl9yZW1vdmVNb2RhbCgpLCAobiA9IHRoaXMuX2ZvY3VzVHJhcCkgPT0gbnVsbCB8fCBuLmRpc2FibGUoKSwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCwgdGhpcy5lbGVtZW50VG9nZ2xlID8gdGhpcy5lbGVtZW50VG9nZ2xlLmZvY3VzKCkgOiB0aGlzLmlucHV0ICYmIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHQuaGFzQXR0cmlidXRlKG9sKSkge1xuICAgICAgICAgIHRoaXMuX3RvZ2dsZUFtUG0oXCJQTVwiKSwgdGhpcy5pbnB1dC52YWx1ZSA9IFwiXCIsIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKEgpO1xuICAgICAgICAgIGxldCBuO1xuICAgICAgICAgIFIodGhpcy5pbnB1dClbMF0gPT09IFwiXCIgPyBuID0gW1wiMTJcIiwgXCIwMFwiLCBcIlBNXCJdIDogbiA9IFIodGhpcy5pbnB1dCk7XG4gICAgICAgICAgY29uc3QgW28sIHIsIGFdID0gbjtcbiAgICAgICAgICB0aGlzLl9zZXRUaXBzQW5kVGltZXNEZXBlbmRPbklucHV0VmFsdWUoXCIxMlwiLCBcIjAwXCIpLCB0aGlzLl9zZXRBY3RpdmVDbGFzc1RvVGlwc09uT3BlbihvLCByLCBhKSwgdGhpcy5faG91ci5jbGljaygpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAodC5oYXNBdHRyaWJ1dGUob28pIHx8IHQuaGFzQXR0cmlidXRlKHJvKSB8fCB0Lmhhc0F0dHJpYnV0ZShobykgJiYgZSkgJiYgaSgpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgc2hvd1ZhbHVlSW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXQudmFsdWU7XG4gIH1cbiAgX2hhbmRsZU9rQnV0dG9uKCkge1xuICAgIEsub24oXG4gICAgICB0aGlzLl9tb2RhbCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIGBbJHtyb31dYCxcbiAgICAgICgpID0+IHtcbiAgICAgICAgbGV0IHsgbWF4VGltZTogdCwgbWluVGltZTogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZvcm1hdDEyOiBpLFxuICAgICAgICAgIGZvcm1hdDI0OiBuLFxuICAgICAgICAgIHJlYWRPbmx5OiBvLFxuICAgICAgICAgIGZvY3VzSW5wdXRBZnRlckFwcHJvdmU6IHIsXG4gICAgICAgICAgZGlzYWJsZVBhc3Q6IGEsXG4gICAgICAgICAgZGlzYWJsZUZ1dHVyZTogbFxuICAgICAgICB9ID0gdGhpcy5fb3B0aW9ucywgcCA9IHRoaXMuX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgYCR7RXN9WyR7SH1dYFxuICAgICAgICApLCB1ID0gYCR7dGhpcy5faG91ci50ZXh0Q29udGVudH06JHt0aGlzLl9taW51dGVzLnRleHRDb250ZW50fWAsIF8gPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIGYgPSBfID09PSAxMiAmJiBpID8gMCA6IF8sIGcgPSBOdW1iZXIodGhpcy5fbWludXRlcy50ZXh0Q29udGVudCk7XG4gICAgICAgIGUgPSBHdChlLCBhLCBpKSwgdCA9IHF0KHQsIGwsIGkpO1xuICAgICAgICBsZXQgW20sIGIsIHZdID0gUihcbiAgICAgICAgICB0LFxuICAgICAgICAgICExXG4gICAgICAgICksIFtULCB5LCBDXSA9IFIoXG4gICAgICAgICAgZSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgICBUID0gVCA9PT0gXCIxMlwiICYmIGkgPyBcIjAwXCIgOiBULCBtID0gbSA9PT0gXCIxMlwiICYmIGkgPyBcIjAwXCIgOiBtO1xuICAgICAgICBjb25zdCBFID0gZiA8IE51bWJlcihUKSwgdyA9IGYgPiBOdW1iZXIobSk7XG4gICAgICAgIGxldCBrID0gITA7XG4gICAgICAgIHAgJiYgKGsgPSB2ID09PSBwLnRleHRDb250ZW50KTtcbiAgICAgICAgbGV0IEQgPSAhMDtcbiAgICAgICAgcCAmJiAoRCA9IEMgPT09IHAudGV4dENvbnRlbnQpO1xuICAgICAgICBjb25zdCBPID0gZyA+IGIgJiYgZiA9PT0gTnVtYmVyKG0pLCB4ID0gZyA8IHkgJiYgZiA9PT0gTnVtYmVyKFQpO1xuICAgICAgICBpZiAodGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoSCwgXCJcIiksIGguYWRkU3R5bGUodGhpcy5lbGVtZW50VG9nZ2xlLCB7XG4gICAgICAgICAgcG9pbnRlckV2ZW50czogXCJhdXRvXCJcbiAgICAgICAgfSksIHQgIT09IFwiXCIpIHtcbiAgICAgICAgICBpZiAoayAmJiAodyB8fCBPKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAodiA9PT0gXCJBTVwiICYmIHAudGV4dENvbnRlbnQgPT09IFwiUE1cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlICE9PSBcIlwiICYmIChEICYmIChFIHx8IHgpIHx8IEMgPT09IFwiUE1cIiAmJiBwLnRleHRDb250ZW50ID09PSBcIkFNXCIpIHx8IGNnKFxuICAgICAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICAgICAgdGhpcy5pbnB1dCxcbiAgICAgICAgICB0aGlzLl9ob3VyLnRleHRDb250ZW50XG4gICAgICAgICkgIT09IHZvaWQgMCAmJiAodGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCAmJiB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShjbyksICFvICYmIHIgJiYgdGhpcy5pbnB1dC5mb2N1cygpLCBoLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgICAgIH0pLCBuID8gdGhpcy5pbnB1dC52YWx1ZSA9IHUgOiBwID09PSBudWxsID8gdGhpcy5pbnB1dC52YWx1ZSA9IGAke3V9IFBNYCA6IHRoaXMuaW5wdXQudmFsdWUgPSBgJHt1fSAke3AudGV4dENvbnRlbnR9YCwgdGhpcy5fYW5pbWF0aW9ucyAmJiB0aGlzLl90b2dnbGVCYWNrZHJvcEFuaW1hdGlvbighMCksIHRoaXMuX3JlbW92ZU1vZGFsKCksIGMudHJpZ2dlcih0aGlzLmlucHV0LCBcImlucHV0LnRlLnRpbWVwaWNrZXJcIiksIGMudHJpZ2dlcih0aGlzLmlucHV0LCBcImlucHV0XCIpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVIb3ZlcklubGluZUJ0bigpIHtcbiAgICBLLm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcIm1vdXNlb3ZlciBtb3VzZWxlYXZlXCIsXG4gICAgICBgWyR7VGd9XWAsXG4gICAgICAoeyB0eXBlOiB0LCB0YXJnZXQ6IGUgfSkgPT4ge1xuICAgICAgICBjb25zdCBpID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtiZ31dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBuID0gZC5maW5kKFxuICAgICAgICAgIGBbJHt2Z31dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBvID0gKGwsIHApID0+IGwuZm9yRWFjaCgodSkgPT4ge1xuICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBoLmFkZENsYXNzKHUsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHUuc2V0QXR0cmlidXRlKEgsIFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoLnJlbW92ZUNsYXNzKHUsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHUucmVtb3ZlQXR0cmlidXRlKEgpO1xuICAgICAgICB9KSwgYSA9IGUuaGFzQXR0cmlidXRlKENzKSA/IGkgOiBuO1xuICAgICAgICBvKGEsIHQgPT09IFwibW91c2VvdmVyXCIpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZURvY3VtZW50Q2xpY2tJbmxpbmUoKSB7XG4gICAgYy5vbihkb2N1bWVudCwgcWEsICh7IHRhcmdldDogdCB9KSA9PiB7XG4gICAgICBpZiAodGhpcy5fbW9kYWwgJiYgIXRoaXMuX21vZGFsLmNvbnRhaW5zKHQpICYmICF0Lmhhc0F0dHJpYnV0ZShnZykpIHtcbiAgICAgICAgaWYgKGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLCBoLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgICAgIH0pLCB0aGlzLl9yZW1vdmVNb2RhbCgpLCAhdGhpcy5fYW5pbWF0aW9ucylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3RvZ2dsZUJhY2tkcm9wQW5pbWF0aW9uKCEwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlU3dpdGNoSG91ck1pbnV0ZSgpIHtcbiAgICBsZyhcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIFRzLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIGMub24oXG4gICAgICB0aGlzLl9tb2RhbCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIFRzLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGZvcm1hdDI0OiB0IH0gPSB0aGlzLl9vcHRpb25zLCBlID0gZC5maW5kKFxuICAgICAgICAgIFRzLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIGkgPSBkLmZpbmQoXG4gICAgICAgICAgYFske3F9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgbiA9IGQuZmluZChcbiAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBvID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtodH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCByID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpLCBhID0gTnVtYmVyKHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQpLCBsID0gKHAsIHUpID0+IHtcbiAgICAgICAgICBuLmZvckVhY2goKGYpID0+IGYucmVtb3ZlKCkpLCBpLmZvckVhY2goKGYpID0+IGYucmVtb3ZlKCkpLCBoLmFkZENsYXNzKHRoaXMuX2hhbmQsIHRoaXMuX2NsYXNzZXMudHJhbnNmb3JtKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBoLnJlbW92ZUNsYXNzKHRoaXMuX2hhbmQsIHRoaXMuX2NsYXNzZXMudHJhbnNmb3JtKTtcbiAgICAgICAgICB9LCA0MDEpLCB0aGlzLl9nZXRBcHBlbmRDbG9jayhwLCBgWyR7dWV9XWAsIHUpO1xuICAgICAgICAgIGNvbnN0IF8gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmID0gZC5maW5kKFxuICAgICAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgICAgICksIGcgPSBkLmZpbmQoXG4gICAgICAgICAgICAgIGBbJHtxfV1gLFxuICAgICAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoZiwgciksIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoZywgYSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoIXQpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgXygpO1xuICAgICAgICAgICAgfSwgNDAxKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBkLmZpbmQoXG4gICAgICAgICAgICAgIGBbJHtodH1dYCxcbiAgICAgICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChmLCByKSwgXygpO1xuICAgICAgICAgICAgfSwgNDAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGUuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgIHAuaGFzQXR0cmlidXRlKEgpICYmIChwLmhhc0F0dHJpYnV0ZSh1bykgPyAoaC5hZGRDbGFzcyh0aGlzLl9oYW5kLCB0aGlzLl9jbGFzc2VzLnRyYW5zZm9ybSksIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3RoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgKiA2fWRlZylgLFxuICAgICAgICAgICAgaGVpZ2h0OiBcImNhbGMoNDAlICsgMXB4KVwiXG4gICAgICAgICAgfSksIHQgJiYgby5sZW5ndGggPiAwICYmIG8uZm9yRWFjaCgodSkgPT4gdS5yZW1vdmUoKSksIGwoXG4gICAgICAgICAgICB0aGlzLm1pbnV0ZXNBcnJheSxcbiAgICAgICAgICAgIHFcbiAgICAgICAgICApLCB0aGlzLl9ob3VyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIlwiLCB0aGlzLl9taW51dGVzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIikgOiBwLmhhc0F0dHJpYnV0ZShDcykgJiYgKGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3RoaXMuX2hvdXIudGV4dENvbnRlbnQgKiAzMH1kZWcpYFxuICAgICAgICAgIH0pLCBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPiAxMiA/IChoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt0aGlzLl9ob3VyLnRleHRDb250ZW50ICogMzAgLSAzNjB9ZGVnKWAsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiMjEuNSVcIlxuICAgICAgICAgIH0pLCBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPiAxMiAmJiBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgICAgICAgfSkpIDogaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IFwiY2FsYyg0MCUgKyAxcHgpXCJcbiAgICAgICAgICB9KSwgdCAmJiB0aGlzLl9nZXRBcHBlbmRDbG9jayhcbiAgICAgICAgICAgIHRoaXMuaW5uZXJIb3VycyxcbiAgICAgICAgICAgIGBbJHttaX1dYCxcbiAgICAgICAgICAgIGh0XG4gICAgICAgICAgKSwgby5sZW5ndGggPiAwICYmIG8uZm9yRWFjaCgodSkgPT4gdS5yZW1vdmUoKSksIGwoXG4gICAgICAgICAgICB0aGlzLmhvdXJzQXJyYXksXG4gICAgICAgICAgICBYXG4gICAgICAgICAgKSwgaC5hZGRTdHlsZSh0aGlzLl9ob3VyLCB7XG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgICAgICAgIH0pLCBoLmFkZFN0eWxlKHRoaXMuX21pbnV0ZXMsIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiXCJcbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVEaXNhYmxpbmdUaXBzTWF4VGltZSh0LCBlLCBpLCBuKSB7XG4gICAgaWYgKCF0aGlzLl9vcHRpb25zLm1heFRpbWUgJiYgIXRoaXMuX29wdGlvbnMuZGlzYWJsZUZ1dHVyZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvID0gZC5maW5kKFxuICAgICAgYFske1h9XWBcbiAgICApLCByID0gZC5maW5kKFxuICAgICAgYFske2h0fV1gXG4gICAgKSwgYSA9IGQuZmluZChcbiAgICAgIGBbJHtxfV1gXG4gICAgKTtcbiAgICBpZiAoIWUgfHwgZSA9PT0gdCkge1xuICAgICAgVWEoXG4gICAgICAgIHIsXG4gICAgICAgIG4sXG4gICAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICAgICksIFVhKFxuICAgICAgICBvLFxuICAgICAgICBuLFxuICAgICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgICApLCBoZyhcbiAgICAgICAgYSxcbiAgICAgICAgaSxcbiAgICAgICAgbixcbiAgICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCxcbiAgICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMlxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZSA9PT0gXCJBTVwiICYmIHQgPT09IFwiUE1cIiAmJiAoby5mb3JFYWNoKChsKSA9PiB7XG4gICAgICBoLmFkZENsYXNzKGwsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgbC5zZXRBdHRyaWJ1dGUoanQsIFwiXCIpO1xuICAgIH0pLCBhLmZvckVhY2goKGwpID0+IHtcbiAgICAgIGguYWRkQ2xhc3MobCwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCBsLnNldEF0dHJpYnV0ZShqdCwgXCJcIik7XG4gICAgfSkpO1xuICB9XG4gIF9oYW5kbGVEaXNhYmxpbmdUaXBzTWluVGltZSh0LCBlLCBpLCBuKSB7XG4gICAgaWYgKCF0aGlzLl9vcHRpb25zLm1pblRpbWUgJiYgIXRoaXMuX29wdGlvbnMuZGlzYWJsZVBhc3QpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbyA9IGQuZmluZChcbiAgICAgIGBbJHtYfV1gXG4gICAgKSwgciA9IGQuZmluZChcbiAgICAgIGBbJHtodH1dYFxuICAgICksIGEgPSBkLmZpbmQoXG4gICAgICBgWyR7cX1dYFxuICAgICk7XG4gICAgIWUgfHwgZSA9PT0gdCA/IChYYShcbiAgICAgIG8sXG4gICAgICBuLFxuICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICApLCBYYShcbiAgICAgIHIsXG4gICAgICBuLFxuICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICApLCBkZyhcbiAgICAgIGEsXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2hvdXIudGV4dENvbnRlbnQsXG4gICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMlxuICAgICkpIDogZSA9PT0gXCJQTVwiICYmIHQgPT09IFwiQU1cIiAmJiAoby5mb3JFYWNoKChsKSA9PiB7XG4gICAgICBoLmFkZENsYXNzKGwsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgbC5zZXRBdHRyaWJ1dGUoanQsIFwiXCIpO1xuICAgIH0pLCBhLmZvckVhY2goKGwpID0+IHtcbiAgICAgIGguYWRkQ2xhc3MobCwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCBsLnNldEF0dHJpYnV0ZShqdCwgXCJcIik7XG4gICAgfSkpO1xuICB9XG4gIF9oYW5kbGVTd2l0Y2hUaW1lTW9kZSgpIHtcbiAgICBjLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBFcyxcbiAgICAgICh7IHRhcmdldDogdCB9KSA9PiB7XG4gICAgICAgIGxldCB7IG1heFRpbWU6IGUsIG1pblRpbWU6IGkgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgZGlzYWJsZVBhc3Q6IG4sIGRpc2FibGVGdXR1cmU6IG8sIGZvcm1hdDEyOiByIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgICBpID0gR3QoaSwgbiwgciksIGUgPSBxdChlLCBvLCByKTtcbiAgICAgICAgY29uc3QgW2EsIGwsIHBdID0gUihcbiAgICAgICAgICBlLFxuICAgICAgICAgICExXG4gICAgICAgICksIFt1LCBfLCBmXSA9IFIoXG4gICAgICAgICAgaSxcbiAgICAgICAgICAhMVxuICAgICAgICApLCBnID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtYfV1gXG4gICAgICAgICksIG0gPSBkLmZpbmQoXG4gICAgICAgICAgYFske3F9XWBcbiAgICAgICAgKTtcbiAgICAgICAgKCgpID0+IHtcbiAgICAgICAgICBnLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIGgucmVtb3ZlQ2xhc3ModiwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCB2LnJlbW92ZUF0dHJpYnV0ZShqdCk7XG4gICAgICAgICAgfSksIG0uZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAgICAgaC5yZW1vdmVDbGFzcyh2LCB0aGlzLl9jbGFzc2VzLnRpcHNEaXNhYmxlZCksIHYucmVtb3ZlQXR0cmlidXRlKGp0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKSwgdGhpcy5faGFuZGxlRGlzYWJsaW5nVGlwc01pblRpbWUoXG4gICAgICAgICAgdC50ZXh0Q29udGVudCxcbiAgICAgICAgICBmLFxuICAgICAgICAgIF8sXG4gICAgICAgICAgdVxuICAgICAgICApLCB0aGlzLl9oYW5kbGVEaXNhYmxpbmdUaXBzTWF4VGltZShcbiAgICAgICAgICB0LnRleHRDb250ZW50LFxuICAgICAgICAgIHAsXG4gICAgICAgICAgbCxcbiAgICAgICAgICBhXG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUFtUG0odC50ZXh0Q29udGVudCksIHQuaGFzQXR0cmlidXRlKEgpIHx8IChkLmZpbmQoXG4gICAgICAgICAgRXNcbiAgICAgICAgKS5mb3JFYWNoKChUKSA9PiB7XG4gICAgICAgICAgVC5oYXNBdHRyaWJ1dGUoSCkgJiYgKGgucmVtb3ZlQ2xhc3MoVCwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgVC5yZW1vdmVBdHRyaWJ1dGUoSCkpO1xuICAgICAgICB9KSwgaC5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0LnNldEF0dHJpYnV0ZShILCBcIlwiKSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlQ2xvY2tDbGljaygpIHtcbiAgICBsZXQgeyBtYXhUaW1lOiB0LCBtaW5UaW1lOiBlIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGNvbnN0IHsgZGlzYWJsZVBhc3Q6IGksIGRpc2FibGVGdXR1cmU6IG4sIGZvcm1hdDEyOiBvIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGUgPSBHdChlLCBpLCBvKSwgdCA9IHF0KHQsIG4sIG8pO1xuICAgIGNvbnN0IHIgPSBSKHQsICExKVsyXSwgYSA9IFIoZSwgITEpWzJdLCBsID0gUih0LCAhMSlbMF0sIHAgPSBSKGUsICExKVswXSwgdSA9IGQuZmluZE9uZShcbiAgICAgIGBbJHthbH1dYFxuICAgICk7XG4gICAgSy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgYCR7WmF9ICR7UWF9ICR7SmF9ICR7dGx9ICR7ZWx9ICR7bmx9ICR7aWx9ICR7c2x9YCxcbiAgICAgIFwiXCIsXG4gICAgICAoXykgPT4ge1xuICAgICAgICBicygpIHx8IF8ucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgeyB0eXBlOiBmLCB0YXJnZXQ6IGcgfSA9IF8sIHsgY2xvc2VNb2RhbE9uTWludXRlc0NsaWNrOiBtLCBzd2l0Y2hIb3Vyc1RvTWludXRlc09uQ2xpY2s6IGIgfSA9IHRoaXMuX29wdGlvbnMsIHYgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske3F9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSAhPT0gbnVsbCwgVCA9IGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApICE9PSBudWxsLCB5ID0gZC5maW5kT25lKFxuICAgICAgICAgIGBbJHtodH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApICE9PSBudWxsLCBDID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtxfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIEUgPSB6YShfLCB1KSwgdyA9IHUub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICBsZXQgayA9IE1hdGguYXRhbjIoRS55IC0gdywgRS54IC0gdyk7XG4gICAgICAgIGlmIChicygpKSB7XG4gICAgICAgICAgY29uc3QgTCA9IHphKF8sIHUsICEwKTtcbiAgICAgICAgICBrID0gTWF0aC5hdGFuMihMLnkgLSB3LCBMLnggLSB3KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgRCA9IG51bGwsIE8gPSBudWxsLCB4ID0gbnVsbDtcbiAgICAgICAgaWYgKGYgPT09IFwibW91c2Vkb3duXCIgfHwgZiA9PT0gXCJtb3VzZW1vdmVcIiB8fCBmID09PSBcInRvdWNobW92ZVwiIHx8IGYgPT09IFwidG91Y2hzdGFydFwiKVxuICAgICAgICAgIChmID09PSBcIm1vdXNlZG93blwiIHx8IGYgPT09IFwidG91Y2hzdGFydFwiIHx8IGYgPT09IFwidG91Y2htb3ZlXCIpICYmICh0aGlzLl9oYXNUYXJnZXRJbm5lckNsYXNzKGcpIHx8IGcuaGFzQXR0cmlidXRlKGFsKSB8fCBnLmhhc0F0dHJpYnV0ZSh1ZSkgfHwgZy5oYXNBdHRyaWJ1dGUocSkgfHwgZy5oYXNBdHRyaWJ1dGUoWCkgfHwgZy5oYXNBdHRyaWJ1dGUoX28pIHx8IGcuaGFzQXR0cmlidXRlKHBvKSB8fCBnLmhhc0F0dHJpYnV0ZShsbCkgfHwgZy5oYXNBdHRyaWJ1dGUoQXMpKSAmJiAodGhpcy5faXNNb3VzZU1vdmUgPSAhMCwgYnMoKSAmJiBfLnRvdWNoZXMgJiYgKEQgPSBfLnRvdWNoZXNbMF0uY2xpZW50WCwgTyA9IF8udG91Y2hlc1swXS5jbGllbnRZLCB4ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChELCBPKSkpO1xuICAgICAgICBlbHNlIGlmIChmID09PSBcIm1vdXNldXBcIiB8fCBmID09PSBcInRvdWNoZW5kXCIpIHtcbiAgICAgICAgICBpZiAodGhpcy5faXNNb3VzZU1vdmUgPSAhMSwgdGhpcy5faGFzVGFyZ2V0SW5uZXJDbGFzcyhnKSB8fCBnLmhhc0F0dHJpYnV0ZSh1ZSkgfHwgZy5oYXNBdHRyaWJ1dGUoWCkgfHwgZy5oYXNBdHRyaWJ1dGUoX28pIHx8IGcuaGFzQXR0cmlidXRlKHBvKSB8fCBnLmhhc0F0dHJpYnV0ZShsbCkgfHwgZy5oYXNBdHRyaWJ1dGUoQXMpKSB7XG4gICAgICAgICAgICBpZiAoKFQgfHwgeSkgJiYgYikge1xuICAgICAgICAgICAgICBjb25zdCBMID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpID4gbCB8fCBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPCBwO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5mb3JtYXQyNCAmJiBsICE9PSBcIlwiICYmIHAgIT09IFwiXCIgJiYgTClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZvcm1hdDI0ICYmIHAgIT09IFwiXCIgJiYgTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpIDwgcClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjLnRyaWdnZXIodGhpcy5fbWludXRlcywgXCJjbGlja1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHYgJiYgbSkge1xuICAgICAgICAgICAgY29uc3QgTCA9IGQuZmluZE9uZShcbiAgICAgICAgICAgICAgYFske3JvfV1gLFxuICAgICAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGMudHJpZ2dlcihMLCBcImNsaWNrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodikge1xuICAgICAgICAgIGxldCBMO1xuICAgICAgICAgIGNvbnN0IFMgPSBNYXRoLnRydW5jKGsgKiAxODAgLyBNYXRoLlBJKSArIDkwLCB7IGRlZ3JlZXM6IE4sIG1pbnV0ZTogUCB9ID0gdGhpcy5fbWFrZU1pbnV0ZXNEZWdyZWVzKFMsIEwpO1xuICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyTWF4TWluTWludXRlc09wdGlvbnMoTiwgUCkgPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjb25zdCB7IGRlZ3JlZXM6IG90LCBtaW51dGU6IHJ0IH0gPSB0aGlzLl9oYW5kbGVyTWF4TWluTWludXRlc09wdGlvbnMoTiwgUCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBpZiAoaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHtvdH1kZWcpYFxuICAgICAgICAgICAgfSksIHJ0ID09PSB2b2lkIDApXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IEcgPSAoKSA9PiBydCA+PSAxMCB8fCBydCA9PT0gXCIwMFwiID8gcnQgOiBgMCR7cnR9YDtcbiAgICAgICAgICAgIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSBHKCksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKFxuICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXNBcnJheSxcbiAgICAgICAgICAgICAgdGhpcy5fbWludXRlcyxcbiAgICAgICAgICAgICAgQ1xuICAgICAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQmFja2dyb3VuZENvbG9yQ2lyY2xlKFxuICAgICAgICAgICAgICBgWyR7cX1dYFxuICAgICAgICAgICAgKSwgdGhpcy5fb2JqV2l0aERhdGFPbkNoYW5nZS5kZWdyZWVzTWludXRlcyA9IG90LCB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlLm1pbnV0ZXMgPSBydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFQgfHwgeSkge1xuICAgICAgICAgIGxldCBMLCBTID0gTWF0aC50cnVuYyhrICogMTgwIC8gTWF0aC5QSSkgKyA5MDtcbiAgICAgICAgICBpZiAoUyA9IE1hdGgucm91bmQoUyAvIDMwKSAqIDMwLCBoLmFkZFN0eWxlKHRoaXMuX2NpcmNsZSwge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMxOTc2ZDJcIlxuICAgICAgICAgIH0pLCB0aGlzLl9tYWtlSG91ckRlZ3JlZXMoZywgUywgTCkgPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjb25zdCBOID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGJzKCkgJiYgUyAmJiB4KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgZGVncmVlczogUCwgaG91cjogb3QgfSA9IHRoaXMuX21ha2VIb3VyRGVncmVlcyh4LCBTLCBMKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZU1vdmVIYW5kKFxuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgb3QsXG4gICAgICAgICAgICAgICAgUFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBkZWdyZWVzOiBQLCBob3VyOiBvdCB9ID0gdGhpcy5fbWFrZUhvdXJEZWdyZWVzKGcsIFMsIEwpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlTW92ZUhhbmQoZywgb3QsIFApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fb2JqV2l0aERhdGFPbkNoYW5nZS5kZWdyZWVzSG91cnMgPSBTLCB0aGlzLl9oYW5kbGVyTWF4TWluSG91cnNPcHRpb25zKFxuICAgICAgICAgICAgUyxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBfXG4gICAgICAgICAgKSAmJiBOKCk7XG4gICAgICAgIH1cbiAgICAgICAgXy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYXNUYXJnZXRJbm5lckNsYXNzKHQpIHtcbiAgICByZXR1cm4gdC5oYXNBdHRyaWJ1dGUobWkpIHx8IHQuaGFzQXR0cmlidXRlKGh0KSB8fCB0Lmhhc0F0dHJpYnV0ZSh5cyk7XG4gIH1cbiAgX2hhbmRsZU1vdmVIYW5kKHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gZC5maW5kKFxuICAgICAgYFske1h9XWAsXG4gICAgICB0aGlzLl9tb2RhbFxuICAgICksIG8gPSBkLmZpbmQoXG4gICAgICBgWyR7aHR9XWAsXG4gICAgICB0aGlzLl9tb2RhbFxuICAgICk7XG4gICAgdGhpcy5faXNNb3VzZU1vdmUgJiYgKHRoaXMuX2hhc1RhcmdldElubmVyQ2xhc3ModCkgPyBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgfSkgOiBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgIGhlaWdodDogXCJjYWxjKDQwJSArIDFweClcIlxuICAgIH0pLCBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHtpfWRlZylgXG4gICAgfSksIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSBlID49IDEwIHx8IGUgPT09IFwiMDBcIiA/IGUgOiBgMCR7ZX1gLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmhvdXJzQXJyYXksIHRoaXMuX2hvdXIsIG4pLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmlubmVySG91cnMsIHRoaXMuX2hvdXIsIG8pLCB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlLmhvdXIgPSBlID49IDEwIHx8IGUgPT09IFwiMDBcIiA/IGUgOiBgMCR7ZX1gKTtcbiAgfVxuICBfaGFuZGxlck1heE1pbk1pbnV0ZXNPcHRpb25zKHQsIGUpIHtcbiAgICBsZXQgeyBtYXhUaW1lOiBpLCBtaW5UaW1lOiBuIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGNvbnN0IHsgZm9ybWF0MTI6IG8sIGluY3JlbWVudDogciwgZGlzYWJsZVBhc3Q6IGEsIGRpc2FibGVGdXR1cmU6IGwgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgbiA9IEd0KG4sIGEsIG8pLCBpID0gcXQoaSwgbCwgbyk7XG4gICAgY29uc3QgcCA9IFIoaSwgITEpWzFdLCB1ID0gUihuLCAhMSlbMV0sIF8gPSBSKGksICExKVswXSwgZiA9IFIobiwgITEpWzBdLCBnID0gZiA9PT0gXCIxMlwiICYmIG8gPyBcIjBcIiA6IGYsIG0gPSBfID09PSBcIjEyXCIgJiYgbyA/IFwiMFwiIDogXywgYiA9IFIoaSwgITEpWzJdLCB2ID0gUihuLCAhMSlbMl0sIFQgPSBwICE9PSBcIlwiID8gcCAqIDYgOiBcIlwiLCB5ID0gdSAhPT0gXCJcIiA/IHUgKiA2IDogXCJcIiwgQyA9IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSwgRSA9IEMgPT09IDEyICYmIG8gPyAwIDogQztcbiAgICBpZiAoIWIgJiYgIXYpIHtcbiAgICAgIGlmIChpICE9PSBcIlwiICYmIG4gIT09IFwiXCIpIHtcbiAgICAgICAgaWYgKE51bWJlcihtKSA9PT0gRSAmJiB0ID4gVCB8fCBOdW1iZXIoZykgPT09IEUgJiYgdCA8IHkpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9IGVsc2UgaWYgKG4gIT09IFwiXCIgJiYgRSA8PSBOdW1iZXIoZykpIHtcbiAgICAgICAgaWYgKHQgPD0geSAtIDYpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9IGVsc2UgaWYgKGkgIT09IFwiXCIgJiYgRSA+PSBOdW1iZXIobSkgJiYgdCA+PSBUICsgNilcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuICE9PSBcIlwiKSB7XG4gICAgICAgIGlmICh2ID09PSBcIlBNXCIgJiYgdGhpcy5faXNBbUVuYWJsZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodiA9PT0gXCJQTVwiICYmIHRoaXMuX2lzUG1FbmFibGVkKSB7XG4gICAgICAgICAgaWYgKEUgPCBOdW1iZXIoZykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaWYgKEUgPD0gTnVtYmVyKGcpICYmIHQgPD0geSAtIDYpXG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSBlbHNlIGlmICh2ID09PSBcIkFNXCIgJiYgdGhpcy5faXNBbUVuYWJsZWQpIHtcbiAgICAgICAgICBpZiAoRSA8IE51bWJlcihnKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAoRSA8PSBOdW1iZXIoZykgJiYgdCA8PSB5IC0gNilcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSAhPT0gXCJcIikge1xuICAgICAgICBpZiAoYiA9PT0gXCJBTVwiICYmIHRoaXMuX2lzUG1FbmFibGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGIgPT09IFwiUE1cIiAmJiB0aGlzLl9pc1BtRW5hYmxlZCkge1xuICAgICAgICAgIGlmIChFID49IE51bWJlcihtKSAmJiB0ID49IFQgKyA2KVxuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gXCJBTVwiICYmIHRoaXMuX2lzQW1FbmFibGVkICYmIEUgPj0gTnVtYmVyKG0pICYmIHQgPj0gVCArIDYpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByICYmICh0ID0gTWF0aC5yb3VuZCh0IC8gMzApICogMzApLCB0IDwgMCA/IHQgPSAzNjAgKyB0IDogdCA+PSAzNjAgJiYgKHQgPSAwKSwge1xuICAgICAgZGVncmVlczogdCxcbiAgICAgIG1pbnV0ZTogZVxuICAgIH07XG4gIH1cbiAgX3JlbW92ZU1vZGFsKCkge1xuICAgIHRoaXMuX2FuaW1hdGlvbnMgPyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3JlbW92ZU1vZGFsRWxlbWVudHMoKSwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XG4gICAgfSwgMzAwKSA6ICh0aGlzLl9yZW1vdmVNb2RhbEVsZW1lbnRzKCksIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpKSwgSy5vZmYoXG4gICAgICB0aGlzLl9kb2N1bWVudCxcbiAgICAgIGAke3FhfSAke3ZzfSAke1phfSAke1FhfSAke0phfSAke3RsfSAke2VsfSAke25sfSAke2lsfSAke3NsfWBcbiAgICApLCBjLm9mZih3aW5kb3csIHZzKTtcbiAgfVxuICBfcmVtb3ZlTW9kYWxFbGVtZW50cygpIHtcbiAgICB0aGlzLl9tb2RhbCAmJiB0aGlzLl9tb2RhbC5yZW1vdmUoKTtcbiAgfVxuICBfdG9nZ2xlQmFja2Ryb3BBbmltYXRpb24odCA9ICExKSB7XG4gICAgdCA/IHRoaXMuX3dyYXBwZXIuY2xhc3NMaXN0LmFkZChcImFuaW1hdGUtW2ZhZGUtb3V0XzM1MG1zX2Vhc2UtaW4tb3V0XVwiKSA6ICh0aGlzLl93cmFwcGVyLmNsYXNzTGlzdC5hZGQoXCJhbmltYXRlLVtmYWRlLWluXzM1MG1zX2Vhc2UtaW4tb3V0XVwiKSwgdGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgaC5hZGRDbGFzcyh0aGlzLl9jbG9jaywgdGhpcy5fY2xhc3Nlcy5jbG9ja0FuaW1hdGlvbikpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3dyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgXCJhbmltYXRlLVtmYWRlLW91dF8zNTBtc19lYXNlLWluLW91dF1cIixcbiAgICAgICAgXCJhbmltYXRlLVtmYWRlLWluXzM1MG1zX2Vhc2UtaW4tb3V0XVwiXG4gICAgICApO1xuICAgIH0sIDM1MSk7XG4gIH1cbiAgX2FkZEFjdGl2ZUNsYXNzVG9UaXAodCwgZSkge1xuICAgIHQuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgTnVtYmVyKGkudGV4dENvbnRlbnQpID09PSBOdW1iZXIoZSkgJiYgKGguYWRkQ2xhc3MoaSwgdGhpcy5fY2xhc3Nlcy50aXBzQWN0aXZlKSwgaS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpO1xuICAgIH0pO1xuICB9XG4gIF9zZXRIb3VyT3JNaW51dGUodCkge1xuICAgIHJldHVybiB0IDwgMTAgPyBgMCR7dH1gIDogdDtcbiAgfVxuICBfYXBwZW5kVGltZXMoKSB7XG4gICAgY29uc3QgeyBmb3JtYXQyNDogdCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBpZiAodCkge1xuICAgICAgdGhpcy5fZ2V0QXBwZW5kQ2xvY2soXG4gICAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgICAgYFske3VlfV1gLFxuICAgICAgICBYXG4gICAgICApLCB0aGlzLl9nZXRBcHBlbmRDbG9jayhcbiAgICAgICAgdGhpcy5pbm5lckhvdXJzLFxuICAgICAgICBgWyR7bWl9XWAsXG4gICAgICAgIGh0XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRBcHBlbmRDbG9jayhcbiAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgIGBbJHt1ZX1dYCxcbiAgICAgIFhcbiAgICApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ud2csXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoQmksIHQsIGtnKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnhnLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKEJpLCB0LCBPZyksIHQ7XG4gIH1cbiAgX2dldENvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKHRoaXMuX29wdGlvbnMuY29udGFpbmVyKTtcbiAgfVxuICBfZ2V0VmFsaWRhdGUodCkge1xuICAgIGNvbnN0IHsgZm9ybWF0MjQ6IGUsIGZvcm1hdDEyOiBpLCBhcHBlbmRWYWxpZGF0aW9uSW5mbzogbiB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBLLm9uKHRoaXMuaW5wdXQsIHQsICh7IHRhcmdldDogbyB9KSA9PiB7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucyA9PT0gbnVsbCB8fCB0aGlzLmlucHV0LnZhbHVlID09PSBcIlwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByID0gL14oMD9bMS05XXwxWzAxMl0pKDpbMC01XVxcZCkgW0FQYXBdW21NXSQvLCBhID0gL14oWzAxXVxcZHwyWzAtM10pKDpbMC01XVxcZCkkLywgbCA9IHIudGVzdChvLnZhbHVlKTtcbiAgICAgIGlmIChhLnRlc3Qoby52YWx1ZSkgIT09ICEwICYmIGUgfHwgbCAhPT0gITAgJiYgaSkge1xuICAgICAgICBuICYmIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKGNvLCBcIlwiKSwgaC5hZGRTdHlsZShvLCB7IG1hcmdpbkJvdHRvbTogMCB9KSwgdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICEwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShjbyksIHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgPSAhMTtcbiAgICAgIGNvbnN0IHUgPSBkLmZpbmRPbmUoXG4gICAgICAgIGBbJHtDZ31dYFxuICAgICAgKTtcbiAgICAgIHUgIT09IG51bGwgJiYgdS5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIEpzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBJZyA9IHtcbiAgdGhyZXNob2xkOiAxMCxcbiAgZGlyZWN0aW9uOiBcImFsbFwiXG59O1xubGV0IERnID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsLCB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgLi4uSWcsXG4gICAgICAuLi5lXG4gICAgfTtcbiAgfVxuICBoYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICB0aGlzLl9zdGFydFBvc2l0aW9uID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZXModCk7XG4gIH1cbiAgaGFuZGxlVG91Y2hNb3ZlKHQpIHtcbiAgICBpZiAoIXRoaXMuX3N0YXJ0UG9zaXRpb24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldENvb3JkaW5hdGVzKHQpLCBpID0ge1xuICAgICAgeDogZS54IC0gdGhpcy5fc3RhcnRQb3NpdGlvbi54LFxuICAgICAgeTogZS55IC0gdGhpcy5fc3RhcnRQb3NpdGlvbi55XG4gICAgfSwgbiA9IHRoaXMuX2dldERpcmVjdGlvbihpKTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gPT09IFwiYWxsXCIpIHtcbiAgICAgIGlmIChuLnkudmFsdWUgPCB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAmJiBuLngudmFsdWUgPCB0aGlzLl9vcHRpb25zLnRocmVzaG9sZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgciA9IG4ueS52YWx1ZSA+IG4ueC52YWx1ZSA/IG4ueS5kaXJlY3Rpb24gOiBuLnguZGlyZWN0aW9uO1xuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGBzd2lwZSR7cn1gKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwic3dpcGVcIiwgeyBkaXJlY3Rpb246IHIgfSksIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvID0gdGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gPT09IFwibGVmdFwiIHx8IHRoaXMuX29wdGlvbnMgPT09IFwicmlnaHRcIiA/IFwieFwiIDogXCJ5XCI7XG4gICAgbltvXS5kaXJlY3Rpb24gPT09IHRoaXMuX29wdGlvbnMuZGlyZWN0aW9uICYmIG5bb10udmFsdWUgPiB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAmJiAoYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGBzd2lwZSR7bltvXS5kaXJlY3Rpb259YCksIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsKTtcbiAgfVxuICBoYW5kbGVUb3VjaEVuZCgpIHtcbiAgICB0aGlzLl9zdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgfVxuICBfZ2V0Q29vcmRpbmF0ZXModCkge1xuICAgIGNvbnN0IFtlXSA9IHQudG91Y2hlcztcbiAgICByZXR1cm4ge1xuICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgeTogZS5jbGllbnRZXG4gICAgfTtcbiAgfVxuICBfZ2V0RGlyZWN0aW9uKHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDoge1xuICAgICAgICBkaXJlY3Rpb246IHQueCA8IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICAgICAgdmFsdWU6IE1hdGguYWJzKHQueClcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIGRpcmVjdGlvbjogdC55IDwgMCA/IFwidXBcIiA6IFwiZG93blwiLFxuICAgICAgICB2YWx1ZTogTWF0aC5hYnModC55KVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0sICRnID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0gXCJzd2lwZVwiLCBpID0ge30pIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fZXZlbnQgPSBlLCB0aGlzLnN3aXBlID0gbmV3IERnKHQsIGkpLCB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlciA9IHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQuYmluZCh0aGlzKSwgdGhpcy5fdG91Y2hNb3ZlSGFuZGxlciA9IHRoaXMuX2hhbmRsZVRvdWNoTW92ZS5iaW5kKHRoaXMpLCB0aGlzLl90b3VjaEVuZEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVUb3VjaEVuZC5iaW5kKHRoaXMpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlciksIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl90b3VjaE1vdmVIYW5kbGVyKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl90b3VjaEVuZEhhbmRsZXIpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlVG91Y2hTdGFydCh0KVxuICAgICksIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2htb3ZlXCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlVG91Y2hNb3ZlKHQpXG4gICAgKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCAodCkgPT4gdGhpcy5faGFuZGxlVG91Y2hFbmQodCkpO1xuICB9XG4gIF9oYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICB0aGlzW3RoaXMuX2V2ZW50XS5oYW5kbGVUb3VjaFN0YXJ0KHQpO1xuICB9XG4gIF9oYW5kbGVUb3VjaE1vdmUodCkge1xuICAgIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoTW92ZSh0KTtcbiAgfVxuICBfaGFuZGxlVG91Y2hFbmQodCkge1xuICAgIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoRW5kKHQpO1xuICB9XG59O1xuY29uc3QgaGwgPSBcInNpZGVuYXZcIiwgd3MgPSBcInRlLnNpZGVuYXZcIiwgTGcgPSBcImRhdGEtdGUtc2lkZW5hdi1yb3RhdGUtaWNvbi1yZWZcIiwgZm8gPSBcIltkYXRhLXRlLXNpZGVuYXYtdG9nZ2xlLXJlZl1cIiwgTmcgPSBcIltkYXRhLXRlLWNvbGxhcHNlLWluaXRdXCIsIE1nID0gJ1tkYXRhLXRlLXNpZGVuYXYtc2xpbT1cInRydWVcIl0nLCBSZyA9ICdbZGF0YS10ZS1zaWRlbmF2LXNsaW09XCJmYWxzZVwiXScsIFBnID0gXCJbZGF0YS10ZS1zaWRlbmF2LW1lbnUtcmVmXVwiLCBMZSA9IFwiW2RhdGEtdGUtc2lkZW5hdi1jb2xsYXBzZS1yZWZdXCIsIGdpID0gXCJbZGF0YS10ZS1zaWRlbmF2LWxpbmstcmVmXVwiLCBCZyA9IFcoKSA/IDEwMCA6IC0xMDAsIEhnID0gVygpID8gLTEwMCA6IDEwMCwgVmcgPSB7XG4gIHNpZGVuYXZBY2NvcmRpb246IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZCYWNrZHJvcDogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkJhY2tkcm9wQ2xhc3M6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBzaWRlbmF2Q2xvc2VPbkVzYzogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkNvbG9yOiBcIihzdHJpbmcpXCIsXG4gIHNpZGVuYXZDb250ZW50OiBcIihudWxsfHN0cmluZylcIixcbiAgc2lkZW5hdkV4cGFuZGFibGU6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZFeHBhbmRPbkhvdmVyOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2Rm9jdXNUcmFwOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2SGlkZGVuOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2TW9kZTogXCIoc3RyaW5nKVwiLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyOiBcIihudWxsfHN0cmluZ3xudW1iZXIpXCIsXG4gIHNpZGVuYXZNb2RlQnJlYWtwb2ludFNpZGU6IFwiKG51bGx8c3RyaW5nfG51bWJlcilcIixcbiAgc2lkZW5hdk1vZGVCcmVha3BvaW50UHVzaDogXCIobnVsbHxzdHJpbmd8bnVtYmVyKVwiLFxuICBzaWRlbmF2QnJlYWtwb2ludFNtOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZCcmVha3BvaW50TWQ6IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdkJyZWFrcG9pbnRMZzogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2QnJlYWtwb2ludFhsOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZCcmVha3BvaW50MnhsOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZTY3JvbGxDb250YWluZXI6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBzaWRlbmF2U2xpbTogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdlNsaW1Db2xsYXBzZWQ6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZTbGltV2lkdGg6IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdlBvc2l0aW9uOiBcIihzdHJpbmcpXCIsXG4gIHNpZGVuYXZSaWdodDogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdlRyYW5zaXRpb25EdXJhdGlvbjogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2V2lkdGg6IFwiKG51bWJlcilcIlxufSwgV2cgPSB7XG4gIHNpZGVuYXZBY2NvcmRpb246ICExLFxuICBzaWRlbmF2QmFja2Ryb3A6ICEwLFxuICBzaWRlbmF2QmFja2Ryb3BDbGFzczogbnVsbCxcbiAgc2lkZW5hdkNsb3NlT25Fc2M6ICEwLFxuICBzaWRlbmF2Q29sb3I6IFwicHJpbWFyeVwiLFxuICBzaWRlbmF2Q29udGVudDogbnVsbCxcbiAgc2lkZW5hdkV4cGFuZGFibGU6ICEwLFxuICBzaWRlbmF2RXhwYW5kT25Ib3ZlcjogITEsXG4gIHNpZGVuYXZGb2N1c1RyYXA6ICEwLFxuICBzaWRlbmF2SGlkZGVuOiAhMCxcbiAgc2lkZW5hdk1vZGU6IFwib3ZlclwiLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyOiBudWxsLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRTaWRlOiBudWxsLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRQdXNoOiBudWxsLFxuICBzaWRlbmF2QnJlYWtwb2ludFNtOiA2NDAsXG4gIHNpZGVuYXZCcmVha3BvaW50TWQ6IDc2OCxcbiAgc2lkZW5hdkJyZWFrcG9pbnRMZzogMTAyNCxcbiAgc2lkZW5hdkJyZWFrcG9pbnRYbDogMTI4MCxcbiAgc2lkZW5hdkJyZWFrcG9pbnQyeGw6IDE1MzYsXG4gIHNpZGVuYXZTY3JvbGxDb250YWluZXI6IG51bGwsXG4gIHNpZGVuYXZTbGltOiAhMSxcbiAgc2lkZW5hdlNsaW1Db2xsYXBzZWQ6ICExLFxuICBzaWRlbmF2U2xpbVdpZHRoOiA3NyxcbiAgc2lkZW5hdlBvc2l0aW9uOiBcImZpeGVkXCIsXG4gIHNpZGVuYXZSaWdodDogITEsXG4gIHNpZGVuYXZUcmFuc2l0aW9uRHVyYXRpb246IDMwMCxcbiAgc2lkZW5hdldpZHRoOiAyNDBcbn07XG5jbGFzcyBDaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSkge1xuICAgIHd0KHRoaXMsIFwiX2FkZEJhY2tkcm9wT25Jbml0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuX29wdGlvbnMuc2lkZW5hdkhpZGRlbiB8fCAodGhpcy5fYmFja2Ryb3Auc2hvdygpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBcInRyYW5zaXRpb25lbmRcIiwgdGhpcy5fYWRkQmFja2Ryb3BPbkluaXQpKTtcbiAgICB9KTtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IGUsIHRoaXMuX0lEID0gZXQoXCJcIiksIHRoaXMuX2NvbnRlbnQgPSBudWxsLCB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlID0gbnVsbCwgdGhpcy5fc2xpbUNvbGxhcHNlZCA9ICExLCB0aGlzLl9hY3RpdmVOb2RlID0gbnVsbCwgdGhpcy5fdGVtcFNsaW0gPSAhMSwgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKSwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCwgdGhpcy5fcGVyZmVjdFNjcm9sbGJhciA9IG51bGwsIHRoaXMuX3RvdWNoID0gbnVsbCwgdGhpcy5fc2V0TW9kZUZyb21CcmVha3BvaW50cygpLCB0aGlzLmVzY0hhbmRsZXIgPSAoaSkgPT4ge1xuICAgICAgaS5rZXlDb2RlID09PSB3ZSAmJiB0aGlzLnRvZ2dsZXIgJiYgTXQodGhpcy50b2dnbGVyKSAmJiAodGhpcy5fdXBkYXRlKCExKSwgYy5vZmYod2luZG93LCBcImtleWRvd25cIiwgdGhpcy5lc2NIYW5kbGVyKSk7XG4gICAgfSwgdGhpcy5oYXNoSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRzKCk7XG4gICAgfSwgdCAmJiAoQS5zZXREYXRhKHQsIHdzLCB0aGlzKSwgdGhpcy5fc2V0dXAoKSksIHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AgJiYgIXRoaXMub3B0aW9ucy5zaWRlbmF2SGlkZGVuICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgYy5vbih0aGlzLl9lbGVtZW50LCBcInRyYW5zaXRpb25lbmRcIiwgdGhpcy5fYWRkQmFja2Ryb3BPbkluaXQpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gaGw7XG4gIH1cbiAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbiA9PT0gXCJmaXhlZFwiKVxuICAgICAgcmV0dXJuIGQuZmluZE9uZShcImJvZHlcIik7XG4gICAgY29uc3QgdCA9IChlKSA9PiAhZS5wYXJlbnROb2RlIHx8IGUucGFyZW50Tm9kZSA9PT0gZG9jdW1lbnQgPyBlIDogZS5wYXJlbnROb2RlLnN0eWxlLnBvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgfHwgZS5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucyhcInJlbGF0aXZlXCIpID8gZS5wYXJlbnROb2RlIDogdChlLnBhcmVudE5vZGUpO1xuICAgIHJldHVybiB0KHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgbGV0IHQgPSAwLCBlID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWRlbmF2UG9zaXRpb24gIT09IFwiZml4ZWRcIikge1xuICAgICAgY29uc3QgbiA9IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdCA9IG4ueCwgZSA9IG4ueCArIG4ud2lkdGg7XG4gICAgfVxuICAgIGNvbnN0IHsgeDogaSB9ID0gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodCAmJiAhVygpIHx8ICF0aGlzLm9wdGlvbnMuc2lkZW5hdlJpZ2h0ICYmIFcoKSkge1xuICAgICAgbGV0IG4gPSAwO1xuICAgICAgaWYgKHRoaXMuY29udGFpbmVyLnNjcm9sbEhlaWdodCA+IHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodCAmJiAobiA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoIC0gdGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgpLCB0aGlzLmNvbnRhaW5lci50YWdOYW1lID09PSBcIkJPRFlcIikge1xuICAgICAgICBjb25zdCBvID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICBuID0gTWF0aC5hYnMod2luZG93LmlubmVyV2lkdGggLSBvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLmFicyhpICsgbiAtIGUpID4gMTA7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmFicyhpIC0gdCkgPCAxMDtcbiAgfVxuICBnZXQgbGlua3MoKSB7XG4gICAgcmV0dXJuIGQuZmluZChnaSwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IG5hdmlnYXRpb24oKSB7XG4gICAgcmV0dXJuIGQuZmluZChQZywgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLldnLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRoaXMuX29wdGlvbnNcbiAgICB9O1xuICAgIHJldHVybiBJKGhsLCB0LCBWZyksIHQ7XG4gIH1cbiAgZ2V0IHNpZGVuYXZTdHlsZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IGAke3RoaXMud2lkdGh9cHhgLFxuICAgICAgaGVpZ2h0OiB0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBcIjEwMHZoXCIgOiBcIjEwMCVcIixcbiAgICAgIHBvc2l0aW9uOiB0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uLFxuICAgICAgdHJhbnNpdGlvbjogYGFsbCAke3RoaXMudHJhbnNpdGlvbkR1cmF0aW9ufSBsaW5lYXJgXG4gICAgfTtcbiAgfVxuICBnZXQgdG9nZ2xlcigpIHtcbiAgICByZXR1cm4gZC5maW5kKGZvKS5maW5kKFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgY29uc3QgaSA9IGguZ2V0RGF0YUF0dHJpYnV0ZShlLCBcInRhcmdldFwiKTtcbiAgICAgICAgcmV0dXJuIGQuZmluZE9uZShpKSA9PT0gdGhpcy5fZWxlbWVudDtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGdldCB0cmFuc2l0aW9uRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5zaWRlbmF2VHJhbnNpdGlvbkR1cmF0aW9uIC8gMWUzfXNgO1xuICB9XG4gIGdldCB0cmFuc2xhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodCA/IEhnIDogQmc7XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9zbGltQ29sbGFwc2VkID8gdGhpcy5vcHRpb25zLnNpZGVuYXZTbGltV2lkdGggOiB0aGlzLm9wdGlvbnMuc2lkZW5hdldpZHRoO1xuICB9XG4gIGdldCBpc0JhY2tkcm9wVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9iYWNrZHJvcC5fZWxlbWVudDtcbiAgfVxuICAvLyBQdWJsaWNcbiAgY2hhbmdlTW9kZSh0KSB7XG4gICAgdGhpcy5fc2V0TW9kZSh0KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGMub2ZmKHdpbmRvdywgXCJrZXlkb3duXCIsIHRoaXMuZXNjSGFuZGxlciksIHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AgJiYgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpLCBjLm9mZih3aW5kb3csIFwiaGFzaGNoYW5nZVwiLCB0aGlzLmhhc2hIYW5kbGVyKSwgdGhpcy5fdG91Y2guZGlzcG9zZSgpLCBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgd3MpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuX2VtaXRFdmVudHMoITEpLCB0aGlzLl91cGRhdGUoITEpLCB0aGlzLl9vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCAmJiB0aGlzLmlzQmFja2Ryb3BWaXNpYmxlICYmIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcbiAgfVxuICBzaG93KCkge1xuICAgIHRoaXMuX2VtaXRFdmVudHMoITApLCB0aGlzLl91cGRhdGUoITApLCB0aGlzLl9vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCAmJiB0aGlzLl9vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9iYWNrZHJvcC5zaG93KCk7XG4gIH1cbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuX2VtaXRFdmVudHMoIXRoaXMuaXNWaXNpYmxlKSwgdGhpcy5fdXBkYXRlKCF0aGlzLmlzVmlzaWJsZSk7XG4gIH1cbiAgdG9nZ2xlU2xpbSgpIHtcbiAgICB0aGlzLl9zZXRTbGltKCF0aGlzLl9zbGltQ29sbGFwc2VkKTtcbiAgfVxuICB1cGRhdGUodCkge1xuICAgIHRoaXMuX29wdGlvbnMgPSB0LCB0aGlzLl9zZXR1cCgpO1xuICB9XG4gIGdldEJyZWFrcG9pbnQodCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1CcmVha3BvaW50VmFsdWVzVG9PYmplY3QoKVt0XTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKGMub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIGZvLFxuICAgICAgQ2kudG9nZ2xlU2lkZW5hdigpXG4gICAgKSwgdGhpcy5fZGlkSW5pdCA9ICEwKTtcbiAgfVxuICBfdHJhbnNmb3JtQnJlYWtwb2ludFZhbHVlc1RvT2JqZWN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBzbTogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50U20sXG4gICAgICBtZDogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50TWQsXG4gICAgICBsZzogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50TGcsXG4gICAgICB4bDogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50WGwsXG4gICAgICBcIjJ4bFwiOiB0aGlzLm9wdGlvbnMuc2lkZW5hdkJyZWFrcG9pbnQyeGxcbiAgICB9O1xuICB9XG4gIF9zZXRNb2RlRnJvbUJyZWFrcG9pbnRzKCkge1xuICAgIGNvbnN0IHQgPSB3aW5kb3cuaW5uZXJXaWR0aCwgZSA9IHRoaXMuX3RyYW5zZm9ybUJyZWFrcG9pbnRWYWx1ZXNUb09iamVjdCgpO1xuICAgIGlmICh0ID09PSB2b2lkIDAgfHwgIWUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50T3ZlciA9PSBcIm51bWJlclwiID8gdCAtIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyIDogdCAtIGVbdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludE92ZXJdLCBuID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRTaWRlID09IFwibnVtYmVyXCIgPyB0IC0gdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFNpZGUgOiB0IC0gZVt0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50U2lkZV0sIG8gPSB0eXBlb2YgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFB1c2ggPT0gXCJudW1iZXJcIiA/IHQgLSB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50UHVzaCA6IHQgLSBlW3RoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRQdXNoXSwgciA9IChsLCBwKSA9PiBsIC0gcCA8IDAgPyAtMSA6IHAgLSBsIDwgMCA/IDEgOiAwLCBhID0gW2ksIG4sIG9dLmZpbHRlcigobCkgPT4gbCAhPSBudWxsICYmIGwgPj0gMCkuc29ydChyKVswXTtcbiAgICBpID4gMCAmJiBpID09PSBhID8gKHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPSBcIm92ZXJcIiwgdGhpcy5fb3B0aW9ucy5zaWRlbmF2SGlkZGVuID0gITApIDogbiA+IDAgJiYgbiA9PT0gYSA/IHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPSBcInNpZGVcIiA6IG8gPiAwICYmIG8gPT09IGEgJiYgKHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPSBcInB1c2hcIik7XG4gIH1cbiAgX2NvbGxhcHNlSXRlbXMoKSB7XG4gICAgdGhpcy5uYXZpZ2F0aW9uLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGQuZmluZChMZSwgdCkuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICBRdC5nZXRJbnN0YW5jZShpKS5oaWRlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfZ2V0T2Zmc2V0VmFsdWUodCwgeyBpbmRleDogZSwgcHJvcGVydHk6IGksIG9mZnNldHM6IG4gfSkge1xuICAgIGNvbnN0IG8gPSB0aGlzLl9nZXRQeFZhbHVlKFxuICAgICAgdGhpcy5faW5pdGlhbENvbnRlbnRTdHlsZVtlXVtuW2ldLnByb3BlcnR5XVxuICAgICksIHIgPSB0ID8gbltpXS52YWx1ZSA6IDA7XG4gICAgcmV0dXJuIG8gKyByO1xuICB9XG4gIF9nZXRQcm9wZXJ0eSguLi50KSB7XG4gICAgcmV0dXJuIHQubWFwKChlLCBpKSA9PiBpID09PSAwID8gZSA6IGVbMF0udG9VcHBlckNhc2UoKS5jb25jYXQoZS5zbGljZSgxKSkpLmpvaW4oXCJcIik7XG4gIH1cbiAgX2dldFB4VmFsdWUodCkge1xuICAgIHJldHVybiB0ID8gcGFyc2VGbG9hdCh0KSA6IDA7XG4gIH1cbiAgX2hhbmRsZVN3aXBlKHQsIGUpIHtcbiAgICBlICYmIHRoaXMuX3NsaW1Db2xsYXBzZWQgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZTbGltICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2RXhwYW5kYWJsZSA/IHRoaXMudG9nZ2xlU2xpbSgpIDogZSB8fCAodGhpcy5fc2xpbUNvbGxhcHNlZCB8fCAhdGhpcy5vcHRpb25zLnNpZGVuYXZTbGltIHx8ICF0aGlzLm9wdGlvbnMuc2lkZW5hdkV4cGFuZGFibGUgPyB0aGlzLnRvZ2dsZXIgJiYgTXQodGhpcy50b2dnbGVyKSAmJiB0aGlzLnRvZ2dsZSgpIDogdGhpcy50b2dnbGVTbGltKCkpO1xuICB9XG4gIF9pc0FjdGl2ZSh0LCBlKSB7XG4gICAgcmV0dXJuIGUgPyBlID09PSB0IDogdC5hdHRyaWJ1dGVzLmhyZWYgPyBuZXcgVVJMKHQsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5ocmVmID09PSB3aW5kb3cubG9jYXRpb24uaHJlZiA6ICExO1xuICB9XG4gIF9pc0FsbFRvQmVDb2xsYXBzZWQoKSB7XG4gICAgcmV0dXJuIGQuZmluZChcbiAgICAgIE5nLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkuZmlsdGVyKFxuICAgICAgKGkpID0+IGkuZ2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiKSA9PT0gXCJ0cnVlXCJcbiAgICApLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBfaXNBbGxDb2xsYXBzZWQoKSB7XG4gICAgcmV0dXJuIGQuZmluZChMZSwgdGhpcy5fZWxlbWVudCkuZmlsdGVyKFxuICAgICAgKHQpID0+IE10KHQpXG4gICAgKS5sZW5ndGggPT09IDA7XG4gIH1cbiAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3ApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3BDbGFzcyA/IHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3BDbGFzcy5zcGxpdChcIiBcIikgOiB0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uID8gW1xuICAgICAgXCJvcGFjaXR5LTUwXCIsXG4gICAgICBcInRyYW5zaXRpb24tYWxsXCIsXG4gICAgICBcImR1cmF0aW9uLTMwMFwiLFxuICAgICAgXCJlYXNlLWluLW91dFwiLFxuICAgICAgdGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbixcbiAgICAgIFwidG9wLTBcIixcbiAgICAgIFwibGVmdC0wXCIsXG4gICAgICBcInotNTBcIixcbiAgICAgIFwiYmctYmxhY2svMTBcIixcbiAgICAgIFwiZGFyazpiZy1ibGFjay02MFwiLFxuICAgICAgXCJ3LWZ1bGxcIixcbiAgICAgIFwiaC1mdWxsXCIsXG4gICAgICB0aGlzLl9lbGVtZW50LmlkXG4gICAgXSA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyBDcih7XG4gICAgICBpc1Zpc2libGU6IHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AsXG4gICAgICBpc0FuaW1hdGVkOiAhMCxcbiAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICBiYWNrZHJvcENsYXNzZXM6IHQsXG4gICAgICBjbGlja0NhbGxiYWNrOiAoKSA9PiB0aGlzLmhpZGUoKVxuICAgIH0pO1xuICB9XG4gIF91cGRhdGVCYWNrZHJvcCh0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIpIHtcbiAgICAgIHQgPyB0aGlzLl9iYWNrZHJvcC5zaG93KCkgOiB0aGlzLmlzQmFja2Ryb3BWaXNpYmxlICYmIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc0JhY2tkcm9wVmlzaWJsZSAmJiB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG4gIH1cbiAgX3NldHVwKCkge1xuICAgIHRoaXMuX3NldHVwVG91Y2goKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZGb2N1c1RyYXAgJiYgdGhpcy5fc2V0dXBGb2N1c1RyYXAoKSwgdGhpcy5fc2V0dXBDb2xsYXBzZSgpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdlNsaW0gJiYgdGhpcy5fc2V0dXBTbGltKCksIHRoaXMuX3NldHVwSW5pdGlhbFN0eWxpbmcoKSwgdGhpcy5fc2V0dXBTY3JvbGxpbmcoKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZDb250ZW50ICYmIHRoaXMuX3NldHVwQ29udGVudCgpLCB0aGlzLl9zZXR1cEFjdGl2ZVN0YXRlKCksIHRoaXMuX3NldHVwUmlwcGxlRWZmZWN0KCksIHRoaXMub3B0aW9ucy5zaWRlbmF2SGlkZGVuIHx8IHRoaXMuX3VwZGF0ZU9mZnNldHMoITAsICEwKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9zZXRUYWJpbmRleCghMCk7XG4gIH1cbiAgX3NldHVwQWN0aXZlU3RhdGUoKSB7XG4gICAgdGhpcy5fc2V0QWN0aXZlRWxlbWVudHMoKSwgdGhpcy5saW5rcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjLm9uKHQsIFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5fc2V0QWN0aXZlRWxlbWVudHModCkpLCBjLm9uKHQsIFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgICBlLmtleUNvZGUgPT09IGl0ICYmIHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRzKHQpO1xuICAgICAgfSk7XG4gICAgfSksIGMub24od2luZG93LCBcImhhc2hjaGFuZ2VcIiwgdGhpcy5oYXNoSGFuZGxlcik7XG4gIH1cbiAgX3NldHVwQ29sbGFwc2UoKSB7XG4gICAgdGhpcy5uYXZpZ2F0aW9uLmZvckVhY2goKHQsIGUpID0+IHtcbiAgICAgIGQuZmluZChMZSwgdCkuZm9yRWFjaChcbiAgICAgICAgKG4sIG8pID0+IHRoaXMuX3NldHVwQ29sbGFwc2VMaXN0KHsgbGlzdDogbiwgaW5kZXg6IG8sIG1lbnU6IHQsIG1lbnVJbmRleDogZSB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBfZ2VuZXJhdGVDb2xscGFzZUlEKHQsIGUpIHtcbiAgICByZXR1cm4gYHNpZGVuYXYtY29sbGFwc2UtJHt0aGlzLl9JRH0tJHtlfS0ke3R9YDtcbiAgfVxuICBfc2V0dXBDb2xsYXBzZUxpc3QoeyBsaXN0OiB0LCBpbmRleDogZSwgbWVudTogaSwgbWVudUluZGV4OiBuIH0pIHtcbiAgICBjb25zdCBvID0gdGhpcy5fZ2VuZXJhdGVDb2xscGFzZUlEKGUsIG4pO1xuICAgIHQuc2V0QXR0cmlidXRlKFwiaWRcIiwgbyksIHQuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1jb2xsYXBzZS1pdGVtXCIsIFwiXCIpO1xuICAgIGNvbnN0IFtyXSA9IGQucHJldih0LCBnaSk7XG4gICAgaC5zZXREYXRhQXR0cmlidXRlKHIsIFwiY29sbGFwc2UtaW5pdFwiLCBcIlwiKSwgci5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtvfWApLCByLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJidXR0b25cIik7XG4gICAgY29uc3QgYSA9IFF0LmdldEluc3RhbmNlKHQpIHx8IG5ldyBRdCh0LCB7XG4gICAgICB0b2dnbGU6ICExLFxuICAgICAgcGFyZW50OiB0aGlzLm9wdGlvbnMuc2lkZW5hdkFjY29yZGlvbiA/IGkgOiB0XG4gICAgfSk7XG4gICAgKHQuZGF0YXNldC50ZVNpZGVuYXZTdGF0ZVNob3cgPT09IFwiXCIgfHwgdC5kYXRhc2V0LnRlQ29sbGFwc2VTaG93ID09PSBcIlwiKSAmJiB0aGlzLl9yb3RhdGVBcnJvdyhyLCAhMSksIGMub24ociwgXCJjbGlja1wiLCAobCkgPT4ge1xuICAgICAgdGhpcy5fdG9nZ2xlQ2F0ZWdvcnkobCwgYSwgdCksIHRoaXMuX3RlbXBTbGltICYmIHRoaXMuX2lzQWxsVG9CZUNvbGxhcHNlZCgpICYmICh0aGlzLl9zZXRTbGltKCEwKSwgdGhpcy5fdGVtcFNsaW0gPSAhMSksIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgdGhpcy5fZm9jdXNUcmFwICYmIHRoaXMuX2ZvY3VzVHJhcC51cGRhdGUoKTtcbiAgICB9KSwgYy5vbihcbiAgICAgIHQsXG4gICAgICBcInNob3cudGUuY29sbGFwc2VcIixcbiAgICAgICgpID0+IHRoaXMuX3JvdGF0ZUFycm93KHIsICExKVxuICAgICksIGMub24oXG4gICAgICB0LFxuICAgICAgXCJoaWRlLnRlLmNvbGxhcHNlXCIsXG4gICAgICAoKSA9PiB0aGlzLl9yb3RhdGVBcnJvdyhyLCAhMClcbiAgICApLCBjLm9uKHQsIFwic2hvd24udGUuY29sbGFwc2VcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9mb2N1c1RyYXAgJiYgdGhpcy5fZm9jdXNUcmFwLnVwZGF0ZSgpO1xuICAgIH0pLCBjLm9uKHQsIFwiaGlkZGVuLnRlLmNvbGxhcHNlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3RlbXBTbGltICYmIHRoaXMuX2lzQWxsQ29sbGFwc2VkKCkgJiYgKHRoaXMuX3NldFNsaW0oITApLCB0aGlzLl90ZW1wU2xpbSA9ICExKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9mb2N1c1RyYXAgJiYgdGhpcy5fZm9jdXNUcmFwLnVwZGF0ZSgpO1xuICAgIH0pO1xuICB9XG4gIF9zZXR1cENvbnRlbnQoKSB7XG4gICAgdGhpcy5fY29udGVudCA9IGQuZmluZCh0aGlzLm9wdGlvbnMuc2lkZW5hdkNvbnRlbnQpLCB0aGlzLl9jb250ZW50LmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBbXG4gICAgICAgIFwiIXBcIixcbiAgICAgICAgXCIhbVwiLFxuICAgICAgICBcIiFweFwiLFxuICAgICAgICBcIiFwbFwiLFxuICAgICAgICBcIiFwclwiLFxuICAgICAgICBcIiFteFwiLFxuICAgICAgICBcIiFtbFwiLFxuICAgICAgICBcIiFtclwiLFxuICAgICAgICBcIiEtcFwiLFxuICAgICAgICBcIiEtbVwiLFxuICAgICAgICBcIiEtcHhcIixcbiAgICAgICAgXCIhLXBsXCIsXG4gICAgICAgIFwiIS1wclwiLFxuICAgICAgICBcIiEtbXhcIixcbiAgICAgICAgXCIhLW1sXCIsXG4gICAgICAgIFwiIS1tclwiXG4gICAgICBdO1xuICAgICAgWy4uLnQuY2xhc3NMaXN0XS5maWx0ZXIoXG4gICAgICAgIChuKSA9PiBlLmZpbmRJbmRleCgobykgPT4gbi5pbmNsdWRlcyhvKSkgPj0gMFxuICAgICAgKS5mb3JFYWNoKChuKSA9PiB0LmNsYXNzTGlzdC5yZW1vdmUobikpO1xuICAgIH0pLCB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlID0gdGhpcy5fY29udGVudC5tYXAoKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgcGFkZGluZ0xlZnQ6IGUsIHBhZGRpbmdSaWdodDogaSwgbWFyZ2luTGVmdDogbiwgbWFyZ2luUmlnaHQ6IG8sIHRyYW5zaXRpb246IHIgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQpO1xuICAgICAgcmV0dXJuIHsgcGFkZGluZ0xlZnQ6IGUsIHBhZGRpbmdSaWdodDogaSwgbWFyZ2luTGVmdDogbiwgbWFyZ2luUmlnaHQ6IG8sIHRyYW5zaXRpb246IHIgfTtcbiAgICB9KTtcbiAgfVxuICBfc2V0dXBGb2N1c1RyYXAoKSB7XG4gICAgdGhpcy5fZm9jdXNUcmFwID0gbmV3IHppKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIHtcbiAgICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgICBjb25kaXRpb246ICh0KSA9PiB0LmtleUNvZGUgPT09IGtlLFxuICAgICAgICBvbmx5VmlzaWJsZTogITBcbiAgICAgIH0sXG4gICAgICB0aGlzLnRvZ2dsZXJcbiAgICApO1xuICB9XG4gIF9zZXR1cEluaXRpYWxTdHlsaW5nKCkge1xuICAgIHRoaXMuX3NldENvbG9yKCksIGguc3R5bGUodGhpcy5fZWxlbWVudCwgdGhpcy5zaWRlbmF2U3R5bGUpO1xuICB9XG4gIF9zZXR1cFNjcm9sbGluZygpIHtcbiAgICBsZXQgdCA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWRlbmF2U2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICB0ID0gZC5maW5kT25lKFxuICAgICAgICB0aGlzLm9wdGlvbnMuc2lkZW5hdlNjcm9sbENvbnRhaW5lcixcbiAgICAgICAgdGhpcy5fZWxlbWVudFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGkgPSBmZCh0LnBhcmVudE5vZGUuY2hpbGRyZW4pLmZpbHRlcihcbiAgICAgICAgKG4pID0+IG4gIT09IHRcbiAgICAgICkucmVkdWNlKChuLCBvKSA9PiBuICsgby5jbGllbnRIZWlnaHQsIDApO1xuICAgICAgaC5zdHlsZSh0LCB7XG4gICAgICAgIG1heEhlaWdodDogYGNhbGMoMTAwJSAtICR7aX1weClgLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcGVyZmVjdFNjcm9sbGJhciA9IG5ldyBCaCh0LCB7XG4gICAgICBzdXBwcmVzc1Njcm9sbFg6ICEwLFxuICAgICAgaGFuZGxlcnM6IFtcImNsaWNrLXJhaWxcIiwgXCJkcmFnLXRodW1iXCIsIFwid2hlZWxcIiwgXCJ0b3VjaFwiXVxuICAgIH0pO1xuICB9XG4gIF9zZXR1cFNsaW0oKSB7XG4gICAgdGhpcy5fc2xpbUNvbGxhcHNlZCA9IHRoaXMub3B0aW9ucy5zaWRlbmF2U2xpbUNvbGxhcHNlZCwgdGhpcy5fdG9nZ2xlU2xpbURpc3BsYXkodGhpcy5fc2xpbUNvbGxhcHNlZCksIHRoaXMub3B0aW9ucy5zaWRlbmF2RXhwYW5kT25Ib3ZlciAmJiAodGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zbGltQ29sbGFwc2VkICYmIHRoaXMuX3NldFNsaW0oITEpO1xuICAgIH0pLCB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3NsaW1Db2xsYXBzZWQgfHwgdGhpcy5fc2V0U2xpbSghMCk7XG4gICAgfSkpO1xuICB9XG4gIF9zZXR1cFJpcHBsZUVmZmVjdCgpIHtcbiAgICB0aGlzLmxpbmtzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGxldCBlID0gZWkuZ2V0SW5zdGFuY2UodCksIGkgPSB0aGlzLm9wdGlvbnMuc2lkZW5hdkNvbG9yO1xuICAgICAgaWYgKGUgJiYgZS5fb3B0aW9ucy5zaWRlbmF2Q29sb3IgIT09IHRoaXMub3B0aW9ucy5zaWRlbmF2Q29sb3IpXG4gICAgICAgIGUuZGlzcG9zZSgpO1xuICAgICAgZWxzZSBpZiAoZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgKGxvY2FsU3RvcmFnZS50aGVtZSA9PT0gXCJkYXJrXCIgfHwgIShcInRoZW1lXCIgaW4gbG9jYWxTdG9yYWdlKSAmJiB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikubWF0Y2hlcykgJiYgKGkgPSBcIndoaXRlXCIpLCBlID0gbmV3IGVpKHQsIHsgcmlwcGxlQ29sb3I6IGkgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwVG91Y2goKSB7XG4gICAgdGhpcy5fdG91Y2ggPSBuZXcgJGcodGhpcy5fZWxlbWVudCwgXCJzd2lwZVwiLCB7IHRocmVzaG9sZDogMjAgfSksIHRoaXMuX3RvdWNoLmluaXQoKSwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcInN3aXBlbGVmdFwiLFxuICAgICAgKHQpID0+IHRoaXMuX2hhbmRsZVN3aXBlKHQsIHRoaXMub3B0aW9ucy5zaWRlbmF2UmlnaHQpXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcInN3aXBlcmlnaHRcIixcbiAgICAgICh0KSA9PiB0aGlzLl9oYW5kbGVTd2lwZSh0LCAhdGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodClcbiAgICApO1xuICB9XG4gIF9zZXRBY3RpdmUodCwgZSkge1xuICAgIHQuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1zaWRlYmFyLXN0YXRlLWFjdGl2ZVwiLCBcIlwiKSwgdGhpcy5fYWN0aXZlTm9kZSAmJiB0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtc2lkZWJhci1zdGF0ZS1hY3RpdmVcIiksIHRoaXMuX2FjdGl2ZU5vZGUgPSB0O1xuICAgIGNvbnN0IFtpXSA9IGQucGFyZW50cyhcbiAgICAgIHRoaXMuX2FjdGl2ZU5vZGUsXG4gICAgICBMZVxuICAgICk7XG4gICAgaWYgKCFpKSB7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVDYXRlZ29yeSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbbl0gPSBkLnByZXYoaSwgZ2kpO1xuICAgIHRoaXMuX3NldEFjdGl2ZUNhdGVnb3J5KG4pLCAhZSAmJiAhdGhpcy5fc2xpbUNvbGxhcHNlZCAmJiBRdC5nZXRJbnN0YW5jZShpKS5zaG93KCk7XG4gIH1cbiAgX3NldEFjdGl2ZUNhdGVnb3J5KHQpIHtcbiAgICB0aGlzLm5hdmlnYXRpb24uZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZC5maW5kKExlLCBlKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIGNvbnN0IFtvXSA9IGQucHJldihuLCBnaSk7XG4gICAgICAgIG8gIT09IHQgPyBvLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtc2lkZW5hdi1zdGF0ZS1hY3RpdmVcIikgOiBvLnNldEF0dHJpYnV0ZShcImRhdGEtdGUtc2lkZW5hdi1zdGF0ZS1hY3RpdmVcIiwgXCJcIik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfc2V0QWN0aXZlRWxlbWVudHModCkge1xuICAgIHRoaXMubmF2aWdhdGlvbi5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBkLmZpbmQoZ2ksIGUpLmZpbHRlcigobikgPT4gZC5uZXh0KG4sIExlKS5sZW5ndGggPT09IDApLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgdGhpcy5faXNBY3RpdmUobiwgdCkgJiYgbiAhPT0gdGhpcy5fYWN0aXZlTm9kZSAmJiB0aGlzLl9zZXRBY3RpdmUobiwgdCk7XG4gICAgICB9KTtcbiAgICB9KSwgdCAmJiB0aGlzLl91cGRhdGVGb2N1cyh0aGlzLmlzVmlzaWJsZSk7XG4gIH1cbiAgX3NldENvbG9yKCkge1xuICAgIGNvbnN0IHQgPSBbXG4gICAgICBcInByaW1hcnlcIixcbiAgICAgIFwic2Vjb25kYXJ5XCIsXG4gICAgICBcInN1Y2Nlc3NcIixcbiAgICAgIFwiaW5mb1wiLFxuICAgICAgXCJ3YXJuaW5nXCIsXG4gICAgICBcImRhbmdlclwiLFxuICAgICAgXCJsaWdodFwiLFxuICAgICAgXCJkYXJrXCJcbiAgICBdLCB7IHNpZGVuYXZDb2xvcjogZSB9ID0gdGhpcy5vcHRpb25zLCBpID0gdC5pbmNsdWRlcyhlKSA/IGUgOiBcInByaW1hcnlcIjtcbiAgICB0LmZvckVhY2goKG4pID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShgc2lkZW5hdi0ke259YCk7XG4gICAgfSksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgYHNpZGVuYXYtJHtpfWApO1xuICB9XG4gIF9zZXRDb250ZW50T2Zmc2V0cyh0LCBlLCBpKSB7XG4gICAgdGhpcy5fY29udGVudC5mb3JFYWNoKChuLCBvKSA9PiB7XG4gICAgICBjb25zdCByID0gdGhpcy5fZ2V0T2Zmc2V0VmFsdWUodCwge1xuICAgICAgICBpbmRleDogbyxcbiAgICAgICAgcHJvcGVydHk6IFwicGFkZGluZ1wiLFxuICAgICAgICBvZmZzZXRzOiBlXG4gICAgICB9KSwgYSA9IHRoaXMuX2dldE9mZnNldFZhbHVlKHQsIHtcbiAgICAgICAgaW5kZXg6IG8sXG4gICAgICAgIHByb3BlcnR5OiBcIm1hcmdpblwiLFxuICAgICAgICBvZmZzZXRzOiBlXG4gICAgICB9KSwgbCA9IHt9O1xuICAgICAgaWYgKGkgfHwgKGwudHJhbnNpdGlvbiA9IGBhbGwgJHt0aGlzLnRyYW5zaXRpb25EdXJhdGlvbn0gbGluZWFyYCksIGxbZS5wYWRkaW5nLnByb3BlcnR5XSA9IGAke3J9cHhgLCBsW2UubWFyZ2luLnByb3BlcnR5XSA9IGAke2F9cHhgLCBoLnN0eWxlKG4sIGwpLCAhIXQpIHtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICBoLnN0eWxlKG4sIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRoaXMuX2luaXRpYWxDb250ZW50U3R5bGVbb10udHJhbnNpdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjLm9uKG4sIFwidHJhbnNpdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgaC5zdHlsZShuLCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlW29dLnRyYW5zaXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX3NldE1vZGUodCkge1xuICAgIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSAhPT0gdCAmJiAodGhpcy5fb3B0aW9ucy5zaWRlbmF2TW9kZSA9IHQsIHRoaXMuX3VwZGF0ZSh0aGlzLmlzVmlzaWJsZSkpO1xuICB9XG4gIF9zZXRTbGltKHQpIHtcbiAgICBjb25zdCBlID0gdCA/IFtcImNvbGxhcHNlXCIsIFwiY29sbGFwc2VkXCJdIDogW1wiZXhwYW5kXCIsIFwiZXhwYW5kZWRcIl07XG4gICAgdGhpcy5fdHJpZ2dlckV2ZW50cyguLi5lKSwgdCAmJiB0aGlzLl9jb2xsYXBzZUl0ZW1zKCksIHRoaXMuX3NsaW1Db2xsYXBzZWQgPSB0LCB0aGlzLl90b2dnbGVTbGltRGlzcGxheSh0KSwgaC5zdHlsZSh0aGlzLl9lbGVtZW50LCB7IHdpZHRoOiBgJHt0aGlzLndpZHRofXB4YCB9KSwgdGhpcy5fdXBkYXRlT2Zmc2V0cyh0aGlzLmlzVmlzaWJsZSk7XG4gIH1cbiAgX3NldFRhYmluZGV4KHQpIHtcbiAgICB0aGlzLmxpbmtzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUudGFiSW5kZXggPSB0ID8gMCA6IC0xO1xuICAgIH0pO1xuICB9XG4gIF9lbWl0RXZlbnRzKHQpIHtcbiAgICBjb25zdCBlID0gdCA/IFtcInNob3dcIiwgXCJzaG93blwiXSA6IFtcImhpZGVcIiwgXCJoaWRkZW5cIl07XG4gICAgdGhpcy5fdHJpZ2dlckV2ZW50cyguLi5lKTtcbiAgfVxuICBfcm90YXRlQXJyb3codCwgZSkge1xuICAgIGNvbnN0IFtpXSA9IGQuY2hpbGRyZW4odCwgYFske0xnfV1gKTtcbiAgICBpICYmIChlID8gaC5yZW1vdmVDbGFzcyhpLCBcInJvdGF0ZS0xODBcIikgOiBoLmFkZENsYXNzKGksIFwicm90YXRlLTE4MFwiKSk7XG4gIH1cbiAgX3RvZ2dsZUNhdGVnb3J5KHQsIGUpIHtcbiAgICB0LnByZXZlbnREZWZhdWx0KCksIGUudG9nZ2xlKCksIHRoaXMuX3NsaW1Db2xsYXBzZWQgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZFeHBhbmRhYmxlICYmICh0aGlzLl90ZW1wU2xpbSA9ICEwLCB0aGlzLl9zZXRTbGltKCExKSk7XG4gIH1cbiAgX3RvZ2dsZVNsaW1EaXNwbGF5KHQpIHtcbiAgICBjb25zdCBlID0gZC5maW5kKFxuICAgICAgTWcsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgaSA9IGQuZmluZChcbiAgICAgIFJnLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIG4gPSAoKSA9PiB7XG4gICAgICBlLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgaC5zdHlsZShvLCB7XG4gICAgICAgICAgZGlzcGxheTogdGhpcy5fc2xpbUNvbGxhcHNlZCA/IFwidW5zZXRcIiA6IFwibm9uZVwiXG4gICAgICAgIH0pO1xuICAgICAgfSksIGkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBoLnN0eWxlKG8sIHtcbiAgICAgICAgICBkaXNwbGF5OiB0aGlzLl9zbGltQ29sbGFwc2VkID8gXCJub25lXCIgOiBcInVuc2V0XCJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHQgPyBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4gbigpLFxuICAgICAgdGhpcy5vcHRpb25zLnNpZGVuYXZUcmFuc2l0aW9uRHVyYXRpb25cbiAgICApIDogbigpO1xuICB9XG4gIGFzeW5jIF90cmlnZ2VyRXZlbnRzKHQsIGUpIHtcbiAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYCR7dH0udGUuc2lkZW5hdmApLCBlICYmIGF3YWl0IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGAke2V9LnRlLnNpZGVuYXZgKTtcbiAgICB9LCB0aGlzLm9wdGlvbnMuc2lkZW5hdlRyYW5zaXRpb25EdXJhdGlvbiArIDUpO1xuICB9XG4gIF9pc2lQaG9uZSgpIHtcbiAgICByZXR1cm4gL2lQaG9uZXxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuICBfdXBkYXRlKHQpIHtcbiAgICB0ICYmIHRoaXMuX2lzaVBob25lKCkgJiYgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcInBzLS1zY3JvbGxpbmcteVwiKSwgdGhpcy50b2dnbGVyICYmIHRoaXMuX3VwZGF0ZVRvZ2dsZXJBcmlhKHQpLCB0aGlzLl91cGRhdGVEaXNwbGF5KHQpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkJhY2tkcm9wICYmIHRoaXMuX3VwZGF0ZUJhY2tkcm9wKHQpLCB0aGlzLl91cGRhdGVPZmZzZXRzKHQpLCB0ICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2Q2xvc2VPbkVzYyAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgIT09IFwic2lkZVwiICYmIGMub24od2luZG93LCBcImtleWRvd25cIiwgdGhpcy5lc2NIYW5kbGVyKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZGb2N1c1RyYXAgJiYgdGhpcy5fdXBkYXRlRm9jdXModCk7XG4gIH1cbiAgX3VwZGF0ZURpc3BsYXkodCkge1xuICAgIGNvbnN0IGUgPSB0ID8gMCA6IHRoaXMudHJhbnNsYXRpb247XG4gICAgaC5zdHlsZSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7ZX0lKWBcbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlRm9jdXModCkge1xuICAgIGlmICh0aGlzLl9zZXRUYWJpbmRleCh0KSwgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdkZvY3VzVHJhcCkge1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNUcmFwLnRyYXAoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fZm9jdXNUcmFwLmRpc2FibGUoKTtcbiAgICB9XG4gICAgdGhpcy5fZm9jdXNUcmFwLmRpc2FibGUoKTtcbiAgfVxuICBfdXBkYXRlT2Zmc2V0cyh0LCBlID0gITEpIHtcbiAgICBjb25zdCBbaSwgbl0gPSB0aGlzLm9wdGlvbnMuc2lkZW5hdlJpZ2h0ID8gW1wicmlnaHRcIiwgXCJsZWZ0XCJdIDogW1wibGVmdFwiLCBcInJpZ2h0XCJdLCBvID0ge1xuICAgICAgcHJvcGVydHk6IHRoaXMuX2dldFByb3BlcnR5KFwicGFkZGluZ1wiLCBpKSxcbiAgICAgIHZhbHVlOiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiID8gMCA6IHRoaXMud2lkdGhcbiAgICB9LCByID0ge1xuICAgICAgcHJvcGVydHk6IHRoaXMuX2dldFByb3BlcnR5KFwibWFyZ2luXCIsIG4pLFxuICAgICAgdmFsdWU6IHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJwdXNoXCIgPyAtMSAqIHRoaXMud2lkdGggOiAwXG4gICAgfTtcbiAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJ1cGRhdGUudGUuc2lkZW5hdlwiLCB7XG4gICAgICBtYXJnaW46IHIsXG4gICAgICBwYWRkaW5nOiBvXG4gICAgfSksIHRoaXMuX2NvbnRlbnQgJiYgKHRoaXMuX2NvbnRlbnQuY2xhc3NOYW1lID0gXCJcIiwgdGhpcy5fc2V0Q29udGVudE9mZnNldHModCwgeyBwYWRkaW5nOiBvLCBtYXJnaW46IHIgfSwgZSkpO1xuICB9XG4gIF91cGRhdGVUb2dnbGVyQXJpYSh0KSB7XG4gICAgdGhpcy50b2dnbGVyLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgdCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyB0b2dnbGVTaWRlbmF2KCkge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBjb25zdCBlID0gZC5jbG9zZXN0KHQudGFyZ2V0LCBmbyksIGkgPSBoLmdldERhdGFBdHRyaWJ1dGVzKGUpLnRhcmdldDtcbiAgICAgIGQuZmluZChpKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIChDaS5nZXRJbnN0YW5jZShuKSB8fCBuZXcgQ2kobikpLnRvZ2dsZSgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSBBLmdldERhdGEodGhpcywgd3MpO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSAmJiAoaSB8fCAoaSA9IG5ldyBDaSh0aGlzLCBuKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEEuZ2V0RGF0YSh0LCB3cyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgWm8gPSBcInN0ZXBwZXJcIiwgdG4gPSBcInRlLnN0ZXBwZXJcIiwgYWkgPSBgLiR7dG59YCwgVWkgPSBgZGF0YS10ZS0ke1pvfWAsIEFpID0gXCJob3Jpem9udGFsXCIsIE90ID0gXCJ2ZXJ0aWNhbFwiLCBGZyA9IGBvbkNoYW5nZVN0ZXAke2FpfWAsIFlnID0gYG9uQ2hhbmdlZFN0ZXAke2FpfWAsIGpnID0ge1xuICBzdGVwcGVyVHlwZTogXCJzdHJpbmdcIixcbiAgc3RlcHBlckxpbmVhcjogXCJib29sZWFuXCIsXG4gIHN0ZXBwZXJOb0VkaXRhYmxlOiBcImJvb2xlYW5cIixcbiAgc3RlcHBlckFjdGl2ZTogXCJzdHJpbmdcIixcbiAgc3RlcHBlckNvbXBsZXRlZDogXCJzdHJpbmdcIixcbiAgc3RlcHBlckludmFsaWQ6IFwic3RyaW5nXCIsXG4gIHN0ZXBwZXJEaXNhYmxlZDogXCJzdHJpbmdcIixcbiAgc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludDogXCJudW1iZXJcIixcbiAgc3RlcHBlck1vYmlsZUJyZWFrcG9pbnQ6IFwibnVtYmVyXCIsXG4gIHN0ZXBwZXJNb2JpbGVCYXJCcmVha3BvaW50OiBcIm51bWJlclwiLFxuICBzdGVwcGVyQW5pbWF0aW9uRHVyYXRpb246IFwibnVtYmVyXCIsXG4gIHNsaWRlSW5MZWZ0QW5pbWF0aW9uOiBcInN0cmluZ1wiLFxuICBzbGlkZU91dExlZnRBbmltYXRpb246IFwic3RyaW5nXCIsXG4gIHNsaWRlSW5SaWdodEFuaW1hdGlvbjogXCJzdHJpbmdcIixcbiAgc2xpZGVPdXRSaWdodEFuaW1hdGlvbjogXCJzdHJpbmdcIlxufSwgS2cgPSB7XG4gIHN0ZXBwZXJUeXBlOiBBaSxcbiAgc3RlcHBlckxpbmVhcjogITEsXG4gIHN0ZXBwZXJOb0VkaXRhYmxlOiAhMSxcbiAgc3RlcHBlckFjdGl2ZTogXCJcIixcbiAgc3RlcHBlckNvbXBsZXRlZDogXCJcIixcbiAgc3RlcHBlckludmFsaWQ6IFwiXCIsXG4gIHN0ZXBwZXJEaXNhYmxlZDogXCJcIixcbiAgc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludDogMCxcbiAgc3RlcHBlck1vYmlsZUJyZWFrcG9pbnQ6IDAsXG4gIHN0ZXBwZXJNb2JpbGVCYXJCcmVha3BvaW50OiA0LFxuICBzdGVwcGVyQW5pbWF0aW9uRHVyYXRpb246IDgwMCxcbiAgc2xpZGVJbkxlZnRBbmltYXRpb246IFwiYW5pbWF0ZS1bc2xpZGUtaW4tbGVmdF8wLjhzX2JvdGhdXCIsXG4gIHNsaWRlT3V0TGVmdEFuaW1hdGlvbjogXCJhbmltYXRlLVtzbGlkZS1vdXQtbGVmdF8wLjhzX2JvdGhdXCIsXG4gIHNsaWRlSW5SaWdodEFuaW1hdGlvbjogXCJhbmltYXRlLVtzbGlkZS1pbi1yaWdodF8wLjhzX2JvdGhdXCIsXG4gIHNsaWRlT3V0UmlnaHRBbmltYXRpb246IFwiYW5pbWF0ZS1bc2xpZGUtb3V0LXJpZ2h0XzAuOHNfYm90aF1cIlxufSwgZGwgPSBgbW91c2Vkb3duJHthaX1gLCB1bCA9IGBrZXlkb3duJHthaX1gLCB6ZyA9IGBrZXl1cCR7YWl9YCwgcGwgPSBgcmVzaXplJHthaX1gLCBLdCA9IGBbJHtVaX0tc3RlcC1yZWZdYCwgWiA9IGBbJHtVaX0taGVhZC1yZWZdYCwgX2wgPSBgWyR7VWl9LWhlYWQtdGV4dC1yZWZdYCwga3MgPSBgWyR7VWl9LWhlYWQtaWNvbi1yZWZdYCwgUSA9IGBbJHtVaX0tY29udGVudC1yZWZdYDtcbmNsYXNzIFVBIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9lbGVtZW50SGVpZ2h0ID0gMCwgdGhpcy5fc3RlcHMgPSBkLmZpbmQoYCR7S3R9YCwgdGhpcy5fZWxlbWVudCksIHRoaXMuX2N1cnJlbnRWaWV3ID0gXCJcIiwgdGhpcy5fYWN0aXZlU3RlcEluZGV4ID0gMCwgdGhpcy5fdmVydGljYWxTdGVwcGVyU3R5bGVzID0gW10sIHRoaXMuX3RpbWVvdXQgPSAwLCB0aGlzLl9lbGVtZW50ICYmIChBLnNldERhdGEodCwgdG4sIHRoaXMpLCB0aGlzLl9pbml0KCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBabztcbiAgfVxuICBnZXQgYWN0aXZlU3RlcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RlcHNbdGhpcy5fYWN0aXZlU3RlcEluZGV4XTtcbiAgfVxuICBnZXQgYWN0aXZlU3RlcEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVTdGVwSW5kZXg7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgYy5vZmYodCwgZGwpLCBjLm9mZih0LCB1bCk7XG4gICAgfSksIGMub2ZmKHdpbmRvdywgcGwpLCBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgdG4pLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBjaGFuZ2VTdGVwKHQpIHtcbiAgICB0aGlzLl90b2dnbGVTdGVwKHQpO1xuICB9XG4gIG5leHRTdGVwKCkge1xuICAgIHRoaXMuX3RvZ2dsZVN0ZXAodGhpcy5fYWN0aXZlU3RlcEluZGV4ICsgMSk7XG4gIH1cbiAgcHJldmlvdXNTdGVwKCkge1xuICAgIHRoaXMuX3RvZ2dsZVN0ZXAodGhpcy5fYWN0aXZlU3RlcEluZGV4IC0gMSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKGAke0t0fWAsIHRoaXMuX2VsZW1lbnQpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uc2V0QXR0cmlidXRlKFwiZGF0YS10ZVwiLCBcImFjdGl2ZS1zdGVwXCIpLCBlID0gZC5maW5kKFxuICAgICAgYCR7X2x9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBpID0gZC5maW5kKFxuICAgICAgYCR7a3N9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHN3aXRjaCAodCA/ICh0aGlzLl9hY3RpdmVTdGVwSW5kZXggPSB0aGlzLl9zdGVwcy5pbmRleE9mKHQpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3MoXG4gICAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXgsXG4gICAgICBcImFkZFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyQWN0aXZlXG4gICAgKSwgZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCJmb250LW1lZGl1bVwiKSwgaVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCIhYmctcHJpbWFyeS0xMDBcIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiIXRleHQtcHJpbWFyeS03MDBcIikpIDogKGVbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiZm9udC1tZWRpdW1cIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiIWJnLXByaW1hcnktMTAwXCIpLCBpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcIiF0ZXh0LXByaW1hcnktNzAwXCIpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3MoXG4gICAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXgsXG4gICAgICBcImFkZFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyQWN0aXZlXG4gICAgKSksIHRoaXMuX2JpbmRNb3VzZURvd24oKSwgdGhpcy5fYmluZEtleXNOYXZpZ2F0aW9uKCksIHRoaXMuX29wdGlvbnMuc3RlcHBlclR5cGUpIHtcbiAgICAgIGNhc2UgT3Q6XG4gICAgICAgIHRoaXMuX3RvZ2dsZVZlcnRpY2FsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5fdG9nZ2xlSG9yaXpvbnRhbCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgKHRoaXMuX29wdGlvbnMuc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludCB8fCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJNb2JpbGVCcmVha3BvaW50KSAmJiB0aGlzLl90b2dnbGVTdGVwcGVyVmlldygpLCB0aGlzLl9iaW5kUmVzaXplKCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5LZyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgSShabywgdCwgamcpLCB0O1xuICB9XG4gIF9iaW5kTW91c2VEb3duKCkge1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoYCR7Wn1gLCB0KTtcbiAgICAgIGMub24oZSwgZGwsIChpKSA9PiB7XG4gICAgICAgIGNvbnN0IG4gPSBkLnBhcmVudHMoaS50YXJnZXQsIGAke0t0fWApWzBdLCBvID0gdGhpcy5fc3RlcHMuaW5kZXhPZihuKTtcbiAgICAgICAgaS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl90b2dnbGVTdGVwKG8pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRSZXNpemUoKSB7XG4gICAgYy5vbih3aW5kb3csIHBsLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jdXJyZW50VmlldyA9PT0gT3QgJiYgdGhpcy5fc2V0U2luZ2xlU3RlcEhlaWdodCh0aGlzLmFjdGl2ZVN0ZXApLCB0aGlzLl9jdXJyZW50VmlldyA9PT0gQWkgJiYgdGhpcy5fc2V0SGVpZ2h0KHRoaXMuYWN0aXZlU3RlcCksICh0aGlzLl9vcHRpb25zLnN0ZXBwZXJWZXJ0aWNhbEJyZWFrcG9pbnQgfHwgdGhpcy5fb3B0aW9ucy5zdGVwcGVyTW9iaWxlQnJlYWtwb2ludCkgJiYgdGhpcy5fdG9nZ2xlU3RlcHBlclZpZXcoKTtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlU3RlcHBlclZpZXcoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX29wdGlvbnMuc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludCA8IHdpbmRvdy5pbm5lcldpZHRoLCBlID0gdGhpcy5fb3B0aW9ucy5zdGVwcGVyVmVydGljYWxCcmVha3BvaW50ID4gd2luZG93LmlubmVyV2lkdGgsIGkgPSB0aGlzLl9vcHRpb25zLnN0ZXBwZXJNb2JpbGVCcmVha3BvaW50ID4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdCAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0gQWkgJiYgdGhpcy5fdG9nZ2xlSG9yaXpvbnRhbCgpLCBlICYmICFpICYmIHRoaXMuX2N1cnJlbnRWaWV3ICE9PSBPdCAmJiAodGhpcy5fc3RlcHMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgY29uc3QgbyA9IGQuZmluZE9uZShgJHtRfWAsIG4pO1xuICAgICAgdGhpcy5fcmVzZXRTdGVwcGVySGVpZ2h0KCksIHRoaXMuX3Nob3dFbGVtZW50KG8pO1xuICAgIH0pLCB0aGlzLl90b2dnbGVWZXJ0aWNhbCgpKTtcbiAgfVxuICBfdG9nZ2xlU3RlcCh0KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCA9PT0gdClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9vcHRpb25zLnN0ZXBwZXJOb0VkaXRhYmxlICYmIHRoaXMuX3RvZ2dsZURpc2FibGVkKCk7XG4gICAgY29uc3QgZSA9IHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCwgaSA9IGMudHJpZ2dlcihcbiAgICAgIHRoaXMuYWN0aXZlU3RlcCxcbiAgICAgIEZnLFxuICAgICAge1xuICAgICAgICBjdXJyZW50U3RlcDogdGhpcy5fYWN0aXZlU3RlcEluZGV4LFxuICAgICAgICBuZXh0U3RlcDogdFxuICAgICAgfVxuICAgICk7XG4gICAgdCA+IHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCAmJiBpLmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX3Nob3dFbGVtZW50KFxuICAgICAgZC5maW5kT25lKGAke1F9YCwgdGhpcy5fc3RlcHNbdF0pXG4gICAgKSwgdGhpcy5fdG9nZ2xlQWN0aXZlKHQpLCB0ID4gdGhpcy5fYWN0aXZlU3RlcEluZGV4ICYmIHRoaXMuX3RvZ2dsZUNvbXBsZXRlZCh0aGlzLl9hY3RpdmVTdGVwSW5kZXgpLCB0aGlzLl9jdXJyZW50VmlldyA9PT0gQWkgPyB0aGlzLl9hbmltYXRlSG9yaXpvbnRhbFN0ZXAodCkgOiAodGhpcy5fYW5pbWF0ZVZlcnRpY2FsU3RlcCh0KSwgdGhpcy5fc2V0U2luZ2xlU3RlcEhlaWdodCh0aGlzLl9zdGVwc1t0XSkpLCB0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoXG4gICAgICBkLmZpbmRPbmUoYCR7Wn1gLCB0aGlzLmFjdGl2ZVN0ZXApLFxuICAgICAgZC5maW5kT25lKGAke1p9YCwgdGhpcy5fc3RlcHNbdF0pXG4gICAgKSwgdGhpcy5fYWN0aXZlU3RlcEluZGV4ID0gdCwgdGhpcy5fc3RlcHNbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlXCIsIFwiYWN0aXZlLXN0ZXBcIiksIHRoaXMuX3N0ZXBzLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgIG5bdGhpcy5fYWN0aXZlU3RlcEluZGV4XSAhPT0gbyAmJiBuLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGVcIik7XG4gICAgfSksIGMudHJpZ2dlcih0aGlzLmFjdGl2ZVN0ZXAsIFlnLCB7XG4gICAgICBjdXJyZW50U3RlcDogdGhpcy5fYWN0aXZlU3RlcEluZGV4LFxuICAgICAgcHJldlN0ZXA6IGVcbiAgICB9KSk7XG4gIH1cbiAgX3Jlc2V0U3RlcHBlckhlaWdodCgpIHtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiXCI7XG4gIH1cbiAgX3NldFN0ZXBzSGVpZ2h0KCkge1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoYCR7UX1gLCB0KSwgaSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUpO1xuICAgICAgdGhpcy5fdmVydGljYWxTdGVwcGVyU3R5bGVzLnB1c2goe1xuICAgICAgICBwYWRkaW5nVG9wOiBwYXJzZUZsb2F0KGkucGFkZGluZ1RvcCksXG4gICAgICAgIHBhZGRpbmdCb3R0b206IHBhcnNlRmxvYXQoaS5wYWRkaW5nQm90dG9tKVxuICAgICAgfSk7XG4gICAgICBjb25zdCBuID0gZS5zY3JvbGxIZWlnaHQ7XG4gICAgICBlLnN0eWxlLmhlaWdodCA9IGAke259cHhgO1xuICAgIH0pO1xuICB9XG4gIF9zZXRTaW5nbGVTdGVwSGVpZ2h0KHQpIHtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKGAke1F9YCwgdCksIGkgPSB0aGlzLmFjdGl2ZVN0ZXAgPT09IHQsIG4gPSB0aGlzLl9zdGVwcy5pbmRleE9mKHQpO1xuICAgIGxldCBvO1xuICAgIGkgPyAoZS5zdHlsZS5oZWlnaHQgPSBcIlwiLCBvID0gZS5zY3JvbGxIZWlnaHQpIDogbyA9IGUuc2Nyb2xsSGVpZ2h0ICsgdGhpcy5fdmVydGljYWxTdGVwcGVyU3R5bGVzW25dLnBhZGRpbmdUb3AgKyB0aGlzLl92ZXJ0aWNhbFN0ZXBwZXJTdHlsZXNbbl0ucGFkZGluZ0JvdHRvbSwgZS5zdHlsZS5oZWlnaHQgPSBgJHtvfXB4YDtcbiAgfVxuICBfdG9nZ2xlVmVydGljYWwoKSB7XG4gICAgdGhpcy5fY3VycmVudFZpZXcgPSBPdCwgdGhpcy5fc2V0U3RlcHNIZWlnaHQoKSwgdGhpcy5faGlkZUluYWN0aXZlU3RlcHMoKTtcbiAgfVxuICBfdG9nZ2xlSG9yaXpvbnRhbCgpIHtcbiAgICB0aGlzLl9jdXJyZW50VmlldyA9IEFpLCB0aGlzLl9zZXRIZWlnaHQodGhpcy5hY3RpdmVTdGVwKSwgdGhpcy5faGlkZUluYWN0aXZlU3RlcHMoKTtcbiAgfVxuICBfdG9nZ2xlU3RlcHBlckNsYXNzKCkge1xuICAgIGQuZmluZE9uZShcbiAgICAgIFwiW2RhdGEtdGUtc3RlcHBlci10eXBlXVwiLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkgIT09IG51bGwgJiYgdGhpcy5fc3RlcHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZC5maW5kT25lKGAke1F9YCwgZSkuY2xhc3NMaXN0LnJlbW92ZShcIiFteS0wXCIpLCBkLmZpbmRPbmUoYCR7UX1gLCBlKS5jbGFzc0xpc3QucmVtb3ZlKFwiIXB5LTBcIiksIGQuZmluZE9uZShgJHtRfWAsIGUpLmNsYXNzTGlzdC5yZW1vdmUoXCIhaC0wXCIpO1xuICAgIH0pO1xuICB9XG4gIF90b2dnbGVTdGVwQ2xhc3ModCwgZSwgaSkge1xuICAgIGkgJiYgdGhpcy5fc3RlcHNbdF0uY2xhc3NMaXN0W2VdKGkpO1xuICB9XG4gIF9iaW5kS2V5c05hdmlnYXRpb24oKSB7XG4gICAgdGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KFxuICAgICAgITEsXG4gICAgICBkLmZpbmRPbmUoYCR7Wn1gLCB0aGlzLmFjdGl2ZVN0ZXApXG4gICAgKSwgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGQuZmluZE9uZShgJHtafWAsIHQpO1xuICAgICAgYy5vbihlLCB1bCwgKGkpID0+IHtcbiAgICAgICAgY29uc3QgbiA9IGQucGFyZW50cyhcbiAgICAgICAgICBpLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgYCR7S3R9YFxuICAgICAgICApWzBdLCBvID0gZC5uZXh0KG4sIGAke0t0fWApWzBdLCByID0gZC5wcmV2KG4sIGAke0t0fWApWzBdLCBhID0gZC5maW5kT25lKFxuICAgICAgICAgIGAke1p9YCxcbiAgICAgICAgICBuXG4gICAgICAgICksIGwgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYCR7Wn1gLFxuICAgICAgICAgIHRoaXMuYWN0aXZlU3RlcFxuICAgICAgICApO1xuICAgICAgICBsZXQgcCA9IG51bGwsIHUgPSBudWxsO1xuICAgICAgICBpZiAobyAmJiAocCA9IGQuZmluZE9uZShgJHtafWAsIG8pKSwgciAmJiAodSA9IGQuZmluZE9uZShgJHtafWAsIHIpKSwgaS5rZXlDb2RlID09PSBLZSAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0gT3QgJiYgKHUgPyAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIHUpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIHUpLCB1LmZvY3VzKCkpIDogcCAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIHApLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIHApLCBwLmZvY3VzKCkpKSwgaS5rZXlDb2RlID09PSB6ZSAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0gT3QgJiYgKHAgPyAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIHApLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIHApLCBwLmZvY3VzKCkpIDogdSAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIHUpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIHUpLCB1LmZvY3VzKCkpKSwgaS5rZXlDb2RlID09PSB6ICYmIHRoaXMuX2N1cnJlbnRWaWV3ID09PSBPdCAmJiAoaS5wcmV2ZW50RGVmYXVsdCgpLCBwICYmICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgcCksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgcCksIHAuZm9jdXMoKSkpLCBpLmtleUNvZGUgPT09IFUgJiYgdGhpcy5fY3VycmVudFZpZXcgPT09IE90ICYmIChpLnByZXZlbnREZWZhdWx0KCksIHUgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCB1KSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCB1KSwgdS5mb2N1cygpKSksIGkua2V5Q29kZSA9PT0gVGUpIHtcbiAgICAgICAgICBjb25zdCBfID0gZC5maW5kT25lKFxuICAgICAgICAgICAgYCR7Wn1gLFxuICAgICAgICAgICAgdGhpcy5fc3RlcHNbMF1cbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCBfKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCBfKSwgXy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpLmtleUNvZGUgPT09IEVlKSB7XG4gICAgICAgICAgY29uc3QgXyA9IHRoaXMuX3N0ZXBzW3RoaXMuX3N0ZXBzLmxlbmd0aCAtIDFdLCBmID0gZC5maW5kT25lKGAke1p9YCwgXyk7XG4gICAgICAgICAgdGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIGYpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIGYpLCBmLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgKGkua2V5Q29kZSA9PT0gaXQgfHwgaS5rZXlDb2RlID09PSBacykgJiYgKGkucHJldmVudERlZmF1bHQoKSwgdGhpcy5jaGFuZ2VTdGVwKHRoaXMuX3N0ZXBzLmluZGV4T2YobikpKSwgaS5rZXlDb2RlID09PSBrZSAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIGwpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsICExKSwgbC5mb2N1cygpKTtcbiAgICAgIH0pLCBjLm9uKGUsIHpnLCAoaSkgPT4ge1xuICAgICAgICBjb25zdCBuID0gZC5wYXJlbnRzKFxuICAgICAgICAgIGkuY3VycmVudFRhcmdldCxcbiAgICAgICAgICBgJHtLdH1gXG4gICAgICAgIClbMF0sIG8gPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYCR7Wn1gLFxuICAgICAgICAgIG5cbiAgICAgICAgKSwgciA9IGQuZmluZE9uZShcbiAgICAgICAgICBgJHtafWAsXG4gICAgICAgICAgdGhpcy5hY3RpdmVTdGVwXG4gICAgICAgICk7XG4gICAgICAgIGkua2V5Q29kZSA9PT0ga2UgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChvLCByKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyghMSwgciksIHIuZm9jdXMoKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlU3RlcFRhYkluZGV4KHQsIGUpIHtcbiAgICB0ICYmIHQuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgLTEpLCBlICYmIGUuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgMCk7XG4gIH1cbiAgX3RvZ2dsZU91dGxpbmVTdHlsZXModCwgZSkge1xuICAgIHQgJiYgKHQuc3R5bGUub3V0bGluZSA9IFwiXCIpLCBlICYmIChlLnN0eWxlLm91dGxpbmUgPSBcInJldmVydFwiKTtcbiAgfVxuICBfdG9nZ2xlRGlzYWJsZWQoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZChgJHtafWAsIHRoaXMuX2VsZW1lbnQpLCBlID0gZC5maW5kKFxuICAgICAgYCR7a3N9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHRbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiY29sb3ItWyM4NTg1ODVdXCIpLCB0W3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcImN1cnNvci1kZWZhdWx0XCIpLCBlW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcIiFiZy1bIzg1ODU4NV1cIiksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyhcbiAgICAgIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCxcbiAgICAgIFwiYWRkXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN0ZXBwZXJEaXNhYmxlZFxuICAgICk7XG4gIH1cbiAgX3RvZ2dsZUFjdGl2ZSh0KSB7XG4gICAgY29uc3QgZSA9IGQuZmluZChcbiAgICAgIGAke19sfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgaSA9IGQuZmluZChcbiAgICAgIGAke2tzfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBlW3RdLmNsYXNzTGlzdC5hZGQoXCJmb250LW1lZGl1bVwiKSwgaVt0XS5jbGFzc0xpc3QuYWRkKFwiIWJnLXByaW1hcnktMTAwXCIpLCBpW3RdLmNsYXNzTGlzdC5hZGQoXCIhdGV4dC1wcmltYXJ5LTcwMFwiKSwgaVt0XS5jbGFzc0xpc3QucmVtb3ZlKFwiIWJnLXN1Y2Nlc3MtMTAwXCIpLCBpW3RdLmNsYXNzTGlzdC5yZW1vdmUoXCIhdGV4dC1zdWNjZXNzLTcwMFwiKSwgZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoXCJmb250LW1lZGl1bVwiKSwgaVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoXCIhYmctcHJpbWFyeS0xMDBcIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgXCIhdGV4dC1wcmltYXJ5LTcwMFwiXG4gICAgKSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKHQsIFwiYWRkXCIsIHRoaXMuX29wdGlvbnMuc3RlcHBlckFjdGl2ZSksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyhcbiAgICAgIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCxcbiAgICAgIFwicmVtb3ZlXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN0ZXBwZXJBY3RpdmVcbiAgICApO1xuICB9XG4gIF90b2dnbGVDb21wbGV0ZWQodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmQoXG4gICAgICBgJHtrc31gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyTm9FZGl0YWJsZSA/IHRoaXMuX3N0ZXBzW3RdLmNsYXNzTGlzdC5hZGQoXCJwb2ludGVyLWV2ZW50cy1ub25lXCIpIDogKGVbdF0uY2xhc3NMaXN0LmFkZChcIiFiZy1zdWNjZXNzLTEwMFwiKSwgZVt0XS5jbGFzc0xpc3QuYWRkKFwiIXRleHQtc3VjY2Vzcy03MDBcIikpLCBlW3RdLmNsYXNzTGlzdC5yZW1vdmUoXCIhYmctZGFuZ2VyLTEwMFwiKSwgZVt0XS5jbGFzc0xpc3QucmVtb3ZlKFwiIXRleHQtZGFuZ2VyLTcwMFwiKSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKHQsIFwiYWRkXCIsIHRoaXMuX29wdGlvbnMuc3RlcHBlckNvbXBsZXRlZCksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyh0LCBcInJlbW92ZVwiLCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJJbnZhbGlkKTtcbiAgfVxuICBfaGlkZUluYWN0aXZlU3RlcHMoKSB7XG4gICAgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgaWYgKCF0LmdldEF0dHJpYnV0ZShcImRhdGEtdGVcIikpIHtcbiAgICAgICAgY29uc3QgZSA9IGQuZmluZE9uZShgJHtRfWAsIHQpO1xuICAgICAgICBlLmNsYXNzTGlzdC5yZW1vdmUoXCJ0cmFuc2xhdGUteC1bMTUwJV1cIiksIHRoaXMuX2hpZGVFbGVtZW50KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9zZXRIZWlnaHQodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoYCR7UX1gLCB0KSwgaSA9IGdldENvbXB1dGVkU3R5bGUoZSksIG4gPSBkLmZpbmRPbmUoYCR7Wn1gLCB0KSwgbyA9IGdldENvbXB1dGVkU3R5bGUobiksIHIgPSBlLm9mZnNldEhlaWdodCArIHBhcnNlRmxvYXQoaS5tYXJnaW5Ub3ApICsgcGFyc2VGbG9hdChpLm1hcmdpbkJvdHRvbSksIGEgPSBuLm9mZnNldEhlaWdodCArIHBhcnNlRmxvYXQoby5tYXJnaW5Ub3ApICsgcGFyc2VGbG9hdChvLm1hcmdpbkJvdHRvbSk7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHthICsgcn1weGA7XG4gIH1cbiAgX2hpZGVFbGVtZW50KHQpIHtcbiAgICAhZC5wYXJlbnRzKFxuICAgICAgdCxcbiAgICAgIGAke0t0fWBcbiAgICApWzBdLmdldEF0dHJpYnV0ZShcImRhdGEtdGVcIikgJiYgdGhpcy5fY3VycmVudFZpZXcgIT09IE90ID8gdC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIgOiAodC5jbGFzc0xpc3QuYWRkKFwiIW15LTBcIiksIHQuY2xhc3NMaXN0LmFkZChcIiFweS0wXCIpLCB0LmNsYXNzTGlzdC5hZGQoXCIhaC0wXCIpKTtcbiAgfVxuICBfc2hvd0VsZW1lbnQodCkge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID09PSBPdCA/ICh0LmNsYXNzTGlzdC5yZW1vdmUoXCIhbXktMFwiKSwgdC5jbGFzc0xpc3QucmVtb3ZlKFwiIXB5LTBcIiksIHQuY2xhc3NMaXN0LnJlbW92ZShcIiFoLTBcIikpIDogdC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICB9XG4gIF9hbmltYXRlSG9yaXpvbnRhbFN0ZXAodCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSwgdGhpcy5fY2xlYXJTdGVwc0FuaW1hdGlvbigpO1xuICAgIGNvbnN0IGUgPSB0ID4gdGhpcy5fYWN0aXZlU3RlcEluZGV4LCBpID0gZC5maW5kT25lKFxuICAgICAgYCR7UX1gLFxuICAgICAgdGhpcy5fc3RlcHNbdF1cbiAgICApLCBuID0gZC5maW5kT25lKFxuICAgICAgYCR7UX1gLFxuICAgICAgdGhpcy5hY3RpdmVTdGVwXG4gICAgKTtcbiAgICBsZXQgbywgcjtcbiAgICB0aGlzLl9zdGVwcy5mb3JFYWNoKChhLCBsKSA9PiB7XG4gICAgICBjb25zdCBwID0gZC5maW5kT25lKGAke1F9YCwgYSk7XG4gICAgICBsICE9PSB0ICYmIGwgIT09IHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCAmJiB0aGlzLl9oaWRlRWxlbWVudChwKTtcbiAgICB9KSwgZSA/IChyID0gdGhpcy5fb3B0aW9ucy5zbGlkZU91dExlZnRBbmltYXRpb24sIG8gPSB0aGlzLl9vcHRpb25zLnNsaWRlSW5SaWdodEFuaW1hdGlvbikgOiAociA9IHRoaXMuX29wdGlvbnMuc2xpZGVPdXRSaWdodEFuaW1hdGlvbiwgbyA9IHRoaXMuX29wdGlvbnMuc2xpZGVJbkxlZnRBbmltYXRpb24pLCBuLmNsYXNzTGlzdC5hZGQociksIGkuY2xhc3NMaXN0LmFkZChvKSwgdGhpcy5fc2V0SGVpZ2h0KHRoaXMuX3N0ZXBzW3RdKSwgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5faGlkZUVsZW1lbnQobiksIHRoaXMuX2NsZWFyU3RlcHNBbmltYXRpb24oKTtcbiAgICB9LCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJBbmltYXRpb25EdXJhdGlvbik7XG4gIH1cbiAgX2NsZWFyU3RlcHNBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgZC5maW5kT25lKGAke1F9YCwgdCkuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5zbGlkZUluTGVmdEFuaW1hdGlvbixcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5zbGlkZU91dExlZnRBbmltYXRpb24sXG4gICAgICAgIHRoaXMuX29wdGlvbnMuc2xpZGVJblJpZ2h0QW5pbWF0aW9uLFxuICAgICAgICB0aGlzLl9vcHRpb25zLnNsaWRlT3V0UmlnaHRBbmltYXRpb25cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgX2FuaW1hdGVWZXJ0aWNhbFN0ZXAodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoXG4gICAgICBgJHtRfWAsXG4gICAgICB0aGlzLl9zdGVwc1t0XVxuICAgICksIGkgPSBkLmZpbmRPbmUoXG4gICAgICBgJHtRfWAsXG4gICAgICB0aGlzLmFjdGl2ZVN0ZXBcbiAgICApO1xuICAgIHRoaXMuX2hpZGVFbGVtZW50KGkpLCB0aGlzLl9zaG93RWxlbWVudChlKTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgdG4pO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IGZsID0gXCJkYXRhLXRlLWlucHV0LXN0YXRlLWFjdGl2ZVwiLCB4cyA9IFwiZGF0YS10ZS1pbnB1dC1zZWxlY3RlZFwiLCBtbCA9IFwiZGF0YS10ZS1pbnB1dC1tdWx0aXBsZS1hY3RpdmVcIiwgZ2wgPSBcIltkYXRhLXRlLWZvcm0tY2hlY2staW5wdXRdXCI7XG5jbGFzcyBibCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGksIG4sIG8sIHIsIGEsIGwsIHAsIHUsIF8pIHtcbiAgICB0aGlzLmlkID0gdCwgdGhpcy5uYXRpdmVPcHRpb24gPSBlLCB0aGlzLm11bHRpcGxlID0gaSwgdGhpcy52YWx1ZSA9IG4sIHRoaXMubGFiZWwgPSBvLCB0aGlzLnNlbGVjdGVkID0gciwgdGhpcy5kaXNhYmxlZCA9IGEsIHRoaXMuaGlkZGVuID0gbCwgdGhpcy5zZWNvbmRhcnlUZXh0ID0gcCwgdGhpcy5ncm91cElkID0gdSwgdGhpcy5pY29uID0gXywgdGhpcy5ub2RlID0gbnVsbCwgdGhpcy5hY3RpdmUgPSAhMTtcbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgdGhpcy5tdWx0aXBsZSA/IHRoaXMuX3NlbGVjdE11bHRpcGxlKCkgOiB0aGlzLl9zZWxlY3RTaW5nbGUoKTtcbiAgfVxuICBfc2VsZWN0U2luZ2xlKCkge1xuICAgIHRoaXMuc2VsZWN0ZWQgfHwgKHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoeHMsIFwiXCIpLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMCksIHRoaXMuc2VsZWN0ZWQgPSAhMCwgdGhpcy5uYXRpdmVPcHRpb24gJiYgKHRoaXMubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITApKTtcbiAgfVxuICBfc2VsZWN0TXVsdGlwbGUoKSB7XG4gICAgaWYgKCF0aGlzLnNlbGVjdGVkKSB7XG4gICAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgICBnbCxcbiAgICAgICAgdGhpcy5ub2RlXG4gICAgICApO1xuICAgICAgdC5jaGVja2VkID0gITAsIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoeHMsIFwiXCIpLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMCksIHRoaXMuc2VsZWN0ZWQgPSAhMCwgdGhpcy5uYXRpdmVPcHRpb24gJiYgKHRoaXMubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITApO1xuICAgIH1cbiAgfVxuICBkZXNlbGVjdCgpIHtcbiAgICB0aGlzLm11bHRpcGxlID8gdGhpcy5fZGVzZWxlY3RNdWx0aXBsZSgpIDogdGhpcy5fZGVzZWxlY3RTaW5nbGUoKTtcbiAgfVxuICBfZGVzZWxlY3RTaW5nbGUoKSB7XG4gICAgdGhpcy5zZWxlY3RlZCAmJiAodGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZSh4cyksIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICExKSwgdGhpcy5zZWxlY3RlZCA9ICExLCB0aGlzLm5hdGl2ZU9wdGlvbiAmJiAodGhpcy5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMSkpO1xuICB9XG4gIF9kZXNlbGVjdE11bHRpcGxlKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgICBnbCxcbiAgICAgICAgdGhpcy5ub2RlXG4gICAgICApO1xuICAgICAgdC5jaGVja2VkID0gITEsIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoeHMpLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMSksIHRoaXMuc2VsZWN0ZWQgPSAhMSwgdGhpcy5uYXRpdmVPcHRpb24gJiYgKHRoaXMubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITEpO1xuICAgIH1cbiAgfVxuICBzZXROb2RlKHQpIHtcbiAgICB0aGlzLm5vZGUgPSB0O1xuICB9XG4gIHNldEFjdGl2ZVN0eWxlcygpIHtcbiAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKG1sLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmUgPSAhMCwgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShmbCwgXCJcIik7XG4gICAgfVxuICB9XG4gIHJlbW92ZUFjdGl2ZVN0eWxlcygpIHtcbiAgICB0aGlzLmFjdGl2ZSAmJiAodGhpcy5hY3RpdmUgPSAhMSwgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShmbCkpLCB0aGlzLm11bHRpcGxlICYmIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUobWwpO1xuICB9XG59XG5jbGFzcyBVZyB7XG4gIGNvbnN0cnVjdG9yKHQgPSAhMSkge1xuICAgIHRoaXMuX211bHRpcGxlID0gdCwgdGhpcy5fc2VsZWN0aW9ucyA9IFtdO1xuICB9XG4gIHNlbGVjdCh0KSB7XG4gICAgdGhpcy5fbXVsdGlwbGUgPyB0aGlzLl9zZWxlY3Rpb25zLnB1c2godCkgOiB0aGlzLl9zZWxlY3Rpb25zID0gW3RdO1xuICB9XG4gIGRlc2VsZWN0KHQpIHtcbiAgICBpZiAodGhpcy5fbXVsdGlwbGUpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLl9zZWxlY3Rpb25zLmZpbmRJbmRleChcbiAgICAgICAgKGkpID0+IHQgPT09IGlcbiAgICAgICk7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25zLnNwbGljZShlLCAxKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuX3NlbGVjdGlvbnMgPSBbXTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9zZWxlY3Rpb25zID0gW107XG4gIH1cbiAgZ2V0IHNlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uc1swXTtcbiAgfVxuICBnZXQgc2VsZWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9ucztcbiAgfVxuICBnZXQgbGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbnNbMF0gJiYgdGhpcy5zZWxlY3Rpb24ubGFiZWw7XG4gIH1cbiAgZ2V0IGxhYmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9ucy5tYXAoKHQpID0+IHQubGFiZWwpLmpvaW4oXCIsIFwiKTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uc1swXSAmJiB0aGlzLnNlbGVjdGlvbi52YWx1ZTtcbiAgfVxuICBnZXQgdmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25zLm1hcCgodCkgPT4gdC52YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIFFvKHMpIHtcbiAgcmV0dXJuIHMuZmlsdGVyKCh0KSA9PiAhdC5kaXNhYmxlZCkuZXZlcnkoKHQpID0+IHQuc2VsZWN0ZWQpO1xufVxuY29uc3QgWGcgPSBcImRhdGEtdGUtc2VsZWN0LWZvcm0tb3V0bGluZS1yZWZcIiwgR2cgPSBcImRhdGEtdGUtc2VsZWN0LXdyYXBwZXItcmVmXCIsIHFnID0gXCJkYXRhLXRlLXNlbGVjdC1pbnB1dC1yZWZcIiwgWmcgPSBcImRhdGEtdGUtc2VsZWN0LWNsZWFyLWJ0bi1yZWZcIiwgUWcgPSBcImRhdGEtdGUtc2VsZWN0LWRyb3Bkb3duLWNvbnRhaW5lci1yZWZcIiwgSmcgPSBcImRhdGEtdGUtc2VsZWN0LWRyb3Bkb3duLXJlZlwiLCB0YiA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9ucy13cmFwcGVyLXJlZlwiLCBlYiA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9ucy1saXN0LXJlZlwiLCBpYiA9IFwiZGF0YS10ZS1zZWxlY3QtaW5wdXQtZmlsdGVyLXJlZlwiLCBFaCA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLXJlZlwiLCBzYiA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWFsbC1yZWZcIiwgbmIgPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi10ZXh0LXJlZlwiLCBvYiA9IFwiZGF0YS10ZS1mb3JtLWNoZWNrLWlucHV0XCIsIHJiID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tZ3JvdXAtcmVmXCIsIGFiID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tZ3JvdXAtbGFiZWwtcmVmXCIsIENoID0gXCJkYXRhLXRlLXNlbGVjdC1zZWxlY3RlZFwiLCBsYiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE5LjUgOC4yNWwtNy41IDcuNS03LjUtNy41XCIgLz5cbjwvc3ZnPlxuYCwgY2IgPSAocykgPT4ge1xuICBzLmNvZGUgPT09IFwiVGFiXCIgfHwgcy5jb2RlID09PSBcIkVzY1wiIHx8IHMucHJldmVudERlZmF1bHQoKTtcbn07XG5mdW5jdGlvbiBPcyhzLCB0LCBlLCBpLCBuKSB7XG4gIHQuc2VsZWN0U2l6ZSA9PT0gXCJkZWZhdWx0XCIgJiYgaC5hZGRDbGFzcyhzLCBlKSwgdC5zZWxlY3RTaXplID09PSBcInNtXCIgJiYgaC5hZGRDbGFzcyhzLCBpKSwgdC5zZWxlY3RTaXplID09PSBcImxnXCIgJiYgaC5hZGRDbGFzcyhzLCBuKTtcbn1cbmZ1bmN0aW9uIGhiKHMsIHQsIGUsIGksIG4pIHtcbiAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIG8uc2V0QXR0cmlidXRlKFwiaWRcIiwgcyksIG8uc2V0QXR0cmlidXRlKEdnLCBcIlwiKTtcbiAgY29uc3QgciA9ICQoXCJkaXZcIik7XG4gIHIuc2V0QXR0cmlidXRlKFhnLCBcIlwiKSwgaC5hZGRDbGFzcyhyLCBpLmZvcm1PdXRsaW5lKTtcbiAgY29uc3QgYSA9ICQoXCJpbnB1dFwiKSwgbCA9IHQuc2VsZWN0RmlsdGVyID8gXCJjb21ib2JveFwiIDogXCJsaXN0Ym94XCIsIHAgPSB0Lm11bHRpcGxlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIsIHUgPSB0LmRpc2FibGVkID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gIGEuc2V0QXR0cmlidXRlKHFnLCBcIlwiKSwgaC5hZGRDbGFzcyhhLCBpLnNlbGVjdElucHV0KSwgT3MoXG4gICAgYSxcbiAgICB0LFxuICAgIGkuc2VsZWN0SW5wdXRTaXplRGVmYXVsdCxcbiAgICBpLnNlbGVjdElucHV0U2l6ZVNtLFxuICAgIGkuc2VsZWN0SW5wdXRTaXplTGdcbiAgKSwgdC5zZWxlY3RGb3JtV2hpdGUgJiYgaC5hZGRDbGFzcyhhLCBpLnNlbGVjdElucHV0V2hpdGUpLCBhLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0XCIpLCBhLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgbCksIGEuc2V0QXR0cmlidXRlKFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIiwgcCksIGEuc2V0QXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiLCB1KSwgYS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhhc3BvcHVwXCIsIFwidHJ1ZVwiKSwgYS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsICExKSwgdC50YWJJbmRleCAmJiBhLnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIHQudGFiSW5kZXgpLCB0LmRpc2FibGVkICYmIGEuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIiksIHQuc2VsZWN0UGxhY2Vob2xkZXIgIT09IFwiXCIgJiYgYS5zZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiLCB0LnNlbGVjdFBsYWNlaG9sZGVyKSwgdC5zZWxlY3RWYWxpZGF0aW9uID8gKGguYWRkU3R5bGUoYSwge1xuICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJub25lXCIsXG4gICAgXCJjYXJldC1jb2xvclwiOiBcInRyYW5zcGFyZW50XCJcbiAgfSksIGguYWRkU3R5bGUociwgeyBjdXJzb3I6IFwicG9pbnRlclwiIH0pKSA6IGEuc2V0QXR0cmlidXRlKFwicmVhZG9ubHlcIiwgXCJ0cnVlXCIpLCB0LnNlbGVjdFZhbGlkYXRpb24gJiYgKGEuc2V0QXR0cmlidXRlKFwicmVxdWlyZWRcIiwgXCJ0cnVlXCIpLCBhLnNldEF0dHJpYnV0ZShcImFyaWEtcmVxdWlyZWRcIiwgXCJ0cnVlXCIpLCBhLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGNiKSk7XG4gIGNvbnN0IF8gPSAkKFwiZGl2XCIpO1xuICBoLmFkZENsYXNzKF8sIGkuc2VsZWN0VmFsaWRhdGlvblZhbGlkKTtcbiAgY29uc3QgZiA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuICAgIGAke3Quc2VsZWN0VmFsaWRGZWVkYmFja31gXG4gICk7XG4gIF8uYXBwZW5kQ2hpbGQoZik7XG4gIGNvbnN0IGcgPSAkKFwiZGl2XCIpO1xuICBoLmFkZENsYXNzKGcsIGkuc2VsZWN0VmFsaWRhdGlvbkludmFsaWQpO1xuICBjb25zdCBtID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXG4gICAgYCR7dC5zZWxlY3RJbnZhbGlkRmVlZGJhY2t9YFxuICApO1xuICBnLmFwcGVuZENoaWxkKG0pO1xuICBjb25zdCBiID0gJChcInNwYW5cIik7XG4gIGIuc2V0QXR0cmlidXRlKFpnLCBcIlwiKSwgaC5hZGRDbGFzcyhiLCBpLnNlbGVjdENsZWFyQnRuKSwgT3MoXG4gICAgYixcbiAgICB0LFxuICAgIGkuc2VsZWN0Q2xlYXJCdG5EZWZhdWx0LFxuICAgIGkuc2VsZWN0Q2xlYXJCdG5TbSxcbiAgICBpLnNlbGVjdENsZWFyQnRuTGdcbiAgKSwgdC5zZWxlY3RGb3JtV2hpdGUgJiYgaC5hZGRDbGFzcyhiLCBpLnNlbGVjdENsZWFyQnRuV2hpdGUpO1xuICBjb25zdCB2ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCLinJVcIik7XG4gIGIuYXBwZW5kQ2hpbGQodiksIGIuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuICBjb25zdCBUID0gJChcInNwYW5cIik7XG4gIHJldHVybiBoLmFkZENsYXNzKFQsIGkuc2VsZWN0QXJyb3cpLCBPcyhcbiAgICBULFxuICAgIHQsXG4gICAgaS5zZWxlY3RBcnJvd0RlZmF1bHQsXG4gICAgaS5zZWxlY3RBcnJvd1NtLFxuICAgIGkuc2VsZWN0QXJyb3dMZ1xuICApLCB0LnNlbGVjdEZvcm1XaGl0ZSAmJiBoLmFkZENsYXNzKFQsIGkuc2VsZWN0QXJyb3dXaGl0ZSksIFQuaW5uZXJIVE1MID0gbiB8fCBsYiwgci5hcHBlbmRDaGlsZChhKSwgZSAmJiAoaC5hZGRDbGFzcyhlLCBpLnNlbGVjdExhYmVsKSwgT3MoXG4gICAgZSxcbiAgICB0LFxuICAgIGkuc2VsZWN0TGFiZWxTaXplRGVmYXVsdCxcbiAgICBpLnNlbGVjdExhYmVsU2l6ZVNtLFxuICAgIGkuc2VsZWN0TGFiZWxTaXplTGdcbiAgKSwgdC5zZWxlY3RGb3JtV2hpdGUgJiYgaC5hZGRDbGFzcyhlLCBpLnNlbGVjdExhYmVsV2hpdGUpLCByLmFwcGVuZENoaWxkKGUpKSwgdC5zZWxlY3RWYWxpZGF0aW9uICYmIChyLmFwcGVuZENoaWxkKF8pLCByLmFwcGVuZENoaWxkKGcpKSwgdC5zZWxlY3RDbGVhckJ1dHRvbiAmJiByLmFwcGVuZENoaWxkKGIpLCByLmFwcGVuZENoaWxkKFQpLCBvLmFwcGVuZENoaWxkKHIpLCBvO1xufVxuZnVuY3Rpb24gdmwocywgdCwgZSwgaSwgbiwgbywgciwgYSkge1xuICBjb25zdCBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbC5zZXRBdHRyaWJ1dGUoUWcsIFwiXCIpLCBoLmFkZENsYXNzKGwsIGEuc2VsZWN0RHJvcGRvd25Db250YWluZXIpLCBsLnNldEF0dHJpYnV0ZShcImlkXCIsIGAke3N9YCksIGwuc3R5bGUud2lkdGggPSBgJHtlfXB4YDtcbiAgY29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHAuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgMCksIHAuc2V0QXR0cmlidXRlKEpnLCBcIlwiKSwgaC5hZGRDbGFzcyhwLCBhLmRyb3Bkb3duKTtcbiAgY29uc3QgdSA9ICQoXCJkaXZcIik7XG4gIHUuc2V0QXR0cmlidXRlKHRiLCBcIlwiKSwgaC5hZGRDbGFzcyh1LCBhLm9wdGlvbnNXcmFwcGVyKSwgaC5hZGRDbGFzcyh1LCBhLm9wdGlvbnNXcmFwcGVyU2Nyb2xsYmFyKSwgdS5zdHlsZS5tYXhIZWlnaHQgPSBgJHtpfXB4YDtcbiAgY29uc3QgXyA9IEFoKFxuICAgIG8sXG4gICAgbixcbiAgICB0LFxuICAgIGFcbiAgKTtcbiAgcmV0dXJuIHUuYXBwZW5kQ2hpbGQoXyksIHQuc2VsZWN0RmlsdGVyICYmIHAuYXBwZW5kQ2hpbGQoXG4gICAgZGIodC5zZWxlY3RTZWFyY2hQbGFjZWhvbGRlciwgYSlcbiAgKSwgcC5hcHBlbmRDaGlsZCh1KSwgciAmJiBwLmFwcGVuZENoaWxkKHIpLCBsLmFwcGVuZENoaWxkKHApLCBsO1xufVxuZnVuY3Rpb24gQWgocywgdCwgZSwgaSkge1xuICBjb25zdCBuID0gJChcImRpdlwiKTtcbiAgbi5zZXRBdHRyaWJ1dGUoZWIsIFwiXCIpLCBoLmFkZENsYXNzKG4sIGkub3B0aW9uc0xpc3QpO1xuICBsZXQgbztcbiAgcmV0dXJuIGUubXVsdGlwbGUgPyBvID0gcGIoXG4gICAgcyxcbiAgICB0LFxuICAgIGUsXG4gICAgaVxuICApIDogbyA9IHViKHMsIGUsIGkpLCBvLmZvckVhY2goKHIpID0+IHtcbiAgICBuLmFwcGVuZENoaWxkKHIpO1xuICB9KSwgbjtcbn1cbmZ1bmN0aW9uIGRiKHMsIHQpIHtcbiAgY29uc3QgZSA9ICQoXCJkaXZcIik7XG4gIGguYWRkQ2xhc3MoZSwgdC5pbnB1dEdyb3VwKTtcbiAgY29uc3QgaSA9ICQoXCJpbnB1dFwiKTtcbiAgcmV0dXJuIGkuc2V0QXR0cmlidXRlKGliLCBcIlwiKSwgaC5hZGRDbGFzcyhpLCB0LnNlbGVjdEZpbHRlcklucHV0KSwgaS5wbGFjZWhvbGRlciA9IHMsIGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInNlYXJjaGJveFwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwidGV4dFwiKSwgZS5hcHBlbmRDaGlsZChpKSwgZTtcbn1cbmZ1bmN0aW9uIHViKHMsIHQsIGUpIHtcbiAgcmV0dXJuIHloKHMsIHQsIGUpO1xufVxuZnVuY3Rpb24gcGIocywgdCwgZSwgaSkge1xuICBsZXQgbiA9IG51bGw7XG4gIGUuc2VsZWN0QWxsICYmIChuID0gX2IoXG4gICAgdCxcbiAgICBzLFxuICAgIGUsXG4gICAgaVxuICApKTtcbiAgY29uc3QgbyA9IHloKHMsIGUsIGkpO1xuICByZXR1cm4gbiA/IFtuLCAuLi5vXSA6IG87XG59XG5mdW5jdGlvbiB5aChzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSBbXTtcbiAgcmV0dXJuIHMuZm9yRWFjaCgobikgPT4ge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICBuLFxuICAgICAgXCJvcHRpb25zXCJcbiAgICApKSB7XG4gICAgICBjb25zdCByID0gYmIobiwgdCwgZSk7XG4gICAgICBpLnB1c2gocik7XG4gICAgfSBlbHNlXG4gICAgICBpLnB1c2god2gobiwgdCwgZSkpO1xuICB9KSwgaTtcbn1cbmZ1bmN0aW9uIF9iKHMsIHQsIGUsIGkpIHtcbiAgY29uc3QgbiA9IFFvKHQpLCBvID0gJChcImRpdlwiKTtcbiAgby5zZXRBdHRyaWJ1dGUoRWgsIFwiXCIpO1xuICBjb25zdCByID0gaS5zZWxlY3RBbGxPcHRpb24gfHwgaS5zZWxlY3RPcHRpb247XG4gIHJldHVybiBoLmFkZENsYXNzKG8sIHIpLCBvLnNldEF0dHJpYnV0ZShzYiwgXCJcIiksIGguYWRkU3R5bGUobywge1xuICAgIGhlaWdodDogYCR7ZS5zZWxlY3RPcHRpb25IZWlnaHR9cHhgXG4gIH0pLCBvLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJvcHRpb25cIiksIG8uc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBuKSwgbiAmJiBvLnNldEF0dHJpYnV0ZShDaCwgXCJcIiksIG8uYXBwZW5kQ2hpbGQoa2gocywgZSwgaSkpLCBzLnNldE5vZGUobyksIG87XG59XG5mdW5jdGlvbiB3aChzLCB0LCBlKSB7XG4gIGlmIChzLm5vZGUpXG4gICAgcmV0dXJuIHMubm9kZTtcbiAgY29uc3QgaSA9ICQoXCJkaXZcIik7XG4gIHJldHVybiBpLnNldEF0dHJpYnV0ZShFaCwgXCJcIiksIGguYWRkQ2xhc3MoaSwgZS5zZWxlY3RPcHRpb24pLCBoLmFkZFN0eWxlKGksIHtcbiAgICBoZWlnaHQ6IGAke3Quc2VsZWN0T3B0aW9uSGVpZ2h0fXB4YFxuICB9KSwgaC5zZXREYXRhQXR0cmlidXRlKGksIFwiaWRcIiwgcy5pZCksIGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIHMuc2VsZWN0ZWQpLCBpLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIiwgcy5kaXNhYmxlZCksIHMuc2VsZWN0ZWQgJiYgaS5zZXRBdHRyaWJ1dGUoQ2gsIFwiXCIpLCBzLmRpc2FibGVkICYmIGkuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXCIsICEwKSwgcy5oaWRkZW4gJiYgaC5hZGRDbGFzcyhpLCBcImhpZGRlblwiKSwgaS5hcHBlbmRDaGlsZChraChzLCB0LCBlKSksIHMuaWNvbiAmJiBpLmFwcGVuZENoaWxkKGdiKHMsIGUpKSwgcy5zZXROb2RlKGkpLCBpO1xufVxuZnVuY3Rpb24ga2gocywgdCwgZSkge1xuICBjb25zdCBpID0gJChcInNwYW5cIik7XG4gIGkuc2V0QXR0cmlidXRlKG5iLCBcIlwiKSwgaC5hZGRDbGFzcyhpLCBlLnNlbGVjdE9wdGlvblRleHQpO1xuICBjb25zdCBuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocy5sYWJlbCk7XG4gIHJldHVybiB0Lm11bHRpcGxlICYmIGkuYXBwZW5kQ2hpbGQobWIocywgZSkpLCBpLmFwcGVuZENoaWxkKG4pLCAocy5zZWNvbmRhcnlUZXh0IHx8IHR5cGVvZiBzLnNlY29uZGFyeVRleHQgPT0gXCJudW1iZXJcIikgJiYgaS5hcHBlbmRDaGlsZChcbiAgICBmYihzLnNlY29uZGFyeVRleHQsIGUpXG4gICksIGk7XG59XG5mdW5jdGlvbiBmYihzLCB0KSB7XG4gIGNvbnN0IGUgPSAkKFwic3BhblwiKTtcbiAgaC5hZGRDbGFzcyhlLCB0LnNlbGVjdE9wdGlvblNlY29uZGFyeVRleHQpO1xuICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocyk7XG4gIHJldHVybiBlLmFwcGVuZENoaWxkKGkpLCBlO1xufVxuZnVuY3Rpb24gbWIocywgdCkge1xuICBjb25zdCBlID0gJChcImlucHV0XCIpO1xuICBlLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJjaGVja2JveFwiKSwgaC5hZGRDbGFzcyhlLCB0LmZvcm1DaGVja0lucHV0KSwgZS5zZXRBdHRyaWJ1dGUob2IsIFwiXCIpO1xuICBjb25zdCBpID0gJChcImxhYmVsXCIpO1xuICByZXR1cm4gcy5zZWxlY3RlZCAmJiBlLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgITApLCBzLmRpc2FibGVkICYmIGUuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgITApLCBlLmFwcGVuZENoaWxkKGkpLCBlO1xufVxuZnVuY3Rpb24gZ2IocywgdCkge1xuICBjb25zdCBlID0gJChcInNwYW5cIiksIGkgPSAkKFwiaW1nXCIpO1xuICByZXR1cm4gaC5hZGRDbGFzcyhpLCB0LnNlbGVjdE9wdGlvbkljb24pLCBpLnNyYyA9IHMuaWNvbiwgZS5hcHBlbmRDaGlsZChpKSwgZTtcbn1cbmZ1bmN0aW9uIGJiKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9ICQoXCJkaXZcIik7XG4gIGkuc2V0QXR0cmlidXRlKHJiLCBcIlwiKSwgaC5hZGRDbGFzcyhpLCBlLnNlbGVjdE9wdGlvbkdyb3VwKSwgaS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZ3JvdXBcIiksIGkuc2V0QXR0cmlidXRlKFwiaWRcIiwgcy5pZCksIHMuaGlkZGVuICYmIGguYWRkQ2xhc3MoaSwgXCJoaWRkZW5cIik7XG4gIGNvbnN0IG4gPSAkKFwibGFiZWxcIik7XG4gIHJldHVybiBuLnNldEF0dHJpYnV0ZShhYiwgXCJcIiksIGguYWRkQ2xhc3MobiwgZS5zZWxlY3RPcHRpb25Hcm91cExhYmVsKSwgaC5hZGRTdHlsZShuLCB7IGhlaWdodDogYCR7dC5zZWxlY3RPcHRpb25IZWlnaHR9cHhgIH0pLCBuLnNldEF0dHJpYnV0ZShcImZvclwiLCBzLmlkKSwgbi50ZXh0Q29udGVudCA9IHMubGFiZWwsIGkuYXBwZW5kQ2hpbGQobiksIHMub3B0aW9ucy5mb3JFYWNoKChvKSA9PiB7XG4gICAgaS5hcHBlbmRDaGlsZCh3aChvLCB0LCBlKSk7XG4gIH0pLCBpO1xufVxuZnVuY3Rpb24gdmIocywgdCkge1xuICBjb25zdCBlID0gJChcImRpdlwiKTtcbiAgcmV0dXJuIGUudGV4dENvbnRlbnQgPSBzLCBoLmFkZENsYXNzKGUsIHQuc2VsZWN0TGFiZWwpLCBoLmFkZENsYXNzKGUsIHQuc2VsZWN0RmFrZVZhbHVlKSwgZTtcbn1cbmNvbnN0IG1vID0gXCJzZWxlY3RcIiwgeWkgPSBcInRlLnNlbGVjdFwiLCBYaSA9IGAuJHt5aX1gLCBUYiA9IGBjbG9zZSR7WGl9YCwgRWIgPSBgb3BlbiR7WGl9YCwgVGwgPSBgb3B0aW9uU2VsZWN0JHtYaX1gLCBFbCA9IGBvcHRpb25EZXNlbGVjdCR7WGl9YCwgQ2IgPSBgdmFsdWVDaGFuZ2Uke1hpfWAsIEFiID0gXCJjaGFuZ2VcIiwgQ2wgPSBcImRhdGEtdGUtc2VsZWN0LWluaXRcIiwgeGggPSBcImRhdGEtdGUtc2VsZWN0LW5vLXJlc3VsdHMtcmVmXCIsIEFsID0gXCJkYXRhLXRlLXNlbGVjdC1vcGVuXCIsIEogPSBcImRhdGEtdGUtaW5wdXQtc3RhdGUtYWN0aXZlXCIsIHp0ID0gXCJkYXRhLXRlLWlucHV0LWZvY3VzZWRcIiwgZ28gPSBcImRhdGEtdGUtaW5wdXQtZGlzYWJsZWRcIiwgeWIgPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1ncm91cC1sYWJlbC1yZWZcIiwgd2IgPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1hbGwtcmVmXCIsIGJpID0gXCJkYXRhLXRlLXNlbGVjdC1zZWxlY3RlZFwiLCBrYiA9IFwiW2RhdGEtdGUtc2VsZWN0LWxhYmVsLXJlZl1cIiwgeWwgPSBcIltkYXRhLXRlLXNlbGVjdC1pbnB1dC1yZWZdXCIsIHhiID0gXCJbZGF0YS10ZS1zZWxlY3QtaW5wdXQtZmlsdGVyLXJlZl1cIiwgT2IgPSBcIltkYXRhLXRlLXNlbGVjdC1kcm9wZG93bi1yZWZdXCIsIFNiID0gXCJbZGF0YS10ZS1zZWxlY3Qtb3B0aW9ucy13cmFwcGVyLXJlZl1cIiwgd2wgPSBcIltkYXRhLXRlLXNlbGVjdC1vcHRpb25zLWxpc3QtcmVmXVwiLCBJYiA9IFwiW2RhdGEtdGUtc2VsZWN0LW9wdGlvbi1yZWZdXCIsIERiID0gXCJbZGF0YS10ZS1zZWxlY3QtY2xlYXItYnRuLXJlZl1cIiwgJGIgPSBcIltkYXRhLXRlLXNlbGVjdC1jdXN0b20tY29udGVudC1yZWZdXCIsIExiID0gYFske3hofV1gLCBrbCA9IFwiW2RhdGEtdGUtc2VsZWN0LWZvcm0tb3V0bGluZS1yZWZdXCIsIE5iID0gXCJbZGF0YS10ZS1zZWxlY3QtdG9nZ2xlXVwiLCBibyA9IFwiW2RhdGEtdGUtaW5wdXQtbm90Y2gtcmVmXVwiLCBNYiA9IHtcbiAgc2VsZWN0QXV0b1NlbGVjdDogITEsXG4gIHNlbGVjdENvbnRhaW5lcjogXCJib2R5XCIsXG4gIHNlbGVjdENsZWFyQnV0dG9uOiAhMSxcbiAgZGlzYWJsZWQ6ICExLFxuICBzZWxlY3REaXNwbGF5ZWRMYWJlbHM6IDUsXG4gIHNlbGVjdEZvcm1XaGl0ZTogITEsXG4gIG11bHRpcGxlOiAhMSxcbiAgc2VsZWN0T3B0aW9uc1NlbGVjdGVkTGFiZWw6IFwib3B0aW9ucyBzZWxlY3RlZFwiLFxuICBzZWxlY3RPcHRpb25IZWlnaHQ6IDM4LFxuICBzZWxlY3RBbGw6ICEwLFxuICBzZWxlY3RBbGxMYWJlbDogXCJTZWxlY3QgYWxsXCIsXG4gIHNlbGVjdFNlYXJjaFBsYWNlaG9sZGVyOiBcIlNlYXJjaC4uLlwiLFxuICBzZWxlY3RTaXplOiBcImRlZmF1bHRcIixcbiAgc2VsZWN0VmlzaWJsZU9wdGlvbnM6IDUsXG4gIHNlbGVjdEZpbHRlcjogITEsXG4gIHNlbGVjdEZpbHRlckRlYm91bmNlOiAzMDAsXG4gIHNlbGVjdE5vUmVzdWx0VGV4dDogXCJObyByZXN1bHRzXCIsXG4gIHNlbGVjdFZhbGlkYXRpb246ICExLFxuICBzZWxlY3RWYWxpZEZlZWRiYWNrOiBcIlZhbGlkXCIsXG4gIHNlbGVjdEludmFsaWRGZWVkYmFjazogXCJJbnZhbGlkXCIsXG4gIHNlbGVjdFBsYWNlaG9sZGVyOiBcIlwiXG59LCBSYiA9IHtcbiAgc2VsZWN0QXV0b1NlbGVjdDogXCJib29sZWFuXCIsXG4gIHNlbGVjdENvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdXR0b246IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlZDogXCJib29sZWFuXCIsXG4gIHNlbGVjdERpc3BsYXllZExhYmVsczogXCJudW1iZXJcIixcbiAgc2VsZWN0Rm9ybVdoaXRlOiBcImJvb2xlYW5cIixcbiAgbXVsdGlwbGU6IFwiYm9vbGVhblwiLFxuICBzZWxlY3RPcHRpb25zU2VsZWN0ZWRMYWJlbDogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uSGVpZ2h0OiBcIm51bWJlclwiLFxuICBzZWxlY3RBbGw6IFwiYm9vbGVhblwiLFxuICBzZWxlY3RBbGxMYWJlbDogXCJzdHJpbmdcIixcbiAgc2VsZWN0U2VhcmNoUGxhY2Vob2xkZXI6IFwic3RyaW5nXCIsXG4gIHNlbGVjdFNpemU6IFwic3RyaW5nXCIsXG4gIHNlbGVjdFZpc2libGVPcHRpb25zOiBcIm51bWJlclwiLFxuICBzZWxlY3RGaWx0ZXI6IFwiYm9vbGVhblwiLFxuICBzZWxlY3RGaWx0ZXJEZWJvdW5jZTogXCJudW1iZXJcIixcbiAgc2VsZWN0Tm9SZXN1bHRUZXh0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RWYWxpZGF0aW9uOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0VmFsaWRGZWVkYmFjazogXCJzdHJpbmdcIixcbiAgc2VsZWN0SW52YWxpZEZlZWRiYWNrOiBcInN0cmluZ1wiLFxuICBzZWxlY3RQbGFjZWhvbGRlcjogXCJzdHJpbmdcIlxufSwgUGIgPSB7XG4gIGRyb3Bkb3duOiBcInJlbGF0aXZlIG91dGxpbmUtbm9uZSBtaW4tdy1bMTAwcHhdIG0tMCBzY2FsZS15LVswLjhdIG9wYWNpdHktMCBiZy13aGl0ZSBzaGFkb3ctWzBfMnB4XzVweF8wX3JnYmEoMCwwLDAsMC4xNiksXzBfMnB4XzEwcHhfMF9yZ2JhKDAsMCwwLDAuMTIpXSB0cmFuc2l0aW9uIGR1cmF0aW9uLTIwMCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXRhLVt0ZS1zZWxlY3Qtb3Blbl06c2NhbGUtMTAwIGRhdGEtW3RlLXNlbGVjdC1vcGVuXTpvcGFjaXR5LTEwMCBkYXJrOmJnLXppbmMtNzAwXCIsXG4gIGZvcm1DaGVja0lucHV0OiBcInJlbGF0aXZlIGZsb2F0LWxlZnQgbXQtWzAuMTVyZW1dIG1yLVs4cHhdIGgtWzEuMTI1cmVtXSB3LVsxLjEyNXJlbV0gYXBwZWFyYW5jZS1ub25lIHJvdW5kZWQtWzAuMjVyZW1dIGJvcmRlci1bMC4xMjVyZW1dIGJvcmRlci1zb2xpZCBib3JkZXItbmV1dHJhbC0zMDAgZGFyazpib3JkZXItbmV1dHJhbC02MDAgb3V0bGluZS1ub25lIGJlZm9yZTpwb2ludGVyLWV2ZW50cy1ub25lIGJlZm9yZTphYnNvbHV0ZSBiZWZvcmU6aC1bMC44NzVyZW1dIGJlZm9yZTp3LVswLjg3NXJlbV0gYmVmb3JlOnNjYWxlLTAgYmVmb3JlOnJvdW5kZWQtZnVsbCBiZWZvcmU6YmctdHJhbnNwYXJlbnQgYmVmb3JlOm9wYWNpdHktMCBiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3RyYW5zcGFyZW50XSBiZWZvcmU6Y29udGVudC1bJyddIGNoZWNrZWQ6Ym9yZGVyLXByaW1hcnkgZGFyazpjaGVja2VkOmJvcmRlci1wcmltYXJ5IGNoZWNrZWQ6YmctcHJpbWFyeSBkYXJrOmNoZWNrZWQ6YmctcHJpbWFyeSBjaGVja2VkOmJlZm9yZTpvcGFjaXR5LVswLjE2XSBjaGVja2VkOmFmdGVyOmFic29sdXRlIGNoZWNrZWQ6YWZ0ZXI6bWwtWzAuMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6LW10LXB4IGNoZWNrZWQ6YWZ0ZXI6YmxvY2sgY2hlY2tlZDphZnRlcjpoLVswLjgxMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6dy1bMC4zNzVyZW1dIGNoZWNrZWQ6YWZ0ZXI6cm90YXRlLTQ1IGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLVswLjEyNXJlbV0gY2hlY2tlZDphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLWwtMCBjaGVja2VkOmFmdGVyOmJvcmRlci1zb2xpZCBjaGVja2VkOmFmdGVyOmJvcmRlci13aGl0ZSBjaGVja2VkOmFmdGVyOmJnLXRyYW5zcGFyZW50IGNoZWNrZWQ6YWZ0ZXI6Y29udGVudC1bJyddIGhvdmVyOmN1cnNvci1wb2ludGVyIGhvdmVyOmJlZm9yZTpvcGFjaXR5LVswLjA0XSBob3ZlcjpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMCwwLDAsMC42KV0gZm9jdXM6c2hhZG93LW5vbmUgZm9jdXM6dHJhbnNpdGlvbi1bYm9yZGVyLWNvbG9yXzAuMnNdIGZvY3VzOmJlZm9yZTpzY2FsZS0xMDAgZm9jdXM6YmVmb3JlOm9wYWNpdHktWzAuMTJdIGZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgwLDAsMCwwLjYpXSBkYXJrOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgyNTUsMjU1LDI1NSwwLjQpXSBmb2N1czpiZWZvcmU6dHJhbnNpdGlvbi1bYm94LXNoYWRvd18wLjJzLHRyYW5zZm9ybV8wLjJzXSBmb2N1czphZnRlcjphYnNvbHV0ZSBmb2N1czphZnRlcjp6LVsxXSBmb2N1czphZnRlcjpibG9jayBmb2N1czphZnRlcjpoLVswLjg3NXJlbV0gZm9jdXM6YWZ0ZXI6dy1bMC44NzVyZW1dIGZvY3VzOmFmdGVyOnJvdW5kZWQtWzAuMTI1cmVtXSBmb2N1czphZnRlcjpjb250ZW50LVsnJ10gY2hlY2tlZDpmb2N1czpiZWZvcmU6c2NhbGUtMTAwIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBkYXJrOmNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBjaGVja2VkOmZvY3VzOmJlZm9yZTp0cmFuc2l0aW9uLVtib3gtc2hhZG93XzAuMnMsdHJhbnNmb3JtXzAuMnNdIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6bWwtWzAuMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6LW10LXB4IGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6aC1bMC44MTI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOnctWzAuMzc1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOnJvdGF0ZS00NSBjaGVja2VkOmZvY3VzOmFmdGVyOnJvdW5kZWQtbm9uZSBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1bMC4xMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXQtMCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1sLTAgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItc29saWQgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItd2hpdGUgY2hlY2tlZDpmb2N1czphZnRlcjpiZy10cmFuc3BhcmVudFwiLFxuICBmb3JtT3V0bGluZTogXCJyZWxhdGl2ZVwiLFxuICBpbml0aWFsaXplZDogXCJoaWRkZW5cIixcbiAgaW5wdXRHcm91cDogXCJmbGV4IGl0ZW1zLWNlbnRlciB3aGl0ZXNwYWNlLW5vd3JhcCBwLTIuNSB0ZXh0LWNlbnRlciB0ZXh0LWJhc2UgZm9udC1ub3JtYWwgbGVhZGluZy1bMS42XSB0ZXh0LWdyYXktNzAwIGRhcms6YmctemluYy04MDAgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6cGxhY2Vob2xkZXI6dGV4dC1ncmF5LTIwMFwiLFxuICBub1Jlc3VsdDogXCJmbGV4IGl0ZW1zLWNlbnRlciBweC00XCIsXG4gIG9wdGlvbnNMaXN0OiBcImxpc3Qtbm9uZSBtLTAgcC0wXCIsXG4gIG9wdGlvbnNXcmFwcGVyOiBcIm92ZXJmbG93LXktYXV0b1wiLFxuICBvcHRpb25zV3JhcHBlclNjcm9sbGJhcjogXCJbJjo6LXdlYmtpdC1zY3JvbGxiYXJdOnctMSBbJjo6LXdlYmtpdC1zY3JvbGxiYXJdOmgtMSBbJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uXTpibG9jayBbJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uXTpoLTAgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbl06YmctdHJhbnNwYXJlbnQgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrLXBpZWNlXTpiZy10cmFuc3BhcmVudCBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VdOnJvdW5kZWQtbm9uZSBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VdOiBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VdOnJvdW5kZWQtbCBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJdOmgtWzUwcHhdIFsmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYl06YmctWyM5OTldIFsmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYl06cm91bmRlZFwiLFxuICBzZWxlY3RBcnJvdzogXCJhYnNvbHV0ZSByaWdodC0zIHRleHQtWzAuOHJlbV0gY3Vyc29yLXBvaW50ZXIgcGVlci1mb2N1czp0ZXh0LXByaW1hcnkgcGVlci1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTp0ZXh0LXByaW1hcnkgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjpwZWVyLXZhbGlkOnRleHQtZ3JlZW4tNjAwIGdyb3VwLWRhdGEtW3RlLXdhcy12YWxpZGF0ZWRdL3ZhbGlkYXRpb246cGVlci1pbnZhbGlkOnRleHQtW3JnYigyMjAsNzYsMTAwKV0gdy01IGgtNVwiLFxuICBzZWxlY3RBcnJvd1doaXRlOiBcInRleHQtZ3JheS01MCBwZWVyLWZvY3VzOiF0ZXh0LXdoaXRlIHBlZXItZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06IXRleHQtd2hpdGVcIixcbiAgc2VsZWN0QXJyb3dEZWZhdWx0OiBcInRvcC0yXCIsXG4gIHNlbGVjdEFycm93TGc6IFwidG9wLVsxM3B4XVwiLFxuICBzZWxlY3RBcnJvd1NtOiBcInRvcC0xXCIsXG4gIHNlbGVjdENsZWFyQnRuOiBcImFic29sdXRlIHRvcC0yIHJpZ2h0LTkgdGV4dC1ibGFjayBjdXJzb3ItcG9pbnRlciBmb2N1czp0ZXh0LXByaW1hcnkgb3V0bGluZS1ub25lIGRhcms6dGV4dC1ncmF5LTIwMFwiLFxuICBzZWxlY3RDbGVhckJ0bldoaXRlOiBcIiF0ZXh0LWdyYXktNTBcIixcbiAgc2VsZWN0Q2xlYXJCdG5EZWZhdWx0OiBcInRvcC0yIHRleHQtYmFzZVwiLFxuICBzZWxlY3RDbGVhckJ0bkxnOiBcInRvcC1bMTFweF0gdGV4dC1iYXNlXCIsXG4gIHNlbGVjdENsZWFyQnRuU206IFwidG9wLTEgdGV4dC1bMC44cmVtXVwiLFxuICBzZWxlY3REcm9wZG93bkNvbnRhaW5lcjogXCJ6LVsxMDcwXVwiLFxuICBzZWxlY3RGYWtlVmFsdWU6IFwidHJhbnNmb3JtLW5vbmUgaGlkZGVuIGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06YmxvY2tcIixcbiAgc2VsZWN0RmlsdGVySW5wdXQ6IFwicmVsYXRpdmUgbS0wIGJsb2NrIHctZnVsbCBtaW4tdy0wIGZsZXgtYXV0byByb3VuZGVkIGJvcmRlciBib3JkZXItc29saWQgYm9yZGVyLWdyYXktMzAwIGJnLXRyYW5zcGFyZW50IGJnLWNsaXAtcGFkZGluZyBweC0zIHB5LTEuNSB0ZXh0LWJhc2UgZm9udC1ub3JtYWwgdGV4dC1ncmF5LTcwMCB0cmFuc2l0aW9uIGR1cmF0aW9uLTMwMCBlYXNlLWluLW91dCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBmb2N1czpib3JkZXItcHJpbWFyeSBmb2N1czp0ZXh0LWdyYXktNzAwIGZvY3VzOnNoYWRvdy10ZS1wcmltYXJ5IGZvY3VzOm91dGxpbmUtbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwbGFjZWhvbGRlcjp0ZXh0LWdyYXktMjAwXCIsXG4gIHNlbGVjdElucHV0OiBcInBlZXIgYmxvY2sgbWluLWgtW2F1dG9dIHctZnVsbCByb3VuZGVkIGJvcmRlci0wIGJnLXRyYW5zcGFyZW50IG91dGxpbmUtbm9uZSB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgZm9jdXM6cGxhY2Vob2xkZXI6b3BhY2l0eS0xMDAgZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpwbGFjZWhvbGRlcjpvcGFjaXR5LTEwMCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwbGFjZWhvbGRlcjp0ZXh0LWdyYXktMjAwIFsmOm5vdChbZGF0YS10ZS1pbnB1dC1wbGFjZWhvbGRlci1hY3RpdmVdKV06cGxhY2Vob2xkZXI6b3BhY2l0eS0wIGN1cnNvci1wb2ludGVyIGRhdGEtW3RlLWlucHV0LWRpc2FibGVkXTpiZy1bI2U5ZWNlZl0gZGF0YS1bdGUtaW5wdXQtZGlzYWJsZWRdOmN1cnNvci1kZWZhdWx0IGdyb3VwLWRhdGEtW3RlLXdhcy12YWxpZGF0ZWRdL3ZhbGlkYXRpb246bWItNCBkYXJrOmRhdGEtW3RlLWlucHV0LWRpc2FibGVkXTpiZy16aW5jLTYwMFwiLFxuICBzZWxlY3RJbnB1dFdoaXRlOiBcIiF0ZXh0LWdyYXktNTBcIixcbiAgc2VsZWN0SW5wdXRTaXplRGVmYXVsdDogXCJweS1bMC4zMnJlbV0gcHgtMyBsZWFkaW5nLVsxLjZdXCIsXG4gIHNlbGVjdElucHV0U2l6ZUxnOiBcInB5LVswLjMycmVtXSBweC0zIGxlYWRpbmctWzIuMTVdXCIsXG4gIHNlbGVjdElucHV0U2l6ZVNtOiBcInB5LVswLjMzcmVtXSBweC0zIHRleHQteHMgbGVhZGluZy1bMS41XVwiLFxuICBzZWxlY3RMYWJlbDogXCJwb2ludGVyLWV2ZW50cy1ub25lIGFic29sdXRlIHRvcC0wIGxlZnQtMyBtYi0wIG1heC13LVs5MCVdIG9yaWdpbi1bMF8wXSB0cnVuY2F0ZSB0ZXh0LWdyYXktNTAwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLW91dCBwZWVyLWZvY3VzOnNjYWxlLVswLjhdIHBlZXItZm9jdXM6dGV4dC1wcmltYXJ5IHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpzY2FsZS1bMC44XSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwZWVyLWZvY3VzOnRleHQtZ3JheS0yMDAgZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpzY2FsZS1bMC44XSBkYXJrOnBlZXItZm9jdXM6dGV4dC1wcmltYXJ5XCIsXG4gIHNlbGVjdExhYmVsV2hpdGU6IFwiIXRleHQtZ3JheS01MFwiLFxuICBzZWxlY3RMYWJlbFNpemVEZWZhdWx0OiBcInB0LVswLjM3cmVtXSBsZWFkaW5nLVsxLjZdIHBlZXItZm9jdXM6LXRyYW5zbGF0ZS15LVswLjlyZW1dIHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzAuOXJlbV0gZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzAuOXJlbV1cIixcbiAgc2VsZWN0TGFiZWxTaXplTGc6IFwicHQtWzAuMzdyZW1dIGxlYWRpbmctWzIuMTVdIHBlZXItZm9jdXM6LXRyYW5zbGF0ZS15LVsxLjE1cmVtXSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVsxLjE1cmVtXSBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMS4xNXJlbV1cIixcbiAgc2VsZWN0TGFiZWxTaXplU206IFwicHQtWzAuMzdyZW1dIHRleHQteHMgbGVhZGluZy1bMS41XSBwZWVyLWZvY3VzOi10cmFuc2xhdGUteS1bMC43NXJlbV0gcGVlci1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC43NXJlbV0gZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzAuNzVyZW1dXCIsXG4gIHNlbGVjdE9wdGlvbjogXCJmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gdy1mdWxsIHB4LTQgdHJ1bmNhdGUgdGV4dC1ncmF5LTcwMCBiZy10cmFuc3BhcmVudCBzZWxlY3Qtbm9uZSBjdXJzb3ItcG9pbnRlciBkYXRhLVt0ZS1pbnB1dC1tdWx0aXBsZS1hY3RpdmVdOmJnLWJsYWNrLzUgaG92ZXI6WyY6bm90KFtkYXRhLXRlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdKV06YmctYmxhY2svNSBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJnLWJsYWNrLzUgZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1zZWxlY3RlZF06ZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpiZy1ibGFjay81IGRhdGEtW3RlLXNlbGVjdC1zZWxlY3RlZF06ZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZGF0YS1bdGUtc2VsZWN0LXNlbGVjdGVkXTpkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTp0ZXh0LWdyYXktNDAwIGRhdGEtW3RlLXNlbGVjdC1zZWxlY3RlZF06ZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06YmctdHJhbnNwYXJlbnQgZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1zZWxlY3RlZF06YmctYmxhY2svWzAuMDJdIGRhdGEtW3RlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdOnRleHQtZ3JheS00MDAgZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZ3JvdXAtZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1ncm91cC1yZWZdL29wdDpwbC03IGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOmhvdmVyOlsmOm5vdChbZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXSldOmJnLXdoaXRlLzMwIGRhcms6ZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpiZy13aGl0ZS8zMCBkYXJrOmRhdGEtW3RlLXNlbGVjdC1vcHRpb24tc2VsZWN0ZWRdOmRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ymctd2hpdGUvMzAgZGFyazpkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTp0ZXh0LWdyYXktNDAwIGRhcms6ZGF0YS1bdGUtaW5wdXQtbXVsdGlwbGUtYWN0aXZlXTpiZy13aGl0ZS8zMFwiLFxuICBzZWxlY3RBbGxPcHRpb246IFwiXCIsXG4gIHNlbGVjdE9wdGlvbkdyb3VwOiBcImdyb3VwL29wdFwiLFxuICBzZWxlY3RPcHRpb25Hcm91cExhYmVsOiBcImZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIHctZnVsbCBweC00IHRydW5jYXRlIGJnLXRyYW5zcGFyZW50IHRleHQtYmxhY2svNTAgc2VsZWN0LW5vbmUgZGFyazp0ZXh0LWdyYXktMzAwXCIsXG4gIHNlbGVjdE9wdGlvbkljb246IFwidy03IGgtNyByb3VuZGVkLWZ1bGxcIixcbiAgc2VsZWN0T3B0aW9uU2Vjb25kYXJ5VGV4dDogXCJibG9jayB0ZXh0LVswLjhyZW1dIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LWdyYXktMzAwXCIsXG4gIHNlbGVjdE9wdGlvblRleHQ6IFwiZ3JvdXBcIixcbiAgc2VsZWN0VmFsaWRhdGlvblZhbGlkOiBcImhpZGRlbiBhYnNvbHV0ZSAtbXQtMyB3LWF1dG8gdGV4dC1zbSB0ZXh0LWdyZWVuLTYwMCBjdXJzb3ItcG9pbnRlciBncm91cC1kYXRhLVt0ZS13YXMtdmFsaWRhdGVkXS92YWxpZGF0aW9uOnBlZXItdmFsaWQ6YmxvY2tcIixcbiAgc2VsZWN0VmFsaWRhdGlvbkludmFsaWQ6IFwiaGlkZGVuIGFic29sdXRlIC1tdC0zIHctYXV0byB0ZXh0LXNtIHRleHQtW3JnYigyMjAsNzYsMTAwKV0gY3Vyc29yLXBvaW50ZXIgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjpwZWVyLWludmFsaWQ6YmxvY2tcIlxufSwgQmIgPSB7XG4gIGRyb3Bkb3duOiBcInN0cmluZ1wiLFxuICBmb3JtQ2hlY2tJbnB1dDogXCJzdHJpbmdcIixcbiAgZm9ybU91dGxpbmU6IFwic3RyaW5nXCIsXG4gIGluaXRpYWxpemVkOiBcInN0cmluZ1wiLFxuICBpbnB1dEdyb3VwOiBcInN0cmluZ1wiLFxuICBub1Jlc3VsdDogXCJzdHJpbmdcIixcbiAgb3B0aW9uc0xpc3Q6IFwic3RyaW5nXCIsXG4gIG9wdGlvbnNXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBvcHRpb25zV3JhcHBlclNjcm9sbGJhcjogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3c6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEFycm93RGVmYXVsdDogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3dMZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3dTbTogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG46IFwic3RyaW5nXCIsXG4gIHNlbGVjdENsZWFyQnRuRGVmYXVsdDogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG5MZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG5TbTogXCJzdHJpbmdcIixcbiAgc2VsZWN0RHJvcGRvd25Db250YWluZXI6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEZha2VWYWx1ZTogXCJzdHJpbmdcIixcbiAgc2VsZWN0RmlsdGVySW5wdXQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdElucHV0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJbnB1dFNpemVEZWZhdWx0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJbnB1dFNpemVMZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0SW5wdXRTaXplU206IFwic3RyaW5nXCIsXG4gIHNlbGVjdExhYmVsOiBcInN0cmluZ1wiLFxuICBzZWxlY3RMYWJlbFNpemVEZWZhdWx0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RMYWJlbFNpemVMZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0TGFiZWxTaXplU206IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbjogXCJzdHJpbmdcIixcbiAgc2VsZWN0QWxsT3B0aW9uOiBcInN0cmluZ1wiLFxuICBzZWxlY3RPcHRpb25Hcm91cDogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uR3JvdXBMYWJlbDogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uSWNvbjogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uU2Vjb25kYXJ5VGV4dDogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uVGV4dDogXCJzdHJpbmdcIlxufTtcbmNsYXNzIGtyIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9jb25maWcuc2VsZWN0UGxhY2Vob2xkZXIgJiYgIXRoaXMuX2NvbmZpZy5tdWx0aXBsZSAmJiB0aGlzLl9hZGRQbGFjZWhvbGRlck9wdGlvbigpLCB0aGlzLl9vcHRpb25zVG9SZW5kZXIgPSB0aGlzLl9nZXRPcHRpb25zVG9SZW5kZXIodCksIHRoaXMuX3BsYWluT3B0aW9ucyA9IHRoaXMuX2dldFBsYWluT3B0aW9ucyh0aGlzLl9vcHRpb25zVG9SZW5kZXIpLCB0aGlzLl9maWx0ZXJlZE9wdGlvbnNMaXN0ID0gbnVsbCwgdGhpcy5fc2VsZWN0aW9uTW9kZWwgPSBuZXcgVWcodGhpcy5tdWx0aXBsZSksIHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ID0gLTEsIHRoaXMuX2FjdGl2ZU9wdGlvbiA9IG51bGwsIHRoaXMuX3dyYXBwZXJJZCA9IGV0KFwic2VsZWN0LXdyYXBwZXItXCIpLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcklkID0gZXQoXCJzZWxlY3QtZHJvcGRvd24tY29udGFpbmVyLVwiKSwgdGhpcy5fc2VsZWN0QWxsSWQgPSBldChcInNlbGVjdC1hbGwtXCIpLCB0aGlzLl9kZWJvdW5jZVRpbWVvdXRJZCA9IG51bGwsIHRoaXMuX2Ryb3Bkb3duSGVpZ2h0ID0gdGhpcy5fY29uZmlnLnNlbGVjdE9wdGlvbkhlaWdodCAqIHRoaXMuX2NvbmZpZy5zZWxlY3RWaXNpYmxlT3B0aW9ucywgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5faW5wdXQgPSBudWxsLCB0aGlzLl9sYWJlbCA9IGQubmV4dCh0aGlzLl9lbGVtZW50LCBrYilbMF0sIHRoaXMuX25vdGNoID0gbnVsbCwgdGhpcy5fZmFrZVZhbHVlID0gbnVsbCwgdGhpcy5faXNGYWtlVmFsdWVBY3RpdmUgPSAhMSwgdGhpcy5fY3VzdG9tQ29udGVudCA9IGQubmV4dChcbiAgICAgIHQsXG4gICAgICAkYlxuICAgIClbMF0sIHRoaXMuX3RvZ2dsZUJ1dHRvbiA9IG51bGwsIHRoaXMuX2VsZW1lbnRUb2dnbGUgPSBudWxsLCB0aGlzLl93cmFwcGVyID0gbnVsbCwgdGhpcy5faW5wdXRFbCA9IG51bGwsIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyID0gbnVsbCwgdGhpcy5fY29udGFpbmVyID0gbnVsbCwgdGhpcy5fc2VsZWN0QWxsT3B0aW9uID0gbnVsbCwgdGhpcy5faW5pdCgpLCB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbnVsbCwgdGhpcy5faXNPcGVuID0gITEsIHRoaXMuX2FkZE11dGF0aW9uT2JzZXJ2ZXIoKSwgdGhpcy5fZWxlbWVudCAmJiBBLnNldERhdGEodCwgeWksIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gbW87XG4gIH1cbiAgZ2V0IGZpbHRlcklucHV0KCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXG4gICAgICB4YixcbiAgICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyXG4gICAgKTtcbiAgfVxuICBnZXQgZHJvcGRvd24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShPYiwgdGhpcy5fZHJvcGRvd25Db250YWluZXIpO1xuICB9XG4gIGdldCBvcHRpb25zTGlzdCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFxuICAgICAgd2wsXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lclxuICAgICk7XG4gIH1cbiAgZ2V0IG9wdGlvbnNXcmFwcGVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXG4gICAgICBTYixcbiAgICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyXG4gICAgKTtcbiAgfVxuICBnZXQgY2xlYXJCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShEYiwgdGhpcy5fd3JhcHBlcik7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlcmVkT3B0aW9uc0xpc3QgPyB0aGlzLl9maWx0ZXJlZE9wdGlvbnNMaXN0IDogdGhpcy5fcGxhaW5PcHRpb25zO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBsZSA/IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnZhbHVlcyA6IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnZhbHVlO1xuICB9XG4gIGdldCBtdWx0aXBsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLm11bHRpcGxlO1xuICB9XG4gIGdldCBoYXNTZWxlY3RBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbGUgJiYgdGhpcy5fY29uZmlnLnNlbGVjdEFsbDtcbiAgfVxuICBnZXQgaGFzU2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb24gfHwgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9ucy5sZW5ndGggPiAwO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uTWIsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKFwibXVsdGlwbGVcIikgJiYgKHQubXVsdGlwbGUgPSAhMCksIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgJiYgKHQuZGlzYWJsZWQgPSAhMCksIHRoaXMuX2VsZW1lbnQudGFiSW5kZXggJiYgKHQudGFiSW5kZXggPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcInRhYkluZGV4XCIpKSwgSShtbywgdCwgUmIpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uUGIsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkobW8sIHQsIEJiKSwgdDtcbiAgfVxuICBfYWRkUGxhY2Vob2xkZXJPcHRpb24oKSB7XG4gICAgY29uc3QgdCA9IG5ldyBPcHRpb24oXCJcIiwgXCJcIiwgITAsICEwKTtcbiAgICB0LmhpZGRlbiA9ICEwLCB0LnNlbGVjdGVkID0gITAsIHRoaXMuX2VsZW1lbnQucHJlcGVuZCh0KTtcbiAgfVxuICBfZ2V0T3B0aW9uc1RvUmVuZGVyKHQpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgcmV0dXJuIHQuY2hpbGROb2Rlcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBpZiAobi5ub2RlTmFtZSA9PT0gXCJPUFRHUk9VUFwiKSB7XG4gICAgICAgIGNvbnN0IG8gPSB7XG4gICAgICAgICAgaWQ6IGV0KFwiZ3JvdXAtXCIpLFxuICAgICAgICAgIGxhYmVsOiBuLmxhYmVsLFxuICAgICAgICAgIGRpc2FibGVkOiBuLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpLFxuICAgICAgICAgIGhpZGRlbjogbi5oYXNBdHRyaWJ1dGUoXCJoaWRkZW5cIiksXG4gICAgICAgICAgb3B0aW9uczogW11cbiAgICAgICAgfTtcbiAgICAgICAgbi5jaGlsZE5vZGVzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgICBhLm5vZGVOYW1lID09PSBcIk9QVElPTlwiICYmIG8ub3B0aW9ucy5wdXNoKFxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlT3B0aW9uT2JqZWN0KGEsIG8pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSksIGUucHVzaChvKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBuLm5vZGVOYW1lID09PSBcIk9QVElPTlwiICYmIGUucHVzaCh0aGlzLl9jcmVhdGVPcHRpb25PYmplY3QobikpO1xuICAgIH0pLCBlO1xuICB9XG4gIF9nZXRQbGFpbk9wdGlvbnModCkge1xuICAgIGlmICghZC5maW5kT25lKFwib3B0Z3JvdXBcIiwgdGhpcy5fZWxlbWVudCkpXG4gICAgICByZXR1cm4gdDtcbiAgICBjb25zdCBpID0gW107XG4gICAgcmV0dXJuIHQuZm9yRWFjaCgobikgPT4ge1xuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuICAgICAgICBuLFxuICAgICAgICBcIm9wdGlvbnNcIlxuICAgICAgKSA/IG4ub3B0aW9ucy5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgIGkucHVzaChyKTtcbiAgICAgIH0pIDogaS5wdXNoKG4pO1xuICAgIH0pLCBpO1xuICB9XG4gIF9jcmVhdGVPcHRpb25PYmplY3QodCwgZSA9IHt9KSB7XG4gICAgY29uc3QgaSA9IGV0KFwib3B0aW9uLVwiKSwgbiA9IGUuaWQgPyBlLmlkIDogbnVsbCwgbyA9IGUuZGlzYWJsZWQgPyBlLmRpc2FibGVkIDogITEsIHIgPSB0LnNlbGVjdGVkIHx8IHQuaGFzQXR0cmlidXRlKGJpKSwgYSA9IHQuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgfHwgbywgbCA9IHQuaGFzQXR0cmlidXRlKFwiaGlkZGVuXCIpIHx8IGUgJiYgZS5oaWRkZW4sIHAgPSB0aGlzLm11bHRpcGxlLCB1ID0gdC52YWx1ZSwgXyA9IHQubGFiZWwsIGYgPSBoLmdldERhdGFBdHRyaWJ1dGUoXG4gICAgICB0LFxuICAgICAgXCJzZWxlY3RTZWNvbmRhcnlUZXh0XCJcbiAgICApLCBnID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwic2VsZWN0LWljb25cIik7XG4gICAgcmV0dXJuIG5ldyBibChcbiAgICAgIGksXG4gICAgICB0LFxuICAgICAgcCxcbiAgICAgIHUsXG4gICAgICBfLFxuICAgICAgcixcbiAgICAgIGEsXG4gICAgICBsLFxuICAgICAgZixcbiAgICAgIG4sXG4gICAgICBnXG4gICAgKTtcbiAgfVxuICBfZ2V0TmF2aWdhdGlvbk9wdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucy5maWx0ZXIoKGUpID0+ICFlLmhpZGRlbik7XG4gICAgcmV0dXJuIHRoaXMuaGFzU2VsZWN0QWxsID8gW3RoaXMuX3NlbGVjdEFsbE9wdGlvbiwgLi4udF0gOiB0O1xuICB9XG4gIF9pbml0KCkge1xuICAgIHRoaXMuX3JlbmRlck1hdGVyaWFsV3JhcHBlcigpLCB0aGlzLl93cmFwcGVyID0gZC5maW5kT25lKGAjJHt0aGlzLl93cmFwcGVySWR9YCksIHRoaXMuX2lucHV0ID0gZC5maW5kT25lKHlsLCB0aGlzLl93cmFwcGVyKSwgdGhpcy5fY29uZmlnLmRpc2FibGVkICYmIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShnbywgXCJcIik7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NvbmZpZy5zZWxlY3RDb250YWluZXI7XG4gICAgdCA9PT0gXCJib2R5XCIgPyB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5ib2R5IDogdGhpcy5fY29udGFpbmVyID0gZC5maW5kT25lKHQpLCB0aGlzLl9pbml0T3V0bGluZUlucHV0KCksIHRoaXMuX3NldERlZmF1bHRTZWxlY3Rpb25zKCksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fYXBwZW5kRmFrZVZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCksIHRoaXMuX2JpbmRDb21wb25lbnRFdmVudHMoKSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgKHRoaXMuX3NlbGVjdEFsbE9wdGlvbiA9IHRoaXMuX2NyZWF0ZVNlbGVjdEFsbE9wdGlvbigpKSwgdGhpcy5fZHJvcGRvd25Db250YWluZXIgPSB2bChcbiAgICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVySWQsXG4gICAgICB0aGlzLl9jb25maWcsXG4gICAgICB0aGlzLl9pbnB1dC5vZmZzZXRXaWR0aCxcbiAgICAgIHRoaXMuX2Ryb3Bkb3duSGVpZ2h0LFxuICAgICAgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLFxuICAgICAgdGhpcy5fb3B0aW9uc1RvUmVuZGVyLFxuICAgICAgdGhpcy5fY3VzdG9tQ29udGVudCxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLl9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpLCB0aGlzLl9saXN0ZW5Ub0ZvY3VzQ2hhbmdlKCk7XG4gIH1cbiAgX3JlbmRlck1hdGVyaWFsV3JhcHBlcigpIHtcbiAgICBjb25zdCB0ID0gaGIoXG4gICAgICB0aGlzLl93cmFwcGVySWQsXG4gICAgICB0aGlzLl9jb25maWcsXG4gICAgICB0aGlzLl9sYWJlbCxcbiAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICB0aGlzLl9jb25maWcuY3VzdG9tQXJyb3dcbiAgICApO1xuICAgIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodCwgdGhpcy5fZWxlbWVudCksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5pbml0aWFsaXplZCksIHQuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgX2luaXRPdXRsaW5lSW5wdXQoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgIGtsLFxuICAgICAgdGhpcy5fd3JhcHBlclxuICAgICk7XG4gICAgbmV3IFYoXG4gICAgICB0LFxuICAgICAge1xuICAgICAgICBpbnB1dEZvcm1XaGl0ZTogdGhpcy5fY29uZmlnLnNlbGVjdEZvcm1XaGl0ZVxuICAgICAgfSxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLmluaXQoKSwgdGhpcy5fbm90Y2ggPSBkLmZpbmRPbmUoYm8sIHRoaXMuX3dyYXBwZXIpO1xuICB9XG4gIF9iaW5kQ29tcG9uZW50RXZlbnRzKCkge1xuICAgIHRoaXMuX2xpc3RlblRvQ29tcG9uZW50S2V5ZG93bigpLCB0aGlzLl9saXN0ZW5Ub1dyYXBwZXJDbGljaygpLCB0aGlzLl9saXN0ZW5Ub0NsZWFyQnRuQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9DbGVhckJ0bktleWRvd24oKTtcbiAgfVxuICBfc2V0RGVmYXVsdFNlbGVjdGlvbnMoKSB7XG4gICAgdGhpcy5vcHRpb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuc2VsZWN0ZWQgJiYgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHQpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0NvbXBvbmVudEtleWRvd24oKSB7XG4gICAgYy5vbih0aGlzLl93cmFwcGVyLCBcImtleWRvd25cIiwgdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKTtcbiAgfVxuICBfaGFuZGxlS2V5ZG93bih0KSB7XG4gICAgdGhpcy5faXNPcGVuICYmICF0aGlzLl9jb25maWcuc2VsZWN0RmlsdGVyID8gdGhpcy5faGFuZGxlT3BlbktleWRvd24odCkgOiB0aGlzLl9oYW5kbGVDbG9zZWRLZXlkb3duKHQpO1xuICB9XG4gIF9oYW5kbGVPcGVuS2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHQua2V5Q29kZSwgaSA9IGUgPT09IHdlIHx8IGUgPT09IFUgJiYgdC5hbHRLZXkgfHwgZSA9PT0ga2U7XG4gICAgaWYgKGUgPT09IGtlICYmIHRoaXMuX2NvbmZpZy5zZWxlY3RBdXRvU2VsZWN0ICYmICF0aGlzLm11bHRpcGxlICYmIHRoaXMuX2hhbmRsZUF1dG9TZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKSwgaSkge1xuICAgICAgdGhpcy5jbG9zZSgpLCB0aGlzLl9pbnB1dC5mb2N1cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGUpIHtcbiAgICAgIGNhc2UgejpcbiAgICAgICAgdGhpcy5fc2V0TmV4dE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9zY3JvbGxUb09wdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVTpcbiAgICAgICAgdGhpcy5fc2V0UHJldmlvdXNPcHRpb25BY3RpdmUoKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlOlxuICAgICAgICB0aGlzLl9zZXRGaXJzdE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9zY3JvbGxUb09wdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRWU6XG4gICAgICAgIHRoaXMuX3NldExhc3RPcHRpb25BY3RpdmUoKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGl0OlxuICAgICAgICB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2FjdGl2ZU9wdGlvbiAmJiAodGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggPT09IDAgPyB0aGlzLl9oYW5kbGVTZWxlY3RBbGwoKSA6IHRoaXMuX2hhbmRsZVNlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX2hhbmRsZUNsb3NlZEtleWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0LmtleUNvZGU7XG4gICAgaWYgKGUgPT09IGl0ICYmIHQucHJldmVudERlZmF1bHQoKSwgKGUgPT09IGl0IHx8IGUgPT09IHogJiYgdC5hbHRLZXkgfHwgZSA9PT0geiAmJiB0aGlzLm11bHRpcGxlKSAmJiB0aGlzLm9wZW4oKSwgdGhpcy5tdWx0aXBsZSlcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIHo6XG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVTpcbiAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgejpcbiAgICAgICAgICB0aGlzLl9zZXROZXh0T3B0aW9uQWN0aXZlKCksIHRoaXMuX2hhbmRsZVNlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFU6XG4gICAgICAgICAgdGhpcy5fc2V0UHJldmlvdXNPcHRpb25BY3RpdmUoKSwgdGhpcy5faGFuZGxlU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVGU6XG4gICAgICAgICAgdGhpcy5fc2V0Rmlyc3RPcHRpb25BY3RpdmUoKSwgdGhpcy5faGFuZGxlU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRWU6XG4gICAgICAgICAgdGhpcy5fc2V0TGFzdE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9oYW5kbGVTZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIF9zY3JvbGxUb09wdGlvbih0KSB7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBlO1xuICAgIGNvbnN0IGkgPSB0aGlzLm9wdGlvbnMuZmlsdGVyKCh1KSA9PiAhdS5oaWRkZW4pO1xuICAgIHRoaXMuaGFzU2VsZWN0QWxsID8gZSA9IGkuaW5kZXhPZih0KSArIDEgOiBlID0gaS5pbmRleE9mKHQpO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9nZXROdW1iZXJPZkdyb3Vwc0JlZm9yZU9wdGlvbihlKSwgbyA9IGUgKyBuLCByID0gdGhpcy5vcHRpb25zV3JhcHBlciwgYSA9IHIub2Zmc2V0SGVpZ2h0LCBsID0gdGhpcy5fY29uZmlnLnNlbGVjdE9wdGlvbkhlaWdodCwgcCA9IHIuc2Nyb2xsVG9wO1xuICAgIGlmIChlID4gLTEpIHtcbiAgICAgIGNvbnN0IHUgPSBvICogbCwgXyA9IHUgKyBsID4gcCArIGE7XG4gICAgICB1IDwgcCA/IHIuc2Nyb2xsVG9wID0gdSA6IF8gPyByLnNjcm9sbFRvcCA9IHUgLSBhICsgbCA6IHIuc2Nyb2xsVG9wID0gcDtcbiAgICB9XG4gIH1cbiAgX2dldE51bWJlck9mR3JvdXBzQmVmb3JlT3B0aW9uKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zLmZpbHRlcigocikgPT4gIXIuaGlkZGVuKSwgaSA9IHRoaXMuX29wdGlvbnNUb1JlbmRlci5maWx0ZXIoKHIpID0+ICFyLmhpZGRlbiksIG4gPSB0aGlzLmhhc1NlbGVjdEFsbCA/IHQgLSAxIDogdDtcbiAgICBsZXQgbyA9IDA7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPD0gbjsgcisrKVxuICAgICAgZVtyXS5ncm91cElkICYmIGlbb10gJiYgaVtvXS5pZCAmJiBlW3JdLmdyb3VwSWQgPT09IGlbb10uaWQgJiYgbysrO1xuICAgIHJldHVybiBvO1xuICB9XG4gIF9zZXROZXh0T3B0aW9uQWN0aXZlKCkge1xuICAgIGxldCB0ID0gdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggKyAxO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXROYXZpZ2F0aW9uT3B0aW9ucygpO1xuICAgIGlmIChlW3RdKSB7XG4gICAgICBmb3IgKDsgZVt0XS5kaXNhYmxlZDsgKVxuICAgICAgICBpZiAodCArPSAxLCAhZVt0XSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl91cGRhdGVBY3RpdmVPcHRpb24oZVt0XSwgdCk7XG4gICAgfVxuICB9XG4gIF9zZXRQcmV2aW91c09wdGlvbkFjdGl2ZSgpIHtcbiAgICBsZXQgdCA9IHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4IC0gMTtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0TmF2aWdhdGlvbk9wdGlvbnMoKTtcbiAgICBpZiAoZVt0XSkge1xuICAgICAgZm9yICg7IGVbdF0uZGlzYWJsZWQ7IClcbiAgICAgICAgaWYgKHQgLT0gMSwgIWVbdF0pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fdXBkYXRlQWN0aXZlT3B0aW9uKGVbdF0sIHQpO1xuICAgIH1cbiAgfVxuICBfc2V0Rmlyc3RPcHRpb25BY3RpdmUoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldE5hdmlnYXRpb25PcHRpb25zKCk7XG4gICAgdGhpcy5fdXBkYXRlQWN0aXZlT3B0aW9uKGVbMF0sIDApO1xuICB9XG4gIF9zZXRMYXN0T3B0aW9uQWN0aXZlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9nZXROYXZpZ2F0aW9uT3B0aW9ucygpLCBlID0gdC5sZW5ndGggLSAxO1xuICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZU9wdGlvbih0W2VdLCBlKTtcbiAgfVxuICBfdXBkYXRlQWN0aXZlT3B0aW9uKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fYWN0aXZlT3B0aW9uO1xuICAgIGkgJiYgaS5yZW1vdmVBY3RpdmVTdHlsZXMoKSwgdC5zZXRBY3RpdmVTdHlsZXMoKSwgdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggPSBlLCB0aGlzLl9hY3RpdmVPcHRpb24gPSB0O1xuICB9XG4gIF9saXN0ZW5Ub1dyYXBwZXJDbGljaygpIHtcbiAgICBjLm9uKHRoaXMuX3dyYXBwZXIsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9DbGVhckJ0bkNsaWNrKCkge1xuICAgIGMub24odGhpcy5jbGVhckJ1dHRvbiwgXCJjbGlja1wiLCAodCkgPT4ge1xuICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LnN0b3BQcm9wYWdhdGlvbigpLCB0aGlzLl9oYW5kbGVDbGVhcigpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0NsZWFyQnRuS2V5ZG93bigpIHtcbiAgICBjLm9uKHRoaXMuY2xlYXJCdXR0b24sIFwia2V5ZG93blwiLCAodCkgPT4ge1xuICAgICAgdC5rZXlDb2RlID09PSBpdCAmJiAodGhpcy5faGFuZGxlQ2xlYXIoKSwgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LnN0b3BQcm9wYWdhdGlvbigpKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQ2xlYXIoKSB7XG4gICAgaWYgKHRoaXMubXVsdGlwbGUpXG4gICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5jbGVhcigpLCB0aGlzLl9kZXNlbGVjdEFsbE9wdGlvbnModGhpcy5vcHRpb25zKSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb247XG4gICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5jbGVhcigpLCB0LmRlc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuX2Zha2VWYWx1ZS50ZXh0Q29udGVudCA9IFwiXCIsIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSwgdGhpcy5fZW1pdFZhbHVlQ2hhbmdlRXZlbnQobnVsbCksIHRoaXMuX2VtaXROYXRpdmVDaGFuZ2VFdmVudCgpO1xuICB9XG4gIF9saXN0ZW5Ub09wdGlvbnNDbGljaygpIHtcbiAgICBjLm9uKHRoaXMub3B0aW9uc1dyYXBwZXIsIFwiY2xpY2tcIiwgKHQpID0+IHtcbiAgICAgIGlmICh0LnRhcmdldC5oYXNBdHRyaWJ1dGUoXG4gICAgICAgIHliXG4gICAgICApKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBpID0gdC50YXJnZXQubm9kZU5hbWUgPT09IFwiRElWXCIgPyB0LnRhcmdldCA6IGQuY2xvc2VzdCh0LnRhcmdldCwgSWIpO1xuICAgICAgaWYgKGkuaGFzQXR0cmlidXRlKHdiKSkge1xuICAgICAgICB0aGlzLl9oYW5kbGVTZWxlY3RBbGwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbyA9IGkuZGF0YXNldC50ZUlkLCByID0gdGhpcy5vcHRpb25zLmZpbmQoKGEpID0+IGEuaWQgPT09IG8pO1xuICAgICAgciAmJiAhci5kaXNhYmxlZCAmJiB0aGlzLl9oYW5kbGVTZWxlY3Rpb24ocik7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVNlbGVjdEFsbCgpIHtcbiAgICB0aGlzLl9zZWxlY3RBbGxPcHRpb24uc2VsZWN0ZWQgPyAodGhpcy5fZGVzZWxlY3RBbGxPcHRpb25zKHRoaXMub3B0aW9ucyksIHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5kZXNlbGVjdCgpKSA6ICh0aGlzLl9zZWxlY3RBbGxPcHRpb25zKHRoaXMub3B0aW9ucyksIHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5zZWxlY3QoKSksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSwgdGhpcy5fZW1pdFZhbHVlQ2hhbmdlRXZlbnQodGhpcy52YWx1ZSksIHRoaXMuX2VtaXROYXRpdmVDaGFuZ2VFdmVudCgpO1xuICB9XG4gIF9zZWxlY3RBbGxPcHRpb25zKHQpIHtcbiAgICB0LmZvckVhY2goKGUpID0+IHtcbiAgICAgICFlLnNlbGVjdGVkICYmICFlLmRpc2FibGVkICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3QoZSksIGUuc2VsZWN0KCkpO1xuICAgIH0pO1xuICB9XG4gIF9kZXNlbGVjdEFsbE9wdGlvbnModCkge1xuICAgIHQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5zZWxlY3RlZCAmJiAhZS5kaXNhYmxlZCAmJiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QoZSksIGUuZGVzZWxlY3QoKSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVNlbGVjdGlvbih0KSB7XG4gICAgdGhpcy5tdWx0aXBsZSA/ICh0aGlzLl9oYW5kbGVNdWx0aVNlbGVjdGlvbih0KSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKSkgOiB0aGlzLl9oYW5kbGVTaW5nbGVTZWxlY3Rpb24odCksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKTtcbiAgfVxuICBfaGFuZGxlQXV0b1NlbGVjdGlvbih0KSB7XG4gICAgdGhpcy5fc2luZ2xlT3B0aW9uU2VsZWN0KHQpLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCk7XG4gIH1cbiAgX2hhbmRsZVNpbmdsZVNlbGVjdGlvbih0KSB7XG4gICAgdGhpcy5fc2luZ2xlT3B0aW9uU2VsZWN0KHQpLCB0aGlzLmNsb3NlKCksIHRoaXMuX2lucHV0LmZvY3VzKCk7XG4gIH1cbiAgX3NpbmdsZU9wdGlvblNlbGVjdCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnNbMF07XG4gICAgZSAmJiBlICE9PSB0ICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdChlKSwgZS5kZXNlbGVjdCgpLCBlLm5vZGUuc2V0QXR0cmlidXRlKGJpLCAhMSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFbCwge1xuICAgICAgdmFsdWU6IGUudmFsdWVcbiAgICB9KSksICghZSB8fCBlICYmIHQgIT09IGUpICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3QodCksIHQuc2VsZWN0KCksIHQubm9kZS5zZXRBdHRyaWJ1dGUoYmksICEwKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFRsLCB7XG4gICAgICB2YWx1ZTogdC52YWx1ZVxuICAgIH0pLCB0aGlzLl9lbWl0VmFsdWVDaGFuZ2VFdmVudCh0aGlzLnZhbHVlKSwgdGhpcy5fZW1pdE5hdGl2ZUNoYW5nZUV2ZW50KCkpO1xuICB9XG4gIF9oYW5kbGVNdWx0aVNlbGVjdGlvbih0KSB7XG4gICAgdC5zZWxlY3RlZCA/ICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdCh0KSwgdC5kZXNlbGVjdCgpLCB0Lm5vZGUuc2V0QXR0cmlidXRlKGJpLCAhMSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFbCwge1xuICAgICAgdmFsdWU6IHQudmFsdWVcbiAgICB9KSkgOiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHQpLCB0LnNlbGVjdCgpLCB0Lm5vZGUuc2V0QXR0cmlidXRlKGJpLCAhMCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBUbCwge1xuICAgICAgdmFsdWU6IHQudmFsdWVcbiAgICB9KSksIHRoaXMuX2VtaXRWYWx1ZUNoYW5nZUV2ZW50KHRoaXMudmFsdWUpLCB0aGlzLl9lbWl0TmF0aXZlQ2hhbmdlRXZlbnQoKTtcbiAgfVxuICBfZW1pdFZhbHVlQ2hhbmdlRXZlbnQodCkge1xuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBDYiwgeyB2YWx1ZTogdCB9KTtcbiAgfVxuICBfZW1pdE5hdGl2ZUNoYW5nZUV2ZW50KCkge1xuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBBYik7XG4gIH1cbiAgX3VwZGF0ZUlucHV0VmFsdWUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubXVsdGlwbGUgPyB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5sYWJlbHMgOiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5sYWJlbDtcbiAgICBsZXQgZTtcbiAgICB0aGlzLm11bHRpcGxlICYmIHRoaXMuX2NvbmZpZy5zZWxlY3REaXNwbGF5ZWRMYWJlbHMgIT09IC0xICYmIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnMubGVuZ3RoID4gdGhpcy5fY29uZmlnLnNlbGVjdERpc3BsYXllZExhYmVscyA/IGUgPSBgJHt0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb25zLmxlbmd0aH0gJHt0aGlzLl9jb25maWcuc2VsZWN0T3B0aW9uc1NlbGVjdGVkTGFiZWx9YCA6IGUgPSB0LCAhdGhpcy5tdWx0aXBsZSAmJiAhdGhpcy5faXNTZWxlY3Rpb25WYWxpZCh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb24pID8gdGhpcy5faW5wdXQudmFsdWUgPSBcIlwiIDogdGhpcy5faXNMYWJlbEVtcHR5KHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbikgPyB0aGlzLl9pbnB1dC52YWx1ZSA9IFwiIFwiIDogZSA/IHRoaXMuX2lucHV0LnZhbHVlID0gZSA6IHRoaXMubXVsdGlwbGUgfHwgIXRoaXMuX29wdGlvbnNUb1JlbmRlclswXSA/IHRoaXMuX2lucHV0LnZhbHVlID0gXCJcIiA6IHRoaXMuX2lucHV0LnZhbHVlID0gdGhpcy5fb3B0aW9uc1RvUmVuZGVyWzBdLmxhYmVsO1xuICB9XG4gIF9pc1NlbGVjdGlvblZhbGlkKHQpIHtcbiAgICByZXR1cm4gISh0ICYmICh0LmRpc2FibGVkIHx8IHQudmFsdWUgPT09IFwiXCIpKTtcbiAgfVxuICBfaXNMYWJlbEVtcHR5KHQpIHtcbiAgICByZXR1cm4gISEodCAmJiB0LmxhYmVsID09PSBcIlwiKTtcbiAgfVxuICBfYXBwZW5kRmFrZVZhbHVlKCkge1xuICAgIGlmICghdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uIHx8IHRoaXMuX3NlbGVjdGlvbk1vZGVsLl9tdWx0aXBsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uLmxhYmVsO1xuICAgIHRoaXMuX2Zha2VWYWx1ZSA9IHZiKHQsIHRoaXMuX2NsYXNzZXMpLCBkLmZpbmRPbmUoXG4gICAgICBrbCxcbiAgICAgIHRoaXMuX3dyYXBwZXJcbiAgICApLmFwcGVuZENoaWxkKHRoaXMuX2Zha2VWYWx1ZSk7XG4gIH1cbiAgX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKENsKSwgZSA9IHRoaXMuX2lucHV0LnZhbHVlICE9PSBcIlwiO1xuICAgIHRoaXMuX2xhYmVsICYmICh0ICYmIChlIHx8IHRoaXMuX2lzT3BlbiB8fCB0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSkgPyAodGhpcy5fbGFiZWwuc2V0QXR0cmlidXRlKEosIFwiXCIpLCB0aGlzLl9ub3RjaC5zZXRBdHRyaWJ1dGUoSiwgXCJcIikpIDogKHRoaXMuX2xhYmVsLnJlbW92ZUF0dHJpYnV0ZShKKSwgdGhpcy5fbm90Y2gucmVtb3ZlQXR0cmlidXRlKEosIFwiXCIpKSk7XG4gIH1cbiAgX3VwZGF0ZUxhYmVsUG9zaXRpb25XaGlsZUNsb3NpbmcoKSB7XG4gICAgdGhpcy5fbGFiZWwgJiYgKHRoaXMuX2lucHV0LnZhbHVlICE9PSBcIlwiIHx8IHRoaXMuX2lzRmFrZVZhbHVlQWN0aXZlID8gKHRoaXMuX2xhYmVsLnNldEF0dHJpYnV0ZShKLCBcIlwiKSwgdGhpcy5fbm90Y2guc2V0QXR0cmlidXRlKEosIFwiXCIpKSA6ICh0aGlzLl9sYWJlbC5yZW1vdmVBdHRyaWJ1dGUoSiksIHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZShKKSkpO1xuICB9XG4gIF91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpIHtcbiAgICB0aGlzLl9mYWtlVmFsdWUgJiYgKHRoaXMuX2lucHV0LnZhbHVlID09PSBcIlwiICYmIHRoaXMuX2Zha2VWYWx1ZS5pbm5lckhUTUwgIT09IFwiXCIgJiYgIXRoaXMuX2NvbmZpZy5zZWxlY3RQbGFjZWhvbGRlciA/ICh0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSA9ICEwLCB0aGlzLl9mYWtlVmFsdWUuc2V0QXR0cmlidXRlKEosIFwiXCIpKSA6ICh0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSA9ICExLCB0aGlzLl9mYWtlVmFsdWUucmVtb3ZlQXR0cmlidXRlKEopKSk7XG4gIH1cbiAgX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpIHtcbiAgICBpZiAoIXRoaXMuY2xlYXJCdXR0b24pXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uIHx8IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnMubGVuZ3RoID4gMCA/IGguYWRkU3R5bGUodGhpcy5jbGVhckJ1dHRvbiwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSkgOiBoLmFkZFN0eWxlKHRoaXMuY2xlYXJCdXR0b24sIHsgZGlzcGxheTogXCJub25lXCIgfSk7XG4gIH1cbiAgX3VwZGF0ZVNlbGVjdEFsbFN0YXRlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9zZWxlY3RBbGxPcHRpb24uc2VsZWN0ZWQsIGUgPSBRbyh0aGlzLm9wdGlvbnMpO1xuICAgICFlICYmIHQgPyB0aGlzLl9zZWxlY3RBbGxPcHRpb24uZGVzZWxlY3QoKSA6IGUgJiYgIXQgJiYgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLnNlbGVjdCgpO1xuICB9XG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLl9pc09wZW4gPyB0aGlzLmNsb3NlKCkgOiB0aGlzLm9wZW4oKTtcbiAgfVxuICBvcGVuKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jb25maWcuZGlzYWJsZWQsIGUgPSBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRWIpO1xuICAgIHRoaXMuX2lzT3BlbiB8fCB0IHx8IGUuZGVmYXVsdFByZXZlbnRlZCB8fCAodGhpcy5fb3BlbkRyb3Bkb3duKCksIHRoaXMuX3VwZGF0ZURyb3Bkb3duV2lkdGgoKSwgdGhpcy5fc2V0Rmlyc3RBY3RpdmVPcHRpb24oKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKSwgdGhpcy5fY29uZmlnLnNlbGVjdEZpbHRlciAmJiAoc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmZpbHRlcklucHV0LmZvY3VzKCk7XG4gICAgfSwgMCksIHRoaXMuX2xpc3RlblRvU2VsZWN0U2VhcmNoKCksIHRoaXMuX2xpc3RlblRvRHJvcGRvd25LZXlkb3duKCkpLCB0aGlzLl9saXN0ZW5Ub09wdGlvbnNDbGljaygpLCB0aGlzLl9saXN0ZW5Ub091dHNpZGVDbGljaygpLCB0aGlzLl9saXN0ZW5Ub1dpbmRvd1Jlc2l6ZSgpLCB0aGlzLl9pc09wZW4gPSAhMCwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl9zZXRJbnB1dEFjdGl2ZVN0eWxlcygpKTtcbiAgfVxuICBfb3BlbkRyb3Bkb3duKCkge1xuICAgIHRoaXMuX3BvcHBlciA9IHNlKHRoaXMuX2lucHV0LCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciwge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiLFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDFdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSksIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kcm9wZG93bkNvbnRhaW5lciksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kcm9wZG93bi5zZXRBdHRyaWJ1dGUoQWwsIFwiXCIpO1xuICAgIH0sIDApO1xuICB9XG4gIF91cGRhdGVEcm9wZG93bldpZHRoKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9pbnB1dC5vZmZzZXRXaWR0aDtcbiAgICBoLmFkZFN0eWxlKHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLCB7IHdpZHRoOiBgJHt0fXB4YCB9KTtcbiAgfVxuICBfc2V0Rmlyc3RBY3RpdmVPcHRpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldE5hdmlnYXRpb25PcHRpb25zKCksIGUgPSB0aGlzLl9hY3RpdmVPcHRpb247XG4gICAgZSAmJiBlLnJlbW92ZUFjdGl2ZVN0eWxlcygpO1xuICAgIGNvbnN0IGkgPSB0aGlzLm11bHRpcGxlID8gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uc1swXSA6IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbjtcbiAgICBpID8gKHRoaXMuX2FjdGl2ZU9wdGlvbiA9IGksIGkuc2V0QWN0aXZlU3R5bGVzKCksIHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ID0gdC5maW5kSW5kZXgoXG4gICAgICAobikgPT4gbiA9PT0gaVxuICAgICkpIDogKHRoaXMuX2FjdGl2ZU9wdGlvbiA9IG51bGwsIHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ID0gLTEpO1xuICB9XG4gIF9zZXRJbnB1dEFjdGl2ZVN0eWxlcygpIHtcbiAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoenQsIFwiXCIpLCBkLmZpbmRPbmUoYm8sIHRoaXMuX3dyYXBwZXIpLnNldEF0dHJpYnV0ZShcbiAgICAgIHp0LFxuICAgICAgXCJcIlxuICAgICk7XG4gIH1cbiAgX2xpc3RlblRvV2luZG93UmVzaXplKCkge1xuICAgIGMub24od2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLl9oYW5kbGVXaW5kb3dSZXNpemUuYmluZCh0aGlzKSk7XG4gIH1cbiAgX2hhbmRsZVdpbmRvd1Jlc2l6ZSgpIHtcbiAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciAmJiB0aGlzLl91cGRhdGVEcm9wZG93bldpZHRoKCk7XG4gIH1cbiAgX2xpc3RlblRvU2VsZWN0U2VhcmNoKCkge1xuICAgIHRoaXMuZmlsdGVySW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gdC50YXJnZXQudmFsdWUsIGkgPSB0aGlzLl9jb25maWcuc2VsZWN0RmlsdGVyRGVib3VuY2U7XG4gICAgICB0aGlzLl9kZWJvdW5jZUZpbHRlcihlLCBpKTtcbiAgICB9KTtcbiAgfVxuICBfZGVib3VuY2VGaWx0ZXIodCwgZSkge1xuICAgIHRoaXMuX2RlYm91bmNlVGltZW91dElkICYmIGNsZWFyVGltZW91dCh0aGlzLl9kZWJvdW5jZVRpbWVvdXRJZCksIHRoaXMuX2RlYm91bmNlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9maWx0ZXJPcHRpb25zKHQpO1xuICAgIH0sIGUpO1xuICB9XG4gIF9maWx0ZXJPcHRpb25zKHQpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgdGhpcy5fb3B0aW9uc1RvUmVuZGVyLmZvckVhY2goKG8pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICAgIG8sXG4gICAgICAgIFwib3B0aW9uc1wiXG4gICAgICApLCBhID0gIXIgJiYgby5sYWJlbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHQudG9Mb3dlckNhc2UoKSksIGwgPSB7fTtcbiAgICAgIHIgJiYgKGwubGFiZWwgPSBvLmxhYmVsLCBsLm9wdGlvbnMgPSB0aGlzLl9maWx0ZXIodCwgby5vcHRpb25zKSwgbC5vcHRpb25zLmxlbmd0aCA+IDAgJiYgZS5wdXNoKGwpKSwgYSAmJiBlLnB1c2gobyk7XG4gICAgfSk7XG4gICAgY29uc3QgaSA9IHRoaXMuX2NvbmZpZy5zZWxlY3ROb1Jlc3VsdFRleHQgIT09IFwiXCIsIG4gPSBlLmxlbmd0aCAhPT0gMDtcbiAgICBpZiAobilcbiAgICAgIHRoaXMuX3VwZGF0ZU9wdGlvbnNMaXN0VGVtcGxhdGUoZSksIHRoaXMuX3BvcHBlci5mb3JjZVVwZGF0ZSgpLCB0aGlzLl9maWx0ZXJlZE9wdGlvbnNMaXN0ID0gdGhpcy5fZ2V0UGxhaW5PcHRpb25zKGUpLCB0aGlzLmhhc1NlbGVjdEFsbCAmJiB0aGlzLl91cGRhdGVTZWxlY3RBbGxTdGF0ZSgpLCB0aGlzLl9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpO1xuICAgIGVsc2UgaWYgKCFuICYmIGkpIHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLl9nZXROb1Jlc3VsdFRlbXBsYXRlKCk7XG4gICAgICB0aGlzLm9wdGlvbnNXcmFwcGVyLmlubmVySFRNTCA9IG87XG4gICAgfVxuICB9XG4gIF91cGRhdGVPcHRpb25zTGlzdFRlbXBsYXRlKHQpIHtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKHdsLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcikgfHwgZC5maW5kT25lKExiLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciksIGkgPSBBaChcbiAgICAgIHQsXG4gICAgICB0aGlzLl9zZWxlY3RBbGxPcHRpb24sXG4gICAgICB0aGlzLl9jb25maWcsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLm9wdGlvbnNXcmFwcGVyLnJlbW92ZUNoaWxkKGUpLCB0aGlzLm9wdGlvbnNXcmFwcGVyLmFwcGVuZENoaWxkKGkpO1xuICB9XG4gIF9nZXROb1Jlc3VsdFRlbXBsYXRlKCkge1xuICAgIHJldHVybiBgPGRpdiBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5ub1Jlc3VsdH1cIiAke3hofSBzdHlsZT1cImhlaWdodDogJHt0aGlzLl9jb25maWcuc2VsZWN0T3B0aW9uSGVpZ2h0fXB4XCI+JHt0aGlzLl9jb25maWcuc2VsZWN0Tm9SZXN1bHRUZXh0fTwvZGl2PmA7XG4gIH1cbiAgX2ZpbHRlcih0LCBlKSB7XG4gICAgY29uc3QgaSA9IHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gZS5maWx0ZXIoXG4gICAgICAobikgPT4gbi5sYWJlbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGkpXG4gICAgKTtcbiAgfVxuICBfbGlzdGVuVG9Ecm9wZG93bktleWRvd24oKSB7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuZHJvcGRvd24sXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIHRoaXMuX2hhbmRsZU9wZW5LZXlkb3duLmJpbmQodGhpcylcbiAgICApO1xuICB9XG4gIF9saXN0ZW5Ub091dHNpZGVDbGljaygpIHtcbiAgICB0aGlzLl9vdXRzaWRlQ2xpY2sgPSB0aGlzLl9oYW5kbGVPdXRTaWRlQ2xpY2suYmluZCh0aGlzKSwgYy5vbihkb2N1bWVudCwgXCJjbGlja1wiLCB0aGlzLl9vdXRzaWRlQ2xpY2spO1xuICB9XG4gIF9saXN0ZW5Ub0ZvY3VzQ2hhbmdlKHQgPSAhMCkge1xuICAgIGlmICh0ID09PSAhMSkge1xuICAgICAgYy5vZmYoXG4gICAgICAgIHRoaXMuX2lucHV0LFxuICAgICAgICBcImZvY3VzXCIsXG4gICAgICAgICgpID0+IHRoaXMuX25vdGNoLnNldEF0dHJpYnV0ZSh6dCwgXCJcIilcbiAgICAgICksIGMub2ZmKFxuICAgICAgICB0aGlzLl9pbnB1dCxcbiAgICAgICAgXCJibHVyXCIsXG4gICAgICAgICgpID0+IHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZSh6dClcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGMub24oXG4gICAgICB0aGlzLl9pbnB1dCxcbiAgICAgIFwiZm9jdXNcIixcbiAgICAgICgpID0+IHRoaXMuX25vdGNoLnNldEF0dHJpYnV0ZSh6dCwgXCJcIilcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5faW5wdXQsXG4gICAgICBcImJsdXJcIixcbiAgICAgICgpID0+IHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZSh6dClcbiAgICApO1xuICB9XG4gIF9oYW5kbGVPdXRTaWRlQ2xpY2sodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl93cmFwcGVyICYmIHRoaXMuX3dyYXBwZXIuY29udGFpbnModC50YXJnZXQpLCBpID0gdC50YXJnZXQgPT09IHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLCBuID0gdGhpcy5fZHJvcGRvd25Db250YWluZXIgJiYgdGhpcy5fZHJvcGRvd25Db250YWluZXIuY29udGFpbnModC50YXJnZXQpO1xuICAgIGxldCBvO1xuICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbiB8fCAodGhpcy5fZWxlbWVudFRvZ2dsZSA9IGQuZmluZChOYikpLCB0aGlzLl9lbGVtZW50VG9nZ2xlICYmIHRoaXMuX2VsZW1lbnRUb2dnbGUuZm9yRWFjaCgocikgPT4ge1xuICAgICAgY29uc3QgYSA9IGguZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgICAgcixcbiAgICAgICAgXCJzZWxlY3QtdG9nZ2xlXCJcbiAgICAgICk7XG4gICAgICAoYSA9PT0gdGhpcy5fZWxlbWVudC5pZCB8fCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhhKSkgJiYgKHRoaXMuX3RvZ2dsZUJ1dHRvbiA9IHIsIG8gPSB0aGlzLl90b2dnbGVCdXR0b24uY29udGFpbnModC50YXJnZXQpKTtcbiAgICB9KSwgIWUgJiYgIWkgJiYgIW4gJiYgIW8gJiYgdGhpcy5jbG9zZSgpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGNvbnN0IHQgPSBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgVGIpLCBlID0gY24oXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lci5jaGlsZHJlblswXVxuICAgICk7XG4gICAgIXRoaXMuX2lzT3BlbiB8fCB0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX2NvbmZpZy5zZWxlY3RGaWx0ZXIgJiYgdGhpcy5oYXNTZWxlY3RBbGwgJiYgKHRoaXMuX3Jlc2V0RmlsdGVyU3RhdGUoKSwgdGhpcy5fdXBkYXRlT3B0aW9uc0xpc3RUZW1wbGF0ZSh0aGlzLl9vcHRpb25zVG9SZW5kZXIpLCB0aGlzLl9jb25maWcubXVsdGlwbGUgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKSksIHRoaXMuX3JlbW92ZURyb3Bkb3duRXZlbnRzKCksIHRoaXMuZHJvcGRvd24ucmVtb3ZlQXR0cmlidXRlKEFsKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoenQpLCB0aGlzLl9pbnB1dC5ibHVyKCksIGQuZmluZE9uZShibywgdGhpcy5fd3JhcHBlcikucmVtb3ZlQXR0cmlidXRlKFxuICAgICAgICB6dFxuICAgICAgKSwgdGhpcy5fbGFiZWwgJiYgIXRoaXMuaGFzU2VsZWN0aW9uICYmICh0aGlzLl9sYWJlbC5yZW1vdmVBdHRyaWJ1dGUoSiksIHRoaXMuX25vdGNoLnNldEF0dHJpYnV0ZShKLCBcIlwiKSwgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKEopLCB0aGlzLl9ub3RjaC5yZW1vdmVBdHRyaWJ1dGUoSikpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uV2hpbGVDbG9zaW5nKCk7XG4gICAgfSwgMCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fY29udGFpbmVyICYmIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLnBhcmVudE5vZGUgPT09IHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fZHJvcGRvd25Db250YWluZXIpLCB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9pc09wZW4gPSAhMSwgYy5vZmYodGhpcy5kcm9wZG93biwgXCJ0cmFuc2l0aW9uZW5kXCIpO1xuICAgIH0sIGUpKTtcbiAgfVxuICBfcmVzZXRGaWx0ZXJTdGF0ZSgpIHtcbiAgICB0aGlzLmZpbHRlcklucHV0LnZhbHVlID0gXCJcIiwgdGhpcy5fZmlsdGVyZWRPcHRpb25zTGlzdCA9IG51bGw7XG4gIH1cbiAgX3JlbW92ZURyb3Bkb3duRXZlbnRzKCkge1xuICAgIGMub2ZmKGRvY3VtZW50LCBcImNsaWNrXCIsIHRoaXMuX291dHNpZGVDbGljayksIHRoaXMuX2NvbmZpZy5zZWxlY3RGaWx0ZXIgJiYgYy5vZmYodGhpcy5kcm9wZG93biwgXCJrZXlkb3duXCIpLCBjLm9mZih0aGlzLm9wdGlvbnNXcmFwcGVyLCBcImNsaWNrXCIpO1xuICB9XG4gIF9hZGRNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICB0aGlzLl93cmFwcGVyICYmICh0aGlzLl91cGRhdGVTZWxlY3Rpb25zKCksIHRoaXMuX3VwZGF0ZURpc2FibGVkU3RhdGUoKSk7XG4gICAgfSksIHRoaXMuX29ic2VydmVNdXRhdGlvbk9ic2VydmVyKCk7XG4gIH1cbiAgX3VwZGF0ZVNlbGVjdGlvbnMoKSB7XG4gICAgdGhpcy5fb3B0aW9uc1RvUmVuZGVyID0gdGhpcy5fZ2V0T3B0aW9uc1RvUmVuZGVyKHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9wbGFpbk9wdGlvbnMgPSB0aGlzLl9nZXRQbGFpbk9wdGlvbnModGhpcy5fb3B0aW9uc1RvUmVuZGVyKSwgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2xlYXIoKSwgdGhpcy5fc2V0RGVmYXVsdFNlbGVjdGlvbnMoKSwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZSgpLCB0aGlzLl91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpLCB0aGlzLmhhc1NlbGVjdEFsbCAmJiB0aGlzLl91cGRhdGVTZWxlY3RBbGxTdGF0ZSgpO1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jb25maWcuZmlsdGVyICYmIHRoaXMuZmlsdGVySW5wdXQgJiYgdGhpcy5maWx0ZXJJbnB1dC52YWx1ZTtcbiAgICB0aGlzLl9pc09wZW4gJiYgIXQgPyAodGhpcy5fdXBkYXRlT3B0aW9uc0xpc3RUZW1wbGF0ZSh0aGlzLl9vcHRpb25zVG9SZW5kZXIpLCB0aGlzLl9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpKSA6IHRoaXMuX2lzT3BlbiAmJiB0ID8gKHRoaXMuX2ZpbHRlck9wdGlvbnModGhpcy5maWx0ZXJJbnB1dC52YWx1ZSksIHRoaXMuX3NldEZpcnN0QWN0aXZlT3B0aW9uKCkpIDogdGhpcy5fZHJvcGRvd25Db250YWluZXIgPSB2bChcbiAgICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVySWQsXG4gICAgICB0aGlzLl9jb25maWcsXG4gICAgICB0aGlzLl9pbnB1dC5vZmZzZXRXaWR0aCxcbiAgICAgIHRoaXMuX2Ryb3Bkb3duSGVpZ2h0LFxuICAgICAgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLFxuICAgICAgdGhpcy5fb3B0aW9uc1RvUmVuZGVyLFxuICAgICAgdGhpcy5fY3VzdG9tQ29udGVudCxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICB9XG4gIF91cGRhdGVEaXNhYmxlZFN0YXRlKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoeWwsIHRoaXMuX3dyYXBwZXIpO1xuICAgIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPyAodGhpcy5fY29uZmlnLmRpc2FibGVkID0gITAsIHQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIiksIHQuc2V0QXR0cmlidXRlKGdvLCBcIlwiKSkgOiAodGhpcy5fY29uZmlnLmRpc2FibGVkID0gITEsIHQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIiksIHQucmVtb3ZlQXR0cmlidXRlKGdvKSk7XG4gIH1cbiAgX29ic2VydmVNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgJiYgdGhpcy5fbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuX2VsZW1lbnQsIHtcbiAgICAgIGF0dHJpYnV0ZXM6ICEwLFxuICAgICAgY2hpbGRMaXN0OiAhMCxcbiAgICAgIGNoYXJhY3RlckRhdGE6ICEwLFxuICAgICAgc3VidHJlZTogITBcbiAgICB9KTtcbiAgfVxuICBfZGlzY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyICYmICh0aGlzLl9tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKSwgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG51bGwpO1xuICB9XG4gIF9jcmVhdGVTZWxlY3RBbGxPcHRpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3NlbGVjdEFsbElkLCBlID0gbnVsbCwgaSA9ICEwLCBuID0gXCJzZWxlY3QtYWxsXCIsIG8gPSB0aGlzLl9jb25maWcuc2VsZWN0QWxsTGFiZWwsIHIgPSBRbyh0aGlzLm9wdGlvbnMpLCBhID0gITEsIGwgPSAhMSwgcCA9IG51bGwsIHUgPSBudWxsLCBfID0gbnVsbDtcbiAgICByZXR1cm4gbmV3IGJsKFxuICAgICAgdCxcbiAgICAgIGUsXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIG8sXG4gICAgICByLFxuICAgICAgYSxcbiAgICAgIGwsXG4gICAgICBwLFxuICAgICAgdSxcbiAgICAgIF9cbiAgICApO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fcmVtb3ZlQ29tcG9uZW50RXZlbnRzKCksIHRoaXMuX2Rlc3Ryb3lNYXRlcmlhbFNlbGVjdCgpLCB0aGlzLl9saXN0ZW5Ub0ZvY3VzQ2hhbmdlKCExKSwgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHlpKTtcbiAgfVxuICBfcmVtb3ZlQ29tcG9uZW50RXZlbnRzKCkge1xuICAgIGMub2ZmKHRoaXMuaW5wdXQsIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMud3JhcHBlciwgdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKSwgYy5vZmYodGhpcy5jbGVhckJ1dHRvbiwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy5jbGVhckJ1dHRvbiwgXCJrZXlkb3duXCIpLCBjLm9mZih3aW5kb3csIFwicmVzaXplXCIsIHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgfVxuICBfZGVzdHJveU1hdGVyaWFsU2VsZWN0KCkge1xuICAgIHRoaXMuX2lzT3BlbiAmJiB0aGlzLmNsb3NlKCksIHRoaXMuX2Rlc3Ryb3lNYXRlcmlhbFRlbXBsYXRlKCk7XG4gIH1cbiAgX2Rlc3Ryb3lNYXRlcmlhbFRlbXBsYXRlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl93cmFwcGVyLnBhcmVudE5vZGUsIGUgPSBkLmZpbmQoXCJsYWJlbFwiLCB0aGlzLl93cmFwcGVyKTtcbiAgICB0LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpLCBlLmZvckVhY2goKGkpID0+IHtcbiAgICAgIHQuYXBwZW5kQ2hpbGQoaSk7XG4gICAgfSksIGUuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgaS5yZW1vdmVBdHRyaWJ1dGUoSik7XG4gICAgfSksIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5pbml0aWFsaXplZCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKENsKSwgdC5yZW1vdmVDaGlsZCh0aGlzLl93cmFwcGVyKTtcbiAgfVxuICBzZXRWYWx1ZSh0KSB7XG4gICAgdGhpcy5vcHRpb25zLmZpbHRlcigoaSkgPT4gaS5zZWxlY3RlZCkuZm9yRWFjaCgoaSkgPT4gaS5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMSksIEFycmF5LmlzQXJyYXkodCkgPyB0LmZvckVhY2goKGkpID0+IHtcbiAgICAgIHRoaXMuX3NlbGVjdEJ5VmFsdWUoaSk7XG4gICAgfSkgOiB0aGlzLl9zZWxlY3RCeVZhbHVlKHQpLCB0aGlzLl91cGRhdGVTZWxlY3Rpb25zKCksIHRoaXMuX2VtaXRWYWx1ZUNoYW5nZUV2ZW50KHRoaXMudmFsdWUpO1xuICB9XG4gIF9zZWxlY3RCeVZhbHVlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zLmZpbmQoXG4gICAgICAoaSkgPT4gaS52YWx1ZSA9PT0gdFxuICAgICk7XG4gICAgcmV0dXJuIGUgPyAoZS5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMCwgITApIDogITE7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0gQS5nZXREYXRhKHRoaXMsIHlpKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcga3IodGhpcywgbikpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgeWkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IEhiID0gKHsgaW5wdXRJRDogcywgbGFiZWxUZXh0OiB0IH0sIGUpID0+IGA8ZGl2IGRhdGEtdGUtY2hpcHMtaW5wdXQtd3JhcHBlciBkYXRhLXRlLWlucHV0LXdyYXBwZXItaW5pdCBjbGFzcz1cIiR7ZS5jaGlwc0lucHV0V3JhcHBlcn1cIj5cbiAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICBjbGFzcz1cIiR7ZS5jaGlwc0lucHV0fVwiXG4gICAgICAgICAgaWQ9XCIke3N9XCJcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIkV4YW1wbGUgbGFiZWxcIiAvPlxuICAgICAgICA8bGFiZWxcbiAgICAgICAgICBmb3I9XCIke3N9XCJcbiAgICAgICAgICBjbGFzcz1cIiR7ZS5jaGlwc0xhYmVsfVwiXG4gICAgICAgICAgPiR7dH1cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PmAsIFZiID0gKHsgdGV4dDogcywgaWNvblNWRzogdCB9LCBlKSA9PiBgPGRpdiBkYXRhLXRlLWNoaXAtaW5pdCBkYXRhLXRlLXJpcHBsZS1pbml0IGNsYXNzPVwiJHtlLmNoaXBFbGVtZW50fVwiPlxuICAgIDxzcGFuIGRhdGEtdGUtY2hpcC10ZXh0PiR7c308L3NwYW4+IFxuICAgICAgPHNwYW4gZGF0YS10ZS1jaGlwLWNsb3NlIGNsYXNzPVwiJHtlLmNoaXBDbG9zZUljb259XCI+XG4gICAgICAgICR7dH1cbiAgICAgIDwvc3Bhbj5cbiAgPC9kaXY+YCwgZW4gPSBcImNoaXBcIiwgV2IgPSBgdGUuJHtlbn1gLCBPaCA9IFwiZGF0YS10ZS1jaGlwLWNsb3NlXCIsIHZvID0gYFske09ofV1gLCBGYiA9IFwiZGVsZXRlLnRlLmNoaXBzXCIsIFliID0gXCJzZWxlY3QudGUuY2hpcFwiLCBqYiA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctMyBoLTNcIj4gPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk02IDE4TDE4IDZNNiA2bDEyIDEyXCIgLz48L3N2Zz4nLCBLYiA9IHtcbiAgdGV4dDogXCJzdHJpbmdcIixcbiAgY2xvc2VJY29uOiBcImJvb2xlYW5cIixcbiAgaW1nOiBcIm9iamVjdFwiLFxuICBpY29uU1ZHOiBcInN0cmluZ1wiXG59LCB6YiA9IHtcbiAgdGV4dDogXCJcIixcbiAgY2xvc2VJY29uOiAhMSxcbiAgaW1nOiB7IHBhdGg6IFwiXCIsIGFsdDogXCJcIiB9LFxuICBpY29uU1ZHOiBqYlxufSwgVWIgPSB7XG4gIGljb246IFwiZmxvYXQtcmlnaHQgcGwtWzhweF0gdGV4dC1bMTZweF0gb3BhY2l0eS1bLjUzXSBjdXJzb3ItcG9pbnRlciBmaWxsLVsjYWZhZmFmXSBob3Zlcjp0ZXh0LVsjOGI4YjhiXSB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1pbi1vdXRcIixcbiAgY2hpcEVsZW1lbnQ6IFwiZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIGgtWzMycHhdIGxlYWRpbmctbG9vc2UgcHktWzVweF0gcHgtWzEycHhdIG1yLTQgbXktWzVweF0gdGV4dC1bMTNweF0gZm9udC1ub3JtYWwgdGV4dC1bIzRmNGY0Zl0gY3Vyc29yLXBvaW50ZXIgYmctWyNlY2VmZjFdIGRhcms6dGV4dC13aGl0ZSBkYXJrOmJnLW5ldXRyYWwtNjAwIHJvdW5kZWQtWzE2cHhdIHRyYW5zaXRpb24tW29wYWNpdHldIGR1cmF0aW9uLTMwMCBlYXNlLWxpbmVhciBbd29yZC13cmFwOiBicmVhay13b3JkXSBzaGFkb3ctbm9uZSBub3JtYWwtY2FzZSBob3Zlcjohc2hhZG93LW5vbmUgYWN0aXZlOmJnLVsjY2FjZmQxXSBpbmxpbmUtYmxvY2sgZm9udC1tZWRpdW0gbGVhZGluZy1ub3JtYWwgdGV4dC1bIzRmNGY0Zl0gdGV4dC1jZW50ZXIgbm8tdW5kZXJsaW5lIGFsaWduLW1pZGRsZSBjdXJzb3ItcG9pbnRlciBzZWxlY3Qtbm9uZSBib3JkZXItWy4xMjVyZW1dIGJvcmRlci1zb2xpZCBib3JkZXItdHJhbnNwYXJlbnQgcHktMS41IHB4LTMgdGV4dC14cyByb3VuZGVkXCIsXG4gIGNoaXBDbG9zZUljb246IFwidy00IGZsb2F0LXJpZ2h0IHBsLVs4cHhdIHRleHQtWzE2cHhdIG9wYWNpdHktWy41M10gY3Vyc29yLXBvaW50ZXIgZmlsbC1bI2FmYWZhZl0gaG92ZXI6ZmlsbC1bIzhiOGI4Yl0gZGFyazpmaWxsLWdyYXktNDAwIGRhcms6aG92ZXI6ZmlsbC1ncmF5LTEwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1pbi1vdXRcIlxufSwgWGIgPSB7XG4gIGljb246IFwic3RyaW5nXCIsXG4gIGNoaXBFbGVtZW50OiBcInN0cmluZ1wiLFxuICBjaGlwQ2xvc2VJY29uOiBcInN0cmluZ1wiXG59O1xuY2xhc3Mgdmkge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30sIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGVuO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX2FwcGVuZENsb3NlSWNvbigpLCB0aGlzLl9oYW5kbGVEZWxldGUoKSwgdGhpcy5faGFuZGxlVGV4dENoaXAoKSwgdGhpcy5faGFuZGxlQ2xpY2tPbkNoaXAoKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9vcHRpb25zID0gbnVsbCwgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiKTtcbiAgfVxuICBhcHBlbmRDaGlwKCkge1xuICAgIGNvbnN0IHsgdGV4dDogdCwgY2xvc2VJY29uOiBlLCBpY29uU1ZHOiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIHJldHVybiBWYih7IHRleHQ6IHQsIGNsb3NlSWNvbjogZSwgaWNvblNWRzogaSB9LCB0aGlzLl9jbGFzc2VzKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9hcHBlbmRDbG9zZUljb24odCA9IHRoaXMuX2VsZW1lbnQpIHtcbiAgICBpZiAoIShkLmZpbmQodm8sIHRoaXMuX2VsZW1lbnQpLmxlbmd0aCA+IDApICYmIHRoaXMuX29wdGlvbnMuY2xvc2VJY29uKSB7XG4gICAgICBjb25zdCBlID0gJChcInNwYW5cIik7XG4gICAgICBlLmNsYXNzTGlzdCA9IHRoaXMuX2NsYXNzZXMuaWNvbiwgZS5zZXRBdHRyaWJ1dGUoT2gpLCBlLmlubmVySFRNTCA9IHRoaXMuX29wdGlvbnMuaWNvblNWRywgdC5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJiZWZvcmVlbmRcIiwgZSk7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVDbGlja09uQ2hpcCgpIHtcbiAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgdGV4dENvbnRlbnQ6IGUgfSA9IHQudGFyZ2V0LCBpID0ge307XG4gICAgICBpLnRhZyA9IGUudHJpbSgpLCBjLnRyaWdnZXIoWWIsIHsgZXZlbnQ6IHQsIG9iajogaSB9KTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlRGVsZXRlKCkge1xuICAgIGQuZmluZChcbiAgICAgIHZvLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkubGVuZ3RoICE9PSAwICYmIGMub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB2bywgKCkgPT4ge1xuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEZiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlVGV4dENoaXAoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5pbm5lclRleHQgPT09IFwiXCIgJiYgKHRoaXMuX2VsZW1lbnQuaW5uZXJUZXh0ID0gdGhpcy5fb3B0aW9ucy50ZXh0KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4uemIsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEkoZW4sIGUsIEtiKSwgZTtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlViLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKGVuLCB0LCBYYiksIHQ7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIFdiKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBIaSA9IFwiY2hpcHNcIiwgR2kgPSBgZGF0YS10ZS0ke0hpfWAsIHhsID0gYHRlLiR7SGl9YCwgR2IgPSBgJHtHaX0taW5wdXQtaW5pdGAsIGJ0ID0gYCR7R2l9LWFjdGl2ZWAsIE9sID0gYCR7R2l9LWluaXRpYWxgLCBTaCA9IGAke0dpfS1wbGFjZWhvbGRlcmAsIHFiID0gYCR7R2l9LWlucHV0LXdyYXBwZXJgLCBKbyA9IFwiZGF0YS10ZS1jaGlwLWluaXRcIiwgSWggPSBcImRhdGEtdGUtY2hpcC1jbG9zZVwiLCBEaCA9IFwiZGF0YS10ZS1jaGlwLXRleHRcIiwgWmIgPSBgWyR7YnR9XWAsIHRyID0gYFske0pvfV1gLCBRYiA9IGAke3RyfSR7WmJ9YCwgVG8gPSBgWyR7SWh9XWAsIEpiID0gYFske3FifV1gLCB0diA9IGBbJHtEaH1dYCwgZXYgPSBgWyR7U2h9XWAsIGl2ID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLWxlYWRpbmctcmVmXCIsIHN2ID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLW1pZGRsZS1yZWZcIiwgbnYgPSBgWyR7aXZ9XWAsIG92ID0gYFske3N2fV1gLCBOZSA9IFwiZGF0YS10ZS1pbnB1dC1zdGF0ZS1hY3RpdmVcIiwgRW8gPSBcIltkYXRhLXRlLWlucHV0LW5vdGNoLXJlZl1cIiwgcnYgPSBcImFkZC50ZS5jaGlwc1wiLCBhdiA9IFwiYXJyb3dEb3duLnRlLmNoaXBzXCIsIGx2ID0gXCJhcnJvd0xlZnQudGUuY2hpcHNcIiwgY3YgPSBcImFycm93UmlnaHQudGUuY2hpcHNcIiwgaHYgPSBcImFycm93VXAudGUuY2hpcHNcIiwgU2wgPSBcImRlbGV0ZS50ZS5jaGlwc1wiLCBJbCA9IFwic2VsZWN0LnRlLmNoaXBzXCIsIGR2ID0ge1xuICBpbnB1dElEOiBcInN0cmluZ1wiLFxuICBwYXJlbnRTZWxlY3RvcjogXCJzdHJpbmdcIixcbiAgaW5pdGlhbFZhbHVlczogXCJhcnJheVwiLFxuICBlZGl0YWJsZTogXCJib29sZWFuXCIsXG4gIGxhYmVsVGV4dDogXCJzdHJpbmdcIixcbiAgaW5wdXRDbGFzc2VzOiBcIm9iamVjdFwiLFxuICBpbnB1dE9wdGlvbnM6IFwib2JqZWN0XCJcbn0sIHV2ID0ge1xuICBpbnB1dElEOiBldChcImNoaXBzLWlucHV0LVwiKSxcbiAgcGFyZW50U2VsZWN0b3I6IFwiXCIsXG4gIGluaXRpYWxWYWx1ZXM6IFt7IHRhZzogXCJpbml0MVwiIH0sIHsgdGFnOiBcImluaXQyXCIgfV0sXG4gIGVkaXRhYmxlOiAhMSxcbiAgbGFiZWxUZXh0OiBcIkV4YW1wbGUgbGFiZWxcIixcbiAgaW5wdXRDbGFzc2VzOiB7fSxcbiAgaW5wdXRPcHRpb25zOiB7fVxufSwgcHYgPSB7XG4gIG9wYWNpdHk6IFwib3BhY2l0eS0wXCIsXG4gIGlucHV0V3JhcHBlclBhZGRpbmc6IFwicC1bNXB4XVwiLFxuICB0cmFuc2l0aW9uOiBcInRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxKV1cIixcbiAgY29udGVudEVkaXRhYmxlOiBcIm91dGxpbmUtbm9uZSAhYm9yZGVyLVszcHhdICFib3JkZXItc29saWQgIWJvcmRlci1bI2IyYjNiNF1cIixcbiAgY2hpcHNJbnB1dFdyYXBwZXI6IFwicmVsYXRpdmUgZmxleCBpdGVtcy1jZW50ZXIgZmxleC13cmFwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxKV1cIixcbiAgY2hpcHNJbnB1dDogXCJwZWVyIGJsb2NrIG1pbi1oLVthdXRvXSB3LVsxNTBweF0gcm91bmRlZCBib3JkZXItMCBiZy10cmFuc3BhcmVudCBweS1bMC4zMnJlbV0gcHgtMyBsZWFkaW5nLVsxLjZdIG91dGxpbmUtbm9uZSB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgZm9jdXM6cGxhY2Vob2xkZXI6b3BhY2l0eS0xMDAgZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpwbGFjZWhvbGRlcjpvcGFjaXR5LTEwMCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwbGFjZWhvbGRlcjp0ZXh0LWdyYXktMjAwIFsmOm5vdChbZGF0YS10ZS1pbnB1dC1wbGFjZWhvbGRlci1hY3RpdmVdKV06cGxhY2Vob2xkZXI6b3BhY2l0eS0wXCIsXG4gIGNoaXBzTGFiZWw6IFwicG9pbnRlci1ldmVudHMtbm9uZSBhYnNvbHV0ZSB0b3AtMCBsZWZ0LTMgbWItMCBtYXgtdy1bOTAlXSBvcmlnaW4tWzBfMF0gdHJ1bmNhdGUgcHQtWzAuMzdyZW1dIGxlYWRpbmctWzEuNl0gdGV4dC1ncmF5LTUwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1vdXQgcGVlci1mb2N1czotdHJhbnNsYXRlLXktWzAuOXJlbV0gcGVlci1mb2N1czpzY2FsZS1bMC44XSBwZWVyLWZvY3VzOnRleHQtcHJpbWFyeSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVswLjlyZW1dIHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpzY2FsZS1bMC44XSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwZWVyLWZvY3VzOnRleHQtZ3JheS0yMDBcIlxufSwgX3YgPSB7XG4gIG9wYWNpdHk6IFwic3RyaW5nXCIsXG4gIGlucHV0V3JhcHBlclBhZGRpbmc6IFwic3RyaW5nXCIsXG4gIHRyYW5zaXRpb246IFwic3RyaW5nXCIsXG4gIGNvbnRlbnRFZGl0YWJsZTogXCJzdHJpbmdcIixcbiAgY2hpcHNJbnB1dFdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGNoaXBzSW5wdXQ6IFwic3RyaW5nXCIsXG4gIGNoaXBzTGFiZWw6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBYQSBleHRlbmRzIHZpIHtcbiAgY29uc3RydWN0b3IoZSwgaSA9IHt9LCBuKSB7XG4gICAgc3VwZXIoZSwgaSk7XG4gICAgd3QodGhpcywgXCJfaGFuZGxlQmx1cklucHV0XCIsICh7IHRhcmdldDogZSB9KSA9PiB7XG4gICAgICBlLnZhbHVlLmxlbmd0aCA+IDAgJiYgdGhpcy5faGFuZGxlQ3JlYXRlQ2hpcChlLCBlLnZhbHVlKSwgdGhpcy5hbGxDaGlwcy5sZW5ndGggPiAwID8gKGUuc2V0QXR0cmlidXRlKGJ0LCBcIlwiKSwgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoTmUsIFwiXCIpLCBkLmZpbmRPbmUoXG4gICAgICAgIEVvLFxuICAgICAgICB0aGlzLmlucHV0LnBhcmVudE5vZGVcbiAgICAgICkuc2V0QXR0cmlidXRlKE5lLCBcIlwiKSwgdGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKFxuICAgICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgICApKSA6IChlLnJlbW92ZUF0dHJpYnV0ZShidCksIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKE5lKSwgZC5maW5kT25lKFxuICAgICAgICBFbyxcbiAgICAgICAgdGhpcy5pbnB1dC5wYXJlbnROb2RlXG4gICAgICApLnJlbW92ZUF0dHJpYnV0ZShOZSksIHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnB1dFdyYXBwZXJQYWRkaW5nLnNwbGl0KFwiIFwiKVxuICAgICAgKSksIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoaSkgPT4gaS5yZW1vdmVBdHRyaWJ1dGUoYnQpKTtcbiAgICB9KTtcbiAgICB0aGlzLl9lbGVtZW50ID0gZSwgdGhpcy5faW5wdXRJbnN0YW5jZSA9IG51bGwsIHRoaXMuX2VsZW1lbnQgJiYgQS5zZXREYXRhKGUsIHhsLCB0aGlzKSwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhpKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMobiksIHRoaXMubnVtYmVyQ2xpY2tzID0gMCwgdGhpcy5pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEhpO1xuICB9XG4gIGdldCBhY3RpdmVDaGlwKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoUWIsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBpbnB1dCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFwiaW5wdXRcIiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IGFsbENoaXBzKCkge1xuICAgIHJldHVybiBkLmZpbmQodHIsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBjaGlwc0lucHV0V3JhcHBlcigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKEpiLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9zZXRDaGlwc0NsYXNzKCksIHRoaXMuX2FwcGVuZElucHV0VG9FbGVtZW50KFNoKSwgdGhpcy5faGFuZGxlSW5pdGlhbFZhbHVlKCksIHRoaXMuX2hhbmRsZUlucHV0VGV4dCgpLCB0aGlzLl9oYW5kbGVLZXlib2FyZCgpLCB0aGlzLl9oYW5kbGVDaGlwc09uU2VsZWN0KCksIHRoaXMuX2hhbmRsZUVkaXRhYmxlKCksIHRoaXMuX2hhbmRsZUNoaXBzRm9jdXMoKSwgdGhpcy5faGFuZGxlQ2xpY2tzT25DaGlwcygpLCB0aGlzLl9pbnB1dEluc3RhbmNlLl9nZXRMYWJlbFdpZHRoKCksIHRoaXMuX2lucHV0SW5zdGFuY2UuX2FwcGx5Tm90Y2goKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9vcHRpb25zID0gbnVsbDtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXROb3RjaERhdGEoKSB7XG4gICAgdGhpcy5fbm90Y2hNaWRkbGUgPSBkLmZpbmRPbmUoXG4gICAgICBvdixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBkLmZpbmRPbmUoXG4gICAgICBudixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICB9XG4gIF9zZXRDaGlwc0NsYXNzKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKEdiLCBcIlwiKTtcbiAgfVxuICBfaGFuZGxlRGVsZXRlRXZlbnRzKGUpIHtcbiAgICBjb25zdCBbaV0gPSB0aGlzLmFsbENoaXBzLnNsaWNlKC0xKTtcbiAgICBpZiAodGhpcy5hY3RpdmVDaGlwID09PSBudWxsKVxuICAgICAgaS5yZW1vdmUoKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIFNsKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmFsbENoaXBzLmZpbmRJbmRleCgoYSkgPT4gYSA9PT0gdGhpcy5hY3RpdmVDaGlwKSwgbyA9IHRoaXMuX2hhbmRsZUFjdGl2ZUNoaXBBZnRlclJlbW92ZShuKSwgciA9IFtdO1xuICAgICAgaWYgKHRoaXMuYWN0aXZlQ2hpcCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5hY3RpdmVDaGlwLnJlbW92ZSgpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgU2wpLCB0aGlzLm51bWJlckNsaWNrcyA9IG4sIG8uc2V0QXR0cmlidXRlKGJ0LCBcIlwiKSwgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGEuaGFzQXR0cmlidXRlKGJ0KSAmJiAoci5wdXNoKGEpLCByLmxlbmd0aCA+IDEgJiYgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChsKSA9PiBsLnJlbW92ZSgpKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX2hhbmRsZVVwRXZlbnRzKGUpIHtcbiAgICB0aGlzLm51bWJlckNsaWNrcyArPSAxLCB0aGlzLm51bWJlckNsaWNrcyA9PT0gdGhpcy5hbGxDaGlwcy5sZW5ndGggKyAxICYmICh0aGlzLm51bWJlckNsaWNrcyA9IDApLCB0aGlzLl9oYW5kbGVSaWdodEtleWJvYXJkQXJyb3codGhpcy5udW1iZXJDbGlja3MpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgY3YpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgaHYpO1xuICB9XG4gIF9oYW5kbGVEb3duRXZlbnRzKGUpIHtcbiAgICB0aGlzLm51bWJlckNsaWNrcyAtPSAxLCB0aGlzLm51bWJlckNsaWNrcyA8PSAwICYmICh0aGlzLm51bWJlckNsaWNrcyA9IHRoaXMuYWxsQ2hpcHMubGVuZ3RoKSwgdGhpcy5faGFuZGxlTGVmdEtleWJvYXJkQXJyb3codGhpcy5udW1iZXJDbGlja3MpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgbHYpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgYXYpO1xuICB9XG4gIF9rZXlib2FyZEV2ZW50cyhlKSB7XG4gICAgY29uc3QgeyB0YXJnZXQ6IGksIGtleUNvZGU6IG4sIGN0cmxLZXk6IG8gfSA9IGU7XG4gICAgaS52YWx1ZS5sZW5ndGggPiAwIHx8IHRoaXMuYWxsQ2hpcHMubGVuZ3RoID09PSAwIHx8IChuID09PSBvbSB8fCBuID09PSBybSA/IHRoaXMuX2hhbmRsZURlbGV0ZUV2ZW50cyhlKSA6IG4gPT09IHplIHx8IG4gPT09IFUgPyB0aGlzLl9oYW5kbGVVcEV2ZW50cyhlKSA6IG4gPT09IEtlIHx8IG4gPT09IHogPyB0aGlzLl9oYW5kbGVEb3duRXZlbnRzKGUpIDogbiA9PT0gNjUgJiYgbyAmJiB0aGlzLl9oYW5kbGVBZGRBY3RpdmVDbGFzcygpKTtcbiAgfVxuICBfaGFuZGxlS2V5Ym9hcmQoKSB7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuaW5wdXQsXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIChlKSA9PiB0aGlzLl9rZXlib2FyZEV2ZW50cyhlKVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUVkaXRhYmxlKCkge1xuICAgIGNvbnN0IHsgZWRpdGFibGU6IGUgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgZSAmJiB0aGlzLmFsbENoaXBzLmZvckVhY2goKGkpID0+IHtcbiAgICAgIGMub24oaSwgXCJkYmxjbGlja1wiLCAobikgPT4ge1xuICAgICAgICBjb25zdCBvID0gZC5maW5kT25lKFRvLCBpKTtcbiAgICAgICAgaS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMuY29udGVudEVkaXRhYmxlLnNwbGl0KFwiIFwiKSksIGkuY29udGVudEVkaXRhYmxlID0gITAsIGkuZm9jdXMoKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaC5hZGRTdHlsZShvLCB7IGRpc3BsYXk6IFwibm9uZVwiIH0pO1xuICAgICAgICB9LCAyMDApLCBvLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSksIG4udGFyZ2V0LnRleHRDb250ZW50LCBjLnRyaWdnZXIoaSwgSWwsIHtcbiAgICAgICAgICBldmVudDogbixcbiAgICAgICAgICBhbGxDaGlwczogdGhpcy5hbGxDaGlwc1xuICAgICAgICB9KTtcbiAgICAgIH0pLCBjLm9uKGRvY3VtZW50LCBcImNsaWNrXCIsICh7IHRhcmdldDogbiB9KSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSBkLmZpbmRPbmUoVG8sIGkpLCByID0gZC5maW5kT25lKHR2LCBpKSwgYSA9IG4gPT09IGksIGwgPSBpICYmIGkuY29udGFpbnMobik7XG4gICAgICAgICFhICYmICFsICYmIChpLmNvbnRlbnRFZGl0YWJsZSA9ICExLCBpLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5jb250ZW50RWRpdGFibGUuc3BsaXQoXCIgXCIpKSwgci50ZXh0Q29udGVudCAhPT0gXCJcIiAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBoLmFkZFN0eWxlKG8sIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCBvLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSk7XG4gICAgICAgIH0sIDE2MCkpLCByLnRleHRDb250ZW50ID09PSBcIlwiICYmIChzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSk7XG4gICAgICAgIH0sIDIwMCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGkucmVtb3ZlKCk7XG4gICAgICAgIH0sIDMwMCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVJlbW92ZUFjdGl2ZUNsYXNzKCkge1xuICAgIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoZSkgPT4gZS5yZW1vdmVBdHRyaWJ1dGUoYnQpKTtcbiAgfVxuICBfaGFuZGxlQWRkQWN0aXZlQ2xhc3MoKSB7XG4gICAgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChlKSA9PiBlLnNldEF0dHJpYnV0ZShidCwgXCJcIikpO1xuICB9XG4gIF9oYW5kbGVSaWdodEtleWJvYXJkQXJyb3coZSkge1xuICAgIHRoaXMuX2hhbmRsZVJlbW92ZUFjdGl2ZUNsYXNzKCksIGUgPT09IDAgJiYgKGUgPSAxKSwgdGhpcy5faGFuZGxlQWRkQWN0aXZlQ2xhc3NXaXRoS2VieWJvYXJkKGUpO1xuICB9XG4gIF9oYW5kbGVMZWZ0S2V5Ym9hcmRBcnJvdyhlKSB7XG4gICAgdGhpcy5faGFuZGxlUmVtb3ZlQWN0aXZlQ2xhc3MoKSwgdGhpcy5faGFuZGxlQWRkQWN0aXZlQ2xhc3NXaXRoS2VieWJvYXJkKGUpO1xuICB9XG4gIF9oYW5kbGVBY3RpdmVDaGlwQWZ0ZXJSZW1vdmUoZSkge1xuICAgIGNvbnN0IGkgPSBlID09PSAwID8gMSA6IGUgLSAxO1xuICAgIHJldHVybiB0aGlzLmFsbENoaXBzW2ldO1xuICB9XG4gIF9oYW5kbGVDbGlja3NPbkNoaXBzKCkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmFsbENoaXBzLmxlbmd0aCA9PT0gMCAmJiAodGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgICApLCB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShidCkpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgcmV0dXJuIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoaSkgPT4gZS5wdXNoKHsgdGFnOiBpLnRleHRDb250ZW50LnRyaW0oKSB9KSksIGU7XG4gIH1cbiAgX2hhbmRsZUV2ZW50cyhlLCBpKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2hhbmRsZVRleHRDb250ZW50KCksIG8gPSB0aGlzLmFsbENoaXBzLmZpbHRlcihcbiAgICAgIChyKSA9PiByLmhhc0F0dHJpYnV0ZShidCkgJiYgclxuICAgICk7XG4gICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGksIHtcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgYWxsQ2hpcHM6IHRoaXMuYWxsQ2hpcHMsXG4gICAgICBhcnJPZk9iamVjdHM6IG4sXG4gICAgICBhY3RpdmU6IG8sXG4gICAgICBhY3RpdmVPYmo6IHtcbiAgICAgICAgdGFnOiBvLmxlbmd0aCA8PSAwID8gXCJcIiA6IG9bMF0udGV4dENvbnRlbnQudHJpbSgpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUNoaXBzRm9jdXMoKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsICh7IHRhcmdldDogeyBhdHRyaWJ1dGVzOiBlIH0gfSkgPT4ge1xuICAgICAgY29uc3QgaSA9IFsuLi5lXS5tYXAoKG4pID0+IG4ubmFtZSk7XG4gICAgICBpLmluY2x1ZGVzKEpvKSB8fCBpLmluY2x1ZGVzKEloKSB8fCBpLmluY2x1ZGVzKERoKSB8fCB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUluaXRpYWxWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5fYXBwZW5kSW5wdXRUb0VsZW1lbnQoT2wpLCB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShPbCkpIHtcbiAgICAgIGNvbnN0IHsgaW5pdGlhbFZhbHVlczogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgIGUuZm9yRWFjaChcbiAgICAgICAgKHsgdGFnOiBpIH0pID0+IHRoaXMuX2hhbmRsZUNyZWF0ZUNoaXAodGhpcy5pbnB1dCwgaSlcbiAgICAgICksIGQuZmluZE9uZShcbiAgICAgICAgRW8sXG4gICAgICAgIHRoaXMuaW5wdXQucGFyZW50Tm9kZVxuICAgICAgKS5zZXRBdHRyaWJ1dGUoTmUsIFwiXCIpLCB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShidCwgXCJcIiksIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKE5lLCBcIlwiKTtcbiAgICB9XG4gICAgdGhpcy5hbGxDaGlwcy5sZW5ndGggPiAwICYmICh0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgKSwgdGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy50cmFuc2l0aW9uLnNwbGl0KFwiIFwiKVxuICAgICkpO1xuICB9XG4gIF9oYW5kbGVLZXlzSW5wdXRUb0VsZW1lbnQoZSkge1xuICAgIGNvbnN0IHsga2V5Q29kZTogaSwgdGFyZ2V0OiBuIH0gPSBlO1xuICAgIGlmIChuLmhhc0F0dHJpYnV0ZShKbykpIHtcbiAgICAgIGNvbnN0IG8gPSBkLmZpbmRPbmUoVG8sIG4pO1xuICAgICAgaSA9PT0gaXQgJiYgKG4uY29udGVudEVkaXRhYmxlID0gITEsIG4uY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLmNvbnRlbnRFZGl0YWJsZS5zcGxpdChcIiBcIikpLCBuLnRleHRDb250ZW50ICE9PSBcIlwiID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGguYWRkU3R5bGUobywgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIG8uY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLm9wYWNpdHkuc3BsaXQoXCIgXCIpKTtcbiAgICAgIH0sIDE2MCkgOiBuLnRleHRDb250ZW50ID09PSBcIlwiICYmIChzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbi5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMub3BhY2l0eS5zcGxpdChcIiBcIikpO1xuICAgICAgfSwgMjAwKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG4ucmVtb3ZlKCk7XG4gICAgICB9LCAzMDApKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpID09PSBpdCkge1xuICAgICAgaWYgKG4udmFsdWUgPT09IFwiXCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX2hhbmRsZUNyZWF0ZUNoaXAobiwgbi52YWx1ZSksIHRoaXMuX2hhbmRsZVJlbW92ZUFjdGl2ZUNsYXNzKCksIHRoaXMubnVtYmVyQ2xpY2tzID0gdGhpcy5hbGxDaGlwcy5sZW5ndGggKyAxLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgcnYpO1xuICAgIH1cbiAgICB0aGlzLmFsbENoaXBzLmxlbmd0aCA+IDAgPyAodGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnB1dFdyYXBwZXJQYWRkaW5nLnNwbGl0KFwiIFwiKVxuICAgICksIHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LmFkZChcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMudHJhbnNpdGlvbi5zcGxpdChcIiBcIilcbiAgICApKSA6IHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICApO1xuICB9XG4gIF9oYW5kbGVJbnB1dFRleHQoKSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcbiAgICAgIGV2LFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImtleXVwXCIsXG4gICAgICBlLFxuICAgICAgKGkpID0+IHRoaXMuX2hhbmRsZUtleXNJbnB1dFRvRWxlbWVudChpKVxuICAgICksIGMub24odGhpcy5pbnB1dCwgXCJibHVyXCIsIChpKSA9PiB0aGlzLl9oYW5kbGVCbHVySW5wdXQoaSkpO1xuICB9XG4gIF9hcHBlbmRJbnB1dFRvRWxlbWVudChlKSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShlKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gSGIodGhpcy5fb3B0aW9ucywgdGhpcy5fY2xhc3Nlcyk7XG4gICAgdGhpcy5fZWxlbWVudC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgaSk7XG4gICAgY29uc3QgbiA9IGQuZmluZE9uZShcbiAgICAgIFwiW2RhdGEtdGUtY2hpcHMtaW5wdXQtd3JhcHBlcl1cIixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHRoaXMuX2lucHV0SW5zdGFuY2UgPSBuZXcgVihcbiAgICAgIG4sXG4gICAgICB0aGlzLl9vcHRpb25zLmlucHV0T3B0aW9ucyxcbiAgICAgIHRoaXMuX29wdGlvbnMuaW5wdXRDbGFzc2VzXG4gICAgKTtcbiAgfVxuICBfaGFuZGxlQ3JlYXRlQ2hpcChlLCBpKSB7XG4gICAgY29uc3QgbiA9ICQoXCJkaXZcIiksIG8gPSB2aS5nZXRJbnN0YW5jZShuKSwgciA9IG5ldyB2aShvLCB7IHRleHQ6IGkgfSwgdGhpcy5fY2xhc3Nlcyk7XG4gICAgdGhpcy5fb3B0aW9ucy5wYXJlbnRTZWxlY3RvciAhPT0gXCJcIiA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5fb3B0aW9ucy5wYXJlbnRTZWxlY3RvcikuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIHIuYXBwZW5kQ2hpcCgpKSA6IGUuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlYmVnaW5cIiwgci5hcHBlbmRDaGlwKCkpLCBlLnZhbHVlID0gXCJcIiwgZC5maW5kKHRyKS5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBsZXQgbCA9IHZpLmdldEluc3RhbmNlKGEpO1xuICAgICAgcmV0dXJuIGwgfHwgKGwgPSBuZXcgdmkoYSwge30sIHRoaXMuX2NsYXNzZXMpKSwgbC5pbml0KCk7XG4gICAgfSksIHRoaXMuX2hhbmRsZUVkaXRhYmxlKCk7XG4gIH1cbiAgX2hhbmRsZUNoaXBzT25TZWxlY3QoKSB7XG4gICAgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgKGkpID0+IHtcbiAgICAgICAgYy50cmlnZ2VyKGUsIElsLCB7XG4gICAgICAgICAgZXZlbnQ6IGksXG4gICAgICAgICAgYWxsQ2hpcHM6IHRoaXMuYWxsQ2hpcHNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQWRkQWN0aXZlQ2xhc3NXaXRoS2VieWJvYXJkKGUpIHtcbiAgICBsZXQgaTtcbiAgICB0aGlzLmFsbENoaXBzW2UgLSAxXSA9PT0gdm9pZCAwID8gaSA9IHRoaXMuYWxsQ2hpcHNbZSAtIDJdIDogaSA9IHRoaXMuYWxsQ2hpcHNbZSAtIDFdLCBpLnNldEF0dHJpYnV0ZShidCk7XG4gIH1cbiAgX2dldENvbmZpZyhlKSB7XG4gICAgY29uc3QgaSA9IHtcbiAgICAgIC4uLnV2LFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLmVcbiAgICB9O1xuICAgIHJldHVybiBJKEhpLCBpLCBkdiksIGk7XG4gIH1cbiAgX2dldENsYXNzZXMoZSkge1xuICAgIGNvbnN0IGkgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIGUgPSB7XG4gICAgICAuLi5wdixcbiAgICAgIC4uLmksXG4gICAgICAuLi5lXG4gICAgfSwgSShIaSwgZSwgX3YpLCBlO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZShlKSB7XG4gICAgcmV0dXJuIEEuZ2V0RGF0YShlLCB4bCk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UoZSwgaSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoZSkgfHwgbmV3IHRoaXMoZSwgdHlwZW9mIGkgPT0gXCJvYmplY3RcIiA/IGkgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgVXQgPSB7XG4gIHBsdWdpbnM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBjb2xvcjogXCJyZ2IoMTAyLDEwMiwxMDIpXCJcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sIHdpID0ge1xuICBsaW5lOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uVXQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjApXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgICAgICB0ZW5zaW9uOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH0sXG4gICAgICB0b29sdGlwczoge1xuICAgICAgICBpbnRlcnNlY3Q6ICExLFxuICAgICAgICBtb2RlOiBcImluZGV4XCJcbiAgICAgIH0sXG4gICAgICBkYXRhc2V0czoge1xuICAgICAgICBib3JkZXJDb2xvcjogXCJyZWRcIlxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgc3RhY2tlZDogITEsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgYm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgZHJhd0JvcmRlcjogITEsXG4gICAgICAgICAgICB6ZXJvTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiBbMl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiYXI6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5VdCxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfSxcbiAgICAgIHRvb2x0aXBzOiB7XG4gICAgICAgIGludGVyc2VjdDogITEsXG4gICAgICAgIG1vZGU6IFwiaW5kZXhcIlxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgYm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgZHJhd0JvcmRlcjogITEsXG4gICAgICAgICAgICB6ZXJvTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiBbMl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwaWU6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5VdCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGFyYzogeyBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIiB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRvdWdobnV0OiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uVXQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBhcmM6IHsgYmFja2dyb3VuZENvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2xhckFyZWE6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5VdCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGFyYzogeyBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIiB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJhZGFyOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uVXQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjUpXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBib3JkZXJXaWR0aDogMlxuICAgICAgICB9LFxuICAgICAgICBwb2ludDoge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2F0dGVyOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uVXQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjUpXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgICAgICB0ZW5zaW9uOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH0sXG4gICAgICB0b29sdGlwczoge1xuICAgICAgICBpbnRlcnNlY3Q6ICExLFxuICAgICAgICBtb2RlOiBcImluZGV4XCJcbiAgICAgIH0sXG4gICAgICBkYXRhc2V0czoge1xuICAgICAgICBib3JkZXJDb2xvcjogXCJyZWRcIlxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgc3RhY2tlZDogITEsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgYm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgZHJhd0JvcmRlcjogITEsXG4gICAgICAgICAgICB6ZXJvTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiBbMl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBidWJibGU6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5VdCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH0sXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIGRyYXdCb3JkZXI6ICExLFxuICAgICAgICAgICAgemVyb0xpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLDApXCIsXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaE9mZnNldDogWzJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBmdiA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIG12KHQpICYmICFndih0KTtcbn07XG5mdW5jdGlvbiBtdihzKSB7XG4gIHJldHVybiAhIXMgJiYgdHlwZW9mIHMgPT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIGd2KHMpIHtcbiAgdmFyIHQgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocyk7XG4gIHJldHVybiB0ID09PSBcIltvYmplY3QgUmVnRXhwXVwiIHx8IHQgPT09IFwiW29iamVjdCBEYXRlXVwiIHx8IFR2KHMpO1xufVxudmFyIGJ2ID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLmZvciwgdnYgPSBidiA/IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpIDogNjAxMDM7XG5mdW5jdGlvbiBUdihzKSB7XG4gIHJldHVybiBzLiQkdHlwZW9mID09PSB2djtcbn1cbmZ1bmN0aW9uIEV2KHMpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocykgPyBbXSA6IHt9O1xufVxuZnVuY3Rpb24gWWkocywgdCkge1xuICByZXR1cm4gdC5jbG9uZSAhPT0gITEgJiYgdC5pc01lcmdlYWJsZU9iamVjdChzKSA/IGlpKEV2KHMpLCBzLCB0KSA6IHM7XG59XG5mdW5jdGlvbiBDdihzLCB0LCBlKSB7XG4gIHJldHVybiBzLmNvbmNhdCh0KS5tYXAoZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBZaShpLCBlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBBdihzLCB0KSB7XG4gIGlmICghdC5jdXN0b21NZXJnZSlcbiAgICByZXR1cm4gaWk7XG4gIHZhciBlID0gdC5jdXN0b21NZXJnZShzKTtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUgOiBpaTtcbn1cbmZ1bmN0aW9uIHl2KHMpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpLmZpbHRlcihmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHQpO1xuICB9KSA6IFtdO1xufVxuZnVuY3Rpb24gRGwocykge1xuICByZXR1cm4gT2JqZWN0LmtleXMocykuY29uY2F0KHl2KHMpKTtcbn1cbmZ1bmN0aW9uICRoKHMsIHQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdCBpbiBzO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIHd2KHMsIHQpIHtcbiAgcmV0dXJuICRoKHMsIHQpICYmICEoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocywgdCkgJiYgT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgdCkpO1xufVxuZnVuY3Rpb24ga3YocywgdCwgZSkge1xuICB2YXIgaSA9IHt9O1xuICByZXR1cm4gZS5pc01lcmdlYWJsZU9iamVjdChzKSAmJiBEbChzKS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICBpW25dID0gWWkoc1tuXSwgZSk7XG4gIH0pLCBEbCh0KS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICB3dihzLCBuKSB8fCAoJGgocywgbikgJiYgZS5pc01lcmdlYWJsZU9iamVjdCh0W25dKSA/IGlbbl0gPSBBdihuLCBlKShzW25dLCB0W25dLCBlKSA6IGlbbl0gPSBZaSh0W25dLCBlKSk7XG4gIH0pLCBpO1xufVxuZnVuY3Rpb24gaWkocywgdCwgZSkge1xuICBlID0gZSB8fCB7fSwgZS5hcnJheU1lcmdlID0gZS5hcnJheU1lcmdlIHx8IEN2LCBlLmlzTWVyZ2VhYmxlT2JqZWN0ID0gZS5pc01lcmdlYWJsZU9iamVjdCB8fCBmdiwgZS5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCA9IFlpO1xuICB2YXIgaSA9IEFycmF5LmlzQXJyYXkodCksIG4gPSBBcnJheS5pc0FycmF5KHMpLCBvID0gaSA9PT0gbjtcbiAgcmV0dXJuIG8gPyBpID8gZS5hcnJheU1lcmdlKHMsIHQsIGUpIDoga3YocywgdCwgZSkgOiBZaSh0LCBlKTtcbn1cbmlpLmFsbCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheVwiKTtcbiAgcmV0dXJuIHQucmVkdWNlKGZ1bmN0aW9uKGksIG4pIHtcbiAgICByZXR1cm4gaWkoaSwgbiwgZSk7XG4gIH0sIHt9KTtcbn07XG52YXIgeHYgPSBpaSwgZXIgPSB4djtcbmNvbnN0ICRsID0gXCJjaGFydFwiLCBTcyA9IFwidGUuY2hhcnRcIiwgT3YgPSBcImNoYXJ0XCIsIENvID0gKHMsIHQsIGUpID0+IHtcbiAgY29uc3QgaSA9IChuLCBvLCByKSA9PiB7XG4gICAgY29uc3QgYSA9IG4uc2xpY2UoKTtcbiAgICByZXR1cm4gby5mb3JFYWNoKChsLCBwKSA9PiB7XG4gICAgICB0eXBlb2YgYVtwXSA+IFwidVwiID8gYVtwXSA9IHIuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoXG4gICAgICAgIGwsXG4gICAgICAgIHJcbiAgICAgICkgOiByLmlzTWVyZ2VhYmxlT2JqZWN0KGwpID8gYVtwXSA9IGVyKG5bcF0sIGwsIHIpIDogbi5pbmRleE9mKGwpID09PSAtMSAmJiBhLnB1c2gobCk7XG4gICAgfSksIGE7XG4gIH07XG4gIHJldHVybiBlcihlW3RdLCBzLCB7XG4gICAgYXJyYXlNZXJnZTogaVxuICB9KTtcbn0sIFN2ID0ge1xuICBkYXJrVGlja3NDb2xvcjogXCIjZmZmXCIsXG4gIGRhcmtMYWJlbENvbG9yOiBcIiNmZmZcIixcbiAgZGFya0dyaWRMaW5lc0NvbG9yOiBcIiM1NTVcIixcbiAgZGFya21vZGVPZmY6IFwidW5kZWZpbmVkXCIsXG4gIGRhcmtNb2RlOiBudWxsLFxuICBkYXJrQmdDb2xvcjogXCIjMjYyNjI2XCIsXG4gIGRhcmtCZ0NvbG9yTGlnaHQ6IFwiI2ZmZlwiLFxuICBvcHRpb25zOiBudWxsXG59LCBJdiA9IHtcbiAgZGFya1RpY2tzQ29sb3I6IFwic3RyaW5nXCIsXG4gIGRhcmtMYWJlbENvbG9yOiBcInN0cmluZ1wiLFxuICBkYXJrR3JpZExpbmVzQ29sb3I6IFwic3RyaW5nXCIsXG4gIGRhcmttb2RlT2ZmOiBcIihzdHJpbmd8bnVsbClcIixcbiAgZGFya01vZGU6IFwiKHN0cmluZ3xudWxsKVwiLFxuICBkYXJrQmdDb2xvcjogXCJzdHJpbmdcIixcbiAgZGFya0JnQ29sb3JMaWdodDogXCJzdHJpbmdcIixcbiAgb3B0aW9uczogXCIob2JqZWN0fG51bGwpXCJcbn07XG5jbGFzcyBMaCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkgPSB7fSwgbiA9IHt9KSB7XG4gICAgdGhpcy5fd2FpdEZvckNoYXJ0cyh0LCBlLCBpLCBuKTtcbiAgfVxuICBhc3luYyBfZ2V0Q2hhcnRqcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBDaGFydDogdCxcbiAgICAgIEFyY0VsZW1lbnQ6IGUsXG4gICAgICBMaW5lRWxlbWVudDogaSxcbiAgICAgIEJhckVsZW1lbnQ6IG4sXG4gICAgICBQb2ludEVsZW1lbnQ6IG8sXG4gICAgICBCYXJDb250cm9sbGVyOiByLFxuICAgICAgQnViYmxlQ29udHJvbGxlcjogYSxcbiAgICAgIERvdWdobnV0Q29udHJvbGxlcjogbCxcbiAgICAgIExpbmVDb250cm9sbGVyOiBwLFxuICAgICAgUGllQ29udHJvbGxlcjogdSxcbiAgICAgIFBvbGFyQXJlYUNvbnRyb2xsZXI6IF8sXG4gICAgICBSYWRhckNvbnRyb2xsZXI6IGYsXG4gICAgICBTY2F0dGVyQ29udHJvbGxlcjogZyxcbiAgICAgIENhdGVnb3J5U2NhbGU6IG0sXG4gICAgICBMaW5lYXJTY2FsZTogYixcbiAgICAgIExvZ2FyaXRobWljU2NhbGU6IHYsXG4gICAgICBSYWRpYWxMaW5lYXJTY2FsZTogVCxcbiAgICAgIFRpbWVTY2FsZTogeSxcbiAgICAgIFRpbWVTZXJpZXNTY2FsZTogQyxcbiAgICAgIERlY2ltYXRpb246IEUsXG4gICAgICBGaWxsZXI6IHcsXG4gICAgICBMZWdlbmQ6IGssXG4gICAgICBUaXRsZTogRCxcbiAgICAgIFRvb2x0aXA6IE8sXG4gICAgICBTdWJUaXRsZTogeFxuICAgIH0gPSBhd2FpdCBpbXBvcnQoXCIuL2NoYXJ0LmVzLmpzXCIpLnRoZW4oKEwpID0+IEwuZik7XG4gICAgcmV0dXJuIHQucmVnaXN0ZXIoXG4gICAgICBlLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICBvLFxuICAgICAgcixcbiAgICAgIGEsXG4gICAgICBsLFxuICAgICAgcCxcbiAgICAgIHUsXG4gICAgICBfLFxuICAgICAgZixcbiAgICAgIGcsXG4gICAgICBtLFxuICAgICAgYixcbiAgICAgIHYsXG4gICAgICBULFxuICAgICAgeSxcbiAgICAgIEMsXG4gICAgICBFLFxuICAgICAgdyxcbiAgICAgIGssXG4gICAgICBELFxuICAgICAgTyxcbiAgICAgIHhcbiAgICApLCB0O1xuICB9XG4gIGFzeW5jIF9nZXRDaGFydERhdGFMYWJlbHMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IGltcG9ydChcIi4vY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5lcy5qc1wiKTtcbiAgfVxuICBhc3luYyBfd2FpdEZvckNoYXJ0cyh0LCBlLCBpID0ge30sIG4gPSB7fSkge1xuICAgIGlmICh0aGlzLl9DaGFydGpzID0gYXdhaXQgdGhpcy5fZ2V0Q2hhcnRqcygpLCB0aGlzLl9DaGFydERhdGFMYWJlbHMgPSBhd2FpdCB0aGlzLl9nZXRDaGFydERhdGFMYWJlbHMoKSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2RhdGEgPSBlLCB0aGlzLl9vcHRpb25zID0gaSwgdGhpcy5fdHlwZSA9IGUudHlwZSwgdGhpcy5fY2FudmFzID0gbnVsbCwgdGhpcy5fY2hhcnQgPSBudWxsLCB0aGlzLl9kYXJrT3B0aW9ucyA9IHRoaXMuX2dldERhcmtDb25maWcobiksIHRoaXMuX2RhcmtNb2RlQ2xhc3NDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaHRtbFwiKSwgdGhpcy5fcHJldkNvbmZpZyA9IG51bGwsIHRoaXMuX29ic2VydmVyID0gbnVsbCwgdGhpcy5fZWxlbWVudCAmJiAoQS5zZXREYXRhKHQsIFNzLCB0aGlzKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBPdiksIHRoaXMuX2NoYXJ0Q29uc3RydWN0b3IoKSksIHRoaXMuX2RhcmtPcHRpb25zLmRhcmttb2RlT2ZmICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy5fZGFya09wdGlvbnMuZGFya01vZGUgPT09IFwiZGFya1wiID8gXCJkYXJrXCIgOiB0aGlzLl9kYXJrT3B0aW9ucy5kYXJrTW9kZSA9PT0gXCJsaWdodFwiID8gXCJsaWdodFwiIDogdGhpcy5zeXN0ZW1Db2xvck1vZGU7XG4gICAgICB0aGlzLl9oYW5kbGVNb2RlKG8pLCB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX29ic2VydmVyQ2FsbGJhY2suYmluZCh0aGlzKSksIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZGFya01vZGVDbGFzc0NvbnRhaW5lciwge1xuICAgICAgICBhdHRyaWJ1dGVzOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiAkbDtcbiAgfVxuICBnZXQgc3lzdGVtQ29sb3JNb2RlKCkge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UudGhlbWUgfHwgKHRoaXMuX2RhcmtNb2RlQ2xhc3NDb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGFya1wiKSA/IFwiZGFya1wiIDogXCJsaWdodFwiKTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCksIEEucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBTcyksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIHVwZGF0ZSh0LCBlKSB7XG4gICAgdCAmJiAodGhpcy5fZGF0YSA9IHsgLi4udGhpcy5fZGF0YSwgLi4udCB9LCB0aGlzLl9jaGFydC5kYXRhID0gdGhpcy5fZGF0YSk7XG4gICAgY29uc3QgaSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiAgICAgIGUsXG4gICAgICBcIm9wdGlvbnNcIlxuICAgICkgPyBlIDogeyBvcHRpb25zOiB7IC4uLmUgfSB9O1xuICAgIHRoaXMuX29wdGlvbnMgPSBlcih0aGlzLl9vcHRpb25zLCBpKSwgdGhpcy5fY2hhcnQub3B0aW9ucyA9IENvKFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX3R5cGUsXG4gICAgICB3aVxuICAgICkub3B0aW9ucywgdGhpcy5fY2hhcnQudXBkYXRlKCk7XG4gIH1cbiAgc2V0VGhlbWUodCkge1xuICAgIHQgIT09IFwiZGFya1wiICYmIHQgIT09IFwibGlnaHRcIiB8fCAhdGhpcy5fZGF0YSB8fCB0aGlzLl9oYW5kbGVNb2RlKHQpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldERhcmtDb25maWcodCkge1xuICAgIGxldCBlID0ge307XG4gICAgY29uc3QgaSA9IGguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgT2JqZWN0LmtleXMoaSkuZm9yRWFjaChcbiAgICAgIChwKSA9PiBwLnN0YXJ0c1dpdGgoXCJkYXJrXCIpICYmIChlW3BdID0gaVtwXSlcbiAgICApLCBlID0ge1xuICAgICAgLi4uU3YsXG4gICAgICAuLi5lXG4gICAgfTtcbiAgICBjb25zdCBuID0ge1xuICAgICAgeToge1xuICAgICAgICB0aWNrczoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtUaWNrc0NvbG9yXG4gICAgICAgIH0sXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrR3JpZExpbmVzQ29sb3JcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHg6IHtcbiAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrVGlja3NDb2xvclxuICAgICAgICB9LFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya0dyaWRMaW5lc0NvbG9yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBvID0ge1xuICAgICAgcjoge1xuICAgICAgICB0aWNrczoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtUaWNrc0NvbG9yLFxuICAgICAgICAgIGJhY2tkcm9wQ29sb3I6IGUuZGFya0JnQ29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtHcmlkTGluZXNDb2xvclxuICAgICAgICB9LFxuICAgICAgICBwb2ludExhYmVsczoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtUaWNrc0NvbG9yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBsID0ge1xuICAgICAgc2NhbGVzOiBbXCJwaWVcIiwgXCJkb3VnaG51dFwiLCBcInBvbGFyQXJlYVwiLCBcInJhZGFyXCJdLmluY2x1ZGVzKHRoaXMuX3R5cGUpID8gW1wicG9sYXJBcmVhXCIsIFwicmFkYXJcIl0uaW5jbHVkZXModGhpcy5fdHlwZSkgPyBvIDoge30gOiBuLFxuICAgICAgcGx1Z2luczoge1xuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgIGNvbG9yOiBlLmRhcmtMYWJlbENvbG9yXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmUsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIC4uLmxcbiAgICAgIH0sXG4gICAgICAuLi50XG4gICAgfSwgSSgkbCwgdCwgSXYpLCB0O1xuICB9XG4gIF9jaGFydENvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVDYW52YXMoKTtcbiAgICAgIGNvbnN0IHQgPSBDbyh0aGlzLl9vcHRpb25zLCB0aGlzLl90eXBlLCB3aSksIGUgPSBbXTtcbiAgICAgIHQuZGF0YUxhYmVsc1BsdWdpbiAmJiBlLnB1c2godGhpcy5fQ2hhcnREYXRhTGFiZWxzLmRlZmF1bHQpLCB0aGlzLl9wcmV2Q29uZmlnID0gdCwgdGhpcy5fY2hhcnQgPSBuZXcgdGhpcy5fQ2hhcnRqcyh0aGlzLl9jYW52YXMsIHtcbiAgICAgICAgLi4udGhpcy5fZGF0YSxcbiAgICAgICAgLi4udCxcbiAgICAgICAgcGx1Z2luczogZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9jcmVhdGVDYW52YXMoKSB7XG4gICAgdGhpcy5fY2FudmFzIHx8ICh0aGlzLl9lbGVtZW50Lm5vZGVOYW1lID09PSBcIkNBTlZBU1wiID8gdGhpcy5fY2FudmFzID0gdGhpcy5fZWxlbWVudCA6ICh0aGlzLl9jYW52YXMgPSAkKFwiY2FudmFzXCIpLCB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcykpKTtcbiAgfVxuICBfaGFuZGxlTW9kZSh0KSB7XG4gICAgdCA9PT0gXCJkYXJrXCIgPyAodGhpcy5fY2hhbmdlRGF0YXNldEJvcmRlckNvbG9yKCksIHRoaXMudXBkYXRlKG51bGwsIHRoaXMuX2RhcmtPcHRpb25zLm9wdGlvbnMpKSA6ICh0aGlzLl9jaGFuZ2VEYXRhc2V0Qm9yZGVyQ29sb3IoITEpLCB0aGlzLl9wcmV2Q29uZmlnICYmIHRoaXMudXBkYXRlKG51bGwsIHRoaXMuX3ByZXZDb25maWcpKTtcbiAgfVxuICBfb2JzZXJ2ZXJDYWxsYmFjayh0KSB7XG4gICAgZm9yIChjb25zdCBlIG9mIHQpXG4gICAgICBlLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiICYmIHRoaXMuX2hhbmRsZU1vZGUodGhpcy5zeXN0ZW1Db2xvck1vZGUpO1xuICB9XG4gIF9jaGFuZ2VEYXRhc2V0Qm9yZGVyQ29sb3IodCA9ICEwKSB7XG4gICAgWy4uLnRoaXMuX2RhdGEuZGF0YS5kYXRhc2V0c10uZm9yRWFjaChcbiAgICAgIChlKSA9PiBbXCJwaWVcIiwgXCJkb3VnaG51dFwiLCBcInBvbGFyQXJlYVwiXS5pbmNsdWRlcyh0aGlzLl90eXBlKSAmJiAoZS5ib3JkZXJDb2xvciA9IHQgPyB0aGlzLl9kYXJrT3B0aW9ucy5kYXJrQmdDb2xvciA6IHRoaXMuX2RhcmtPcHRpb25zLmRhcmtCZ0NvbG9yTGlnaHQpXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUsIGkpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IG4gPSBBLmdldERhdGEodGhpcywgU3MpO1xuICAgICAgaWYgKCEoIW4gJiYgL2Rpc3Bvc2UvLnRlc3QodCkpKSB7XG4gICAgICAgIGlmICghbikge1xuICAgICAgICAgIGNvbnN0IG8gPSBlID8gQ28oZSwgaSwgd2kpIDogd2lbaV07XG4gICAgICAgICAgbiA9IG5ldyBMaCh0aGlzLCB7XG4gICAgICAgICAgICAuLi50LFxuICAgICAgICAgICAgLi4ub1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuW3RdID4gXCJ1XCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgICBuW3RdKGUsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIFNzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG4vKiFcbiAqIHBlcmZlY3Qtc2Nyb2xsYmFyIHYxLjUuM1xuICogQ29weXJpZ2h0IDIwMjEgSHl1bmplIEp1biwgTURCb290c3RyYXAgYW5kIENvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgTUlUXG4gKi9cbmZ1bmN0aW9uIE50KHMpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocyk7XG59XG5mdW5jdGlvbiBjdChzLCB0KSB7XG4gIGZvciAodmFyIGUgaW4gdCkge1xuICAgIHZhciBpID0gdFtlXTtcbiAgICB0eXBlb2YgaSA9PSBcIm51bWJlclwiICYmIChpID0gaSArIFwicHhcIiksIHMuc3R5bGVbZV0gPSBpO1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gSXMocykge1xuICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHJldHVybiB0LmNsYXNzTmFtZSA9IHMsIHQ7XG59XG52YXIgTGwgPSB0eXBlb2YgRWxlbWVudCA8IFwidVwiICYmIChFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IpO1xuZnVuY3Rpb24gSnQocywgdCkge1xuICBpZiAoIUxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVsZW1lbnQgbWF0Y2hpbmcgbWV0aG9kIHN1cHBvcnRlZFwiKTtcbiAgcmV0dXJuIExsLmNhbGwocywgdCk7XG59XG5mdW5jdGlvbiBZZShzKSB7XG4gIHMucmVtb3ZlID8gcy5yZW1vdmUoKSA6IHMucGFyZW50Tm9kZSAmJiBzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocyk7XG59XG5mdW5jdGlvbiBObChzLCB0KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoXG4gICAgcy5jaGlsZHJlbixcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gSnQoZSwgdCk7XG4gICAgfVxuICApO1xufVxudmFyIGogPSB7XG4gIG1haW46IFwicHNcIixcbiAgcnRsOiBcInBzX19ydGxcIixcbiAgZWxlbWVudDoge1xuICAgIHRodW1iOiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gXCJwc19fdGh1bWItXCIgKyBzO1xuICAgIH0sXG4gICAgcmFpbDogZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFwicHNfX3JhaWwtXCIgKyBzO1xuICAgIH0sXG4gICAgY29uc3VtaW5nOiBcInBzX19jaGlsZC0tY29uc3VtZVwiXG4gIH0sXG4gIHN0YXRlOiB7XG4gICAgZm9jdXM6IFwicHMtLWZvY3VzXCIsXG4gICAgY2xpY2tpbmc6IFwicHMtLWNsaWNraW5nXCIsXG4gICAgYWN0aXZlOiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gXCJwcy0tYWN0aXZlLVwiICsgcztcbiAgICB9LFxuICAgIHNjcm9sbGluZzogZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFwicHMtLXNjcm9sbGluZy1cIiArIHM7XG4gICAgfVxuICB9XG59LCBOaCA9IHsgeDogbnVsbCwgeTogbnVsbCB9O1xuZnVuY3Rpb24gTWgocywgdCkge1xuICB2YXIgZSA9IHMuZWxlbWVudC5jbGFzc0xpc3QsIGkgPSBqLnN0YXRlLnNjcm9sbGluZyh0KTtcbiAgZS5jb250YWlucyhpKSA/IGNsZWFyVGltZW91dChOaFt0XSkgOiBlLmFkZChpKTtcbn1cbmZ1bmN0aW9uIFJoKHMsIHQpIHtcbiAgTmhbdF0gPSBzZXRUaW1lb3V0KFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHMuaXNBbGl2ZSAmJiBzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShqLnN0YXRlLnNjcm9sbGluZyh0KSk7XG4gICAgfSxcbiAgICBzLnNldHRpbmdzLnNjcm9sbGluZ1RocmVzaG9sZFxuICApO1xufVxuZnVuY3Rpb24gRHYocywgdCkge1xuICBNaChzLCB0KSwgUmgocywgdCk7XG59XG52YXIgcWkgPSBmdW5jdGlvbih0KSB7XG4gIHRoaXMuZWxlbWVudCA9IHQsIHRoaXMuaGFuZGxlcnMgPSB7fTtcbn0sIFBoID0geyBpc0VtcHR5OiB7IGNvbmZpZ3VyYWJsZTogITAgfSB9O1xucWkucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbih0LCBlKSB7XG4gIHR5cGVvZiB0aGlzLmhhbmRsZXJzW3RdID4gXCJ1XCIgJiYgKHRoaXMuaGFuZGxlcnNbdF0gPSBbXSksIHRoaXMuaGFuZGxlcnNbdF0ucHVzaChlKSwgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodCwgZSwgITEpO1xufTtcbnFpLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbih0LCBlKSB7XG4gIHZhciBpID0gdGhpcztcbiAgdGhpcy5oYW5kbGVyc1t0XSA9IHRoaXMuaGFuZGxlcnNbdF0uZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gZSAmJiBuICE9PSBlID8gITAgOiAoaS5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgbiwgITEpLCAhMSk7XG4gIH0pO1xufTtcbnFpLnByb3RvdHlwZS51bmJpbmRBbGwgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgdCBpbiB0aGlzLmhhbmRsZXJzKVxuICAgIHRoaXMudW5iaW5kKHQpO1xufTtcblBoLmlzRW1wdHkuZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzID0gdGhpcztcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaGFuZGxlcnMpLmV2ZXJ5KFxuICAgIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBzLmhhbmRsZXJzW3RdLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocWkucHJvdG90eXBlLCBQaCk7XG52YXIgbGkgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ldmVudEVsZW1lbnRzID0gW107XG59O1xubGkucHJvdG90eXBlLmV2ZW50RWxlbWVudCA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSB0aGlzLmV2ZW50RWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gaS5lbGVtZW50ID09PSB0O1xuICB9KVswXTtcbiAgcmV0dXJuIGUgfHwgKGUgPSBuZXcgcWkodCksIHRoaXMuZXZlbnRFbGVtZW50cy5wdXNoKGUpKSwgZTtcbn07XG5saS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgdGhpcy5ldmVudEVsZW1lbnQodCkuYmluZChlLCBpKTtcbn07XG5saS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICB2YXIgbiA9IHRoaXMuZXZlbnRFbGVtZW50KHQpO1xuICBuLnVuYmluZChlLCBpKSwgbi5pc0VtcHR5ICYmIHRoaXMuZXZlbnRFbGVtZW50cy5zcGxpY2UodGhpcy5ldmVudEVsZW1lbnRzLmluZGV4T2YobiksIDEpO1xufTtcbmxpLnByb3RvdHlwZS51bmJpbmRBbGwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ldmVudEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0LnVuYmluZEFsbCgpO1xuICB9KSwgdGhpcy5ldmVudEVsZW1lbnRzID0gW107XG59O1xubGkucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gIHZhciBuID0gdGhpcy5ldmVudEVsZW1lbnQodCksIG8gPSBmdW5jdGlvbihyKSB7XG4gICAgbi51bmJpbmQoZSwgbyksIGkocik7XG4gIH07XG4gIG4uYmluZChlLCBvKTtcbn07XG5mdW5jdGlvbiBEcyhzKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KHMpO1xuICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gIHJldHVybiB0LmluaXRDdXN0b21FdmVudChzLCAhMSwgITEsIHZvaWQgMCksIHQ7XG59XG5mdW5jdGlvbiBmbihzLCB0LCBlLCBpLCBuKSB7XG4gIGkgPT09IHZvaWQgMCAmJiAoaSA9ICEwKSwgbiA9PT0gdm9pZCAwICYmIChuID0gITEpO1xuICB2YXIgbztcbiAgaWYgKHQgPT09IFwidG9wXCIpXG4gICAgbyA9IFtcbiAgICAgIFwiY29udGVudEhlaWdodFwiLFxuICAgICAgXCJjb250YWluZXJIZWlnaHRcIixcbiAgICAgIFwic2Nyb2xsVG9wXCIsXG4gICAgICBcInlcIixcbiAgICAgIFwidXBcIixcbiAgICAgIFwiZG93blwiXG4gICAgXTtcbiAgZWxzZSBpZiAodCA9PT0gXCJsZWZ0XCIpXG4gICAgbyA9IFtcbiAgICAgIFwiY29udGVudFdpZHRoXCIsXG4gICAgICBcImNvbnRhaW5lcldpZHRoXCIsXG4gICAgICBcInNjcm9sbExlZnRcIixcbiAgICAgIFwieFwiLFxuICAgICAgXCJsZWZ0XCIsXG4gICAgICBcInJpZ2h0XCJcbiAgICBdO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQSBwcm9wZXIgYXhpcyBzaG91bGQgYmUgcHJvdmlkZWRcIik7XG4gICR2KHMsIGUsIG8sIGksIG4pO1xufVxuZnVuY3Rpb24gJHYocywgdCwgZSwgaSwgbikge1xuICB2YXIgbyA9IGVbMF0sIHIgPSBlWzFdLCBhID0gZVsyXSwgbCA9IGVbM10sIHAgPSBlWzRdLCB1ID0gZVs1XTtcbiAgaSA9PT0gdm9pZCAwICYmIChpID0gITApLCBuID09PSB2b2lkIDAgJiYgKG4gPSAhMSk7XG4gIHZhciBfID0gcy5lbGVtZW50O1xuICBzLnJlYWNoW2xdID0gbnVsbCwgX1thXSA8IDEgJiYgKHMucmVhY2hbbF0gPSBcInN0YXJ0XCIpLCBfW2FdID4gc1tvXSAtIHNbcl0gLSAxICYmIChzLnJlYWNoW2xdID0gXCJlbmRcIiksIHQgJiYgKF8uZGlzcGF0Y2hFdmVudChEcyhcInBzLXNjcm9sbC1cIiArIGwpKSwgdCA8IDAgPyBfLmRpc3BhdGNoRXZlbnQoRHMoXCJwcy1zY3JvbGwtXCIgKyBwKSkgOiB0ID4gMCAmJiBfLmRpc3BhdGNoRXZlbnQoRHMoXCJwcy1zY3JvbGwtXCIgKyB1KSksIGkgJiYgRHYocywgbCkpLCBzLnJlYWNoW2xdICYmICh0IHx8IG4pICYmIF8uZGlzcGF0Y2hFdmVudChEcyhcInBzLVwiICsgbCArIFwiLXJlYWNoLVwiICsgcy5yZWFjaFtsXSkpO1xufVxuZnVuY3Rpb24gRihzKSB7XG4gIHJldHVybiBwYXJzZUludChzLCAxMCkgfHwgMDtcbn1cbmZ1bmN0aW9uIEx2KHMpIHtcbiAgcmV0dXJuIEp0KHMsIFwiaW5wdXQsW2NvbnRlbnRlZGl0YWJsZV1cIikgfHwgSnQocywgXCJzZWxlY3QsW2NvbnRlbnRlZGl0YWJsZV1cIikgfHwgSnQocywgXCJ0ZXh0YXJlYSxbY29udGVudGVkaXRhYmxlXVwiKSB8fCBKdChzLCBcImJ1dHRvbixbY29udGVudGVkaXRhYmxlXVwiKTtcbn1cbmZ1bmN0aW9uIE52KHMpIHtcbiAgdmFyIHQgPSBOdChzKTtcbiAgcmV0dXJuIEYodC53aWR0aCkgKyBGKHQucGFkZGluZ0xlZnQpICsgRih0LnBhZGRpbmdSaWdodCkgKyBGKHQuYm9yZGVyTGVmdFdpZHRoKSArIEYodC5ib3JkZXJSaWdodFdpZHRoKTtcbn1cbnZhciBWZSA9IHtcbiAgaXNXZWJLaXQ6IHR5cGVvZiBkb2N1bWVudCA8IFwidVwiICYmIFwiV2Via2l0QXBwZWFyYW5jZVwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxcbiAgc3VwcG9ydHNUb3VjaDogdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIChcIm9udG91Y2hzdGFydFwiIGluIHdpbmRvdyB8fCBcIm1heFRvdWNoUG9pbnRzXCIgaW4gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSxcbiAgc3VwcG9ydHNJZVBvaW50ZXI6IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyxcbiAgaXNDaHJvbWU6IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiAvQ2hyb21lL2kudGVzdChuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudClcbn07XG5mdW5jdGlvbiBIdChzKSB7XG4gIHZhciB0ID0gcy5lbGVtZW50LCBlID0gTWF0aC5mbG9vcih0LnNjcm9sbFRvcCksIGkgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBzLmNvbnRhaW5lcldpZHRoID0gTWF0aC5yb3VuZChpLndpZHRoKSwgcy5jb250YWluZXJIZWlnaHQgPSBNYXRoLnJvdW5kKGkuaGVpZ2h0KSwgcy5jb250ZW50V2lkdGggPSB0LnNjcm9sbFdpZHRoLCBzLmNvbnRlbnRIZWlnaHQgPSB0LnNjcm9sbEhlaWdodCwgdC5jb250YWlucyhzLnNjcm9sbGJhclhSYWlsKSB8fCAoTmwodCwgai5lbGVtZW50LnJhaWwoXCJ4XCIpKS5mb3JFYWNoKFxuICAgIGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBZZShuKTtcbiAgICB9XG4gICksIHQuYXBwZW5kQ2hpbGQocy5zY3JvbGxiYXJYUmFpbCkpLCB0LmNvbnRhaW5zKHMuc2Nyb2xsYmFyWVJhaWwpIHx8IChObCh0LCBqLmVsZW1lbnQucmFpbChcInlcIikpLmZvckVhY2goXG4gICAgZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIFllKG4pO1xuICAgIH1cbiAgKSwgdC5hcHBlbmRDaGlsZChzLnNjcm9sbGJhcllSYWlsKSksICFzLnNldHRpbmdzLnN1cHByZXNzU2Nyb2xsWCAmJiBzLmNvbnRhaW5lcldpZHRoICsgcy5zZXR0aW5ncy5zY3JvbGxYTWFyZ2luT2Zmc2V0IDwgcy5jb250ZW50V2lkdGggPyAocy5zY3JvbGxiYXJYQWN0aXZlID0gITAsIHMucmFpbFhXaWR0aCA9IHMuY29udGFpbmVyV2lkdGggLSBzLnJhaWxYTWFyZ2luV2lkdGgsIHMucmFpbFhSYXRpbyA9IHMuY29udGFpbmVyV2lkdGggLyBzLnJhaWxYV2lkdGgsIHMuc2Nyb2xsYmFyWFdpZHRoID0gTWwoXG4gICAgcyxcbiAgICBGKHMucmFpbFhXaWR0aCAqIHMuY29udGFpbmVyV2lkdGggLyBzLmNvbnRlbnRXaWR0aClcbiAgKSwgcy5zY3JvbGxiYXJYTGVmdCA9IEYoXG4gICAgKHMubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgdC5zY3JvbGxMZWZ0KSAqIChzLnJhaWxYV2lkdGggLSBzLnNjcm9sbGJhclhXaWR0aCkgLyAocy5jb250ZW50V2lkdGggLSBzLmNvbnRhaW5lcldpZHRoKVxuICApKSA6IHMuc2Nyb2xsYmFyWEFjdGl2ZSA9ICExLCAhcy5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFkgJiYgcy5jb250YWluZXJIZWlnaHQgKyBzLnNldHRpbmdzLnNjcm9sbFlNYXJnaW5PZmZzZXQgPCBzLmNvbnRlbnRIZWlnaHQgPyAocy5zY3JvbGxiYXJZQWN0aXZlID0gITAsIHMucmFpbFlIZWlnaHQgPSBzLmNvbnRhaW5lckhlaWdodCAtIHMucmFpbFlNYXJnaW5IZWlnaHQsIHMucmFpbFlSYXRpbyA9IHMuY29udGFpbmVySGVpZ2h0IC8gcy5yYWlsWUhlaWdodCwgcy5zY3JvbGxiYXJZSGVpZ2h0ID0gTWwoXG4gICAgcyxcbiAgICBGKHMucmFpbFlIZWlnaHQgKiBzLmNvbnRhaW5lckhlaWdodCAvIHMuY29udGVudEhlaWdodClcbiAgKSwgcy5zY3JvbGxiYXJZVG9wID0gRihcbiAgICBlICogKHMucmFpbFlIZWlnaHQgLSBzLnNjcm9sbGJhcllIZWlnaHQpIC8gKHMuY29udGVudEhlaWdodCAtIHMuY29udGFpbmVySGVpZ2h0KVxuICApKSA6IHMuc2Nyb2xsYmFyWUFjdGl2ZSA9ICExLCBzLnNjcm9sbGJhclhMZWZ0ID49IHMucmFpbFhXaWR0aCAtIHMuc2Nyb2xsYmFyWFdpZHRoICYmIChzLnNjcm9sbGJhclhMZWZ0ID0gcy5yYWlsWFdpZHRoIC0gcy5zY3JvbGxiYXJYV2lkdGgpLCBzLnNjcm9sbGJhcllUb3AgPj0gcy5yYWlsWUhlaWdodCAtIHMuc2Nyb2xsYmFyWUhlaWdodCAmJiAocy5zY3JvbGxiYXJZVG9wID0gcy5yYWlsWUhlaWdodCAtIHMuc2Nyb2xsYmFyWUhlaWdodCksIE12KHQsIHMpLCBzLnNjcm9sbGJhclhBY3RpdmUgPyB0LmNsYXNzTGlzdC5hZGQoai5zdGF0ZS5hY3RpdmUoXCJ4XCIpKSA6ICh0LmNsYXNzTGlzdC5yZW1vdmUoai5zdGF0ZS5hY3RpdmUoXCJ4XCIpKSwgcy5zY3JvbGxiYXJYV2lkdGggPSAwLCBzLnNjcm9sbGJhclhMZWZ0ID0gMCwgdC5zY3JvbGxMZWZ0ID0gcy5pc1J0bCA9PT0gITAgPyBzLmNvbnRlbnRXaWR0aCA6IDApLCBzLnNjcm9sbGJhcllBY3RpdmUgPyB0LmNsYXNzTGlzdC5hZGQoai5zdGF0ZS5hY3RpdmUoXCJ5XCIpKSA6ICh0LmNsYXNzTGlzdC5yZW1vdmUoai5zdGF0ZS5hY3RpdmUoXCJ5XCIpKSwgcy5zY3JvbGxiYXJZSGVpZ2h0ID0gMCwgcy5zY3JvbGxiYXJZVG9wID0gMCwgdC5zY3JvbGxUb3AgPSAwKTtcbn1cbmZ1bmN0aW9uIE1sKHMsIHQpIHtcbiAgcmV0dXJuIHMuc2V0dGluZ3MubWluU2Nyb2xsYmFyTGVuZ3RoICYmICh0ID0gTWF0aC5tYXgodCwgcy5zZXR0aW5ncy5taW5TY3JvbGxiYXJMZW5ndGgpKSwgcy5zZXR0aW5ncy5tYXhTY3JvbGxiYXJMZW5ndGggJiYgKHQgPSBNYXRoLm1pbih0LCBzLnNldHRpbmdzLm1heFNjcm9sbGJhckxlbmd0aCkpLCB0O1xufVxuZnVuY3Rpb24gTXYocywgdCkge1xuICB2YXIgZSA9IHsgd2lkdGg6IHQucmFpbFhXaWR0aCB9LCBpID0gTWF0aC5mbG9vcihzLnNjcm9sbFRvcCk7XG4gIHQuaXNSdGwgPyBlLmxlZnQgPSB0Lm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIHMuc2Nyb2xsTGVmdCArIHQuY29udGFpbmVyV2lkdGggLSB0LmNvbnRlbnRXaWR0aCA6IGUubGVmdCA9IHMuc2Nyb2xsTGVmdCwgdC5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA/IGUuYm90dG9tID0gdC5zY3JvbGxiYXJYQm90dG9tIC0gaSA6IGUudG9wID0gdC5zY3JvbGxiYXJYVG9wICsgaSwgY3QodC5zY3JvbGxiYXJYUmFpbCwgZSk7XG4gIHZhciBuID0geyB0b3A6IGksIGhlaWdodDogdC5yYWlsWUhlaWdodCB9O1xuICB0LmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQgPyB0LmlzUnRsID8gbi5yaWdodCA9IHQuY29udGVudFdpZHRoIC0gKHQubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgcy5zY3JvbGxMZWZ0KSAtIHQuc2Nyb2xsYmFyWVJpZ2h0IC0gdC5zY3JvbGxiYXJZT3V0ZXJXaWR0aCAtIDkgOiBuLnJpZ2h0ID0gdC5zY3JvbGxiYXJZUmlnaHQgLSBzLnNjcm9sbExlZnQgOiB0LmlzUnRsID8gbi5sZWZ0ID0gdC5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyBzLnNjcm9sbExlZnQgKyB0LmNvbnRhaW5lcldpZHRoICogMiAtIHQuY29udGVudFdpZHRoIC0gdC5zY3JvbGxiYXJZTGVmdCAtIHQuc2Nyb2xsYmFyWU91dGVyV2lkdGggOiBuLmxlZnQgPSB0LnNjcm9sbGJhcllMZWZ0ICsgcy5zY3JvbGxMZWZ0LCBjdCh0LnNjcm9sbGJhcllSYWlsLCBuKSwgY3QodC5zY3JvbGxiYXJYLCB7XG4gICAgbGVmdDogdC5zY3JvbGxiYXJYTGVmdCxcbiAgICB3aWR0aDogdC5zY3JvbGxiYXJYV2lkdGggLSB0LnJhaWxCb3JkZXJYV2lkdGhcbiAgfSksIGN0KHQuc2Nyb2xsYmFyWSwge1xuICAgIHRvcDogdC5zY3JvbGxiYXJZVG9wLFxuICAgIGhlaWdodDogdC5zY3JvbGxiYXJZSGVpZ2h0IC0gdC5yYWlsQm9yZGVyWVdpZHRoXG4gIH0pO1xufVxuZnVuY3Rpb24gUnYocykge1xuICBzLmVsZW1lbnQsIHMuZXZlbnQuYmluZChzLnNjcm9sbGJhclksIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSksIHMuZXZlbnQuYmluZChzLnNjcm9sbGJhcllSYWlsLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0LnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0IC0gcy5zY3JvbGxiYXJZUmFpbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AsIGkgPSBlID4gcy5zY3JvbGxiYXJZVG9wID8gMSA6IC0xO1xuICAgIHMuZWxlbWVudC5zY3JvbGxUb3AgKz0gaSAqIHMuY29udGFpbmVySGVpZ2h0LCBIdChzKSwgdC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSksIHMuZXZlbnQuYmluZChzLnNjcm9sbGJhclgsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSksIHMuZXZlbnQuYmluZChzLnNjcm9sbGJhclhSYWlsLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0LnBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0IC0gcy5zY3JvbGxiYXJYUmFpbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0LCBpID0gZSA+IHMuc2Nyb2xsYmFyWExlZnQgPyAxIDogLTE7XG4gICAgcy5lbGVtZW50LnNjcm9sbExlZnQgKz0gaSAqIHMuY29udGFpbmVyV2lkdGgsIEh0KHMpLCB0LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFB2KHMpIHtcbiAgUmwocywgW1xuICAgIFwiY29udGFpbmVyV2lkdGhcIixcbiAgICBcImNvbnRlbnRXaWR0aFwiLFxuICAgIFwicGFnZVhcIixcbiAgICBcInJhaWxYV2lkdGhcIixcbiAgICBcInNjcm9sbGJhclhcIixcbiAgICBcInNjcm9sbGJhclhXaWR0aFwiLFxuICAgIFwic2Nyb2xsTGVmdFwiLFxuICAgIFwieFwiLFxuICAgIFwic2Nyb2xsYmFyWFJhaWxcIlxuICBdKSwgUmwocywgW1xuICAgIFwiY29udGFpbmVySGVpZ2h0XCIsXG4gICAgXCJjb250ZW50SGVpZ2h0XCIsXG4gICAgXCJwYWdlWVwiLFxuICAgIFwicmFpbFlIZWlnaHRcIixcbiAgICBcInNjcm9sbGJhcllcIixcbiAgICBcInNjcm9sbGJhcllIZWlnaHRcIixcbiAgICBcInNjcm9sbFRvcFwiLFxuICAgIFwieVwiLFxuICAgIFwic2Nyb2xsYmFyWVJhaWxcIlxuICBdKTtcbn1cbmZ1bmN0aW9uIFJsKHMsIHQpIHtcbiAgdmFyIGUgPSB0WzBdLCBpID0gdFsxXSwgbiA9IHRbMl0sIG8gPSB0WzNdLCByID0gdFs0XSwgYSA9IHRbNV0sIGwgPSB0WzZdLCBwID0gdFs3XSwgdSA9IHRbOF0sIF8gPSBzLmVsZW1lbnQsIGYgPSBudWxsLCBnID0gbnVsbCwgbSA9IG51bGw7XG4gIGZ1bmN0aW9uIGIoeSkge1xuICAgIHkudG91Y2hlcyAmJiB5LnRvdWNoZXNbMF0gJiYgKHlbbl0gPSB5LnRvdWNoZXNbMF0ucGFnZVkpLCBfW2xdID0gZiArIG0gKiAoeVtuXSAtIGcpLCBNaChzLCBwKSwgSHQocyksIHkuc3RvcFByb3BhZ2F0aW9uKCksIHkudHlwZS5zdGFydHNXaXRoKFwidG91Y2hcIikgJiYgeS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPiAxICYmIHkucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBmdW5jdGlvbiB2KCkge1xuICAgIFJoKHMsIHApLCBzW3VdLmNsYXNzTGlzdC5yZW1vdmUoai5zdGF0ZS5jbGlja2luZyksIHMuZXZlbnQudW5iaW5kKHMub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgYik7XG4gIH1cbiAgZnVuY3Rpb24gVCh5LCBDKSB7XG4gICAgZiA9IF9bbF0sIEMgJiYgeS50b3VjaGVzICYmICh5W25dID0geS50b3VjaGVzWzBdLnBhZ2VZKSwgZyA9IHlbbl0sIG0gPSAoc1tpXSAtIHNbZV0pIC8gKHNbb10gLSBzW2FdKSwgQyA/IHMuZXZlbnQuYmluZChzLm93bmVyRG9jdW1lbnQsIFwidG91Y2htb3ZlXCIsIGIpIDogKHMuZXZlbnQuYmluZChzLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIGIpLCBzLmV2ZW50Lm9uY2Uocy5vd25lckRvY3VtZW50LCBcIm1vdXNldXBcIiwgdiksIHkucHJldmVudERlZmF1bHQoKSksIHNbdV0uY2xhc3NMaXN0LmFkZChqLnN0YXRlLmNsaWNraW5nKSwgeS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICBzLmV2ZW50LmJpbmQoc1tyXSwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oeSkge1xuICAgIFQoeSk7XG4gIH0pLCBzLmV2ZW50LmJpbmQoc1tyXSwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uKHkpIHtcbiAgICBUKHksICEwKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBCdihzKSB7XG4gIHZhciB0ID0gcy5lbGVtZW50LCBlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEp0KHQsIFwiOmhvdmVyXCIpO1xuICB9LCBpID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEp0KHMuc2Nyb2xsYmFyWCwgXCI6Zm9jdXNcIikgfHwgSnQocy5zY3JvbGxiYXJZLCBcIjpmb2N1c1wiKTtcbiAgfTtcbiAgZnVuY3Rpb24gbihvLCByKSB7XG4gICAgdmFyIGEgPSBNYXRoLmZsb29yKHQuc2Nyb2xsVG9wKTtcbiAgICBpZiAobyA9PT0gMCkge1xuICAgICAgaWYgKCFzLnNjcm9sbGJhcllBY3RpdmUpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGlmIChhID09PSAwICYmIHIgPiAwIHx8IGEgPj0gcy5jb250ZW50SGVpZ2h0IC0gcy5jb250YWluZXJIZWlnaHQgJiYgciA8IDApXG4gICAgICAgIHJldHVybiAhcy5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uO1xuICAgIH1cbiAgICB2YXIgbCA9IHQuc2Nyb2xsTGVmdDtcbiAgICBpZiAociA9PT0gMCkge1xuICAgICAgaWYgKCFzLnNjcm9sbGJhclhBY3RpdmUpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGlmIChsID09PSAwICYmIG8gPCAwIHx8IGwgPj0gcy5jb250ZW50V2lkdGggLSBzLmNvbnRhaW5lcldpZHRoICYmIG8gPiAwKVxuICAgICAgICByZXR1cm4gIXMuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIHMuZXZlbnQuYmluZChzLm93bmVyRG9jdW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbihvKSB7XG4gICAgaWYgKCEoby5pc0RlZmF1bHRQcmV2ZW50ZWQgJiYgby5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBvLmRlZmF1bHRQcmV2ZW50ZWQpICYmICEoIWUoKSAmJiAhaSgpKSkge1xuICAgICAgdmFyIHIgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA6IHMub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgaWYgKHIudGFnTmFtZSA9PT0gXCJJRlJBTUVcIilcbiAgICAgICAgICByID0gci5jb250ZW50RG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAoOyByLnNoYWRvd1Jvb3Q7IClcbiAgICAgICAgICAgIHIgPSByLnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKEx2KHIpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gMCwgbCA9IDA7XG4gICAgICBzd2l0Y2ggKG8ud2hpY2gpIHtcbiAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICBvLm1ldGFLZXkgPyBhID0gLXMuY29udGVudFdpZHRoIDogby5hbHRLZXkgPyBhID0gLXMuY29udGFpbmVyV2lkdGggOiBhID0gLTMwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgIG8ubWV0YUtleSA/IGwgPSBzLmNvbnRlbnRIZWlnaHQgOiBvLmFsdEtleSA/IGwgPSBzLmNvbnRhaW5lckhlaWdodCA6IGwgPSAzMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICBvLm1ldGFLZXkgPyBhID0gcy5jb250ZW50V2lkdGggOiBvLmFsdEtleSA/IGEgPSBzLmNvbnRhaW5lcldpZHRoIDogYSA9IDMwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgIG8ubWV0YUtleSA/IGwgPSAtcy5jb250ZW50SGVpZ2h0IDogby5hbHRLZXkgPyBsID0gLXMuY29udGFpbmVySGVpZ2h0IDogbCA9IC0zMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICBvLnNoaWZ0S2V5ID8gbCA9IHMuY29udGFpbmVySGVpZ2h0IDogbCA9IC1zLmNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICBsID0gcy5jb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgbCA9IC1zLmNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICBsID0gcy5jb250ZW50SGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgIGwgPSAtcy5jb250ZW50SGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHMuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxYICYmIGEgIT09IDAgfHwgcy5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFkgJiYgbCAhPT0gMCB8fCAodC5zY3JvbGxUb3AgLT0gbCwgdC5zY3JvbGxMZWZ0ICs9IGEsIEh0KHMpLCBuKGEsIGwpICYmIG8ucHJldmVudERlZmF1bHQoKSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIEh2KHMpIHtcbiAgdmFyIHQgPSBzLmVsZW1lbnQ7XG4gIGZ1bmN0aW9uIGUociwgYSkge1xuICAgIHZhciBsID0gTWF0aC5mbG9vcih0LnNjcm9sbFRvcCksIHAgPSB0LnNjcm9sbFRvcCA9PT0gMCwgdSA9IGwgKyB0Lm9mZnNldEhlaWdodCA9PT0gdC5zY3JvbGxIZWlnaHQsIF8gPSB0LnNjcm9sbExlZnQgPT09IDAsIGYgPSB0LnNjcm9sbExlZnQgKyB0Lm9mZnNldFdpZHRoID09PSB0LnNjcm9sbFdpZHRoLCBnO1xuICAgIHJldHVybiBNYXRoLmFicyhhKSA+IE1hdGguYWJzKHIpID8gZyA9IHAgfHwgdSA6IGcgPSBfIHx8IGYsIGcgPyAhcy5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uIDogITA7XG4gIH1cbiAgZnVuY3Rpb24gaShyKSB7XG4gICAgdmFyIGEgPSByLmRlbHRhWCwgbCA9IC0xICogci5kZWx0YVk7XG4gICAgcmV0dXJuICh0eXBlb2YgYSA+IFwidVwiIHx8IHR5cGVvZiBsID4gXCJ1XCIpICYmIChhID0gLTEgKiByLndoZWVsRGVsdGFYIC8gNiwgbCA9IHIud2hlZWxEZWx0YVkgLyA2KSwgci5kZWx0YU1vZGUgJiYgci5kZWx0YU1vZGUgPT09IDEgJiYgKGEgKj0gMTAsIGwgKj0gMTApLCBhICE9PSBhICYmIGwgIT09IGwgJiYgKGEgPSAwLCBsID0gci53aGVlbERlbHRhKSwgci5zaGlmdEtleSA/IFstbCwgLWFdIDogW2EsIGxdO1xuICB9XG4gIGZ1bmN0aW9uIG4ociwgYSwgbCkge1xuICAgIGlmICghVmUuaXNXZWJLaXQgJiYgdC5xdWVyeVNlbGVjdG9yKFwic2VsZWN0OmZvY3VzXCIpKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGlmICghdC5jb250YWlucyhyKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKHZhciBwID0gcjsgcCAmJiBwICE9PSB0OyApIHtcbiAgICAgIGlmIChwLmNsYXNzTGlzdC5jb250YWlucyhqLmVsZW1lbnQuY29uc3VtaW5nKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgdmFyIHUgPSBOdChwKTtcbiAgICAgIGlmIChsICYmIHUub3ZlcmZsb3dZLm1hdGNoKC8oc2Nyb2xsfGF1dG8pLykpIHtcbiAgICAgICAgdmFyIF8gPSBwLnNjcm9sbEhlaWdodCAtIHAuY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAoXyA+IDAgJiYgKHAuc2Nyb2xsVG9wID4gMCAmJiBsIDwgMCB8fCBwLnNjcm9sbFRvcCA8IF8gJiYgbCA+IDApKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChhICYmIHUub3ZlcmZsb3dYLm1hdGNoKC8oc2Nyb2xsfGF1dG8pLykpIHtcbiAgICAgICAgdmFyIGYgPSBwLnNjcm9sbFdpZHRoIC0gcC5jbGllbnRXaWR0aDtcbiAgICAgICAgaWYgKGYgPiAwICYmIChwLnNjcm9sbExlZnQgPiAwICYmIGEgPCAwIHx8IHAuc2Nyb2xsTGVmdCA8IGYgJiYgYSA+IDApKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIHAgPSBwLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBmdW5jdGlvbiBvKHIpIHtcbiAgICB2YXIgYSA9IGkociksIGwgPSBhWzBdLCBwID0gYVsxXTtcbiAgICBpZiAoIW4oci50YXJnZXQsIGwsIHApKSB7XG4gICAgICB2YXIgdSA9ICExO1xuICAgICAgcy5zZXR0aW5ncy51c2VCb3RoV2hlZWxBeGVzID8gcy5zY3JvbGxiYXJZQWN0aXZlICYmICFzLnNjcm9sbGJhclhBY3RpdmUgPyAocCA/IHQuc2Nyb2xsVG9wIC09IHAgKiBzLnNldHRpbmdzLndoZWVsU3BlZWQgOiB0LnNjcm9sbFRvcCArPSBsICogcy5zZXR0aW5ncy53aGVlbFNwZWVkLCB1ID0gITApIDogcy5zY3JvbGxiYXJYQWN0aXZlICYmICFzLnNjcm9sbGJhcllBY3RpdmUgJiYgKGwgPyB0LnNjcm9sbExlZnQgKz0gbCAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCA6IHQuc2Nyb2xsTGVmdCAtPSBwICogcy5zZXR0aW5ncy53aGVlbFNwZWVkLCB1ID0gITApIDogKHQuc2Nyb2xsVG9wIC09IHAgKiBzLnNldHRpbmdzLndoZWVsU3BlZWQsIHQuc2Nyb2xsTGVmdCArPSBsICogcy5zZXR0aW5ncy53aGVlbFNwZWVkKSwgSHQocyksIHUgPSB1IHx8IGUobCwgcCksIHUgJiYgIXIuY3RybEtleSAmJiAoci5zdG9wUHJvcGFnYXRpb24oKSwgci5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICB9XG4gIH1cbiAgdHlwZW9mIHdpbmRvdy5vbndoZWVsIDwgXCJ1XCIgPyBzLmV2ZW50LmJpbmQodCwgXCJ3aGVlbFwiLCBvKSA6IHR5cGVvZiB3aW5kb3cub25tb3VzZXdoZWVsIDwgXCJ1XCIgJiYgcy5ldmVudC5iaW5kKHQsIFwibW91c2V3aGVlbFwiLCBvKTtcbn1cbmZ1bmN0aW9uIFZ2KHMpIHtcbiAgaWYgKCFWZS5zdXBwb3J0c1RvdWNoICYmICFWZS5zdXBwb3J0c0llUG9pbnRlcilcbiAgICByZXR1cm47XG4gIHZhciB0ID0gcy5lbGVtZW50O1xuICBmdW5jdGlvbiBlKG0sIGIpIHtcbiAgICB2YXIgdiA9IE1hdGguZmxvb3IodC5zY3JvbGxUb3ApLCBUID0gdC5zY3JvbGxMZWZ0LCB5ID0gTWF0aC5hYnMobSksIEMgPSBNYXRoLmFicyhiKTtcbiAgICBpZiAoQyA+IHkpIHtcbiAgICAgIGlmIChiIDwgMCAmJiB2ID09PSBzLmNvbnRlbnRIZWlnaHQgLSBzLmNvbnRhaW5lckhlaWdodCB8fCBiID4gMCAmJiB2ID09PSAwKVxuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFkgPT09IDAgJiYgYiA+IDAgJiYgVmUuaXNDaHJvbWU7XG4gICAgfSBlbHNlIGlmICh5ID4gQyAmJiAobSA8IDAgJiYgVCA9PT0gcy5jb250ZW50V2lkdGggLSBzLmNvbnRhaW5lcldpZHRoIHx8IG0gPiAwICYmIFQgPT09IDApKVxuICAgICAgcmV0dXJuICEwO1xuICAgIHJldHVybiAhMDtcbiAgfVxuICBmdW5jdGlvbiBpKG0sIGIpIHtcbiAgICB0LnNjcm9sbFRvcCAtPSBiLCB0LnNjcm9sbExlZnQgLT0gbSwgSHQocyk7XG4gIH1cbiAgdmFyIG4gPSB7fSwgbyA9IDAsIHIgPSB7fSwgYSA9IG51bGw7XG4gIGZ1bmN0aW9uIGwobSkge1xuICAgIHJldHVybiBtLnRhcmdldFRvdWNoZXMgPyBtLnRhcmdldFRvdWNoZXNbMF0gOiBtO1xuICB9XG4gIGZ1bmN0aW9uIHAobSkge1xuICAgIHJldHVybiBtLnBvaW50ZXJUeXBlICYmIG0ucG9pbnRlclR5cGUgPT09IFwicGVuXCIgJiYgbS5idXR0b25zID09PSAwID8gITEgOiAhIShtLnRhcmdldFRvdWNoZXMgJiYgbS50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PT0gMSB8fCBtLnBvaW50ZXJUeXBlICYmIG0ucG9pbnRlclR5cGUgIT09IFwibW91c2VcIiAmJiBtLnBvaW50ZXJUeXBlICE9PSBtLk1TUE9JTlRFUl9UWVBFX01PVVNFKTtcbiAgfVxuICBmdW5jdGlvbiB1KG0pIHtcbiAgICBpZiAocChtKSkge1xuICAgICAgdmFyIGIgPSBsKG0pO1xuICAgICAgbi5wYWdlWCA9IGIucGFnZVgsIG4ucGFnZVkgPSBiLnBhZ2VZLCBvID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCksIGEgIT09IG51bGwgJiYgY2xlYXJJbnRlcnZhbChhKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gXyhtLCBiLCB2KSB7XG4gICAgaWYgKCF0LmNvbnRhaW5zKG0pKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAodmFyIFQgPSBtOyBUICYmIFQgIT09IHQ7ICkge1xuICAgICAgaWYgKFQuY2xhc3NMaXN0LmNvbnRhaW5zKGouZWxlbWVudC5jb25zdW1pbmcpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB2YXIgeSA9IE50KFQpO1xuICAgICAgaWYgKHYgJiYgeS5vdmVyZmxvd1kubWF0Y2goLyhzY3JvbGx8YXV0bykvKSkge1xuICAgICAgICB2YXIgQyA9IFQuc2Nyb2xsSGVpZ2h0IC0gVC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGlmIChDID4gMCAmJiAoVC5zY3JvbGxUb3AgPiAwICYmIHYgPCAwIHx8IFQuc2Nyb2xsVG9wIDwgQyAmJiB2ID4gMCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgaWYgKGIgJiYgeS5vdmVyZmxvd1gubWF0Y2goLyhzY3JvbGx8YXV0bykvKSkge1xuICAgICAgICB2YXIgRSA9IFQuc2Nyb2xsV2lkdGggLSBULmNsaWVudFdpZHRoO1xuICAgICAgICBpZiAoRSA+IDAgJiYgKFQuc2Nyb2xsTGVmdCA+IDAgJiYgYiA8IDAgfHwgVC5zY3JvbGxMZWZ0IDwgRSAmJiBiID4gMCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgVCA9IFQucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGZ1bmN0aW9uIGYobSkge1xuICAgIGlmIChwKG0pKSB7XG4gICAgICB2YXIgYiA9IGwobSksIHYgPSB7IHBhZ2VYOiBiLnBhZ2VYLCBwYWdlWTogYi5wYWdlWSB9LCBUID0gdi5wYWdlWCAtIG4ucGFnZVgsIHkgPSB2LnBhZ2VZIC0gbi5wYWdlWTtcbiAgICAgIGlmIChfKG0udGFyZ2V0LCBULCB5KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaShULCB5KSwgbiA9IHY7XG4gICAgICB2YXIgQyA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpLCBFID0gQyAtIG87XG4gICAgICBFID4gMCAmJiAoci54ID0gVCAvIEUsIHIueSA9IHkgLyBFLCBvID0gQyksIGUoVCwgeSkgJiYgbS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnKCkge1xuICAgIHMuc2V0dGluZ3Muc3dpcGVFYXNpbmcgJiYgKGNsZWFySW50ZXJ2YWwoYSksIGEgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFyLnggJiYgIXIueSkge1xuICAgICAgICBjbGVhckludGVydmFsKGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnMoci54KSA8IDAuMDEgJiYgTWF0aC5hYnMoci55KSA8IDAuMDEpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFzLmVsZW1lbnQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaShyLnggKiAzMCwgci55ICogMzApLCByLnggKj0gMC44LCByLnkgKj0gMC44O1xuICAgIH0sIDEwKSk7XG4gIH1cbiAgVmUuc3VwcG9ydHNUb3VjaCA/IChzLmV2ZW50LmJpbmQodCwgXCJ0b3VjaHN0YXJ0XCIsIHUpLCBzLmV2ZW50LmJpbmQodCwgXCJ0b3VjaG1vdmVcIiwgZiksIHMuZXZlbnQuYmluZCh0LCBcInRvdWNoZW5kXCIsIGcpKSA6IFZlLnN1cHBvcnRzSWVQb2ludGVyICYmICh3aW5kb3cuUG9pbnRlckV2ZW50ID8gKHMuZXZlbnQuYmluZCh0LCBcInBvaW50ZXJkb3duXCIsIHUpLCBzLmV2ZW50LmJpbmQodCwgXCJwb2ludGVybW92ZVwiLCBmKSwgcy5ldmVudC5iaW5kKHQsIFwicG9pbnRlcnVwXCIsIGcpKSA6IHdpbmRvdy5NU1BvaW50ZXJFdmVudCAmJiAocy5ldmVudC5iaW5kKHQsIFwiTVNQb2ludGVyRG93blwiLCB1KSwgcy5ldmVudC5iaW5kKHQsIFwiTVNQb2ludGVyTW92ZVwiLCBmKSwgcy5ldmVudC5iaW5kKHQsIFwiTVNQb2ludGVyVXBcIiwgZykpKTtcbn1cbnZhciBXdiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIGhhbmRsZXJzOiBbXCJjbGljay1yYWlsXCIsIFwiZHJhZy10aHVtYlwiLCBcImtleWJvYXJkXCIsIFwid2hlZWxcIiwgXCJ0b3VjaFwiXSxcbiAgICBtYXhTY3JvbGxiYXJMZW5ndGg6IG51bGwsXG4gICAgbWluU2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxuICAgIHNjcm9sbGluZ1RocmVzaG9sZDogMWUzLFxuICAgIHNjcm9sbFhNYXJnaW5PZmZzZXQ6IDAsXG4gICAgc2Nyb2xsWU1hcmdpbk9mZnNldDogMCxcbiAgICBzdXBwcmVzc1Njcm9sbFg6ICExLFxuICAgIHN1cHByZXNzU2Nyb2xsWTogITEsXG4gICAgc3dpcGVFYXNpbmc6ICEwLFxuICAgIHVzZUJvdGhXaGVlbEF4ZXM6ICExLFxuICAgIHdoZWVsUHJvcGFnYXRpb246ICEwLFxuICAgIHdoZWVsU3BlZWQ6IDFcbiAgfTtcbn0sIEZ2ID0ge1xuICBcImNsaWNrLXJhaWxcIjogUnYsXG4gIFwiZHJhZy10aHVtYlwiOiBQdixcbiAga2V5Ym9hcmQ6IEJ2LFxuICB3aGVlbDogSHYsXG4gIHRvdWNoOiBWdlxufSwgWmkgPSBmdW5jdGlvbih0LCBlKSB7XG4gIHZhciBpID0gdGhpcztcbiAgaWYgKGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAodCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkpLCAhdCB8fCAhdC5ub2RlTmFtZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBlbGVtZW50IGlzIHNwZWNpZmllZCB0byBpbml0aWFsaXplIFBlcmZlY3RTY3JvbGxiYXJcIik7XG4gIHRoaXMuZWxlbWVudCA9IHQsIHQuY2xhc3NMaXN0LmFkZChqLm1haW4pLCB0aGlzLnNldHRpbmdzID0gV3YoKTtcbiAgZm9yICh2YXIgbiBpbiBlKVxuICAgIHRoaXMuc2V0dGluZ3Nbbl0gPSBlW25dO1xuICB0aGlzLmNvbnRhaW5lcldpZHRoID0gbnVsbCwgdGhpcy5jb250YWluZXJIZWlnaHQgPSBudWxsLCB0aGlzLmNvbnRlbnRXaWR0aCA9IG51bGwsIHRoaXMuY29udGVudEhlaWdodCA9IG51bGw7XG4gIHZhciBvID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuY2xhc3NMaXN0LmFkZChqLnN0YXRlLmZvY3VzKTtcbiAgfSwgciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmNsYXNzTGlzdC5yZW1vdmUoai5zdGF0ZS5mb2N1cyk7XG4gIH07XG4gIHRoaXMuaXNSdGwgPSBOdCh0KS5kaXJlY3Rpb24gPT09IFwicnRsXCIsIHRoaXMuaXNSdGwgPT09ICEwICYmIHQuY2xhc3NMaXN0LmFkZChqLnJ0bCksIHRoaXMuaXNOZWdhdGl2ZVNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwID0gdC5zY3JvbGxMZWZ0LCB1ID0gbnVsbDtcbiAgICByZXR1cm4gdC5zY3JvbGxMZWZ0ID0gLTEsIHUgPSB0LnNjcm9sbExlZnQgPCAwLCB0LnNjcm9sbExlZnQgPSBwLCB1O1xuICB9KCksIHRoaXMubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ID0gdGhpcy5pc05lZ2F0aXZlU2Nyb2xsID8gdC5zY3JvbGxXaWR0aCAtIHQuY2xpZW50V2lkdGggOiAwLCB0aGlzLmV2ZW50ID0gbmV3IGxpKCksIHRoaXMub3duZXJEb2N1bWVudCA9IHQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCwgdGhpcy5zY3JvbGxiYXJYUmFpbCA9IElzKGouZWxlbWVudC5yYWlsKFwieFwiKSksIHQuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxiYXJYUmFpbCksIHRoaXMuc2Nyb2xsYmFyWCA9IElzKGouZWxlbWVudC50aHVtYihcInhcIikpLCB0aGlzLnNjcm9sbGJhclhSYWlsLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsYmFyWCksIHRoaXMuc2Nyb2xsYmFyWC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAwKSwgdGhpcy5ldmVudC5iaW5kKHRoaXMuc2Nyb2xsYmFyWCwgXCJmb2N1c1wiLCBvKSwgdGhpcy5ldmVudC5iaW5kKHRoaXMuc2Nyb2xsYmFyWCwgXCJibHVyXCIsIHIpLCB0aGlzLnNjcm9sbGJhclhBY3RpdmUgPSBudWxsLCB0aGlzLnNjcm9sbGJhclhXaWR0aCA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWExlZnQgPSBudWxsO1xuICB2YXIgYSA9IE50KHRoaXMuc2Nyb2xsYmFyWFJhaWwpO1xuICB0aGlzLnNjcm9sbGJhclhCb3R0b20gPSBwYXJzZUludChhLmJvdHRvbSwgMTApLCBpc05hTih0aGlzLnNjcm9sbGJhclhCb3R0b20pID8gKHRoaXMuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20gPSAhMSwgdGhpcy5zY3JvbGxiYXJYVG9wID0gRihhLnRvcCkpIDogdGhpcy5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA9ICEwLCB0aGlzLnJhaWxCb3JkZXJYV2lkdGggPSBGKGEuYm9yZGVyTGVmdFdpZHRoKSArIEYoYS5ib3JkZXJSaWdodFdpZHRoKSwgY3QodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIHRoaXMucmFpbFhNYXJnaW5XaWR0aCA9IEYoYS5tYXJnaW5MZWZ0KSArIEYoYS5tYXJnaW5SaWdodCksIGN0KHRoaXMuc2Nyb2xsYmFyWFJhaWwsIHsgZGlzcGxheTogXCJcIiB9KSwgdGhpcy5yYWlsWFdpZHRoID0gbnVsbCwgdGhpcy5yYWlsWFJhdGlvID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJZUmFpbCA9IElzKGouZWxlbWVudC5yYWlsKFwieVwiKSksIHQuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxiYXJZUmFpbCksIHRoaXMuc2Nyb2xsYmFyWSA9IElzKGouZWxlbWVudC50aHVtYihcInlcIikpLCB0aGlzLnNjcm9sbGJhcllSYWlsLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsYmFyWSksIHRoaXMuc2Nyb2xsYmFyWS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAwKSwgdGhpcy5ldmVudC5iaW5kKHRoaXMuc2Nyb2xsYmFyWSwgXCJmb2N1c1wiLCBvKSwgdGhpcy5ldmVudC5iaW5kKHRoaXMuc2Nyb2xsYmFyWSwgXCJibHVyXCIsIHIpLCB0aGlzLnNjcm9sbGJhcllBY3RpdmUgPSBudWxsLCB0aGlzLnNjcm9sbGJhcllIZWlnaHQgPSBudWxsLCB0aGlzLnNjcm9sbGJhcllUb3AgPSBudWxsO1xuICB2YXIgbCA9IE50KHRoaXMuc2Nyb2xsYmFyWVJhaWwpO1xuICB0aGlzLnNjcm9sbGJhcllSaWdodCA9IHBhcnNlSW50KGwucmlnaHQsIDEwKSwgaXNOYU4odGhpcy5zY3JvbGxiYXJZUmlnaHQpID8gKHRoaXMuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA9ICExLCB0aGlzLnNjcm9sbGJhcllMZWZ0ID0gRihsLmxlZnQpKSA6IHRoaXMuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA9ICEwLCB0aGlzLnNjcm9sbGJhcllPdXRlcldpZHRoID0gdGhpcy5pc1J0bCA/IE52KHRoaXMuc2Nyb2xsYmFyWSkgOiBudWxsLCB0aGlzLnJhaWxCb3JkZXJZV2lkdGggPSBGKGwuYm9yZGVyVG9wV2lkdGgpICsgRihsLmJvcmRlckJvdHRvbVdpZHRoKSwgY3QodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIHRoaXMucmFpbFlNYXJnaW5IZWlnaHQgPSBGKGwubWFyZ2luVG9wKSArIEYobC5tYXJnaW5Cb3R0b20pLCBjdCh0aGlzLnNjcm9sbGJhcllSYWlsLCB7IGRpc3BsYXk6IFwiXCIgfSksIHRoaXMucmFpbFlIZWlnaHQgPSBudWxsLCB0aGlzLnJhaWxZUmF0aW8gPSBudWxsLCB0aGlzLnJlYWNoID0ge1xuICAgIHg6IHQuc2Nyb2xsTGVmdCA8PSAwID8gXCJzdGFydFwiIDogdC5zY3JvbGxMZWZ0ID49IHRoaXMuY29udGVudFdpZHRoIC0gdGhpcy5jb250YWluZXJXaWR0aCA/IFwiZW5kXCIgOiBudWxsLFxuICAgIHk6IHQuc2Nyb2xsVG9wIDw9IDAgPyBcInN0YXJ0XCIgOiB0LnNjcm9sbFRvcCA+PSB0aGlzLmNvbnRlbnRIZWlnaHQgLSB0aGlzLmNvbnRhaW5lckhlaWdodCA/IFwiZW5kXCIgOiBudWxsXG4gIH0sIHRoaXMuaXNBbGl2ZSA9ICEwLCB0aGlzLnNldHRpbmdzLmhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBGdltwXShpKTtcbiAgfSksIHRoaXMubGFzdFNjcm9sbFRvcCA9IE1hdGguZmxvb3IodC5zY3JvbGxUb3ApLCB0aGlzLmxhc3RTY3JvbGxMZWZ0ID0gdC5zY3JvbGxMZWZ0LCB0aGlzLmV2ZW50LmJpbmQodGhpcy5lbGVtZW50LCBcInNjcm9sbFwiLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIGkub25TY3JvbGwocCk7XG4gIH0pLCBIdCh0aGlzKTtcbn07XG5aaS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaXNBbGl2ZSAmJiAodGhpcy5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgPSB0aGlzLmlzTmVnYXRpdmVTY3JvbGwgPyB0aGlzLmVsZW1lbnQuc2Nyb2xsV2lkdGggLSB0aGlzLmVsZW1lbnQuY2xpZW50V2lkdGggOiAwLCBjdCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9KSwgY3QodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIHRoaXMucmFpbFhNYXJnaW5XaWR0aCA9IEYoTnQodGhpcy5zY3JvbGxiYXJYUmFpbCkubWFyZ2luTGVmdCkgKyBGKE50KHRoaXMuc2Nyb2xsYmFyWFJhaWwpLm1hcmdpblJpZ2h0KSwgdGhpcy5yYWlsWU1hcmdpbkhlaWdodCA9IEYoTnQodGhpcy5zY3JvbGxiYXJZUmFpbCkubWFyZ2luVG9wKSArIEYoTnQodGhpcy5zY3JvbGxiYXJZUmFpbCkubWFyZ2luQm90dG9tKSwgY3QodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiBcIm5vbmVcIiB9KSwgY3QodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiBcIm5vbmVcIiB9KSwgSHQodGhpcyksIGZuKHRoaXMsIFwidG9wXCIsIDAsICExLCAhMCksIGZuKHRoaXMsIFwibGVmdFwiLCAwLCAhMSwgITApLCBjdCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6IFwiXCIgfSksIGN0KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogXCJcIiB9KSk7XG59O1xuWmkucHJvdG90eXBlLm9uU2Nyb2xsID0gZnVuY3Rpb24odCkge1xuICB0aGlzLmlzQWxpdmUgJiYgKEh0KHRoaXMpLCBmbih0aGlzLCBcInRvcFwiLCB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wIC0gdGhpcy5sYXN0U2Nyb2xsVG9wKSwgZm4oXG4gICAgdGhpcyxcbiAgICBcImxlZnRcIixcbiAgICB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdCAtIHRoaXMubGFzdFNjcm9sbExlZnRcbiAgKSwgdGhpcy5sYXN0U2Nyb2xsVG9wID0gTWF0aC5mbG9vcih0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wKSwgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IHRoaXMuZWxlbWVudC5zY3JvbGxMZWZ0KTtcbn07XG5aaS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmlzQWxpdmUgJiYgKHRoaXMuZXZlbnQudW5iaW5kQWxsKCksIFllKHRoaXMuc2Nyb2xsYmFyWCksIFllKHRoaXMuc2Nyb2xsYmFyWSksIFllKHRoaXMuc2Nyb2xsYmFyWFJhaWwpLCBZZSh0aGlzLnNjcm9sbGJhcllSYWlsKSwgdGhpcy5yZW1vdmVQc0NsYXNzZXMoKSwgdGhpcy5lbGVtZW50ID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJYID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJZID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJYUmFpbCA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWVJhaWwgPSBudWxsLCB0aGlzLmlzQWxpdmUgPSAhMSk7XG59O1xuWmkucHJvdG90eXBlLnJlbW92ZVBzQ2xhc3NlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5lbGVtZW50LmNsYXNzTmFtZS5zcGxpdChcIiBcIikuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gIXQubWF0Y2goL15wcyhbLV9dLit8KSQvKTtcbiAgfSkuam9pbihcIiBcIik7XG59O1xuY29uc3QgQW8gPSBcInBlcmZlY3RTY3JvbGxiYXJcIiwgWXYgPSBcInBlcmZlY3Qtc2Nyb2xsYmFyXCIsICRzID0gXCJ0ZS5wZXJmZWN0U2Nyb2xsYmFyXCIsIFN0ID0gXCJ0ZVwiLCBJdCA9IFwicHNcIiwgeW8gPSBbXG4gIHsgdGU6IGBzY3JvbGxYLiR7U3R9LiR7SXR9YCwgcHM6IFwicHMtc2Nyb2xsLXhcIiB9LFxuICB7IHRlOiBgc2Nyb2xsWS4ke1N0fS4ke0l0fWAsIHBzOiBcInBzLXNjcm9sbC15XCIgfSxcbiAgeyB0ZTogYHNjcm9sbFVwLiR7U3R9LiR7SXR9YCwgcHM6IFwicHMtc2Nyb2xsLXVwXCIgfSxcbiAgeyB0ZTogYHNjcm9sbERvd24uJHtTdH0uJHtJdH1gLCBwczogXCJwcy1zY3JvbGwtZG93blwiIH0sXG4gIHsgdGU6IGBzY3JvbGxMZWZ0LiR7U3R9LiR7SXR9YCwgcHM6IFwicHMtc2Nyb2xsLWxlZnRcIiB9LFxuICB7IHRlOiBgc2Nyb2xsUmlnaHQuJHtTdH0uJHtJdH1gLCBwczogXCJwcy1zY3JvbGwtcmlnaHRcIiB9LFxuICB7IHRlOiBgc2Nyb2xsWEVuZC4ke1N0fS4ke0l0fWAsIHBzOiBcInBzLXgtcmVhY2gtZW5kXCIgfSxcbiAgeyB0ZTogYHNjcm9sbFlFbmQuJHtTdH0uJHtJdH1gLCBwczogXCJwcy15LXJlYWNoLWVuZFwiIH0sXG4gIHsgdGU6IGBzY3JvbGxYU3RhcnQuJHtTdH0uJHtJdH1gLCBwczogXCJwcy14LXJlYWNoLXN0YXJ0XCIgfSxcbiAgeyB0ZTogYHNjcm9sbFlTdGFydC4ke1N0fS4ke0l0fWAsIHBzOiBcInBzLXktcmVhY2gtc3RhcnRcIiB9XG5dLCBqdiA9IHtcbiAgaGFuZGxlcnM6IFtcImNsaWNrLXJhaWxcIiwgXCJkcmFnLXRodW1iXCIsIFwia2V5Ym9hcmRcIiwgXCJ3aGVlbFwiLCBcInRvdWNoXCJdLFxuICB3aGVlbFNwZWVkOiAxLFxuICB3aGVlbFByb3BhZ2F0aW9uOiAhMCxcbiAgc3dpcGVFYXNpbmc6ICEwLFxuICBtaW5TY3JvbGxiYXJMZW5ndGg6IG51bGwsXG4gIG1heFNjcm9sbGJhckxlbmd0aDogbnVsbCxcbiAgc2Nyb2xsaW5nVGhyZXNob2xkOiAxZTMsXG4gIHVzZUJvdGhXaGVlbEF4ZXM6ICExLFxuICBzdXBwcmVzc1Njcm9sbFg6ICExLFxuICBzdXBwcmVzc1Njcm9sbFk6ICExLFxuICBzY3JvbGxYTWFyZ2luT2Zmc2V0OiAwLFxuICBzY3JvbGxZTWFyZ2luT2Zmc2V0OiAwLFxuICBwb3NpdGlvblJpZ2h0OiAhMFxufSwgS3YgPSB7XG4gIGhhbmRsZXJzOiBcIihzdHJpbmd8YXJyYXkpXCIsXG4gIHdoZWVsU3BlZWQ6IFwibnVtYmVyXCIsXG4gIHdoZWVsUHJvcGFnYXRpb246IFwiYm9vbGVhblwiLFxuICBzd2lwZUVhc2luZzogXCJib29sZWFuXCIsXG4gIG1pblNjcm9sbGJhckxlbmd0aDogXCIobnVtYmVyfG51bGwpXCIsXG4gIG1heFNjcm9sbGJhckxlbmd0aDogXCIobnVtYmVyfG51bGwpXCIsXG4gIHNjcm9sbGluZ1RocmVzaG9sZDogXCJudW1iZXJcIixcbiAgdXNlQm90aFdoZWVsQXhlczogXCJib29sZWFuXCIsXG4gIHN1cHByZXNzU2Nyb2xsWDogXCJib29sZWFuXCIsXG4gIHN1cHByZXNzU2Nyb2xsWTogXCJib29sZWFuXCIsXG4gIHNjcm9sbFhNYXJnaW5PZmZzZXQ6IFwibnVtYmVyXCIsXG4gIHNjcm9sbFlNYXJnaW5PZmZzZXQ6IFwibnVtYmVyXCIsXG4gIHBvc2l0aW9uUmlnaHQ6IFwiYm9vbGVhblwiXG59LCB6diA9IHtcbiAgcHM6IFwiZ3JvdXAvcHMgb3ZlcmZsb3ctaGlkZGVuIFtvdmVyZmxvdy1hbmNob3I6bm9uZV0gdG91Y2gtbm9uZVwiLFxuICByYWlsWDogXCJncm91cC94IGFic29sdXRlIGJvdHRvbS0wIGgtWzAuOTM3NXJlbV0gaGlkZGVuIG9wYWNpdHktMCB0cmFuc2l0aW9uLVtiYWNrZ3JvdW5kLWNvbG9yLF9vcGFjaXR5XSBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgei1bMTAzNV0gZ3JvdXAtWyYucHMtLWFjdGl2ZS14XS9wczpibG9jayBncm91cC1ob3Zlci9wczpvcGFjaXR5LTYwIGdyb3VwLWZvY3VzL3BzOm9wYWNpdHktNjAgZ3JvdXAtWyYucHMtLXNjcm9sbGluZy14XS9wczpvcGFjaXR5LTYwIGhvdmVyOiFvcGFjaXR5LTkwIGZvY3VzOiFvcGFjaXR5LTkwIFsmLnBzLS1jbGlja2luZ106IW9wYWNpdHktOTAgb3V0bGluZS1ub25lXCIsXG4gIHJhaWxYQ29sb3JzOiBcImdyb3VwLVsmLnBzLS1hY3RpdmUteF0vcHM6YmctdHJhbnNwYXJlbnQgaG92ZXI6IWJnLVsjZWVlXSBmb2N1czohYmctWyNlZWVdIFsmLnBzLS1jbGlja2luZ106IWJnLVsjZWVlXSBkYXJrOmhvdmVyOiFiZy1bIzU1NV0gZGFyazpmb2N1czohYmctWyM1NTVdIGRhcms6WyYucHMtLWNsaWNraW5nXTohYmctWyM1NTVdXCIsXG4gIHJhaWxYVGh1bWI6IFwiYWJzb2x1dGUgYm90dG9tLTAuNSByb3VuZGVkLW1kIGgtMS41IGdyb3VwLWZvY3VzL3BzOm9wYWNpdHktMTAwIGdyb3VwLWFjdGl2ZS9wczpvcGFjaXR5LTEwMCBbdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yXy4yc19saW5lYXIsX2hlaWdodF8uMnNfZWFzZS1pbi1vdXRdIGdyb3VwLWhvdmVyL3g6aC1bMTFweF0gZ3JvdXAtZm9jdXMveDpoLVswLjY4NzVyZW1dIGdyb3VwLVsmLnBzLS1jbGlja2luZ10veDpiZy1bIzk5OV0gZ3JvdXAtWyYucHMtLWNsaWNraW5nXS94OmgtWzExcHhdIG91dGxpbmUtbm9uZVwiLFxuICByYWlsWFRodW1iQ29sb3JzOiBcImJnLVsjYWFhXSBncm91cC1ob3Zlci94OmJnLVsjOTk5XSBncm91cC1mb2N1cy94OmJnLVsjOTk5XVwiLFxuICByYWlsWTogXCJncm91cC95IGFic29sdXRlIHJpZ2h0LTAgdy1bMC45Mzc1cmVtXSBoaWRkZW4gb3BhY2l0eS0wIHRyYW5zaXRpb24tW2JhY2tncm91bmQtY29sb3IsX29wYWNpdHldIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSB6LVsxMDM1XSBncm91cC1bJi5wcy0tYWN0aXZlLXldL3BzOmJsb2NrIGdyb3VwLWhvdmVyL3BzOm9wYWNpdHktNjAgZ3JvdXAtZm9jdXMvcHM6b3BhY2l0eS02MCBncm91cC1bJi5wcy0tc2Nyb2xsaW5nLXldL3BzOm9wYWNpdHktNjAgaG92ZXI6IW9wYWNpdHktOTAgZm9jdXM6IW9wYWNpdHktOTAgWyYucHMtLWNsaWNraW5nXTohb3BhY2l0eS05MCBvdXRsaW5lLW5vbmVcIixcbiAgcmFpbFlDb2xvcnM6IFwiZ3JvdXAtWyYucHMtLWFjdGl2ZS15XS9wczpiZy10cmFuc3BhcmVudCBob3ZlcjohYmctWyNlZWVdIGZvY3VzOiFiZy1bI2VlZV0gWyYucHMtLWNsaWNraW5nXTohYmctWyNlZWVdIGRhcms6aG92ZXI6IWJnLVsjNTU1XSBkYXJrOmZvY3VzOiFiZy1bIzU1NV0gZGFyazpbJi5wcy0tY2xpY2tpbmddOiFiZy1bIzU1NV1cIixcbiAgcmFpbFlUaHVtYjogXCJhYnNvbHV0ZSByaWdodC0wLjUgcm91bmRlZC1tZCB3LTEuNSBncm91cC1mb2N1cy9wczpvcGFjaXR5LTEwMCBncm91cC1hY3RpdmUvcHM6b3BhY2l0eS0xMDAgW3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvcl8uMnNfbGluZWFyLF93aWR0aF8uMnNfZWFzZS1pbi1vdXQsX29wYWNpdHldIGdyb3VwLWhvdmVyL3k6dy1bMTFweF0gZ3JvdXAtZm9jdXMveTp3LVswLjY4NzVyZW1dIGdyb3VwLVsmLnBzLS1jbGlja2luZ10veTp3LVsxMXB4XSBvdXRsaW5lLW5vbmVcIixcbiAgcmFpbFlUaHVtYkNvbG9yczogXCJiZy1bI2FhYV0gZ3JvdXAtaG92ZXIveTpiZy1bIzk5OV0gZ3JvdXAtZm9jdXMveTpiZy1bIzk5OV0gZ3JvdXAtWyYucHMtLWNsaWNraW5nXS95OmJnLVsjOTk5XVwiXG59LCBVdiA9IHtcbiAgcHM6IFwic3RyaW5nXCIsXG4gIHJhaWxYOiBcInN0cmluZ1wiLFxuICByYWlsWENvbG9yczogXCJzdHJpbmdcIixcbiAgcmFpbFhUaHVtYjogXCJzdHJpbmdcIixcbiAgcmFpbFhUaHVtYkNvbG9yczogXCJzdHJpbmdcIixcbiAgcmFpbFk6IFwic3RyaW5nXCIsXG4gIHJhaWxZQ29sb3JzOiBcInN0cmluZ1wiLFxuICByYWlsWVRodW1iOiBcInN0cmluZ1wiLFxuICByYWlsWVRodW1iQ29sb3JzOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgeHIge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30sIGkgPSB7fSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5wZXJmZWN0U2Nyb2xsYmFyID0gbnVsbCwgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsLCB0aGlzLl9wc0NsYXNzZXMgPSBbXG4gICAgICB7XG4gICAgICAgIHBzOiBcInBzX19yYWlsLXhcIixcbiAgICAgICAgdGU6IHRoaXMuX2NsYXNzZXMucmFpbFgsXG4gICAgICAgIHRlQ29sb3I6IHRoaXMuX2NsYXNzZXMucmFpbFhDb2xvcnNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBzOiBcInBzX19yYWlsLXlcIixcbiAgICAgICAgdGU6IHRoaXMuX2NsYXNzZXMucmFpbFksXG4gICAgICAgIHRlQ29sb3I6IHRoaXMuX2NsYXNzZXMucmFpbFlDb2xvcnNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBzOiBcInBzX190aHVtYi14XCIsXG4gICAgICAgIHRlOiB0aGlzLl9jbGFzc2VzLnJhaWxYVGh1bWIsXG4gICAgICAgIHRlQ29sb3I6IHRoaXMuX2NsYXNzZXMucmFpbFhUaHVtYkNvbG9yc1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcHM6IFwicHNfX3RodW1iLXlcIixcbiAgICAgICAgdGU6IHRoaXMuX2NsYXNzZXMucmFpbFlUaHVtYixcbiAgICAgICAgdGVDb2xvcjogdGhpcy5fY2xhc3Nlcy5yYWlsWVRodW1iQ29sb3JzXG4gICAgICB9XG4gICAgXSwgdGhpcy5fZWxlbWVudCAmJiAoQS5zZXREYXRhKHQsICRzLCB0aGlzKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBZdikpLCB0aGlzLmluaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gQW87XG4gIH1cbiAgZ2V0IHJhaWxYKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXCIucHNfX3JhaWwteFwiLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgcmFpbFkoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcIi5wc19fcmFpbC15XCIsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiBlLmhhbmRsZXJzICE9PSB2b2lkIDAgJiYgKGUuaGFuZGxlcnMgPSBlLmhhbmRsZXJzLnNwbGl0KFwiIFwiKSksIHQgPSB7XG4gICAgICAuLi5qdixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgSShBbywgdCwgS3YpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uenYsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoQW8sIHQsIFV2KSwgdDtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9vcHRpb25zLnBvc2l0aW9uUmlnaHQgJiYgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpLCBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgJHMpLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fZGF0YUF0dHJPcHRpb25zID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHRoaXMucGVyZmVjdFNjcm9sbGJhci5kZXN0cm95KCksIHRoaXMucmVtb3ZlRXZlbnQoeW8pLCB0aGlzLnBlcmZlY3RTY3JvbGxiYXIgPSBudWxsO1xuICB9XG4gIGluaXQoKSB7XG4gICAgaWYgKHRoaXMucGVyZmVjdFNjcm9sbGJhciA9IG5ldyBaaSh0aGlzLl9lbGVtZW50LCB0aGlzLl9vcHRpb25zKSwgdGhpcy5fYWRkUGVyZmVjdFNjcm9sbGJhclN0eWxlcygpLCB0aGlzLl91cGRhdGVTY3JvbGxQb3NpdGlvbigpLCB0aGlzLnBlcmZlY3RTY3JvbGxiYXIudXBkYXRlKCksIHRoaXMuX2luaXRFdmVudHMoeW8pLCB0aGlzLl9vcHRpb25zLnBvc2l0aW9uUmlnaHQpIHtcbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdCA9IHtcbiAgICAgICAgYXR0cmlidXRlczogITAsXG4gICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wiY2xhc3NcIiwgXCJjbGFzc05hbWVcIl1cbiAgICAgIH07XG4gICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2VsZW1lbnQsIHQpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlU2Nyb2xsUG9zaXRpb24oKSB7XG4gICAgY29uc3QgdCA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShcImhlaWdodFwiKSwgZSA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShcIndpZHRoXCIpO1xuICAgIHRoaXMucmFpbFggJiYgKHRoaXMucmFpbFguc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoY2FsYygtMTAwJSArICR7dGhpcy5fY2FuVHJhbnNmb3JtKHQpID8gdCA6IFwiMHB4XCJ9KSlgKSwgdGhpcy5yYWlsWSAmJiAodGhpcy5yYWlsWS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWChjYWxjKC0xMDAlICsgJHt0aGlzLl9jYW5UcmFuc2Zvcm0oZSkgPyBlIDogXCIwcHhcIn0pKWApO1xuICB9XG4gIF9jYW5UcmFuc2Zvcm0odCkge1xuICAgIHJldHVybiB0ICYmIHQuaW5jbHVkZXMoXCJweFwiKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVyZmVjdFNjcm9sbGJhci51cGRhdGUoKTtcbiAgfVxuICBfaW5pdEV2ZW50cyh0ID0gW10pIHtcbiAgICB0LmZvckVhY2goXG4gICAgICAoeyBwczogZSwgdGU6IGkgfSkgPT4gYy5vbihcbiAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgZSxcbiAgICAgICAgKG4pID0+IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBpLCB7IGU6IG4gfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIF9hZGRQZXJmZWN0U2Nyb2xsYmFyU3R5bGVzKCkge1xuICAgIHRoaXMuX3BzQ2xhc3Nlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gZC5maW5kT25lKGAuJHt0LnBzfWAsIHRoaXMuX2VsZW1lbnQpO1xuICAgICAgaC5hZGRDbGFzcyhlLCB0LnRlKSwgaC5hZGRDbGFzcyhlLCB0LnRlQ29sb3IpO1xuICAgIH0pLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMucHMpLCBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIFwicHNcIik7XG4gIH1cbiAgcmVtb3ZlRXZlbnQodCkge1xuICAgIGxldCBlID0gW107XG4gICAgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAoZSA9IHlvLmZpbHRlcigoeyB0ZTogaSB9KSA9PiBpID09PSB0KSksIGUuZm9yRWFjaCgoeyBwczogaSwgdGU6IG4gfSkgPT4ge1xuICAgICAgYy5vZmYodGhpcy5fZWxlbWVudCwgaSksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIG4pO1xuICAgIH0pO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGUgPSBBLmdldERhdGEodGhpcywgJHMpO1xuICAgICAgY29uc3QgaSA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFlICYmIC9kaXNwb3NlfGhpZGUvLnRlc3QodCkpICYmIChlIHx8IChlID0gbmV3IHhyKHRoaXMsIGkpKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgJHMpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IEJoID0geHIsIFh2ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1zZWxlY3QtcmVmXCIsIEd2ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1wYWdpbmF0aW9uLW5hdi1yZWZcIiwgcXYgPSBcImRhdGEtdGUtZGF0YXRhYmxlLXBhZ2luYXRpb24tcmlnaHQtcmVmXCIsIFp2ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1wYWdpbmF0aW9uLWxlZnQtcmVmXCIsIFF2ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1wYWdpbmF0aW9uLXN0YXJ0LXJlZlwiLCBKdiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcGFnaW5hdGlvbi1lbmQtcmVmXCIsIHRUID0gKHtcbiAgdGV4dDogcyxcbiAgZW50cmllczogdCxcbiAgZW50cmllc09wdGlvbnM6IGUsXG4gIGZ1bGxQYWdpbmF0aW9uOiBpLFxuICByb3dzVGV4dDogbixcbiAgYWxsVGV4dDogbyxcbiAgcGFnaW5hdGlvblN0YXJ0SWNvblRlbXBsYXRlOiByLFxuICBwYWdpbmF0aW9uTGVmdEljb25UZW1wbGF0ZTogYSxcbiAgcGFnaW5hdGlvblJpZ2h0SWNvblRlbXBsYXRlOiBsLFxuICBwYWdpbmF0aW9uRW5kSWNvblRlbXBsYXRlOiBwLFxuICBjbGFzc2VzOiB1XG59LCBfLCBmKSA9PiB7XG4gIGNvbnN0IGcgPSBlLm1hcCgobSkgPT4gbSA9PT0gXCJBbGxcIiA/IGA8b3B0aW9uIHZhbHVlPVwiJHttfVwiICR7bSA9PT0gdCA/IFwic2VsZWN0ZWRcIiA6IFwiXCJ9PiR7b308L29wdGlvbj5gIDogYDxvcHRpb24gdmFsdWU9XCIke219XCIgJHttID09PSB0ID8gXCJzZWxlY3RlZFwiIDogXCJcIn0+JHttfTwvb3B0aW9uPmApLmpvaW4oYFxuYCk7XG4gIHJldHVybiBgXG48ZGl2IGNsYXNzPVwiJHt1LnBhZ2luYXRpb259ICR7ZiA/IGAke3UucGFnaW5hdGlvbkJvcmRlcmVkfWAgOiBcIlwifSAke3UuYm9yZGVyQ29sb3J9ICR7dS5jb2xvcn1cIj5cbiAgPGRpdiBjbGFzcz1cIiR7dS5zZWxlY3RJdGVtc1dyYXBwZXJ9XCI+ICBcbiAgICA8cCBjbGFzcz1cIiR7dS5wYWdpbmF0aW9uUm93c1RleHR9ICR7XyA/IGAke3UubG9hZGluZ1BhZ2luYXRpb25Sb3dzVGV4dH1gIDogXCJcIn1cIj4ke259PC9wPlxuICAgIDxkaXYgY2xhc3M9XCIke3Uuc2VsZWN0V3JhcHBlcn0gJHtfID8gYCR7dS5sb2FkaW5nUGFnaW5hdGlvblNlbGVjdFdyYXBwZXJ9YCA6IFwiXCJ9XCI+XG4gICAgICA8c2VsZWN0IG5hbWU9XCJlbnRyaWVzXCJcbiAgICAgICAgJHtfID8gXCJkaXNhYmxlZFwiIDogXCJcIn0gY2xhc3M9XCJzZWxlY3RcIiAke1h2fT5cbiAgICAgICAgJHtnfVxuICAgICAgPC9zZWxlY3Q+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiJHt1LnBhZ2luYXRpb25OYXZ9ICR7XyA/IGAke3UubG9hZGluZ1BhZ2luYXRpb25OYXZ9YCA6IFwiXCJ9XCIgJHtHdn0+XG4gICR7c31cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCIke3UucGFnaW5hdGlvbkJ1dHRvbnNXcmFwcGVyfVwiPlxuICAgICR7aSA/IGA8YnV0dG9uIGRhdGEtdGUtcmlwcGxlLWluaXQgZGF0YS10ZS1yaXBwbGUtY29sb3I9XCJkYXJrXCIgY2xhc3M9XCIke3UucGFnaW5hdGlvblN0YXJ0QnV0dG9ufVwiICR7UXZ9PlxuICAgICAgICAgICAke3J9XG4gICAgICAgICAgPC9idXR0b24+YCA6IFwiXCJ9XG4gICAgPGJ1dHRvbiBkYXRhLXRlLXJpcHBsZS1pbml0IGRhdGEtdGUtcmlwcGxlLWNvbG9yPVwiZGFya1wiIGNsYXNzPVwiJHt1LnBhZ2luYXRpb25MZWZ0QnV0dG9ufVwiICR7WnZ9PlxuICAgICAgJHthfVxuICA8L2J1dHRvbj5cbiAgICA8YnV0dG9uIGRhdGEtdGUtcmlwcGxlLWluaXQgZGF0YS10ZS1yaXBwbGUtY29sb3I9XCJkYXJrXCIgY2xhc3M9XCIke3UucGFnaW5hdGlvblJpZ2h0QnV0dG9ufVwiICR7cXZ9PlxuICAgICAgJHtsfVxuICA8L2J1dHRvbj5cbiAgICAke2kgPyBgPGJ1dHRvbiBkYXRhLXRlLXJpcHBsZS1pbml0IGRhdGEtdGUtcmlwcGxlLWNvbG9yPVwiZGFya1wiIGNsYXNzPVwiJHt1LnBhZ2luYXRpb25FbmRCdXR0b259XCIgJHtKdn0+XG4gICAgICAgICAgICR7cH1cbiAgICAgICAgICA8L2J1dHRvbj5gIDogXCJcIn1cbiAgPC9kaXY+XG48L2Rpdj5cbmA7XG59LCBlVCA9IFwiZGF0YS10ZS1kYXRhdGFibGUtc29ydC1pY29uLXJlZlwiLCBpVCA9IFwiZGF0YS10ZS1kYXRhdGFibGUtaGVhZGVyLWNoZWNrYm94LXJlZlwiLCBzVCA9IChzLCB0LCBlLCBpLCBuLCBvLCByLCBhKSA9PiB7XG4gIGNvbnN0IGwgPSBlID8gYFxuICA8dGggc2NvcGU9XCJjb2xcIj5cbiAgICA8ZGl2IGNsYXNzPVwiJHthLmNoZWNrYm94SGVhZGVyV3JhcHBlcn1cIj5cbiAgICAgIDxpbnB1dFxuICAgICAgICBjbGFzcz1cIiR7YS5jaGVja2JveEhlYWRlcn1cIlxuICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICB2YWx1ZT1cIlwiXG4gICAgICAgICR7aVR9XG4gICAgICAgIC8+XG4gICAgPC9kaXY+XG4gIDwvdGg+XG4gIGAgOiAnPHRoIHNjb3BlPVwiY29sXCI+PC90aD4nLCBwID0gcy5tYXAoKHUsIF8pID0+IHtcbiAgICBjb25zdCBmID0gdS5maXhlZCA/IHMuZmlsdGVyKChnLCBtKSA9PiBnLmZpeGVkID09PSB1LmZpeGVkICYmIG0gPCBfKS5yZWR1Y2UoKGcsIG0pID0+IGcgKyBtLndpZHRoLCAwKSA6IG51bGw7XG4gICAgcmV0dXJuIGA8dGggY2xhc3M9XCIke2EuY29sdW1ufSAke2kgPyBgJHthLnRhYmxlQm9yZGVyZWR9YCA6IFwiXCJ9ICR7YS5ib3JkZXJDb2xvcn0gJHtuID8gYCR7YS5zbX1gIDogXCJcIn0gJHt1LmZpeGVkID8gYCR7YS5maXhlZEhlYWRlcn0gJHthLmNvbG9yfWAgOiBcIlwifSAke28gPyBgJHthLmxvYWRpbmdDb2x1bW59YCA6IFwiXCJ9XCIgc3R5bGU9XCIke3UuZml4ZWQgPyBgJHt1LmZpeGVkID09PSBcInJpZ2h0XCIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIn06ICR7Zn1weDtgIDogXCJcIn1cIiBzY29wZT1cImNvbFwiPiR7dS5zb3J0ID8gYDxkaXYgY2xhc3M9XCIke2Euc29ydEljb25XcmFwcGVyfVwiPjxzcGFuIGNsYXNzPVwiJHthLnNvcnRJY29ufSAke28gPyBcImludmlzaWJsZVwiIDogXCJcIn1cIiBkYXRhLXRlLXNvcnQ9XCIke3UuZmllbGR9XCIgJHtlVH0+JHtyfTwvc3Bhbj5gIDogXCJcIn0gPHNwYW4gY2xhc3M9XCIke3Uuc29ydCA/IFwiXCIgOiBcInBsLVsxOHB4XVwifVwiPiR7dS5sYWJlbH08L3NwYW4+PC9kaXY+PC90aD5gO1xuICB9KTtcbiAgcmV0dXJuIFt0ID8gbCA6IFwiXCIsIC4uLnBdLmpvaW4oYFxuYCk7XG59LCBuVCA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcm93LXJlZlwiLCBvVCA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcm93LWNoZWNrYm94LXJlZlwiLCByVCA9IFwiZGF0YS10ZS1kYXRhdGFibGUtY2VsbC1yZWZcIiwgYVQgPSAoe1xuICByb3dzOiBzLFxuICBjb2x1bW5zOiB0LFxuICBub0ZvdW5kTWVzc2FnZTogZSxcbiAgZWRpdDogaSxcbiAgc2VsZWN0YWJsZTogbixcbiAgbG9hZGluZzogbyxcbiAgYm9yZGVyZWQ6IHIsXG4gIGJvcmRlcmxlc3M6IGEsXG4gIHN0cmlwZWQ6IGwsXG4gIGhvdmVyOiBwLFxuICBzbTogdSxcbiAgY2xhc3NlczogX1xufSkgPT4ge1xuICBjb25zdCBmID0gcy5tYXAoKGcpID0+IHtcbiAgICBjb25zdCBtID0gYFxuICAgICAgPHRkIGRhdGEtdGUtZmllbGQ9XCJjaGVja2JveFwiIGNsYXNzPVwiJHtyID8gYCR7Xy50YWJsZUJvcmRlcmVkfSAke18uYm9yZGVyQ29sb3J9YCA6IFwiXCJ9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke18uY2hlY2tib3hSb3dXcmFwcGVyfVwiPlxuICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgY2xhc3M9XCIke18uY2hlY2tib3hSb3d9XCJcbiAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICB2YWx1ZT1cIlwiXG4gICAgICAgICAgICBkYXRhLXRlLXJvdy1pbmRleD1cIiR7Zy5yb3dJbmRleH1cIiAgJHtvVH0vPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvdGQ+YCwgYiA9IHQubWFwKCh2LCBUKSA9PiB7XG4gICAgICBjb25zdCB5ID0ge307XG4gICAgICBpZiAodi53aWR0aCAmJiAoeVtcIm1pbi13aWR0aFwiXSA9IGAke3Yud2lkdGggLSAxfXB4YCwgeVtcIm1heC13aWR0aFwiXSA9IGAke3Yud2lkdGh9cHhgLCB5LndpZHRoID0gYCR7di53aWR0aH1weGApLCB2LmZpeGVkKSB7XG4gICAgICAgIGNvbnN0IEUgPSB0LmZpbHRlcigodywgaykgPT4gdy5maXhlZCA9PT0gdi5maXhlZCAmJiBrIDwgVCkucmVkdWNlKCh3LCBrKSA9PiB3ICsgay53aWR0aCwgMCk7XG4gICAgICAgIHlbdi5maXhlZCA9PT0gXCJyaWdodFwiID8gXCJyaWdodFwiIDogXCJsZWZ0XCJdID0gYCR7RX1weGA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYDx0ZCBzdHlsZT1cIiR7T2JqZWN0LmtleXMoeSkubWFwKChFKSA9PiBgJHtFfTogJHt5W0VdfWApLmpvaW4oXCI7IFwiKX1cIiBjbGFzcz1cIiR7Xy5yb3dJdGVtfSAke18uYm9yZGVyQ29sb3J9ICR7aSA/IGAke18uZWRpdH1gIDogXCJcIn0gJHtyID8gYCR7Xy50YWJsZUJvcmRlcmVkfWAgOiBcIlwifSAke3UgPyBgJHtfLnNtfWAgOiBcIlwifSAke3YuZml4ZWQgPyBgJHtfLmZpeGVkSGVhZGVyfSAke18uY29sb3J9YCA6IFwiXCJ9XCIgJHtyVH0gZGF0YS10ZS1maWVsZD1cIiR7di5maWVsZH1cIiAke2kgJiYgJ2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIid9PiR7Z1t2LmZpZWxkXX08L3RkPmA7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgICByZXR1cm4gYDx0ciBzY29wZT1cInJvd1wiIGNsYXNzPVwiJHtfLnJvd30gJHtfLmJvcmRlckNvbG9yfSAke18ucm93QW5pbWF0aW9ufSAke2wgPyBgJHtfLnN0cmlwZWR9YCA6IFwiXCJ9ICR7YSA/IGAke18uYm9yZGVybGVzc31gIDogXCJcIn0gJHtwID8gYCR7Xy5ob3ZlclJvd31gIDogXCJcIn1cIiBkYXRhLXRlLWluZGV4PVwiJHtnLnJvd0luZGV4fVwiICR7blR9PiR7biA/IG0gOiBcIlwifSR7Yn08L3RyPmA7XG4gIH0pO1xuICByZXR1cm4gcy5sZW5ndGggPiAwIHx8IG8gPyBmLmpvaW4oYFxuYCkgOiBgPHRyIGNsYXNzPVwiJHtfLm5vRm91bmRNZXNzYWdlV3JhcHBlcn0gJHtfLmJvcmRlckNvbG9yfVwiPjx0ZCBjbGFzcz1cIiR7Xy5ub0ZvdW5kTWVzc2FnZX1cIj4ke2V9PC90ZD48L3RyPmA7XG59LCBsVCA9IFwiZGF0YS10ZS1kYXRhdGFibGUtaW5uZXItcmVmXCIsIGNUID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1oZWFkZXItcmVmXCIsIFBsID0gKHtcbiAgY29sdW1uczogcyxcbiAgcm93czogdCxcbiAgbm9Gb3VuZE1lc3NhZ2U6IGUsXG4gIGVkaXQ6IGksXG4gIG11bHRpOiBuLFxuICBzZWxlY3RhYmxlOiBvLFxuICBsb2FkaW5nOiByLFxuICBsb2FkaW5nTWVzc2FnZTogYSxcbiAgcGFnaW5hdGlvbjogbCxcbiAgYm9yZGVyZWQ6IHAsXG4gIGJvcmRlcmxlc3M6IHUsXG4gIHN0cmlwZWQ6IF8sXG4gIGhvdmVyOiBmLFxuICBmaXhlZEhlYWRlcjogZyxcbiAgc206IG0sXG4gIHNvcnRJY29uVGVtcGxhdGU6IGIsXG4gIGNsYXNzZXM6IHZcbn0pID0+IHtcbiAgY29uc3QgVCA9IGFUKHtcbiAgICByb3dzOiB0LFxuICAgIGNvbHVtbnM6IHMsXG4gICAgbm9Gb3VuZE1lc3NhZ2U6IGUsXG4gICAgZWRpdDogaSxcbiAgICBsb2FkaW5nOiByLFxuICAgIHNlbGVjdGFibGU6IG8sXG4gICAgYm9yZGVyZWQ6IHAsXG4gICAgYm9yZGVybGVzczogdSxcbiAgICBzdHJpcGVkOiBfLFxuICAgIGhvdmVyOiBmLFxuICAgIHNtOiBtLFxuICAgIGNsYXNzZXM6IHZcbiAgfSksIHkgPSBzVChcbiAgICBzLFxuICAgIG8sXG4gICAgbixcbiAgICBwLFxuICAgIG0sXG4gICAgcixcbiAgICBiLFxuICAgIHZcbiAgKTtcbiAgcmV0dXJuIHsgdGFibGU6IGBcbjxkaXYgY2xhc3M9XCIke3YuY29sb3J9XCIgJHtsVH0+XG4gIDx0YWJsZSBjbGFzcz1cIiR7di50YWJsZX1cIj5cbiAgICA8dGhlYWQgY2xhc3M9XCIke3YudGFibGVIZWFkZXJ9ICR7cCA/IGAke3YudGFibGVCb3JkZXJlZH1gIDogXCJcIn0gJHt1ID8gYCR7di5ib3JkZXJsZXNzfWAgOiBcIlwifSAke3YuYm9yZGVyQ29sb3J9XCIgJHtjVH0+XG4gICAgICA8dHI+XG4gICAgICAgICR7eX1cbiAgICAgIDwvdHI+XG4gICAgPC90aGVhZD5cbiAgICA8dGJvZHkgY2xhc3M9XCIke2cgPyBgJHt2LmZpeGVkSGVhZGVyQm9keX1gIDogXCJcIn1cIj5cbiAgICAgICR7ciA/IFwiXCIgOiBUfVxuICAgIDwvdGJvZHk+XG4gIDwvdGFibGU+XG48L2Rpdj5cbiR7ciA/IGBcbiAgPGRpdiBjbGFzcz1cIiR7di5sb2FkaW5nSXRlbXNXcmFwcGVyfVwiPlxuICAgIDxkaXYgY2xhc3M9XCIke3YubG9hZGluZ1Byb2dyZXNzQmFyV3JhcHBlcn1cIj5cbiAgICAgIDxkaXYgY2xhc3M9XCIke3YubG9hZGluZ1Byb2dyZXNzQmFyfVwiPjwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjxwIGNsYXNzPVwiJHt2LmxvYWRpbmdNZXNzYWdlfVwiPiR7YX08L3A+XG5gIDogXCJcIn1cbiR7bC5lbmFibGUgPyB0VChsLCByLCBwKSA6IFwiXCJ9XG4gIGAsIHJvd3M6IFQsIGNvbHVtbjogeSB9O1xufSwgaFQgPSAoeyByb3dzOiBzLCBmaWVsZDogdCwgb3JkZXI6IGUgfSkgPT4gcy5zb3J0KChuLCBvKSA9PiB7XG4gIGxldCByID0gblt0XSwgYSA9IG9bdF07XG4gIHJldHVybiB0eXBlb2YgciA9PSBcInN0cmluZ1wiICYmIChyID0gci50b0xvd2VyQ2FzZSgpKSwgdHlwZW9mIGEgPT0gXCJzdHJpbmdcIiAmJiAoYSA9IGEudG9Mb3dlckNhc2UoKSksIHIgPCBhID8gZSA9PT0gXCJkZXNjXCIgPyAxIDogLTEgOiByID4gYSA/IGUgPT09IFwiZGVzY1wiID8gLTEgOiAxIDogMDtcbn0pLCBkVCA9IChzLCB0LCBlKSA9PiB7XG4gIGlmICghdClcbiAgICByZXR1cm4gcztcbiAgY29uc3QgaSA9IChuKSA9PiB7XG4gICAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcmV0dXJuIG8uaW5uZXJIVE1MID0gbiwgbiA9IG8udGV4dENvbnRlbnQgfHwgby5pbm5lclRleHQgfHwgXCJcIiwgbi50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkubWF0Y2godC50b0xvd2VyQ2FzZSgpKTtcbiAgfTtcbiAgcmV0dXJuIHMuZmlsdGVyKChuKSA9PiB7XG4gICAgaWYgKGUgJiYgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBpKG5bZV0pO1xuICAgIGxldCBvID0gT2JqZWN0LnZhbHVlcyhuKTtcbiAgICByZXR1cm4gZSAmJiBBcnJheS5pc0FycmF5KGUpICYmIChvID0gT2JqZWN0LmtleXMobikuZmlsdGVyKChyKSA9PiBlLmluY2x1ZGVzKHIpKS5tYXAoKHIpID0+IG5bcl0pKSwgby5maWx0ZXIoKHIpID0+IGkocikpLmxlbmd0aCA+IDA7XG4gIH0pO1xufSwgQmwgPSAoeyByb3dzOiBzLCBlbnRyaWVzOiB0LCBhY3RpdmVQYWdlOiBlIH0pID0+IHtcbiAgY29uc3QgaSA9IGUgKiB0O1xuICByZXR1cm4gcy5zbGljZShpLCBpICsgTnVtYmVyKHQpKTtcbn0sIFZpID0gXCJkYXRhdGFibGVcIiwgZ3QgPSBgZGF0YS10ZS0ke1ZpfWAsIGtpID0gYHRlLiR7Vml9YCwgQW4gPSBgLiR7a2l9YCwgdVQgPSBgWyR7Z3R9LWlubmVyLXJlZl1gLCB3byA9IGBbJHtndH0tY2VsbC1yZWZdYCwgcFQgPSBgWyR7Z3R9LWhlYWRlci1yZWZdYCwgX1QgPSBgWyR7Z3R9LWhlYWRlci1jaGVja2JveC1yZWZdYCwgZlQgPSBgWyR7Z3R9LXBhZ2luYXRpb24tcmlnaHQtcmVmXWAsIG1UID0gYFske2d0fS1wYWdpbmF0aW9uLWxlZnQtcmVmXWAsIGdUID0gYFske2d0fS1wYWdpbmF0aW9uLXN0YXJ0LXJlZl1gLCBiVCA9IGBbJHtndH0tcGFnaW5hdGlvbi1lbmQtcmVmXWAsIHZUID0gYFske2d0fS1wYWdpbmF0aW9uLW5hdi1yZWZdYCwgVFQgPSBgWyR7Z3R9LXNlbGVjdC1yZWZdYCwga28gPSBgWyR7Z3R9LXNvcnQtaWNvbi1yZWZdYCwgVGkgPSBgWyR7Z3R9LXJvdy1yZWZdYCwgeG8gPSBgWyR7Z3R9LXJvdy1jaGVja2JveC1yZWZdYCwgRVQgPSBgc2VsZWN0Um93cyR7QW59YCwgSGwgPSBgcmVuZGVyJHtBbn1gLCBDVCA9IGByb3dDbGljayR7QW59YCwgQVQgPSBgdXBkYXRlJHtBbn1gLCB5VCA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk00LjUgMTAuNUwxMiAzbTAgMGw3LjUgNy41TTEyIDN2MThcIiAvPlxuPC9zdmc+YCwgd1QgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTguNzUgMTkuNWwtNy41LTcuNSA3LjUtNy41bS02IDE1TDUuMjUgMTJsNy41LTcuNVwiIC8+XG48L3N2Zz5gLCBrVCA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xNS43NSAxOS41TDguMjUgMTJsNy41LTcuNVwiIC8+XG48L3N2Zz5gLCB4VCA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk04LjI1IDQuNWw3LjUgNy41LTcuNSA3LjVcIiAvPlxuPC9zdmc+YCwgT1QgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTEuMjUgNC41bDcuNSA3LjUtNy41IDcuNW0tNi0xNWw3LjUgNy41LTcuNSA3LjVcIi8+XG48L3N2Zz5gLCBTVCA9IFwiYm9yZGVyLW5ldXRyYWwtMjAwIGRhcms6Ym9yZGVyLW5ldXRyYWwtNTAwXCIsIElUID0gXCJib3JkZXItbm9uZVwiLCBEVCA9IFwicmVsYXRpdmUgZmxvYXQtbGVmdCAtbWwtWzEuNXJlbV0gbXItWzZweF0gbXQtWzAuMTVyZW1dIGgtWzEuMTI1cmVtXSB3LVsxLjEyNXJlbV0gYXBwZWFyYW5jZS1ub25lIHJvdW5kZWQtWzAuMjVyZW1dIGJvcmRlci1bMC4xMjVyZW1dIGJvcmRlci1zb2xpZCBib3JkZXItbmV1dHJhbC0zMDAgb3V0bGluZS1ub25lIGJlZm9yZTpwb2ludGVyLWV2ZW50cy1ub25lIGJlZm9yZTphYnNvbHV0ZSBiZWZvcmU6aC1bMC44NzVyZW1dIGJlZm9yZTp3LVswLjg3NXJlbV0gYmVmb3JlOnNjYWxlLTAgYmVmb3JlOnJvdW5kZWQtZnVsbCBiZWZvcmU6YmctdHJhbnNwYXJlbnQgYmVmb3JlOm9wYWNpdHktMCBiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3RyYW5zcGFyZW50XSBiZWZvcmU6Y29udGVudC1bJyddIGNoZWNrZWQ6Ym9yZGVyLXByaW1hcnkgY2hlY2tlZDpiZy1wcmltYXJ5IGNoZWNrZWQ6YmVmb3JlOm9wYWNpdHktWzAuMTZdIGNoZWNrZWQ6YWZ0ZXI6YWJzb2x1dGUgY2hlY2tlZDphZnRlcjotbXQtcHggY2hlY2tlZDphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDphZnRlcjpibG9jayBjaGVja2VkOmFmdGVyOmgtWzAuODEyNXJlbV0gY2hlY2tlZDphZnRlcjp3LVswLjM3NXJlbV0gY2hlY2tlZDphZnRlcjpyb3RhdGUtNDUgY2hlY2tlZDphZnRlcjpib3JkZXItWzAuMTI1cmVtXSBjaGVja2VkOmFmdGVyOmJvcmRlci1sLTAgY2hlY2tlZDphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXNvbGlkIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXdoaXRlIGNoZWNrZWQ6YWZ0ZXI6YmctdHJhbnNwYXJlbnQgY2hlY2tlZDphZnRlcjpjb250ZW50LVsnJ10gaG92ZXI6Y3Vyc29yLXBvaW50ZXIgaG92ZXI6YmVmb3JlOm9wYWNpdHktWzAuMDRdIGhvdmVyOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgwLDAsMCwwLjYpXSBmb2N1czpzaGFkb3ctbm9uZSBmb2N1czp0cmFuc2l0aW9uLVtib3JkZXItY29sb3JfMC4yc10gZm9jdXM6YmVmb3JlOnNjYWxlLTEwMCBmb2N1czpiZWZvcmU6b3BhY2l0eS1bMC4xMl0gZm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDAsMCwwLDAuNildIGZvY3VzOmJlZm9yZTp0cmFuc2l0aW9uLVtib3gtc2hhZG93XzAuMnMsdHJhbnNmb3JtXzAuMnNdIGZvY3VzOmFmdGVyOmFic29sdXRlIGZvY3VzOmFmdGVyOnotWzFdIGZvY3VzOmFmdGVyOmJsb2NrIGZvY3VzOmFmdGVyOmgtWzAuODc1cmVtXSBmb2N1czphZnRlcjp3LVswLjg3NXJlbV0gZm9jdXM6YWZ0ZXI6cm91bmRlZC1bMC4xMjVyZW1dIGZvY3VzOmFmdGVyOmNvbnRlbnQtWycnXSBjaGVja2VkOmZvY3VzOmJlZm9yZTpzY2FsZS0xMDAgY2hlY2tlZDpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4XyMzYjcxY2FdIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnRyYW5zaXRpb24tW2JveC1zaGFkb3dfMC4ycyx0cmFuc2Zvcm1fMC4yc10gY2hlY2tlZDpmb2N1czphZnRlcjotbXQtcHggY2hlY2tlZDpmb2N1czphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpoLVswLjgxMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6dy1bMC4zNzVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm90YXRlLTQ1IGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm91bmRlZC1ub25lIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLVswLjEyNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItbC0wIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXQtMCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1zb2xpZCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci13aGl0ZSBjaGVja2VkOmZvY3VzOmFmdGVyOmJnLXRyYW5zcGFyZW50IGRhcms6Ym9yZGVyLW5ldXRyYWwtNjAwIGRhcms6Y2hlY2tlZDpib3JkZXItcHJpbWFyeSBkYXJrOmNoZWNrZWQ6YmctcHJpbWFyeSBkYXJrOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgyNTUsMjU1LDI1NSwwLjQpXSBkYXJrOmNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBkYXJrOmJvcmRlci1uZXV0cmFsLTQwMFwiLCAkVCA9IFwibWItWzAuMTI1cmVtXSBtaW4taC1bMS41cmVtXSBwbC1bMS41cmVtXSBtbC0zIGZsZXggaXRlbXMtY2VudGVyXCIsIExUID0gXCJyZWxhdGl2ZSBmbG9hdC1sZWZ0IC1tbC1bMS41cmVtXSBtci1bNnB4XSBtdC1bMC4xNXJlbV0gaC1bMS4xMjVyZW1dIHctWzEuMTI1cmVtXSBhcHBlYXJhbmNlLW5vbmUgcm91bmRlZC1bMC4yNXJlbV0gYm9yZGVyLVswLjEyNXJlbV0gYm9yZGVyLXNvbGlkIGJvcmRlci1uZXV0cmFsLTMwMCBvdXRsaW5lLW5vbmUgYmVmb3JlOnBvaW50ZXItZXZlbnRzLW5vbmUgYmVmb3JlOmFic29sdXRlIGJlZm9yZTpoLVswLjg3NXJlbV0gYmVmb3JlOnctWzAuODc1cmVtXSBiZWZvcmU6c2NhbGUtMCBiZWZvcmU6cm91bmRlZC1mdWxsIGJlZm9yZTpiZy10cmFuc3BhcmVudCBiZWZvcmU6b3BhY2l0eS0wIGJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfdHJhbnNwYXJlbnRdIGJlZm9yZTpjb250ZW50LVsnJ10gY2hlY2tlZDpib3JkZXItcHJpbWFyeSBjaGVja2VkOmJnLXByaW1hcnkgY2hlY2tlZDpiZWZvcmU6b3BhY2l0eS1bMC4xNl0gY2hlY2tlZDphZnRlcjphYnNvbHV0ZSBjaGVja2VkOmFmdGVyOi1tdC1weCBjaGVja2VkOmFmdGVyOm1sLVswLjI1cmVtXSBjaGVja2VkOmFmdGVyOmJsb2NrIGNoZWNrZWQ6YWZ0ZXI6aC1bMC44MTI1cmVtXSBjaGVja2VkOmFmdGVyOnctWzAuMzc1cmVtXSBjaGVja2VkOmFmdGVyOnJvdGF0ZS00NSBjaGVja2VkOmFmdGVyOmJvcmRlci1bMC4xMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLWwtMCBjaGVja2VkOmFmdGVyOmJvcmRlci10LTAgY2hlY2tlZDphZnRlcjpib3JkZXItc29saWQgY2hlY2tlZDphZnRlcjpib3JkZXItd2hpdGUgY2hlY2tlZDphZnRlcjpiZy10cmFuc3BhcmVudCBjaGVja2VkOmFmdGVyOmNvbnRlbnQtWycnXSBob3ZlcjpjdXJzb3ItcG9pbnRlciBob3ZlcjpiZWZvcmU6b3BhY2l0eS1bMC4wNF0gaG92ZXI6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDAsMCwwLDAuNildIGZvY3VzOnNoYWRvdy1ub25lIGZvY3VzOnRyYW5zaXRpb24tW2JvcmRlci1jb2xvcl8wLjJzXSBmb2N1czpiZWZvcmU6c2NhbGUtMTAwIGZvY3VzOmJlZm9yZTpvcGFjaXR5LVswLjEyXSBmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMCwwLDAsMC42KV0gZm9jdXM6YmVmb3JlOnRyYW5zaXRpb24tW2JveC1zaGFkb3dfMC4ycyx0cmFuc2Zvcm1fMC4yc10gZm9jdXM6YWZ0ZXI6YWJzb2x1dGUgZm9jdXM6YWZ0ZXI6ei1bMV0gZm9jdXM6YWZ0ZXI6YmxvY2sgZm9jdXM6YWZ0ZXI6aC1bMC44NzVyZW1dIGZvY3VzOmFmdGVyOnctWzAuODc1cmVtXSBmb2N1czphZnRlcjpyb3VuZGVkLVswLjEyNXJlbV0gZm9jdXM6YWZ0ZXI6Y29udGVudC1bJyddIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNjYWxlLTEwMCBjaGVja2VkOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfIzNiNzFjYV0gY2hlY2tlZDpmb2N1czpiZWZvcmU6dHJhbnNpdGlvbi1bYm94LXNoYWRvd18wLjJzLHRyYW5zZm9ybV8wLjJzXSBjaGVja2VkOmZvY3VzOmFmdGVyOi1tdC1weCBjaGVja2VkOmZvY3VzOmFmdGVyOm1sLVswLjI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOmgtWzAuODEyNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjp3LVswLjM3NXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpyb3RhdGUtNDUgY2hlY2tlZDpmb2N1czphZnRlcjpyb3VuZGVkLW5vbmUgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItWzAuMTI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1sLTAgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXNvbGlkIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXdoaXRlIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpib3JkZXItbmV1dHJhbC02MDAgZGFyazpjaGVja2VkOmJvcmRlci1wcmltYXJ5IGRhcms6Y2hlY2tlZDpiZy1wcmltYXJ5IGRhcms6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDI1NSwyNTUsMjU1LDAuNCldIGRhcms6Y2hlY2tlZDpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4XyMzYjcxY2FdIGRhcms6Ym9yZGVyLW5ldXRyYWwtNDAwXCIsIE5UID0gXCJtYi1bMC4xMjVyZW1dIG1pbi1oLVsxLjVyZW1dIHBsLVsxLjVyZW1dIG1sLTMgZmxleCBpdGVtcy1jZW50ZXJcIiwgTVQgPSBcImJnLXdoaXRlIGRhcms6YmctbmV1dHJhbC04MDBcIiwgUlQgPSBcInB5LTQgcGwtMSB0ZXh0LWNsaXAgb3ZlcmZsb3ctaGlkZGVuIHRleHQtWyMyMTI1MjldIGRhcms6dGV4dC13aGl0ZVwiLCBQVCA9IFwiZm9jdXM6b3V0bGluZS1ub25lXCIsIEJUID0gXCJzdGlja3kgdG9wLTAgei0zMFwiLCBIVCA9IFwic3RpY2t5IHotMTAgYmctaW5oZXJpdFwiLCBWVCA9IFwiaG92ZXI6YmctbmV1dHJhbC0xMDAgZGFyazpob3ZlcjpiZy1uZXV0cmFsLTcwMFwiLCBXVCA9IFwicG9pbnRlci1ldmVudHMtbm9uZSBjdXJzb3Itbm9uZSB0ZXh0LW5ldXRyYWwtNDAwIGRhcms6dGV4dC1uZXV0cmFsLTMwMFwiLCBGVCA9IFwiaC1bMnB4XSByZWxhdGl2ZSB3LWZ1bGwgb3ZlcmZsb3ctaGlkZGVuXCIsIFlUID0gXCJ0ZXh0LWNlbnRlciB0ZXh0LW5ldXRyYWwtNTAwIGZvbnQtbGlnaCB0ZXh0LXNtIG15LTQgZGFyazp0ZXh0LW5ldXRyYWwtNDAwXCIsIGpUID0gXCJ0ZXh0LW5ldXRyYWwtNTAwIGRhcms6dGV4dC1uZXV0cmFsLTMwMFwiLCBLVCA9IFwidGV4dC1uZXV0cmFsLTUwMCBkYXJrOnRleHQtbmV1dHJhbC0zMDBcIiwgelQgPSBcInBvaW50ZXItZXZlbnRzLW5vbmUgY3Vyc29yLW5vbmVcIiwgVVQgPSBcImgtZnVsbCB3LVs0NSVdIGJnLXByaW1hcnktNDAwIGRhcms6YmctcHJpbWFyeS02MDBcIiwgWFQgPSBcImgtZnVsbCBhbmltYXRlLVtwcm9ncmVzc18zc19lYXNlLWluLW91dF9pbmZpbml0ZV1cIiwgR1QgPSBcInBsLTIgcHktMyBmb250LWxpZ2h0IHRleHQtc20gZGFyazp0ZXh0LW5ldXRyYWwtMzAwXCIsIHFUID0gXCJib3JkZXItYlwiLCBaVCA9IFwiZmxleCBtZDpmbGV4LXJvdyBqdXN0aWZ5LWVuZCBpdGVtcy1jZW50ZXIgcHktMiBzcGFjZS14LTQgdGV4dC1zbSBmbGV4LWNvbCBsZWFkaW5nLVsxLjZdXCIsIFFUID0gXCJib3JkZXIgYm9yZGVyLXQtMFwiLCBKVCA9IFwib3JkZXItMSBteS0zIG1kOm9yZGVyLW5vbmUgbWQ6bXktMCBtZDpwci0xXCIsIHRFID0gXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBwLTIuNSB0ZXh0LXhzIGZvbnQtbWVkaXVtIHVwcGVyY2FzZSBsZWFkaW5nLW5vcm1hbCB0cmFuc2l0aW9uIGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBob3ZlcjpiZy1uZXV0cmFsLTEwMCBob3Zlcjp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMCBhY3RpdmU6dGV4dC1wcmltYXJ5LTcwMCBkaXNhYmxlZDp0ZXh0LXNsYXRlLTMwMCBkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmhvdmVyOmJnLW5ldXRyYWwtNTAwIGRhcms6ZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpkaXNhYmxlZDp0ZXh0LW5ldXRyYWwtNjAwXCIsIGVFID0gXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBwLTIuNSBmb250LW1lZGl1bSB1cHBlcmNhc2UgbGVhZGluZy1ub3JtYWwgdHJhbnNpdGlvbiBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgaG92ZXI6YmctbmV1dHJhbC0xMDAgaG92ZXI6dGV4dC1wcmltYXJ5LTYwMCBmb2N1czp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTAgYWN0aXZlOnRleHQtcHJpbWFyeS03MDAgZGlzYWJsZWQ6dGV4dC1zbGF0ZS0zMDAgZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpob3ZlcjpiZy1uZXV0cmFsLTUwMCBkYXJrOmRpc2FibGVkOmhvdmVyOmJnLXRyYW5zcGFyZW50IGRhcms6ZGlzYWJsZWQ6dGV4dC1uZXV0cmFsLTYwMFwiLCBpRSA9IFwiZm9udC1ub3JtYWwgb3JkZXItMiBtYi0zIG1kOm9yZGVyLW5vbmUgbWQ6bWItMFwiLCBzRSA9IFwiaW5saW5lLWJsb2NrIHJvdW5kZWQgcC0yLjUgZm9udC1tZWRpdW0gdXBwZXJjYXNlIGxlYWRpbmctbm9ybWFsIHRyYW5zaXRpb24gZHVyYXRpb24tMTUwIGVhc2UtaW4tb3V0IGhvdmVyOmJnLW5ldXRyYWwtMTAwIGhvdmVyOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6dGV4dC1wcmltYXJ5LTYwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0wIGFjdGl2ZTp0ZXh0LXByaW1hcnktNzAwIGRpc2FibGVkOnRleHQtc2xhdGUtMzAwIGRpc2FibGVkOmhvdmVyOmJnLXRyYW5zcGFyZW50IGRhcms6aG92ZXI6YmctbmV1dHJhbC01MDAgZGFyazpkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmRpc2FibGVkOnRleHQtbmV1dHJhbC02MDBcIiwgbkUgPSBcImZvbnQtbGlnaHRcIiwgb0UgPSBcImlubGluZS1ibG9jayByb3VuZGVkIHAtMi41IGZvbnQtbWVkaXVtIHVwcGVyY2FzZSBsZWFkaW5nLW5vcm1hbCB0cmFuc2l0aW9uIGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBob3ZlcjpiZy1uZXV0cmFsLTEwMCBob3Zlcjp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMCBhY3RpdmU6dGV4dC1wcmltYXJ5LTcwMCBkaXNhYmxlZDp0ZXh0LXNsYXRlLTMwMCBkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmhvdmVyOmJnLW5ldXRyYWwtNTAwIGRhcms6ZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpkaXNhYmxlZDp0ZXh0LW5ldXRyYWwtNjAwXCIsIHJFID0gXCJib3JkZXItYlwiLCBhRSA9IFwidHJhbnNpdGlvbiBlYXNlLWluLW91dCBkdXJhdGlvbi0zMDAgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIiwgbEUgPSBcIndoaXRlc3BhY2Utbm93cmFwIHRleHQtY2xpcCBvdmVyZmxvdy1hdXRvIHB4LVsxLjRyZW1dIHB5LTRcIiwgY0UgPSBcInJlbGF0aXZlXCIsIGhFID0gXCIhYmctbmV1dHJhbC0xMDAgZGFyazohYmctbmV1dHJhbC02MDBcIiwgZEUgPSBcImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtNCBvcmRlci0zIG1kOm9yZGVyLW5vbmVcIiwgdUUgPSBcInctWzcwcHhdXCIsIHBFID0gXCIhcHktMlwiLCBfRSA9IFwidy1bMTVweF0gaC1bMTBweF0gb3JpZ2luLWJvdHRvbSBmb250LWJsYWNrIG1yLTEgb3BhY2l0eS0wIHRleHQtbmV1dHJhbC01MDAgZ3JvdXAtaG92ZXI6b3BhY2l0eS0xMDAgdHJhbnNpdGlvbiBob3ZlcjplYXNlLWluLW91dCB0cmFuc2Zvcm0gZWFzZS1saW5lYXIgZHVyYXRpb24tMzAwIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhcms6dGV4dC1uZXV0cmFsLTQwMFwiLCBmRSA9IFwiZmxleCBmbGV4LXJvdyBncm91cFwiLCBtRSA9IFwiWyY6bnRoLWNoaWxkKG9kZCldOmJnLW5ldXRyYWwtNTAgWyY6bnRoLWNoaWxkKG9kZCldOmRhcms6YmctbmV1dHJhbC03MDBcIiwgZ0UgPSBcImJvcmRlclwiLCBiRSA9IFwiYm9yZGVyLWIgZm9udC1ub3JtYWwgcHgtWzEuNHJlbV1cIiwgdkUgPSBcInRleHQtbGVmdCB0ZXh0LXNtIGZvbnQtbGlnaHQgdy1mdWxsIGxlYWRpbmctWzEuNl1cIiwgVEUgPSB7XG4gIGJvcmRlcmVkOiBcImJvb2xlYW5cIixcbiAgYm9yZGVybGVzczogXCJib29sZWFuXCIsXG4gIGNsaWNrYWJsZVJvd3M6IFwiYm9vbGVhblwiLFxuICBkZWZhdWx0VmFsdWU6IFwic3RyaW5nXCIsXG4gIGVkaXQ6IFwiYm9vbGVhblwiLFxuICBlbnRyaWVzOiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBlbnRyaWVzT3B0aW9uczogXCJhcnJheVwiLFxuICBmdWxsUGFnaW5hdGlvbjogXCJib29sZWFuXCIsXG4gIGhvdmVyOiBcImJvb2xlYW5cIixcbiAgbG9hZGluZzogXCJib29sZWFuXCIsXG4gIGxvYWRpbmdNZXNzYWdlOiBcInN0cmluZ1wiLFxuICBtYXhXaWR0aDogXCIobnVsbHxudW1iZXJ8c3RyaW5nKVwiLFxuICBtYXhIZWlnaHQ6IFwiKG51bGx8bnVtYmVyfHN0cmluZylcIixcbiAgbXVsdGk6IFwiYm9vbGVhblwiLFxuICBub0ZvdW5kTWVzc2FnZTogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbjogXCJib29sZWFuXCIsXG4gIHNlbGVjdGFibGU6IFwiYm9vbGVhblwiLFxuICBzbTogXCJib29sZWFuXCIsXG4gIHNvcnRGaWVsZDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIHNvcnRPcmRlcjogXCJzdHJpbmdcIixcbiAgZml4ZWRIZWFkZXI6IFwiYm9vbGVhblwiLFxuICBzdHJpcGVkOiBcImJvb2xlYW5cIixcbiAgcm93c1RleHQ6IFwic3RyaW5nXCIsXG4gIG9mVGV4dDogXCJzdHJpbmdcIixcbiAgYWxsVGV4dDogXCJzdHJpbmdcIixcbiAgZm9yY2VTb3J0OiBcImJvb2xlYW5cIixcbiAgc29ydEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvblN0YXJ0SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uRW5kSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uTGVmdEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvblJpZ2h0SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiXG59LCBFRSA9IHtcbiAgYm9yZGVyZWQ6ICExLFxuICBib3JkZXJsZXNzOiAhMSxcbiAgY2xpY2thYmxlUm93czogITEsXG4gIGRlZmF1bHRWYWx1ZTogXCItXCIsXG4gIGVkaXQ6ICExLFxuICBlbnRyaWVzOiAxMCxcbiAgZW50cmllc09wdGlvbnM6IFsxMCwgMjUsIDUwLCAyMDBdLFxuICBmaXhlZEhlYWRlcjogITEsXG4gIGZ1bGxQYWdpbmF0aW9uOiAhMSxcbiAgaG92ZXI6ICExLFxuICBsb2FkaW5nOiAhMSxcbiAgbG9hZGluZ01lc3NhZ2U6IFwiTG9hZGluZyByZXN1bHRzLi4uXCIsXG4gIG1heFdpZHRoOiBudWxsLFxuICBtYXhIZWlnaHQ6IG51bGwsXG4gIG11bHRpOiAhMSxcbiAgbm9Gb3VuZE1lc3NhZ2U6IFwiTm8gbWF0Y2hpbmcgcmVzdWx0cyBmb3VuZFwiLFxuICBwYWdpbmF0aW9uOiAhMCxcbiAgc2VsZWN0YWJsZTogITEsXG4gIHNtOiAhMSxcbiAgc29ydEZpZWxkOiBudWxsLFxuICBzb3J0T3JkZXI6IFwiYXNjXCIsXG4gIHN0cmlwZWQ6ICExLFxuICByb3dzVGV4dDogXCJSb3dzIHBlciBwYWdlOlwiLFxuICBvZlRleHQ6IFwib2ZcIixcbiAgYWxsVGV4dDogXCJBbGxcIixcbiAgZm9yY2VTb3J0OiAhMSxcbiAgc29ydEljb25UZW1wbGF0ZTogeVQsXG4gIHBhZ2luYXRpb25TdGFydEljb25UZW1wbGF0ZTogd1QsXG4gIHBhZ2luYXRpb25FbmRJY29uVGVtcGxhdGU6IE9ULFxuICBwYWdpbmF0aW9uTGVmdEljb25UZW1wbGF0ZToga1QsXG4gIHBhZ2luYXRpb25SaWdodEljb25UZW1wbGF0ZTogeFRcbn0sIENFID0ge1xuICBsYWJlbDogXCJzdHJpbmdcIixcbiAgZmllbGQ6IFwic3RyaW5nXCIsXG4gIGZpeGVkOiBcIihib29sZWFufHN0cmluZylcIixcbiAgZm9ybWF0OiBcIihmdW5jdGlvbnxudWxsKVwiLFxuICB3aWR0aDogXCIobnVtYmVyfG51bGwpXCIsXG4gIHNvcnQ6IFwiYm9vbGVhblwiLFxuICBjb2x1bW5JbmRleDogXCJudW1iZXJcIlxufSwgQUUgPSB7XG4gIGxhYmVsOiBcIlwiLFxuICBmaWVsZDogXCJcIixcbiAgZml4ZWQ6ICExLFxuICBmb3JtYXQ6IG51bGwsXG4gIHdpZHRoOiBudWxsLFxuICBzb3J0OiAhMCxcbiAgY29sdW1uSW5kZXg6IDBcbn0sIHlFID0ge1xuICB0YWJsZTogdkUsXG4gIHRhYmxlSGVhZGVyOiBiRSxcbiAgY29sdW1uOiBSVCxcbiAgcGFnaW5hdGlvbjogWlQsXG4gIHNlbGVjdFdyYXBwZXI6IHVFLFxuICBzY3JvbGw6IGNFLFxuICB0YWJsZUJvcmRlcmVkOiBnRSxcbiAgcGFnaW5hdGlvbkJvcmRlcmVkOiBRVCxcbiAgYm9yZGVybGVzczogSVQsXG4gIGNoZWNrYm94Um93V3JhcHBlcjogTlQsXG4gIGNoZWNrYm94Um93OiBMVCxcbiAgY2hlY2tib3hIZWFkZXJXcmFwcGVyOiAkVCxcbiAgY2hlY2tib3hIZWFkZXI6IERULFxuICByb3c6IHJFLFxuICByb3dJdGVtOiBsRSxcbiAgc3RyaXBlZDogbUUsXG4gIHNvcnRJY29uV3JhcHBlcjogZkUsXG4gIHNvcnRJY29uOiBfRSxcbiAgcGFnaW5hdGlvblJvd3NUZXh0OiBuRSxcbiAgcGFnaW5hdGlvbk5hdjogaUUsXG4gIHBhZ2luYXRpb25CdXR0b25zV3JhcHBlcjogSlQsXG4gIGhvdmVyUm93OiBWVCxcbiAgYm9yZGVyQ29sb3I6IFNULFxuICBjb2xvcjogTVQsXG4gIGZpeGVkSGVhZGVyOiBCVCxcbiAgZml4ZWRIZWFkZXJCb2R5OiBIVCxcbiAgc2VsZWN0YWJsZVJvdzogaEUsXG4gIHJvd0FuaW1hdGlvbjogYUUsXG4gIHNtOiBwRSxcbiAgZWRpdDogUFQsXG4gIHNlbGVjdEl0ZW1zV3JhcHBlcjogZEUsXG4gIHBhZ2luYXRpb25TdGFydEJ1dHRvbjogb0UsXG4gIHBhZ2luYXRpb25MZWZ0QnV0dG9uOiBlRSxcbiAgcGFnaW5hdGlvblJpZ2h0QnV0dG9uOiBzRSxcbiAgcGFnaW5hdGlvbkVuZEJ1dHRvbjogdEUsXG4gIGxvYWRpbmdJdGVtc1dyYXBwZXI6IEZULFxuICBsb2FkaW5nUHJvZ3Jlc3NCYXJXcmFwcGVyOiBYVCxcbiAgbG9hZGluZ1Byb2dyZXNzQmFyOiBVVCxcbiAgbG9hZGluZ01lc3NhZ2U6IFlULFxuICBsb2FkaW5nUGFnaW5hdGlvblJvd3NUZXh0OiBLVCxcbiAgbG9hZGluZ1BhZ2luYXRpb25TZWxlY3RXcmFwcGVyOiB6VCxcbiAgbG9hZGluZ1BhZ2luYXRpb25OYXY6IGpULFxuICBsb2FkaW5nQ29sdW1uOiBXVCxcbiAgbm9Gb3VuZE1lc3NhZ2VXcmFwcGVyOiBxVCxcbiAgbm9Gb3VuZE1lc3NhZ2U6IEdUXG59LCB3RSA9IHtcbiAgdGFibGU6IFwic3RyaW5nXCIsXG4gIHRhYmxlSGVhZGVyOiBcInN0cmluZ1wiLFxuICBjb2x1bW46IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb246IFwic3RyaW5nXCIsXG4gIHNlbGVjdFdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHNjcm9sbDogXCJzdHJpbmdcIixcbiAgdGFibGVCb3JkZXJlZDogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkJvcmRlcmVkOiBcInN0cmluZ1wiLFxuICBib3JkZXJsZXNzOiBcInN0cmluZ1wiLFxuICBjaGVja2JveFJvd1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGNoZWNrYm94Um93OiBcInN0cmluZ1wiLFxuICBjaGVja2JveEhlYWRlcldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGNoZWNrYm94SGVhZGVyOiBcInN0cmluZ1wiLFxuICByb3c6IFwic3RyaW5nXCIsXG4gIHJvd0l0ZW06IFwic3RyaW5nXCIsXG4gIHN0cmlwZWQ6IFwic3RyaW5nXCIsXG4gIHNvcnRJY29uV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgc29ydEljb246IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25Sb3dzVGV4dDogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbk5hdjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkJ1dHRvbnNXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBob3ZlclJvdzogXCJzdHJpbmdcIixcbiAgYm9yZGVyQ29sb3I6IFwic3RyaW5nXCIsXG4gIGNvbG9yOiBcInN0cmluZ1wiLFxuICBmaXhlZEhlYWRlcjogXCJzdHJpbmdcIixcbiAgZml4ZWRIZWFkZXJCb2R5OiBcInN0cmluZ1wiLFxuICBzZWxlY3RhYmxlUm93OiBcInN0cmluZ1wiLFxuICByb3dBbmltYXRpb246IFwic3RyaW5nXCIsXG4gIHNtOiBcInN0cmluZ1wiLFxuICBlZGl0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJdGVtc1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25TdGFydEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkxlZnRCdXR0b246IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25SaWdodEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkVuZEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ0l0ZW1zV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1Byb2dyZXNzQmFyV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1Byb2dyZXNzQmFyOiBcInN0cmluZ1wiLFxuICBsb2FkaW5nTWVzc2FnZTogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1BhZ2luYXRpb25Sb3dzVGV4dDogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1BhZ2luYXRpb25TZWxlY3RXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBsb2FkaW5nUGFnaW5hdGlvbk5hdjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ0NvbHVtbjogXCJzdHJpbmdcIixcbiAgbm9Gb3VuZE1lc3NhZ2VXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBub0ZvdW5kTWVzc2FnZTogXCJzdHJpbmdcIlxufTtcbmNsYXNzIEhoIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpID0ge30sIG4gPSB7fSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0T3B0aW9ucyhpKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMobiksIHRoaXMuX3NvcnRSZXZlcnNlID0gITEsIHRoaXMuX2FjdGl2ZVBhZ2UgPSAwLCB0aGlzLl9zZWFyY2ggPSBcIlwiLCB0aGlzLl9zZWFyY2hDb2x1bW4gPSBudWxsLCB0aGlzLl9wYWdpbmF0aW9uTGVmdCA9IG51bGwsIHRoaXMuX3BhZ2luYXRpb25SaWdodCA9IG51bGwsIHRoaXMuX3BhZ2luYXRpb25TdGFydCA9IG51bGwsIHRoaXMuX3BhZ2luYXRpb25FbmQgPSBudWxsLCB0aGlzLl9zZWxlY3QgPSBudWxsLCB0aGlzLl9zZWxlY3RJbnN0YW5jZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkID0gW10sIHRoaXMuX2NoZWNrYm94ZXMgPSBudWxsLCB0aGlzLl9oZWFkZXJDaGVja2JveCA9IG51bGwsIHRoaXMuX3Jvd3MgPSB0aGlzLl9nZXRSb3dzKGUucm93cyksIHRoaXMuX2NvbHVtbnMgPSB0aGlzLl9nZXRDb2x1bW5zKGUuY29sdW1ucyksIHRoaXMuX2VsZW1lbnQgJiYgKEEuc2V0RGF0YSh0LCBraSwgdGhpcyksIHRoaXMuX3BlcmZlY3RTY3JvbGxiYXIgPSBudWxsLCB0aGlzLl9zZXR1cCgpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gVmk7XG4gIH1cbiAgZ2V0IGNvbHVtbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbnMubWFwKCh0LCBlKSA9PiB7XG4gICAgICBsZXQgaSA9IHtcbiAgICAgICAgLi4uQUUsXG4gICAgICAgIGZpZWxkOiBgZmllbGRfJHtlfWAsXG4gICAgICAgIGNvbHVtbkluZGV4OiBlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyBpLmxhYmVsID0gdCA6IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgKGkgPSB7XG4gICAgICAgIC4uLmksXG4gICAgICAgIC4uLnRcbiAgICAgIH0pLCBJKFwiY29sdW1uXCIsIGksIENFKSwgaTtcbiAgICB9KTtcbiAgfVxuICBnZXQgcm93cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcm93cy5tYXAoKHQsIGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSB7XG4gICAgICAgIHJvd0luZGV4OiBlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyB0aGlzLmNvbHVtbnMuZm9yRWFjaCgobiwgbykgPT4ge1xuICAgICAgICB0W29dID09PSAwID8gaVtuLmZpZWxkXSA9IHRbb10gOiBpW24uZmllbGRdID0gdFtvXSB8fCB0aGlzLl9vcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH0pIDogdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0aGlzLmNvbHVtbnMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICB0W24uZmllbGRdID09PSAwID8gaVtuLmZpZWxkXSA9IHRbbi5maWVsZF0gOiBpW24uZmllbGRdID0gdFtuLmZpZWxkXSB8fCB0aGlzLl9vcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH0pLCBpO1xuICAgIH0pO1xuICB9XG4gIGdldCBzZWFyY2hSZXN1bHQoKSB7XG4gICAgcmV0dXJuIGRUKHRoaXMucm93cywgdGhpcy5fc2VhcmNoLCB0aGlzLl9zZWFyY2hDb2x1bW4pO1xuICB9XG4gIGdldCBjb21wdXRlZFJvd3MoKSB7XG4gICAgbGV0IHQgPSBbLi4udGhpcy5zZWFyY2hSZXN1bHRdO1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciAmJiAodCA9IGhUKHtcbiAgICAgIHJvd3M6IHQsXG4gICAgICBmaWVsZDogdGhpcy5fb3B0aW9ucy5zb3J0RmllbGQsXG4gICAgICBvcmRlcjogdGhpcy5fb3B0aW9ucy5zb3J0T3JkZXJcbiAgICB9KSksIHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbiAmJiAodGhpcy5fb3B0aW9ucy5lbnRyaWVzID09PSBcIkFsbFwiID8gdCA9IEJsKHtcbiAgICAgIHJvd3M6IHQsXG4gICAgICBlbnRyaWVzOiB0Lmxlbmd0aCxcbiAgICAgIGFjdGl2ZVBhZ2U6IHRoaXMuX2FjdGl2ZVBhZ2VcbiAgICB9KSA6IHQgPSBCbCh7XG4gICAgICByb3dzOiB0LFxuICAgICAgZW50cmllczogdGhpcy5fb3B0aW9ucy5lbnRyaWVzLFxuICAgICAgYWN0aXZlUGFnZTogdGhpcy5fYWN0aXZlUGFnZVxuICAgIH0pKSwgdDtcbiAgfVxuICBnZXQgcGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZW50cmllcyA9PT0gXCJBbGxcIiA/IDEgOiBNYXRoLmNlaWwodGhpcy5zZWFyY2hSZXN1bHQubGVuZ3RoIC8gdGhpcy5fb3B0aW9ucy5lbnRyaWVzKTtcbiAgfVxuICBnZXQgbmF2aWdhdGlvblRleHQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2FjdGl2ZVBhZ2UgKiB0aGlzLl9vcHRpb25zLmVudHJpZXM7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoUmVzdWx0Lmxlbmd0aCA9PT0gMCA/IGAwICR7dGhpcy5fb3B0aW9ucy5vZlRleHR9IDBgIDogdGhpcy5fb3B0aW9ucy5lbnRyaWVzID09PSBcIkFsbFwiID8gYDEgLSAke3RoaXMuc2VhcmNoUmVzdWx0Lmxlbmd0aH0gJHt0aGlzLl9vcHRpb25zLm9mVGV4dH0gJHt0aGlzLnNlYXJjaFJlc3VsdC5sZW5ndGh9YCA6IGAke3QgKyAxfSAtICR7dGhpcy5jb21wdXRlZFJvd3MubGVuZ3RoICsgdH0gJHt0aGlzLl9vcHRpb25zLm9mVGV4dH0gJHt0aGlzLnNlYXJjaFJlc3VsdC5sZW5ndGh9YDtcbiAgfVxuICBnZXQgdGFibGVPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB0aGlzLl9jbGFzc2VzLFxuICAgICAgY29sdW1uczogdGhpcy5jb2x1bW5zLFxuICAgICAgcm93czogdGhpcy5jb21wdXRlZFJvd3MsXG4gICAgICBub0ZvdW5kTWVzc2FnZTogdGhpcy5fb3B0aW9ucy5ub0ZvdW5kTWVzc2FnZSxcbiAgICAgIGVkaXQ6IHRoaXMuX29wdGlvbnMuZWRpdCxcbiAgICAgIGxvYWRpbmc6IHRoaXMuX29wdGlvbnMubG9hZGluZyxcbiAgICAgIGxvYWRlckNsYXNzOiB0aGlzLl9vcHRpb25zLmxvYWRlckNsYXNzLFxuICAgICAgbG9hZGluZ01lc3NhZ2U6IHRoaXMuX29wdGlvbnMubG9hZGluZ01lc3NhZ2UsXG4gICAgICBzZWxlY3RhYmxlOiB0aGlzLl9vcHRpb25zLnNlbGVjdGFibGUsXG4gICAgICBtdWx0aTogdGhpcy5fb3B0aW9ucy5tdWx0aSxcbiAgICAgIGJvcmRlcmVkOiB0aGlzLl9vcHRpb25zLmJvcmRlcmVkLFxuICAgICAgYm9yZGVybGVzczogdGhpcy5fb3B0aW9ucy5ib3JkZXJsZXNzLFxuICAgICAgc3RyaXBlZDogdGhpcy5fb3B0aW9ucy5zdHJpcGVkLFxuICAgICAgaG92ZXI6IHRoaXMuX29wdGlvbnMuaG92ZXIsXG4gICAgICBmaXhlZEhlYWRlcjogdGhpcy5fb3B0aW9ucy5maXhlZEhlYWRlcixcbiAgICAgIHNtOiB0aGlzLl9vcHRpb25zLnNtLFxuICAgICAgc29ydEljb25UZW1wbGF0ZTogdGhpcy5fb3B0aW9ucy5zb3J0SWNvblRlbXBsYXRlLFxuICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICBlbmFibGU6IHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbixcbiAgICAgICAgdGV4dDogdGhpcy5uYXZpZ2F0aW9uVGV4dCxcbiAgICAgICAgZW50cmllczogdGhpcy5fb3B0aW9ucy5lbnRyaWVzLFxuICAgICAgICBlbnRyaWVzT3B0aW9uczogdGhpcy5fb3B0aW9ucy5lbnRyaWVzT3B0aW9ucyxcbiAgICAgICAgZnVsbFBhZ2luYXRpb246IHRoaXMuX29wdGlvbnMuZnVsbFBhZ2luYXRpb24sXG4gICAgICAgIHJvd3NUZXh0OiB0aGlzLl9vcHRpb25zLnJvd3NUZXh0LFxuICAgICAgICBvZlRleHQ6IHRoaXMuX29wdGlvbnMub2ZUZXh0LFxuICAgICAgICBhbGxUZXh0OiB0aGlzLl9vcHRpb25zLmFsbFRleHQsXG4gICAgICAgIHBhZ2luYXRpb25TdGFydEljb25UZW1wbGF0ZTogdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uU3RhcnRJY29uVGVtcGxhdGUsXG4gICAgICAgIHBhZ2luYXRpb25MZWZ0SWNvblRlbXBsYXRlOiB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb25MZWZ0SWNvblRlbXBsYXRlLFxuICAgICAgICBwYWdpbmF0aW9uUmlnaHRJY29uVGVtcGxhdGU6IHRoaXMuX29wdGlvbnMucGFnaW5hdGlvblJpZ2h0SWNvblRlbXBsYXRlLFxuICAgICAgICBwYWdpbmF0aW9uRW5kSWNvblRlbXBsYXRlOiB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb25FbmRJY29uVGVtcGxhdGUsXG4gICAgICAgIGNsYXNzZXM6IHRoaXMuX2NsYXNzZXNcbiAgICAgIH0sXG4gICAgICBmb3JjZVNvcnQ6IHRoaXMuX29wdGlvbnMuZm9yY2VTb3J0XG4gICAgfTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdXBkYXRlKHQsIGUgPSB7fSkge1xuICAgIHQgJiYgdC5yb3dzICYmICh0aGlzLl9yb3dzID0gdC5yb3dzKSwgdCAmJiB0LmNvbHVtbnMgJiYgKHRoaXMuX2NvbHVtbnMgPSB0LmNvbHVtbnMpLCB0aGlzLl9jbGVhckNsYXNzTGlzdChlKSwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnMoeyAuLi50aGlzLl9vcHRpb25zLCAuLi5lIH0pLCB0aGlzLl9zZXR1cCgpLCB0aGlzLl9wZXJmb3JtU29ydCgpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fc2VsZWN0SW5zdGFuY2UgJiYgdGhpcy5fc2VsZWN0SW5zdGFuY2UuZGlzcG9zZSgpLCBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwga2kpLCB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpLCB0aGlzLl9wZXJmZWN0U2Nyb2xsYmFyLmRlc3Ryb3koKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgc2VhcmNoKHQsIGUpIHtcbiAgICB0aGlzLl9zZWFyY2ggPSB0LCB0aGlzLl9zZWFyY2hDb2x1bW4gPSBlLCB0aGlzLl9hY3RpdmVQYWdlID0gMCwgdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX3RvZ2dsZURpc2FibGVTdGF0ZSgpLCB0aGlzLl9yZW5kZXJSb3dzKCksIHRoaXMuX29wdGlvbnMubWF4SGVpZ2h0ICYmICh0aGlzLl9wZXJmZWN0U2Nyb2xsYmFyLmVsZW1lbnQuc2Nyb2xsVG9wID0gMCwgdGhpcy5fcGVyZmVjdFNjcm9sbGJhci51cGRhdGUoKSk7XG4gIH1cbiAgc29ydCh0LCBlID0gXCJhc2NcIikge1xuICAgIHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID0gZSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHRoaXMuX29wdGlvbnMuc29ydEZpZWxkID0gdGhpcy5jb2x1bW5zLmZpbmQoXG4gICAgICAobikgPT4gbi5sYWJlbCA9PT0gdFxuICAgICkuZmllbGQgOiB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCA9IHQuZmllbGQ7XG4gICAgY29uc3QgaSA9IGQuZmluZE9uZShcbiAgICAgIGBbZGF0YS10ZS1zb3J0PVwiJHt0aGlzLl9vcHRpb25zLnNvcnRGaWVsZH1cIl1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgdGhpcy5fYWN0aXZlUGFnZSA9IDAsIHRoaXMuX3RvZ2dsZURpc2FibGVTdGF0ZSgpLCB0aGlzLl9yZW5kZXJSb3dzKCksIHRoaXMuX3NldEFjdGl2ZVNvcnRJY29uKGkpO1xuICB9XG4gIHNldEFjdGl2ZVBhZ2UodCkge1xuICAgIHQgPCB0aGlzLnBhZ2VzICYmIHRoaXMuX2NoYW5nZUFjdGl2ZVBhZ2UodCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnlFLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKFZpLCB0LCB3RSksIHQ7XG4gIH1cbiAgX2NoYW5nZUFjdGl2ZVBhZ2UodCkge1xuICAgIHRoaXMuX2FjdGl2ZVBhZ2UgPSB0LCB0aGlzLl90b2dnbGVEaXNhYmxlU3RhdGUoKSwgdGhpcy5fcmVuZGVyUm93cygpO1xuICB9XG4gIF9jbGVhckNsYXNzTGlzdCh0KSB7XG4gICAgW1wiaG92ZXJcIiwgXCJib3JkZXJlZFwiLCBcImJvcmRlcmxlc3NcIiwgXCJzbVwiLCBcInN0cmlwZWRcIl0uZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgdGhpcy5fb3B0aW9uc1tlXSAmJiAhdFtlXSAmJiBoLnJlbW92ZURhdGFBdHRyaWJ1dGUoYGRhdGEtdGUtJHtlfWApO1xuICAgIH0pO1xuICB9XG4gIF9lbWl0U2VsZWN0RXZlbnQoKSB7XG4gICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVULCB7XG4gICAgICBzZWxlY3RlZFJvd3M6IHRoaXMucm93cy5maWx0ZXIoXG4gICAgICAgICh0KSA9PiB0aGlzLl9zZWxlY3RlZC5pbmRleE9mKHQucm93SW5kZXgpICE9PSAtMVxuICAgICAgKSxcbiAgICAgIHNlbGVjdGVkSW5kZXhlczogdGhpcy5fc2VsZWN0ZWQsXG4gICAgICBhbGxTZWxlY3RlZDogdGhpcy5fc2VsZWN0ZWQubGVuZ3RoID09PSB0aGlzLnJvd3MubGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgX2dldFJvd3ModCA9IFtdKSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcInRib2R5XCIsIHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiBlID8gWy4uLmQuZmluZChcInRyXCIsIGUpLm1hcCgobikgPT4gZC5maW5kKFwidGRcIiwgbikubWFwKChvKSA9PiBvLmlubmVySFRNTCkpLCAuLi50XSA6IHQ7XG4gIH1cbiAgX2dldENvbHVtbnModCA9IFtdKSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcInRoZWFkXCIsIHRoaXMuX2VsZW1lbnQpO1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiB0O1xuICAgIGNvbnN0IGkgPSBkLmZpbmRPbmUoXCJ0clwiLCBlKTtcbiAgICByZXR1cm4gWy4uLmQuZmluZChcInRoXCIsIGkpLm1hcCgobykgPT4gKHtcbiAgICAgIGxhYmVsOiBvLmlubmVySFRNTCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXMobylcbiAgICB9KSksIC4uLnRdO1xuICB9XG4gIF9nZXRDU1NWYWx1ZSh0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0IDogYCR7dH1weGA7XG4gIH1cbiAgX2dldE9wdGlvbnModCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5FRSxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gSShWaSwgZSwgVEUpLCBlO1xuICB9XG4gIF9zZXRBY3RpdmVSb3dzKCkge1xuICAgIGQuZmluZChUaSwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdGhpcy5fc2VsZWN0ZWQuaW5jbHVkZXMoaC5nZXREYXRhQXR0cmlidXRlKHQsIFwiaW5kZXhcIikpID8gaC5hZGRDbGFzcyh0LCBgYWN0aXZlICR7dGhpcy5fY2xhc3Nlcy5zZWxlY3RhYmxlUm93fWApIDogaC5yZW1vdmVDbGFzcyh0LCBgYWN0aXZlICR7dGhpcy5fY2xhc3Nlcy5zZWxlY3RhYmxlUm93fWApO1xuICAgIH0pO1xuICB9XG4gIF9zZXRFbnRyaWVzKHQpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0T3B0aW9ucyh7XG4gICAgICAuLi50aGlzLl9vcHRpb25zLFxuICAgICAgZW50cmllczogdC50YXJnZXQudmFsdWVcbiAgICB9KSwgdGhpcy5fYWN0aXZlUGFnZSA+IHRoaXMucGFnZXMgLSAxICYmICh0aGlzLl9hY3RpdmVQYWdlID0gdGhpcy5wYWdlcyAtIDEpLCB0aGlzLl90b2dnbGVEaXNhYmxlU3RhdGUoKSwgdGhpcy5fcmVuZGVyUm93cygpO1xuICB9XG4gIF9zZXRTZWxlY3RlZCgpIHtcbiAgICBkLmZpbmQoeG8sIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goXG4gICAgICAodCkgPT4ge1xuICAgICAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwicm93SW5kZXhcIik7XG4gICAgICAgIHQuY2hlY2tlZCA9IHRoaXMuX3NlbGVjdGVkLmluY2x1ZGVzKGUpO1xuICAgICAgfVxuICAgICksIHRoaXMuX3NldEFjdGl2ZVJvd3MoKTtcbiAgfVxuICBfc2V0QWN0aXZlU29ydEljb24odCkge1xuICAgIGQuZmluZChrbywgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID09PSBcImRlc2NcIiAmJiBlID09PSB0ID8gMTgwIDogMDtcbiAgICAgIGguc3R5bGUoZSwge1xuICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGUoJHtpfWRlZylgXG4gICAgICB9KSwgZSA9PT0gdCAmJiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA/IGguYWRkQ2xhc3MoZSwgXCJvcGFjaXR5LTEwMFwiKSA6IGgucmVtb3ZlQ2xhc3MoZSwgXCJvcGFjaXR5LTEwMFwiKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0dXAoKSB7XG4gICAgdGhpcy5fcmVuZGVyVGFibGUoKSwgdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX3NldHVwUGFnaW5hdGlvbigpLCB0aGlzLl9vcHRpb25zLmVkaXQgJiYgdGhpcy5fc2V0dXBFZGl0YWJsZSgpLCB0aGlzLl9vcHRpb25zLmNsaWNrYWJsZVJvd3MgJiYgdGhpcy5fc2V0dXBDbGlja2FibGVSb3dzKCksIHRoaXMuX29wdGlvbnMuc2VsZWN0YWJsZSAmJiB0aGlzLl9zZXR1cFNlbGVjdGFibGUoKSwgdGhpcy5fc2V0dXBTY3JvbGwoKSwgdGhpcy5fc2V0dXBTb3J0KCk7XG4gIH1cbiAgX3NldHVwQ2xpY2thYmxlUm93cygpIHtcbiAgICBkLmZpbmQoVGksIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGUodCwgXCJpbmRleFwiKTtcbiAgICAgIGguYWRkQ2xhc3ModCwgXCJjdXJzb3ItcG9pbnRlclwiKSwgYy5vbih0LCBcImNsaWNrXCIsIChpKSA9PiB7XG4gICAgICAgIGQubWF0Y2hlcyhpLnRhcmdldCwgeG8pIHx8IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBDVCwge1xuICAgICAgICAgIGluZGV4OiBlLFxuICAgICAgICAgIHJvdzogdGhpcy5yb3dzW2VdXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwRWRpdGFibGUoKSB7XG4gICAgZC5maW5kKFRpLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwiaW5kZXhcIik7XG4gICAgICBkLmZpbmQod28sIHQpLmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgYy5vbihpLCBcImlucHV0XCIsIChuKSA9PiB0aGlzLl91cGRhdGVSb3cobiwgZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwU2Nyb2xsKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUodVQsIHRoaXMuX2VsZW1lbnQpLCBlID0ge307XG4gICAgaWYgKHRoaXMuX29wdGlvbnMubWF4SGVpZ2h0ICYmIChlLm1heEhlaWdodCA9IHRoaXMuX2dldENTU1ZhbHVlKHRoaXMuX29wdGlvbnMubWF4SGVpZ2h0KSksIHRoaXMuX29wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRDU1NWYWx1ZSh0aGlzLl9vcHRpb25zLm1heFdpZHRoKTtcbiAgICAgIGUubWF4V2lkdGggPSBpLCBoLnN0eWxlKHRoaXMuX2VsZW1lbnQsIHsgbWF4V2lkdGg6IGkgfSk7XG4gICAgfVxuICAgIGlmIChoLnN0eWxlKHQsIGUpLCBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMuc2Nyb2xsfWApLCB0aGlzLl9vcHRpb25zLmZpeGVkSGVhZGVyKSB7XG4gICAgICBsZXQgaSA9IGQuZmluZChwVCwgdGhpcy5fZWxlbWVudCk7XG4gICAgICB0aGlzLl9vcHRpb25zLnNlbGVjdGFibGUgJiYgKGkgPSBpLmZpbHRlcigobiwgbykgPT4gKGguYWRkQ2xhc3MoXG4gICAgICAgIG4sXG4gICAgICAgIGAke3RoaXMuX2NsYXNzZXMuZml4ZWRIZWFkZXJ9ICR7dGhpcy5fY2xhc3Nlcy5jb2xvcn1gXG4gICAgICApLCBvICE9PSAwKSkpLCBpLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgICAgaC5hZGRDbGFzcyhcbiAgICAgICAgICBuLFxuICAgICAgICAgIGAke3RoaXMuX2NsYXNzZXMuZml4ZWRIZWFkZXJ9ICR7dGhpcy5fY2xhc3Nlcy5jb2xvcn1gXG4gICAgICAgICksIHRoaXMuY29sdW1uc1tvXS5maXhlZCAmJiBoLmFkZENsYXNzKG4sIFwiIXotNDBcIik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcGVyZmVjdFNjcm9sbGJhciA9IG5ldyBCaCh0KTtcbiAgfVxuICBfc2V0dXBTb3J0KCkge1xuICAgIGQuZmluZChrbywgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcInNvcnRcIiksIFtpXSA9IGQucGFyZW50cyh0LCBcInRoXCIpO1xuICAgICAgaWYgKHRoaXMuY29sdW1ucy5zb3J0KVxuICAgICAgICBoLmFkZENsYXNzKGksIFwiY3Vyc29yLXBvaW50ZXJcIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybjtcbiAgICAgIGUgPT09IHRoaXMuX29wdGlvbnMuc29ydEZpZWxkICYmIHRoaXMuX3NldEFjdGl2ZVNvcnRJY29uKHQpLCBjLm9uKGksIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCA9PT0gZSAmJiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9PT0gXCJhc2NcIiA/IHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID0gXCJkZXNjXCIgOiB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCA9PT0gZSAmJiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9PT0gXCJkZXNjXCIgPyB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9IHRoaXMuX29wdGlvbnMuZm9yY2VTb3J0ID8gXCJhc2NcIiA6IG51bGwgOiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9IFwiYXNjXCIsIHRoaXMuX29wdGlvbnMuc29ydEZpZWxkID0gZSwgdGhpcy5fYWN0aXZlUGFnZSA9IDAsIHRoaXMuX3BlcmZvcm1Tb3J0KCksIHRoaXMuX3NldEFjdGl2ZVNvcnRJY29uKHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3BlcmZvcm1Tb3J0KCkge1xuICAgIHRoaXMuX3RvZ2dsZURpc2FibGVTdGF0ZSgpLCB0aGlzLl9yZW5kZXJSb3dzKCk7XG4gIH1cbiAgX3NldHVwU2VsZWN0YWJsZSgpIHtcbiAgICB0aGlzLl9jaGVja2JveGVzID0gZC5maW5kKHhvLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5faGVhZGVyQ2hlY2tib3ggPSBkLmZpbmRPbmUoXG4gICAgICBfVCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5faGVhZGVyQ2hlY2tib3gsXG4gICAgICBcImlucHV0XCIsXG4gICAgICAodCkgPT4gdGhpcy5fdG9nZ2xlU2VsZWN0QWxsKHQpXG4gICAgKSwgdGhpcy5fY2hlY2tib3hlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwicm93SW5kZXhcIik7XG4gICAgICBjLm9uKFxuICAgICAgICB0LFxuICAgICAgICBcImlucHV0XCIsXG4gICAgICAgIChpKSA9PiB0aGlzLl90b2dnbGVTZWxlY3RSb3coaSwgZSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwUGFnaW5hdGlvbigpIHtcbiAgICB0aGlzLl9wYWdpbmF0aW9uUmlnaHQgPSBkLmZpbmRPbmUoXG4gICAgICBmVCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl9wYWdpbmF0aW9uTGVmdCA9IGQuZmluZE9uZShcbiAgICAgIG1ULFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9wYWdpbmF0aW9uUmlnaHQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICAoKSA9PiB0aGlzLl9jaGFuZ2VBY3RpdmVQYWdlKHRoaXMuX2FjdGl2ZVBhZ2UgKyAxKVxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9wYWdpbmF0aW9uTGVmdCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgICgpID0+IHRoaXMuX2NoYW5nZUFjdGl2ZVBhZ2UodGhpcy5fYWN0aXZlUGFnZSAtIDEpXG4gICAgKSwgdGhpcy5fb3B0aW9ucy5mdWxsUGFnaW5hdGlvbiAmJiAodGhpcy5fcGFnaW5hdGlvblN0YXJ0ID0gZC5maW5kT25lKFxuICAgICAgZ1QsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fcGFnaW5hdGlvbkVuZCA9IGQuZmluZE9uZShcbiAgICAgIGJULFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9wYWdpbmF0aW9uU3RhcnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICAoKSA9PiB0aGlzLl9jaGFuZ2VBY3RpdmVQYWdlKDApXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX3BhZ2luYXRpb25FbmQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICAoKSA9PiB0aGlzLl9jaGFuZ2VBY3RpdmVQYWdlKHRoaXMucGFnZXMgLSAxKVxuICAgICkpLCB0aGlzLl90b2dnbGVEaXNhYmxlU3RhdGUoKSwgdGhpcy5fc2V0dXBQYWdpbmF0aW9uU2VsZWN0KCk7XG4gIH1cbiAgX3NldHVwUGFnaW5hdGlvblNlbGVjdCgpIHtcbiAgICB0aGlzLl9zZWxlY3QgPSBkLmZpbmRPbmUoVFQsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9zZWxlY3RJbnN0YW5jZSA9IG5ldyBrcih0aGlzLl9zZWxlY3QpLCBjLm9uKFxuICAgICAgdGhpcy5fc2VsZWN0LFxuICAgICAgXCJ2YWx1ZUNoYW5nZS50ZS5zZWxlY3RcIixcbiAgICAgICh0KSA9PiB0aGlzLl9zZXRFbnRyaWVzKHQpXG4gICAgKTtcbiAgfVxuICBfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uICYmIChjLm9mZih0aGlzLl9wYWdpbmF0aW9uUmlnaHQsIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMuX3BhZ2luYXRpb25MZWZ0LCBcImNsaWNrXCIpLCBjLm9mZih0aGlzLl9zZWxlY3QsIFwidmFsdWVDaGFuZ2UudGUuc2VsZWN0XCIpLCB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uICYmIChjLm9mZih0aGlzLl9wYWdpbmF0aW9uU3RhcnQsIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMuX3BhZ2luYXRpb25FbmQsIFwiY2xpY2tcIikpKSwgdGhpcy5fb3B0aW9ucy5lZGl0ICYmIGQuZmluZCh3bywgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgYy5vZmYodCwgXCJpbnB1dFwiKTtcbiAgICB9KSwgdGhpcy5fb3B0aW9ucy5jbGlja2FibGVSb3dzICYmIGQuZmluZChUaSwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgYy5vZmYodCwgXCJjbGlja1wiKTtcbiAgICB9KSwgZC5maW5kKGtvLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBbZV0gPSBkLnBhcmVudHModCwgXCJ0aFwiKTtcbiAgICAgIGMub2ZmKGUsIFwiY2xpY2tcIik7XG4gICAgfSksIHRoaXMuX29wdGlvbnMuc2VsZWN0YWJsZSAmJiAoYy5vZmYodGhpcy5faGVhZGVyQ2hlY2tib3gsIFwiaW5wdXRcIiksIHRoaXMuX2NoZWNrYm94ZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgYy5vZmYodCwgXCJpbnB1dFwiKTtcbiAgICB9KSk7XG4gIH1cbiAgX3JlbmRlclRhYmxlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuaW5uZXJIVE1MID0gUGwodGhpcy50YWJsZU9wdGlvbnMpLnRhYmxlLCB0aGlzLl9mb3JtYXRDZWxscygpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgSGwpO1xuICB9XG4gIF9yZW5kZXJSb3dzKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXCJ0Ym9keVwiLCB0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uKSB7XG4gICAgICBjb25zdCBlID0gZC5maW5kT25lKFxuICAgICAgICB2VCxcbiAgICAgICAgdGhpcy5fZWxlbWVudFxuICAgICAgKTtcbiAgICAgIGUuaW5uZXJUZXh0ID0gdGhpcy5uYXZpZ2F0aW9uVGV4dDtcbiAgICB9XG4gICAgdC5pbm5lckhUTUwgPSBQbCh0aGlzLnRhYmxlT3B0aW9ucykucm93cywgdGhpcy5fZm9ybWF0Q2VsbHMoKSwgdGhpcy5fb3B0aW9ucy5lZGl0ICYmIHRoaXMuX3NldHVwRWRpdGFibGUoKSwgdGhpcy5fb3B0aW9ucy5zZWxlY3RhYmxlICYmICh0aGlzLl9zZXR1cFNlbGVjdGFibGUoKSwgdGhpcy5fc2V0U2VsZWN0ZWQoKSksIHRoaXMuX29wdGlvbnMuY2xpY2thYmxlUm93cyAmJiB0aGlzLl9zZXR1cENsaWNrYWJsZVJvd3MoKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEhsKTtcbiAgfVxuICBfZm9ybWF0Q2VsbHMoKSB7XG4gICAgZC5maW5kKFRpLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBjb25zdCBpID0gaC5nZXREYXRhQXR0cmlidXRlKGUsIFwiaW5kZXhcIik7XG4gICAgICBkLmZpbmQod28sIGUpLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgY29uc3QgciA9IGguZ2V0RGF0YUF0dHJpYnV0ZShvLCBcImZpZWxkXCIpLCBhID0gdGhpcy5jb2x1bW5zLmZpbmQoKGwpID0+IGwuZmllbGQgPT09IHIpO1xuICAgICAgICBhICYmIGEuZm9ybWF0ICE9PSBudWxsICYmIGEuZm9ybWF0KG8sIHRoaXMucm93c1tpXVtyXSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlRGlzYWJsZVN0YXRlKCkge1xuICAgIHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbiAhPT0gITEgJiYgKHRoaXMuX2FjdGl2ZVBhZ2UgPT09IDAgfHwgdGhpcy5fb3B0aW9ucy5sb2FkaW5nID8gKHRoaXMuX3BhZ2luYXRpb25MZWZ0LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpLCB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uICYmIHRoaXMuX3BhZ2luYXRpb25TdGFydC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKSkgOiAodGhpcy5fcGFnaW5hdGlvbkxlZnQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIiksIHRoaXMuX29wdGlvbnMuZnVsbFBhZ2luYXRpb24gJiYgdGhpcy5fcGFnaW5hdGlvblN0YXJ0LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpKSwgdGhpcy5fYWN0aXZlUGFnZSA9PT0gdGhpcy5wYWdlcyAtIDEgfHwgdGhpcy5fb3B0aW9ucy5sb2FkaW5nIHx8IHRoaXMucGFnZXMgPT09IDAgPyAodGhpcy5fcGFnaW5hdGlvblJpZ2h0LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpLCB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uICYmIHRoaXMuX3BhZ2luYXRpb25FbmQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIikpIDogKHRoaXMuX3BhZ2luYXRpb25SaWdodC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSwgdGhpcy5fb3B0aW9ucy5mdWxsUGFnaW5hdGlvbiAmJiB0aGlzLl9wYWdpbmF0aW9uRW5kLnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpKSk7XG4gIH1cbiAgX3RvZ2dsZVNlbGVjdEFsbCh0KSB7XG4gICAgdC50YXJnZXQuY2hlY2tlZCA/IHRoaXMuX3NlbGVjdGVkID0gdGhpcy5yb3dzLm1hcCgoZSkgPT4gZS5yb3dJbmRleCkgOiB0aGlzLl9zZWxlY3RlZCA9IFtdLCB0aGlzLl9zZXRTZWxlY3RlZCgpLCB0aGlzLl9lbWl0U2VsZWN0RXZlbnQoKTtcbiAgfVxuICBfdG9nZ2xlU2VsZWN0Um93KHQsIGUpIHtcbiAgICB0LnRhcmdldC5jaGVja2VkID8gdGhpcy5fb3B0aW9ucy5tdWx0aSAmJiAhdGhpcy5fc2VsZWN0ZWQuaW5jbHVkZXMoZSkgPyB0aGlzLl9zZWxlY3RlZCA9IFsuLi50aGlzLl9zZWxlY3RlZCwgZV0gOiAodGhpcy5fc2VsZWN0ZWQgPSBbZV0sIHRoaXMuX2NoZWNrYm94ZXMuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgaSAhPT0gdC50YXJnZXQgJiYgKGkuY2hlY2tlZCA9ICExKTtcbiAgICB9KSkgOiB0aGlzLl9zZWxlY3RlZCA9IHRoaXMuX3NlbGVjdGVkLmZpbHRlcigoaSkgPT4gaSAhPT0gZSksIHRoaXMuX29wdGlvbnMubXVsdGkgJiYgIXQudGFyZ2V0LmNoZWNrZWQgJiYgKHRoaXMuX2hlYWRlckNoZWNrYm94LmNoZWNrZWQgPSAhMSksIHRoaXMuX3NldEFjdGl2ZVJvd3MoKSwgdGhpcy5fZW1pdFNlbGVjdEV2ZW50KCk7XG4gIH1cbiAgX3VwZGF0ZVJvdyh0LCBlKSB7XG4gICAgY29uc3QgaSA9IGguZ2V0RGF0YUF0dHJpYnV0ZSh0LnRhcmdldCwgXCJmaWVsZFwiKSwgbiA9IHQudGFyZ2V0LnRleHRDb250ZW50LCBvID0gdGhpcy5fcm93c1tlXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuICAgICAgY29uc3QgYSA9IHRoaXMuY29sdW1ucy5maW5kKChsKSA9PiBsLmZpZWxkID09PSBpKS5jb2x1bW5JbmRleDtcbiAgICAgIG9bYV0gPSBuO1xuICAgIH0gZWxzZVxuICAgICAgb1tpXSA9IG47XG4gICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEFULCB7XG4gICAgICByb3dzOiB0aGlzLl9yb3dzLFxuICAgICAgY29sdW1uczogdGhpcy5fY29sdW1uc1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSwgaSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgbiA9IEEuZ2V0RGF0YSh0aGlzLCBraSk7XG4gICAgICBjb25zdCBvID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIW4gJiYgL2Rpc3Bvc2UvLnRlc3QodCkpICYmIChuIHx8IChuID0gbmV3IEhoKHRoaXMsIG8sIGUpKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIG5bdF0oZSwgaSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIGtpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBWbCA9IFwicmF0aW5nXCIsIHNuID0gXCJ0ZS5yYXRpbmdcIiwga0UgPSBcImRhdGEtdGUtcmF0aW5nLWluaXRcIiwgeEUgPSBcIltkYXRhLXRlLXJhdGluZy1pY29uLXJlZl1cIiwgY2kgPSBgLiR7c259YCwgT0UgPSBcIkFycm93TGVmdFwiLCBTRSA9IFwiQXJyb3dSaWdodFwiLCBJRSA9IHtcbiAgdG9vbHRpcDogXCJzdHJpbmdcIixcbiAgdmFsdWU6IFwiKHN0cmluZ3xudW1iZXIpXCIsXG4gIHJlYWRvbmx5OiBcImJvb2xlYW5cIixcbiAgYWZ0ZXI6IFwic3RyaW5nXCIsXG4gIGJlZm9yZTogXCJzdHJpbmdcIixcbiAgZHluYW1pYzogXCJib29sZWFuXCIsXG4gIGFjdGl2ZTogXCJzdHJpbmdcIlxufSwgREUgPSB7XG4gIHRvb2x0aXA6IFwidG9wXCIsXG4gIHZhbHVlOiBcIlwiLFxuICByZWFkb25seTogITEsXG4gIGFmdGVyOiBcIlwiLFxuICBiZWZvcmU6IFwiXCIsXG4gIGR5bmFtaWM6ICExLFxuICBhY3RpdmU6IFwiZmlsbC1jdXJyZW50XCJcbn0sIFdsID0gYG9uU2VsZWN0JHtjaX1gLCAkRSA9IGBvbkhvdmVyJHtjaX1gLCBGbCA9IGBrZXl1cCR7Y2l9YCwgWWwgPSBgZm9jdXNvdXQke2NpfWAsIGpsID0gYGtleWRvd24ke2NpfWAsIEtsID0gYG1vdXNlZG93biR7Y2l9YDtcbmNsYXNzIEdBIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9pY29ucyA9IGQuZmluZCh4RSwgdGhpcy5fZWxlbWVudCksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2luZGV4ID0gLTEsIHRoaXMuX3NhdmVkSW5kZXggPSBudWxsLCB0aGlzLl9vcmlnaW5hbENsYXNzTGlzdCA9IFtdLCB0aGlzLl9vcmlnaW5hbEljb25zID0gW10sIHRoaXMuX2ZuID0ge30sIHRoaXMuX3Rvb2x0aXBzID0gW10sIHRoaXMuX2VsZW1lbnQgJiYgKEEuc2V0RGF0YSh0LCBzbiwgdGhpcyksIHRoaXMuX2luaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFZsO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHNuKSwgdGhpcy5fb3B0aW9ucy5yZWFkb25seSB8fCAoYy5vZmYodGhpcy5fZWxlbWVudCwgRmwpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBZbCksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIGpsKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLl9mbi5tb3VzZWxlYXZlKSwgdGhpcy5faWNvbnMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgYy5vZmYodCwgS2wpLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIHRoaXMuX2ZuLm1vdXNlZW50ZXJbZV0pLCBoLnJlbW92ZUNsYXNzKHQsIFwiY3Vyc29yLXBvaW50ZXJcIik7XG4gICAgfSksIHRoaXMuX3Rvb2x0aXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtFKSwgdC5kaXNwb3NlKCk7XG4gICAgfSksIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHQucmVtb3ZlQXR0cmlidXRlKFwidGFiSW5kZXhcIikpKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9vcHRpb25zLnJlYWRvbmx5IHx8ICh0aGlzLl9iaW5kTW91c2VFbnRlcigpLCB0aGlzLl9iaW5kTW91c2VMZWF2ZSgpLCB0aGlzLl9iaW5kTW91c2VEb3duKCksIHRoaXMuX2JpbmRLZXlEb3duKCksIHRoaXMuX2JpbmRLZXlVcCgpLCB0aGlzLl9iaW5kRm9jdXNMb3N0KCksIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGguYWRkQ2xhc3ModCwgXCJjdXJzb3ItcG9pbnRlclwiKTtcbiAgICB9KSksIHRoaXMuX29wdGlvbnMuZHluYW1pYyAmJiAodGhpcy5fc2F2ZU9yaWdpbmFsQ2xhc3NMaXN0KCksIHRoaXMuX3NhdmVPcmlnaW5hbEljb25zKCkpLCB0aGlzLl9zZXRDdXN0b21UZXh0KCksIHRoaXMuX3NldFRvb2xUaXBzKCksIHRoaXMuX29wdGlvbnMudmFsdWUgJiYgKHRoaXMuX2luZGV4ID0gdGhpcy5fb3B0aW9ucy52YWx1ZSAtIDEsIHRoaXMuX3VwZGF0ZVJhdGluZyh0aGlzLl9pbmRleCkpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uREUsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoVmwsIHQsIElFKSwgdDtcbiAgfVxuICBfYmluZE1vdXNlRW50ZXIoKSB7XG4gICAgdGhpcy5fZm4ubW91c2VlbnRlciA9IFtdLCB0aGlzLl9pY29ucy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICB0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwibW91c2VlbnRlclwiLFxuICAgICAgICAvLyB0aGlzLl9mbi5tb3VzZWVudGVyW2ldIGlzIG5lZWRlZCB0byBjcmVhdGUgcmVmZXJlbmNlIGFuZCB1bnBpbiBldmVudHMgYWZ0ZXIgY2FsbCBkaXNwb3NlXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICB0aGlzLl9mbi5tb3VzZWVudGVyW2VdID0gKGkpID0+IHtcbiAgICAgICAgICB0aGlzLl9pbmRleCA9IHRoaXMuX2ljb25zLmluZGV4T2YoaS50YXJnZXQpLCB0aGlzLl91cGRhdGVSYXRpbmcodGhpcy5faW5kZXgpLCB0aGlzLl90cmlnZ2VyRXZlbnRzKHQsICRFKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZE1vdXNlTGVhdmUoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJtb3VzZWxlYXZlXCIsXG4gICAgICAvLyB0aGlzLl9mbi5tb3VzZWxlYXZlIGlzIG5lZWRlZCB0byBjcmVhdGUgcmVmZXJlbmNlIGFuZCB1bnBpbiBldmVudHMgYWZ0ZXIgY2FsbCBkaXNwb3NlXG4gICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgIHRoaXMuX2ZuLm1vdXNlbGVhdmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3NhdmVkSW5kZXggIT09IG51bGwgPyAodGhpcy5fdXBkYXRlUmF0aW5nKHRoaXMuX3NhdmVkSW5kZXgpLCB0aGlzLl9pbmRleCA9IHRoaXMuX3NhdmVkSW5kZXgpIDogdGhpcy5fb3B0aW9ucy52YWx1ZSA/ICh0aGlzLl91cGRhdGVSYXRpbmcodGhpcy5fb3B0aW9ucy52YWx1ZSAtIDEpLCB0aGlzLl9pbmRleCA9IHRoaXMuX29wdGlvbnMudmFsdWUgLSAxKSA6ICh0aGlzLl9pbmRleCA9IC0xLCB0aGlzLl9jbGVhclJhdGluZygpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9iaW5kTW91c2VEb3duKCkge1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGMub24odCwgS2wsICgpID0+IHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudE91dGxpbmUoXCJub25lXCIpLCB0aGlzLl9zYXZlZEluZGV4ID0gdGhpcy5faW5kZXgsIHRoaXMuX3RyaWdnZXJFdmVudHModCwgV2wpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRLZXlEb3duKCkge1xuICAgIHRoaXMuX2VsZW1lbnQudGFiSW5kZXggPSAwLCBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGpsLFxuICAgICAgKHQpID0+IHRoaXMuX3VwZGF0ZUFmdGVyS2V5RG93bih0KVxuICAgICk7XG4gIH1cbiAgX2JpbmRLZXlVcCgpIHtcbiAgICBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIEZsLFxuICAgICAgKCkgPT4gdGhpcy5fc2V0RWxlbWVudE91dGxpbmUoXCJhdXRvXCIpXG4gICAgKTtcbiAgfVxuICBfYmluZEZvY3VzTG9zdCgpIHtcbiAgICBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFlsLFxuICAgICAgKCkgPT4gdGhpcy5fc2V0RWxlbWVudE91dGxpbmUoXCJub25lXCIpXG4gICAgKTtcbiAgfVxuICBfc2V0RWxlbWVudE91dGxpbmUodCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3V0bGluZSA9IHQ7XG4gIH1cbiAgX3RyaWdnZXJFdmVudHModCwgZSkge1xuICAgIGMudHJpZ2dlcih0LCBlLCB7XG4gICAgICB2YWx1ZTogdGhpcy5faW5kZXggKyAxXG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZUFmdGVyS2V5RG93bih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2ljb25zLmxlbmd0aCAtIDEsIGkgPSB0aGlzLl9pbmRleDtcbiAgICB0LmtleSA9PT0gU0UgJiYgdGhpcy5faW5kZXggPCBlICYmICh0aGlzLl9pbmRleCArPSAxKSwgdC5rZXkgPT09IE9FICYmIHRoaXMuX2luZGV4ID4gLTEgJiYgKHRoaXMuX2luZGV4IC09IDEpLCBpICE9PSB0aGlzLl9pbmRleCAmJiAodGhpcy5fc2F2ZWRJbmRleCA9IHRoaXMuX2luZGV4LCB0aGlzLl91cGRhdGVSYXRpbmcodGhpcy5fc2F2ZWRJbmRleCksIHRoaXMuX3RyaWdnZXJFdmVudHModGhpcy5faWNvbnNbdGhpcy5fc2F2ZWRJbmRleF0sIFdsKSk7XG4gIH1cbiAgX3VwZGF0ZVJhdGluZyh0KSB7XG4gICAgdGhpcy5fY2xlYXJSYXRpbmcoKSwgdGhpcy5fb3B0aW9ucy5keW5hbWljICYmIHRoaXMuX3Jlc3RvcmVPcmlnaW5hbEljb24odCksIHRoaXMuX2ljb25zLmZvckVhY2goKGUsIGkpID0+IHtcbiAgICAgIGkgPD0gdCAmJiBoLmFkZENsYXNzKGUucXVlcnlTZWxlY3RvcihcInN2Z1wiKSwgdGhpcy5fb3B0aW9ucy5hY3RpdmUpO1xuICAgIH0pO1xuICB9XG4gIF9jbGVhclJhdGluZygpIHtcbiAgICB0aGlzLl9pY29ucy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICBjb25zdCBpID0gdC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpO1xuICAgICAgdGhpcy5fb3B0aW9ucy5keW5hbWljICYmICh0LmNsYXNzTGlzdCA9IHRoaXMuX29yaWdpbmFsQ2xhc3NMaXN0W2VdLCBpLmlubmVySFRNTCA9IHRoaXMuX29yaWdpbmFsSWNvbnNbZV0pLCBoLnJlbW92ZUNsYXNzKGksIHRoaXMuX29wdGlvbnMuYWN0aXZlKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0VG9vbFRpcHMoKSB7XG4gICAgdGhpcy5faWNvbnMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgY29uc3QgaSA9IGguZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcInRvZ2dsZVwiKTtcbiAgICAgIHQudGl0bGUgJiYgIWkgJiYgKGguc2V0RGF0YUF0dHJpYnV0ZSh0LCBcInRvZ2dsZVwiLCBcInRvb2x0aXBcIiksIHRoaXMuX3Rvb2x0aXBzW2VdID0gbmV3IHJpKHQsIHtcbiAgICAgICAgcGxhY2VtZW50OiB0aGlzLl9vcHRpb25zLnRvb2x0aXBcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0Q3VzdG9tVGV4dCgpIHtcbiAgICB0aGlzLl9pY29ucy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwiYWZ0ZXJcIiksIGkgPSBoLmdldERhdGFBdHRyaWJ1dGUodCwgXCJiZWZvcmVcIik7XG4gICAgICBlICYmIHQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYWZ0ZXJFbmRcIiwgZSksIGkgJiYgdC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVCZWdpblwiLCBpKTtcbiAgICB9KTtcbiAgfVxuICBfc2F2ZU9yaWdpbmFsQ2xhc3NMaXN0KCkge1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LmNsYXNzTGlzdC52YWx1ZTtcbiAgICAgIHRoaXMuX29yaWdpbmFsQ2xhc3NMaXN0LnB1c2goZSk7XG4gICAgfSk7XG4gIH1cbiAgX3NhdmVPcmlnaW5hbEljb25zKCkge1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIikuaW5uZXJIVE1MO1xuICAgICAgdGhpcy5fb3JpZ2luYWxJY29ucy5wdXNoKGUpO1xuICAgIH0pO1xuICB9XG4gIF9yZXN0b3JlT3JpZ2luYWxJY29uKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fb3JpZ2luYWxDbGFzc0xpc3RbdF0sIGkgPSB0aGlzLl9vcmlnaW5hbEljb25zW3RdO1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgIGlmIChvIDw9IHQpIHtcbiAgICAgICAgY29uc3QgciA9IG4ucXVlcnlTZWxlY3RvcihcInN2Z1wiKTtcbiAgICAgICAgci5pbm5lckhUTUwgPSBpLCBuLmNsYXNzTGlzdCA9IGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEEuZ2V0RGF0YSh0LCBzbik7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgT28gPSBcInBvcGNvbmZpcm1cIiwgeGkgPSBcInRlLnBvcGNvbmZpcm1cIiwgVmggPSBgLiR7eGl9YCwgTEUgPSBgY2FuY2VsJHtWaH1gLCBORSA9IGBjb25maXJtJHtWaH1gLCBNRSA9IFwiW2RhdGEtdGUtcG9wY29uZmlybS1ib2R5XVwiLCBTbyA9IFwiZGF0YS10ZS1wb3Bjb25maXJtLXBvcG92ZXJcIiwgUkUgPSBcImRhdGEtdGUtcG9wY29uZmlybS1tb2RhbFwiLCB6bCA9IFwiZGF0YS10ZS1wb3Bjb25maXJtLWJhY2tkcm9wXCIsIFBFID0ge1xuICBwb3Bjb25maXJtTW9kZTogXCJzdHJpbmdcIixcbiAgbWVzc2FnZTogXCJzdHJpbmdcIixcbiAgY2FuY2VsVGV4dDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIG9rVGV4dDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIHBvcGNvbmZpcm1JY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIGNhbmNlbExhYmVsOiBcIihudWxsfHN0cmluZylcIixcbiAgY29uZmlybUxhYmVsOiBcIihudWxsfHN0cmluZylcIixcbiAgcG9zaXRpb246IFwiKG51bGx8c3RyaW5nKVwiXG59LCBCRSA9IHtcbiAgcG9wY29uZmlybU1vZGU6IFwiaW5saW5lXCIsXG4gIG1lc3NhZ2U6IFwiQXJlIHlvdSBzdXJlP1wiLFxuICBjYW5jZWxUZXh0OiBcIkNhbmNlbFwiLFxuICBva1RleHQ6IFwiT0tcIixcbiAgcG9wY29uZmlybUljb25UZW1wbGF0ZTogXCJcIixcbiAgY2FuY2VsTGFiZWw6IFwiQ2FuY2VsXCIsXG4gIGNvbmZpcm1MYWJlbDogXCJDb25maXJtXCIsXG4gIHBvc2l0aW9uOiBcImJvdHRvbVwiXG59LCBIRSA9IHtcbiAgYmFja2Ryb3A6IFwic3RyaW5nXCIsXG4gIGJvZHk6IFwic3RyaW5nXCIsXG4gIGJ0bkNhbmNlbDogXCJzdHJpbmdcIixcbiAgYnRuQ29uZmlybTogXCJzdHJpbmdcIixcbiAgYnRuc0NvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgZmFkZTogXCJzdHJpbmdcIixcbiAgaWNvbjogXCJzdHJpbmdcIixcbiAgbWVzc2FnZTogXCJzdHJpbmdcIixcbiAgbWVzc2FnZVRleHQ6IFwic3RyaW5nXCIsXG4gIG1vZGFsOiBcInN0cmluZ1wiLFxuICBwb3BvdmVyOiBcInN0cmluZ1wiXG59LCBWRSA9IHtcbiAgYmFja2Ryb3A6IFwiaC1mdWxsIHctZnVsbCB6LVsxMDcwXSBmaXhlZCB0b3AtMCBsZWZ0LTAgYmctWyMwMDAwMDA2Nl0gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXJcIixcbiAgYm9keTogXCJwLVsxcmVtXSBiZy13aGl0ZSByb3VuZGVkLVswLjVyZW1dIG9wYWNpdHktMCBkYXJrOmJnLW5ldXRyYWwtNzAwXCIsXG4gIGJ0bkNhbmNlbDogXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBiZy1wcmltYXJ5LTEwMCBweC00IHBiLVs1cHhdIHB0LVs2cHhdIHRleHQteHMgZm9udC1tZWRpdW0gdXBwZXJjYXNlIGxlYWRpbmctbm9ybWFsIHRleHQtcHJpbWFyeS03MDAgdHJhbnNpdGlvbiBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgaG92ZXI6YmctcHJpbWFyeS1hY2NlbnQtMTAwIGZvY3VzOmJnLXByaW1hcnktYWNjZW50LTEwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0wIGFjdGl2ZTpiZy1wcmltYXJ5LWFjY2VudC0yMDBcIixcbiAgYnRuQ29uZmlybTogXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBiZy1wcmltYXJ5IHB4LTQgcGItWzVweF0gcHQtWzZweF0gdGV4dC14cyBmb250LW1lZGl1bSB1cHBlcmNhc2UgbGVhZGluZy1ub3JtYWwgdGV4dC13aGl0ZSBzaGFkb3ctWzBfNHB4XzlweF8tNHB4XyMzYjcxY2FdIHRyYW5zaXRpb24gZHVyYXRpb24tMTUwIGVhc2UtaW4tb3V0IGhvdmVyOmJnLXByaW1hcnktNjAwIGhvdmVyOnNoYWRvdy1bMF84cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuMyksMF80cHhfMThweF8wX3JnYmEoNTksMTEzLDIwMiwwLjIpXSBmb2N1czpiZy1wcmltYXJ5LTYwMCBmb2N1czpzaGFkb3ctWzBfOHB4XzlweF8tNHB4X3JnYmEoNTksMTEzLDIwMiwwLjMpLDBfNHB4XzE4cHhfMF9yZ2JhKDU5LDExMywyMDIsMC4yKV0gZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMCBhY3RpdmU6YmctcHJpbWFyeS03MDAgYWN0aXZlOnNoYWRvdy1bMF84cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuMyksMF80cHhfMThweF8wX3JnYmEoNTksMTEzLDIwMiwwLjIpXSBkYXJrOnNoYWRvdy1bMF80cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuNSldIGRhcms6aG92ZXI6c2hhZG93LVswXzhweF85cHhfLTRweF9yZ2JhKDU5LDExMywyMDIsMC4yKSwwXzRweF8xOHB4XzBfcmdiYSg1OSwxMTMsMjAyLDAuMSldIGRhcms6Zm9jdXM6c2hhZG93LVswXzhweF85cHhfLTRweF9yZ2JhKDU5LDExMywyMDIsMC4yKSwwXzRweF8xOHB4XzBfcmdiYSg1OSwxMTMsMjAyLDAuMSldIGRhcms6YWN0aXZlOnNoYWRvdy1bMF84cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuMiksMF80cHhfMThweF8wX3JnYmEoNTksMTEzLDIwMiwwLjEpXVwiLFxuICBidG5zQ29udGFpbmVyOiBcImZsZXgganVzdGlmeS1lbmQgc3BhY2UteC0yXCIsXG4gIGZhZGU6IFwidHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLVsxNTBtc10gZWFzZS1saW5lYXJcIixcbiAgaWNvbjogXCJwci0yXCIsXG4gIG1lc3NhZ2U6IFwiZmxleCBtYi0zXCIsXG4gIG1lc3NhZ2VUZXh0OiBcInRleHQtbmV1dHJhbC02MDAgZGFyazp0ZXh0LXdoaXRlXCIsXG4gIG1vZGFsOiBcImFic29sdXRlIHctWzMwMHB4XSB6LVsxMDgwXSBzaGFkb3ctc20gcm91bmRlZC1bMC41cmVtXVwiLFxuICBwb3BvdmVyOiBcInctWzMwMHB4XSBib3JkZXItMCByb3VuZGVkLVswLjVyZW1dIHotWzEwODBdIHNoYWRvdy1zbVwiXG59O1xuY2xhc3MgV2gge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jYW5jZWxCdXR0b24gPSBcIlwiLCB0aGlzLl9jb25maXJtQnV0dG9uID0gXCJcIiwgdGhpcy5faXNPcGVuID0gITEsIHRoaXMuX3VpZCA9IHRoaXMuX2VsZW1lbnQuaWQgPyBgcG9wY29uZmlybS0ke3RoaXMuX2VsZW1lbnQuaWR9YCA6IGV0KFwicG9wY29uZmlybS1cIiksIHQgJiYgQS5zZXREYXRhKHQsIHhpLCB0aGlzKSwgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5vcGVuLmJpbmQodGhpcyksIGMub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBPbztcbiAgfVxuICBnZXQgY29udGFpbmVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoYCMke3RoaXMuX3VpZH1gKTtcbiAgfVxuICBnZXQgcG9wY29uZmlybUJvZHkoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcbiAgICAgIE1FLFxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICApO1xuICB9XG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgICh0aGlzLl9pc09wZW4gfHwgdGhpcy5jb250YWluZXIgIT09IG51bGwpICYmIHRoaXMuY2xvc2UoKSwgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHhpKSwgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBvcGVuKCkge1xuICAgIHRoaXMuX2lzT3BlbiB8fCAodGhpcy5fb3B0aW9ucy5wb3Bjb25maXJtTW9kZSA9PT0gXCJpbmxpbmVcIiA/IHRoaXMuX29wZW5Qb3BvdmVyKHRoaXMuX2dldFBvcG92ZXJUZW1wbGF0ZSgpKSA6IHRoaXMuX29wZW5Nb2RhbCh0aGlzLl9nZXRNb2RhbFRlbXBsYXRlKCkpLCB0aGlzLl9oYW5kbGVDYW5jZWxCdXR0b25DbGljaygpLCB0aGlzLl9oYW5kbGVDb25maXJtQnV0dG9uQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9Fc2NhcGVLZXkoKSwgdGhpcy5fbGlzdGVuVG9PdXRzaWRlQ2xpY2soKSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2lzT3Blbikge1xuICAgICAgaWYgKHRoaXMuX3BvcHBlciAhPT0gbnVsbCB8fCBkLmZpbmRPbmUoYFske1NvfV1gKSAhPT0gbnVsbClcbiAgICAgICAgYy5vbihcbiAgICAgICAgICB0aGlzLnBvcGNvbmZpcm1Cb2R5LFxuICAgICAgICAgIFwidHJhbnNpdGlvbmVuZFwiLFxuICAgICAgICAgIHRoaXMuX2hhbmRsZVBvcGNvbmZpcm1UcmFuc2l0aW9uRW5kLmJpbmQodGhpcylcbiAgICAgICAgKSwgaC5yZW1vdmVDbGFzcyh0aGlzLnBvcGNvbmZpcm1Cb2R5LCBcIm9wYWNpdHktMTAwXCIpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske3psfV1gXG4gICAgICAgICk7XG4gICAgICAgIGgucmVtb3ZlQ2xhc3ModGhpcy5wb3Bjb25maXJtQm9keSwgXCJvcGFjaXR5LTEwMFwiKSwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0KSwgdGhpcy5faXNPcGVuID0gITE7XG4gICAgICB9XG4gICAgICBjLm9mZihkb2N1bWVudCwgXCJjbGlja1wiLCB0aGlzLl9oYW5kbGVPdXRzaWRlQ2xpY2suYmluZCh0aGlzKSksIGMub2ZmKGRvY3VtZW50LCBcImtleWRvd25cIiwgdGhpcy5faGFuZGxlRXNjYXBlS2V5LmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlUG9wY29uZmlybVRyYW5zaXRpb25FbmQodCkge1xuICAgIGlmICh0LnRhcmdldCAhPT0gdGhpcy5wb3Bjb25maXJtQm9keSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKFxuICAgICAgYFske1NvfV1gXG4gICAgKTtcbiAgICBjLm9mZih0aGlzLnBvcGNvbmZpcm1Cb2R5LCBcInRyYW5zaXRpb25lbmRcIiksIHRoaXMuX2lzT3BlbiAmJiB0ICYmIHQucHJvcGVydHlOYW1lID09PSBcIm9wYWNpdHlcIiAmJiAodGhpcy5fcG9wcGVyLmRlc3Ryb3koKSwgZSAmJiBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGUpLCB0aGlzLl9pc09wZW4gPSAhMSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0UG9wb3ZlclRlbXBsYXRlKCkge1xuICAgIGNvbnN0IHQgPSAkKFwiZGl2XCIpLCBlID0gdGhpcy5fZ2V0UG9wY29uZmlybVRlbXBsYXRlKCk7XG4gICAgcmV0dXJuIHQuc2V0QXR0cmlidXRlKFNvLCBcIlwiKSwgaC5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLnBvcG92ZXIpLCB0LmlkID0gdGhpcy5fdWlkLCB0LmlubmVySFRNTCA9IGUsIHQ7XG4gIH1cbiAgX2dldE1vZGFsVGVtcGxhdGUoKSB7XG4gICAgY29uc3QgdCA9ICQoXCJkaXZcIiksIGUgPSB0aGlzLl9nZXRQb3Bjb25maXJtVGVtcGxhdGUoKTtcbiAgICByZXR1cm4gdC5zZXRBdHRyaWJ1dGUoUkUsIFwiXCIpLCBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMubW9kYWx9YCksIHQuaWQgPSB0aGlzLl91aWQsIHQuaW5uZXJIVE1MID0gZSwgdDtcbiAgfVxuICBfZ2V0UG9wY29uZmlybVRlbXBsYXRlKCkge1xuICAgIHJldHVybiBgPGRpdiBkYXRhLXRlLXBvcGNvbmZpcm0tYm9keSBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5ib2R5fVwiPlxuICAgICAgPHAgY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMubWVzc2FnZX1cIj5cbiAgICAgICR7dGhpcy5fb3B0aW9ucy5wb3Bjb25maXJtSWNvblRlbXBsYXRlID8gYDxzcGFuIGNsYXNzPVwiJHt0aGlzLl9jbGFzc2VzLmljb259XCI+JHt0aGlzLl9vcHRpb25zLnBvcGNvbmZpcm1JY29uVGVtcGxhdGV9PC9zcGFuPmAgOiBcIlwifVxuICAgICAgPHNwYW4gY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMubWVzc2FnZVRleHR9XCI+JHt0aGlzLl9vcHRpb25zLm1lc3NhZ2V9PC9zcGFuPlxuICAgICAgPC9wPlxuICAgICAgPGRpdiBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5idG5zQ29udGFpbmVyfVwiPlxuICAgICAgJHt0aGlzLl9vcHRpb25zLmNhbmNlbFRleHQgPyBgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS10ZS1yaXBwbGUtaW5pdCBkYXRhLXRlLXJpcHBsZS1jb2xvcj1cImxpZ2h0XCIgaWQ9XCJwb3Bjb25maXJtLWJ1dHRvbi1jYW5jZWxcIiBhcmlhLWxhYmVsPVwiJHt0aGlzLl9vcHRpb25zLmNhbmNlbExhYmVsfVwiXG4gICAgICAgIGNsYXNzPVwiJHt0aGlzLl9jbGFzc2VzLmJ0bkNhbmNlbH1cIj4ke3RoaXMuX29wdGlvbnMuY2FuY2VsVGV4dH08L2J1dHRvbj5gIDogXCJcIn1cbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtdGUtcmlwcGxlLWluaXQgZGF0YS10ZS1yaXBwbGUtY29sb3I9XCJsaWdodFwiIGlkPVwicG9wY29uZmlybS1idXR0b24tY29uZmlybVwiXG4gICAgICBhcmlhLWxhYmVsPVwiJHt0aGlzLl9vcHRpb25zLmNvbmZpcm1MYWJlbH1cIlxuICAgICAgY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMuYnRuQ29uZmlybX1cIj4ke3RoaXMuX29wdGlvbnMub2tUZXh0ID8gdGhpcy5fb3B0aW9ucy5va1RleHQgOiBcIk9rXCJ9PC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5gO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uQkUsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH0sIEkoT28sIHQsIFBFKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlZFLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKE9vLCB0LCBIRSksIHQ7XG4gIH1cbiAgX29wZW5Qb3BvdmVyKHQpIHtcbiAgICB0aGlzLl9wb3BwZXIgPSBzZSh0aGlzLl9lbGVtZW50LCB0LCB7XG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuX3RyYW5zbGF0ZVBvc2l0aW9uVmFsdWUoKSxcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCA1XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGguYWRkQ2xhc3MoXG4gICAgICAgIHRoaXMucG9wY29uZmlybUJvZHksXG4gICAgICAgIGAke3RoaXMuX2NsYXNzZXMuZmFkZX0gb3BhY2l0eS0xMDBgXG4gICAgICApLCB0aGlzLl9pc09wZW4gPSAhMDtcbiAgICB9LCAwKTtcbiAgfVxuICBfb3Blbk1vZGFsKHQpIHtcbiAgICBjb25zdCBlID0gJChcImRpdlwiKTtcbiAgICBlLnNldEF0dHJpYnV0ZSh6bCwgXCJcIiksIGguYWRkQ2xhc3MoZSwgdGhpcy5fY2xhc3Nlcy5iYWNrZHJvcCksIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZSksIGUuYXBwZW5kQ2hpbGQodCksIGguYWRkQ2xhc3ModGhpcy5wb3Bjb25maXJtQm9keSwgXCJvcGFjaXR5LTEwMFwiKSwgdGhpcy5faXNPcGVuID0gITA7XG4gIH1cbiAgX2hhbmRsZUNhbmNlbEJ1dHRvbkNsaWNrKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICB0aGlzLl9jYW5jZWxCdXR0b24gPSBkLmZpbmRPbmUoXG4gICAgICBcIiNwb3Bjb25maXJtLWJ1dHRvbi1jYW5jZWxcIixcbiAgICAgIHRcbiAgICApLCBlaS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMuX2NhbmNlbEJ1dHRvbiwgeyByaXBwbGVDb2xvcjogXCJsaWdodFwiIH0pLCB0aGlzLl9jYW5jZWxCdXR0b24gIT09IG51bGwgJiYgYy5vbih0aGlzLl9jYW5jZWxCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZSgpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgTEUpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVDb25maXJtQnV0dG9uQ2xpY2soKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY29udGFpbmVyO1xuICAgIHRoaXMuX2NvbmZpcm1CdXR0b24gPSBkLmZpbmRPbmUoXG4gICAgICBcIiNwb3Bjb25maXJtLWJ1dHRvbi1jb25maXJtXCIsXG4gICAgICB0XG4gICAgKSwgZWkuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLl9jb25maXJtQnV0dG9uLCB7IHJpcHBsZUNvbG9yOiBcImxpZ2h0XCIgfSksIGMub24odGhpcy5fY29uZmlybUJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmNsb3NlKCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBORSk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvRXNjYXBlS2V5KCkge1xuICAgIGMub24oZG9jdW1lbnQsIFwia2V5ZG93blwiLCB0aGlzLl9oYW5kbGVFc2NhcGVLZXkuYmluZCh0aGlzKSk7XG4gIH1cbiAgX2hhbmRsZUVzY2FwZUtleSh0KSB7XG4gICAgdC5rZXlDb2RlID09PSB3ZSAmJiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgX2xpc3RlblRvT3V0c2lkZUNsaWNrKCkge1xuICAgIGMub24oZG9jdW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5faGFuZGxlT3V0c2lkZUNsaWNrLmJpbmQodGhpcykpO1xuICB9XG4gIF9oYW5kbGVPdXRzaWRlQ2xpY2sodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNvbnRhaW5lciwgaSA9IHQudGFyZ2V0ID09PSBlLCBuID0gZSAmJiBlLmNvbnRhaW5zKHQudGFyZ2V0KSwgbyA9IHQudGFyZ2V0ID09PSB0aGlzLl9lbGVtZW50LCByID0gdGhpcy5fZWxlbWVudCAmJiB0aGlzLl9lbGVtZW50LmNvbnRhaW5zKHQudGFyZ2V0KTtcbiAgICAhaSAmJiAhbiAmJiAhbyAmJiAhciAmJiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgX3RyYW5zbGF0ZVBvc2l0aW9uVmFsdWUoKSB7XG4gICAgc3dpdGNoICh0aGlzLl9vcHRpb25zLnBvc2l0aW9uKSB7XG4gICAgICBjYXNlIFwidG9wIGxlZnRcIjpcbiAgICAgICAgcmV0dXJuIFwidG9wLWVuZFwiO1xuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICByZXR1cm4gXCJ0b3BcIjtcbiAgICAgIGNhc2UgXCJ0b3AgcmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIFwidG9wLXN0YXJ0XCI7XG4gICAgICBjYXNlIFwiYm90dG9tIGxlZnRcIjpcbiAgICAgICAgcmV0dXJuIFwiYm90dG9tLWVuZFwiO1xuICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICByZXR1cm4gXCJib3R0b21cIjtcbiAgICAgIGNhc2UgXCJib3R0b20gcmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIFwiYm90dG9tLXN0YXJ0XCI7XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0XCI7XG4gICAgICBjYXNlIFwibGVmdCB0b3BcIjpcbiAgICAgICAgcmV0dXJuIFwibGVmdC1lbmRcIjtcbiAgICAgIGNhc2UgXCJsZWZ0IGJvdHRvbVwiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0LXN0YXJ0XCI7XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIFwicmlnaHRcIjtcbiAgICAgIGNhc2UgXCJyaWdodCB0b3BcIjpcbiAgICAgICAgcmV0dXJuIFwicmlnaHQtZW5kXCI7XG4gICAgICBjYXNlIFwicmlnaHQgYm90dG9tXCI6XG4gICAgICAgIHJldHVybiBcInJpZ2h0LXN0YXJ0XCI7XG4gICAgICBjYXNlIHZvaWQgMDpcbiAgICAgICAgcmV0dXJuIFwiYm90dG9tXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJib3R0b21cIjtcbiAgICB9XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBpID0gQS5nZXREYXRhKHRoaXMsIHhpKSwgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSkge1xuICAgICAgICBpZiAoIWkpXG4gICAgICAgICAgcmV0dXJuIG5ldyBXaCh0aGlzLCBuKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICAgIGlbdF0oZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgeGkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IElvID0gXCJsaWdodGJveFwiLCBPaSA9IFwidGUubGlnaHRib3hcIiwgV0UgPSBgLiR7T2l9YCwgRkUgPSBcIi5kYXRhLWFwaVwiLCBNZSA9IGBjbGljayR7V0V9JHtGRX1gLCBGaCA9IFwiW2RhdGEtdGUtbGlnaHRib3gtaW5pdF1cIiwgWUUgPSBgJHtGaH0gaW1nOm5vdChbZGF0YS10ZS1saWdodGJveC1kaXNhYmxlZF0pYCwgVWwgPSBcImRhdGEtdGUtbGlnaHRib3gtY2FwdGlvblwiLCBqRSA9IFwiZGF0YS10ZS1saWdodGJveC1kaXNhYmxlZFwiLCBEdCA9IFwiZGF0YS10ZS1saWdodGJveC1hY3RpdmVcIiwgS0UgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTkuNSAxMmgtMTVtMCAwbDYuNzUgNi43NU00LjUgMTJsNi43NS02Ljc1XCIgLz5cbjwvc3ZnPlxuYCwgekUgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNC41IDEyaDE1bTAgMGwtNi43NS02Ljc1TTE5LjUgMTJsLTYuNzUgNi43NVwiIC8+XG48L3N2Zz5cbmAsIFVFID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0zLjc1IDMuNzV2NC41bTAtNC41aDQuNW0tNC41IDBMOSA5TTMuNzUgMjAuMjV2LTQuNW0wIDQuNWg0LjVtLTQuNSAwTDkgMTVNMjAuMjUgMy43NWgtNC41bTQuNSAwdjQuNW0wLTQuNUwxNSA5bTUuMjUgMTEuMjVoLTQuNW00LjUgMHYtNC41bTAgNC41TDE1IDE1XCIgLz5cbjwvc3ZnPlxuYCwgWEUgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTkgOVY0LjVNOSA5SDQuNU05IDlMMy43NSAzLjc1TTkgMTV2NC41TTkgMTVINC41TTkgMTVsLTUuMjUgNS4yNU0xNSA5aDQuNU0xNSA5VjQuNU0xNSA5bDUuMjUtNS4yNU0xNSAxNWg0LjVNMTUgMTV2NC41bTAtNC41bDUuMjUgNS4yNVwiIC8+XG48L3N2Zz5cbmAsIEdFID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0yMSAyMWwtNS4xOTctNS4xOTdtMCAwQTcuNSA3LjUgMCAxMDUuMTk2IDUuMTk2YTcuNSA3LjUgMCAwMDEwLjYwNyAxMC42MDd6TTEwLjUgNy41djZtMy0zaC02XCIgLz5cbjwvc3ZnPlxuYCwgcUUgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0yMSAyMWwtNS4xOTctNS4xOTdtMCAwQTcuNSA3LjUgMCAxMDUuMTk2IDUuMTk2YTcuNSA3LjUgMCAwMDEwLjYwNyAxMC42MDd6TTEzLjUgMTAuNWgtNlwiIC8+XG48L3N2Zz5cbmAsIFpFID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk02IDE4TDE4IDZNNiA2bDEyIDEyXCIgLz5cbjwvc3ZnPlxuYCwgUUUgPSB7XG4gIGNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgem9vbUxldmVsOiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBwcmV2SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBuZXh0SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBzaG93RnVsbHNjcmVlbkljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgaGlkZUZ1bGxzY3JlZW5JY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHpvb21Jbkljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgY2xvc2VJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHpvb21PdXRJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHNwaW5uZXJDb250ZW50OiBcInN0cmluZ1wiXG59LCBKRSA9IHtcbiAgY29udGFpbmVyOiBcImJvZHlcIixcbiAgem9vbUxldmVsOiAxLFxuICBwcmV2SWNvblRlbXBsYXRlOiBLRSxcbiAgbmV4dEljb25UZW1wbGF0ZTogekUsXG4gIHNob3dGdWxsc2NyZWVuSWNvblRlbXBsYXRlOiBVRSxcbiAgaGlkZUZ1bGxzY3JlZW5JY29uVGVtcGxhdGU6IFhFLFxuICB6b29tSW5JY29uVGVtcGxhdGU6IEdFLFxuICB6b29tT3V0SWNvblRlbXBsYXRlOiBxRSxcbiAgY2xvc2VJY29uVGVtcGxhdGU6IFpFLFxuICBzcGlubmVyQ29udGVudDogXCJMb2FkaW5nLi4uXCJcbn0sIHQwID0ge1xuICBjYXB0aW9uOiBcInRleHQtd2hpdGUgdGV4dC1lbGxpcHNpcyBvdmVyZmxvdy1oaWRkZW4gd2hpdGVzcGFjZS1ub3dyYXAgbXgtWzEwcHhdIHRleHQtY2VudGVyXCIsXG4gIGNhcHRpb25XcmFwcGVyOiBcImZpeGVkIGxlZnQtMCBib3R0b20tMCB3LWZ1bGwgaC1bNTBweF0gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXJcIixcbiAgY2xvc2VCdG46IFwiYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdy1bNTBweF0gaC1bNTBweF0gcHgtNCB0ZXh0LVsjYjNiM2IzXSB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgZWFzZS1pbi1vdXQgaG92ZXI6dGV4dC13aGl0ZSBmb2N1czp0ZXh0LXdoaXRlIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG91dGxpbmUtbm9uZVwiLFxuICBmdWxsc2NyZWVuQnRuOiBcImJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHctWzUwcHhdIGgtWzUwcHhdIHB4LTQgdGV4dC1bI2IzYjNiM10gdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0IGhvdmVyOnRleHQtd2hpdGUgZm9jdXM6dGV4dC13aGl0ZSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBvdXRsaW5lLW5vbmVcIixcbiAgZ2FsbGVyeTogXCJpbnZpc2libGUgZml4ZWQgbGVmdC0wIHRvcC0wIHctZnVsbCBoLWZ1bGwgei1bMTEwMF0gcG9pbnRlci1ldmVudHMtbm9uZSBvcGFjaXR5LTAgYmctWyMwMDAwMDBlNl0gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tWzQwMG1zXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICBnYWxsZXJ5Q29udGVudDogXCJmaXhlZCB0b3AtWzUwcHhdIGxlZnQtWzUwcHhdIHctW2NhbGMoMTAwJS0xMDBweCldIGgtW2NhbGMoMTAwJS0xMDBweCldXCIsXG4gIGdhbGxlcnlDb3VudGVyOiBcImZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHB4LVsxMHB4XSBtYi0wIGgtZnVsbCB0ZXh0LVsjYjNiM2IzXVwiLFxuICBpbWc6IFwiYWJzb2x1dGUgbGVmdC0wIHRvcC0wIHctZnVsbCBtYXgtaC1mdWxsIGgtYXV0byBjdXJzb3ItcG9pbnRlciBwb2ludGVyLWV2ZW50cy1hdXRvXCIsXG4gIGltZ1dyYXBwZXI6IFwiYWJzb2x1dGUgdG9wLTAgbGVmdC0wIHctZnVsbCBoLWZ1bGwgb3BhY2l0eS0wIHRyYW5zZm9ybSBzY2FsZS1bMC4yNV0gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tWzQwMG1zXSBlYXNlLW91dCBwb2ludGVyLWV2ZW50cy1ub25lIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6dHJhbnNmb3JtLW5vbmVcIixcbiAgbGVmdFRvb2xzOiBcImZsb2F0LWxlZnQgaC1mdWxsXCIsXG4gIGxvYWRlcjogXCJmaXhlZCBsZWZ0LTAgdG9wLTAgei1bMl0gdy1mdWxsIGgtZnVsbCB0ZXh0LW5ldXRyYWwtNTAgb3BhY2l0eS0xIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHBvaW50ZXItZXZlbnRzLW5vbmUgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLVsxMDAwbXNdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIG5leHRCdG46IFwiYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdy1mdWxsIGgtWzUwcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHRleHQtWyNiM2IzYjNdIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBlYXNlLWluLW91dCBob3Zlcjp0ZXh0LXdoaXRlIGZvY3VzOnRleHQtd2hpdGUgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgb3V0bGluZS1ub25lXCIsXG4gIG5leHRCdG5XcmFwcGVyOiBcImZpeGVkIHJpZ2h0LTAgdG9wLTAgdy1bNTBweF0gaC1mdWxsIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi1bNDAwbXNdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIHByZXZCdG46IFwiYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdy1mdWxsIGgtWzUwcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHRleHQtWyNiM2IzYjNdIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBlYXNlLWluLW91dCBob3Zlcjp0ZXh0LXdoaXRlIGZvY3VzOnRleHQtd2hpdGUgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgb3V0bGluZS1ub25lXCIsXG4gIHByZXZCdG5XcmFwcGVyOiBcImZpeGVkIGxlZnQtMCB0b3AtMCB3LVs1MHB4XSBoLWZ1bGwgZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLVs0MDBtc10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIixcbiAgcmlnaHRUb29sczogXCJmbG9hdC1yaWdodFwiLFxuICBzcGlubmVyOiBcImlubGluZS1ibG9jayBoLTggdy04IGFuaW1hdGUtW3NwaW5uZXItZ3Jvd18wLjc1c19saW5lYXJfaW5maW5pdGVdIHJvdW5kZWQtZnVsbCBiZy1jdXJyZW50IGFsaWduLVstMC4xMjVlbV0gbW90aW9uLXJlZHVjZTphbmltYXRlLVtzcGlubmVyLWdyb3dfMS41c19saW5lYXJfaW5maW5pdGVdXCIsXG4gIHNwaW5uZXJDb250ZW50OiBcIiFhYnNvbHV0ZSAhLW0tcHggIWgtcHggIXctcHggIW92ZXJmbG93LWhpZGRlbiAhd2hpdGVzcGFjZS1ub3dyYXAgIWJvcmRlci0wICFwLTAgIVtjbGlwOnJlY3QoMCwwLDAsMCldXCIsXG4gIHRvb2xiYXI6IFwiYWJzb2x1dGUgdG9wLTAgbGVmdC0wIHctZnVsbCBoLVs1MHB4XSB6LTIwIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi1bNDAwbXNdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIHZlcnRpY2FsOiBcImgtZnVsbCBtYXgtaC1mdWxsIHctYXV0b1wiLFxuICB6b29tQnRuOiBcImJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHctWzUwcHhdIGgtWzUwcHhdIHB4LTQgdGV4dC1bI2IzYjNiM10gdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0IGhvdmVyOnRleHQtd2hpdGUgZm9jdXM6dGV4dC13aGl0ZSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBvdXRsaW5lLW5vbmVcIlxufSwgZTAgPSB7XG4gIGNhcHRpb246IFwic3RyaW5nXCIsXG4gIGNhcHRpb25XcmFwcGVyOiBcInN0cmluZ1wiLFxuICBjbG9zZUJ0bjogXCJzdHJpbmdcIixcbiAgZnVsbHNjcmVlbkJ0bjogXCJzdHJpbmdcIixcbiAgZ2FsbGVyeTogXCJzdHJpbmdcIixcbiAgZ2FsbGVyeUNvbnRlbnQ6IFwic3RyaW5nXCIsXG4gIGdhbGxlcnlDb3VudGVyOiBcInN0cmluZ1wiLFxuICBpbWc6IFwic3RyaW5nXCIsXG4gIGltZ1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGxlZnRUb29sczogXCJzdHJpbmdcIixcbiAgbG9hZGVyOiBcInN0cmluZ1wiLFxuICBuZXh0QnRuOiBcInN0cmluZ1wiLFxuICBuZXh0QnRuV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgcHJldkJ0bjogXCJzdHJpbmdcIixcbiAgcHJldkJ0bldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHJpZ2h0VG9vbHM6IFwic3RyaW5nXCIsXG4gIHNwaW5uZXI6IFwic3RyaW5nXCIsXG4gIHNwaW5uZXJDb250ZW50OiBcInN0cmluZ1wiLFxuICB0b29sYmFyOiBcInN0cmluZ1wiLFxuICB2ZXJ0aWNhbDogXCJzdHJpbmdcIixcbiAgem9vbUJ0bjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIG5uIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSBlLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fZ2V0Q29udGFpbmVyKCksIHRoaXMuX2lkID0gYGxpZ2h0Ym94LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWAsIHRoaXMuX2FjdGl2ZUltZyA9IDAsIHRoaXMuX2ltYWdlcyA9IFtdLCB0aGlzLl96b29tID0gMSwgdGhpcy5fZ2FsbGVyeSA9IG51bGwsIHRoaXMuX2dhbGxlcnlUb29sYmFyID0gbnVsbCwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQgPSBudWxsLCB0aGlzLl9sb2FkZXIgPSBudWxsLCB0aGlzLl9pbWdDb3VudGVyID0gbnVsbCwgdGhpcy5fYW5pbWF0aW5nID0gITEsIHRoaXMuX2Z1bGxzY3JlZW4gPSAhMSwgdGhpcy5fem9vbUJ0biA9IG51bGwsIHRoaXMuX2Z1bGxzY3JlZW5CdG4gPSBudWxsLCB0aGlzLl90b29sc1RvZ2dsZVRpbWVyID0gMCwgdGhpcy5fbW91c2Vkb3duID0gITEsIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWCA9IDAsIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWSA9IDAsIHRoaXMuX29yaWdpbmFsUG9zaXRpb25YID0gMCwgdGhpcy5fb3JpZ2luYWxQb3NpdGlvblkgPSAwLCB0aGlzLl9wb3NpdGlvblggPSAwLCB0aGlzLl9wb3NpdGlvblkgPSAwLCB0aGlzLl96b29tVGltZXIgPSAwLCB0aGlzLl90YXBDb3VudGVyID0gMCwgdGhpcy5fdGFwVGltZSA9IDAsIHRoaXMuX3JpZ2h0QXJyb3cgPSBudWxsLCB0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyID0gbnVsbCwgdGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIgPSBudWxsLCB0aGlzLl9pbml0aWF0ZWQgPSAhMSwgdGhpcy5fbXVsdGl0b3VjaCA9ICExLCB0aGlzLl90b3VjaFpvb21Qb3NpdGlvbiA9IFtdLCB0aGlzLl9lbGVtZW50ICYmIChBLnNldERhdGEodCwgT2ksIHRoaXMpLCB0aGlzLmluaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIElvO1xuICB9XG4gIGdldCBhY3RpdmVJbWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUltZztcbiAgfVxuICBnZXQgY3VycmVudEltZygpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFxuICAgICAgYFske0R0fV1gLFxuICAgICAgdGhpcy5fZ2FsbGVyeUNvbnRlbnRcbiAgICApO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICAuLi5KRSxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50aGlzLl9vcHRpb25zXG4gICAgfTtcbiAgICByZXR1cm4gSShJbywgdCwgUUUpLCB0O1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX2luaXRpYXRlZCB8fCAodGhpcy5fYXBwZW5kVGVtcGxhdGUoKSwgdGhpcy5faW5pdGlhdGVkID0gITApO1xuICB9XG4gIG9wZW4odCA9IDApIHtcbiAgICB0aGlzLl9nZXRJbWFnZXMoKSwgdGhpcy5fc2V0QWN0aXZlSW1nKHQpLCB0aGlzLl9zb3J0SW1hZ2VzKCksIHRoaXMuX3RyaWdnZXJFdmVudHMoXCJvcGVuXCIsIFwib3BlbmVkXCIpLCB0aGlzLl9sb2FkSW1hZ2VzKCkudGhlbigoZSkgPT4ge1xuICAgICAgdGhpcy5fcmVzaXplSW1hZ2VzKGUpLCB0aGlzLl90b2dnbGVUZW1wbGF0ZSgpLCB0aGlzLl9hZGRFdmVudHMoKSwgdGhpcy5fZm9jdXNGdWxsc2NyZWVuQnRuKCk7XG4gICAgfSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5yZXNldCgpLCB0aGlzLl9yZW1vdmVFdmVudHMoKSwgdGhpcy5fdG9nZ2xlVGVtcGxhdGUoKSwgdGhpcy5fdHJpZ2dlckV2ZW50cyhcImNsb3NlXCIsIFwiY2xvc2VkXCIpO1xuICB9XG4gIHNsaWRlKHQgPSBcInJpZ2h0XCIpIHtcbiAgICB0aGlzLl9hbmltYXRpbmcgPT09ICEwIHx8IHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSB8fCAodGhpcy5fdHJpZ2dlckV2ZW50cyhcInNsaWRlXCIsIFwic2xpZGVkXCIpLCB0aGlzLl9iZWZvcmVTbGlkZUV2ZW50cygpLCB0ID09PSBcInJpZ2h0XCIgJiYgdGhpcy5fc2xpZGVIb3Jpem9udGFsbHkodCksIHQgPT09IFwibGVmdFwiICYmIHRoaXMuX3NsaWRlSG9yaXpvbnRhbGx5KHQpLCB0ID09PSBcImZpcnN0XCIgJiYgdGhpcy5fc2xpZGVUb1RhcmdldCh0KSwgdCA9PT0gXCJsYXN0XCIgJiYgdGhpcy5fc2xpZGVUb1RhcmdldCh0KSwgdGhpcy5fYWZ0ZXJTbGlkZUV2ZW50cygpKTtcbiAgfVxuICB6b29tSW4oKSB7XG4gICAgdGhpcy5fem9vbSA+PSAzIHx8ICh0aGlzLl90cmlnZ2VyRXZlbnRzKFwiem9vbUluXCIsIFwiem9vbWVkSW5cIiksIHRoaXMuX3pvb20gKz0gcGFyc2VGbG9hdCh0aGlzLm9wdGlvbnMuem9vbUxldmVsKSwgaC5zdHlsZSh0aGlzLmN1cnJlbnRJbWcucGFyZW50Tm9kZSwge1xuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHt0aGlzLl96b29tfSlgXG4gICAgfSksIHRoaXMuX3VwZGF0ZVpvb21CdG4oKSk7XG4gIH1cbiAgem9vbU91dCgpIHtcbiAgICB0aGlzLl96b29tIDw9IDEgfHwgKHRoaXMuX3RyaWdnZXJFdmVudHMoXCJ6b29tT3V0XCIsIFwiem9vbWVkT3V0XCIpLCB0aGlzLl96b29tIC09IHBhcnNlRmxvYXQodGhpcy5vcHRpb25zLnpvb21MZXZlbCksIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7dGhpcy5fem9vbX0pYFxuICAgIH0pLCB0aGlzLl91cGRhdGVab29tQnRuKCksIHRoaXMuX3VwZGF0ZUltZ1Bvc2l0aW9uKCkpO1xuICB9XG4gIHRvZ2dsZUZ1bGxzY3JlZW4oKSB7XG4gICAgdGhpcy5fZnVsbHNjcmVlbiA9PT0gITEgPyAodGhpcy5fZnVsbHNjcmVlbkJ0bi5zZXRBdHRyaWJ1dGUoRHQsIFwiXCIpLCB0aGlzLl9mdWxsc2NyZWVuQnRuLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5oaWRlRnVsbHNjcmVlbkljb25UZW1wbGF0ZSwgdGhpcy5fZ2FsbGVyeS5yZXF1ZXN0RnVsbHNjcmVlbiAmJiB0aGlzLl9nYWxsZXJ5LnJlcXVlc3RGdWxsc2NyZWVuKCksIHRoaXMuX2Z1bGxzY3JlZW4gPSAhMCkgOiAodGhpcy5fZnVsbHNjcmVlbkJ0bi5yZW1vdmVBdHRyaWJ1dGUoRHQpLCBkb2N1bWVudC5leGl0RnVsbHNjcmVlbiAmJiBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpLCB0aGlzLl9mdWxsc2NyZWVuID0gITEpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc3RvcmVEZWZhdWx0RnVsbHNjcmVlbigpLCB0aGlzLl9yZXN0b3JlRGVmYXVsdFBvc2l0aW9uKCksIHRoaXMuX3Jlc3RvcmVEZWZhdWx0Wm9vbSgpLCBjbGVhclRpbWVvdXQodGhpcy5fdG9vbHNUb2dnbGVUaW1lciksIGNsZWFyVGltZW91dCh0aGlzLl9kb3VibGVUYXBUaW1lcik7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjLm9mZihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgTWUsXG4gICAgICBZRSxcbiAgICAgIHRoaXMudG9nZ2xlXG4gICAgKSwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQgJiYgdGhpcy5fcmVtb3ZlRXZlbnRzKCksIHRoaXMuX2dhbGxlcnkgJiYgdGhpcy5fZ2FsbGVyeS5yZW1vdmUoKSwgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIE9pKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnQwLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKElvLCB0LCBlMCksIHQ7XG4gIH1cbiAgX2dldEltYWdlcygpIHtcbiAgICBjb25zdCBlID0gZC5maW5kKFwiaW1nXCIsIHRoaXMuX2VsZW1lbnQpLmZpbHRlcihcbiAgICAgIChpKSA9PiAhaS5oYXNBdHRyaWJ1dGUoakUpXG4gICAgKTtcbiAgICB0aGlzLl9pbWFnZXMgPSBlO1xuICB9XG4gIF9nZXRDb250YWluZXIoKSB7XG4gICAgdGhpcy5fY29udGFpbmVyID0gZC5maW5kT25lKHRoaXMub3B0aW9ucy5jb250YWluZXIpO1xuICB9XG4gIF9zZXRBY3RpdmVJbWcodCkge1xuICAgIHRoaXMuX2FjdGl2ZUltZyA9IHR5cGVvZiB0ID09IFwibnVtYmVyXCIgPyB0IDogdGhpcy5faW1hZ2VzLmluZGV4T2YodC50YXJnZXQpO1xuICB9XG4gIF9hcHBlbmRUZW1wbGF0ZSgpIHtcbiAgICB0aGlzLl9nYWxsZXJ5ID0gJChcImRpdlwiKSwgaC5hZGRDbGFzcyh0aGlzLl9nYWxsZXJ5LCBgJHt0aGlzLl9jbGFzc2VzLmdhbGxlcnl9YCksIHRoaXMuX2VsZW1lbnQuZGF0YXNldC5pZCA9IHRoaXMuX2lkLCB0aGlzLl9nYWxsZXJ5LmlkID0gdGhpcy5faWQsIHRoaXMuX2FwcGVuZExvYWRlcigpLCB0aGlzLl9hcHBlbmRUb29sYmFyKCksIHRoaXMuX2FwcGVuZENvbnRlbnQoKSwgdGhpcy5fYXBwZW5kQXJyb3dzKCksIHRoaXMuX2FwcGVuZENhcHRpb24oKSwgdGhpcy5fY29udGFpbmVyLmFwcGVuZCh0aGlzLl9nYWxsZXJ5KTtcbiAgfVxuICBfYXBwZW5kVG9vbGJhcigpIHtcbiAgICB0aGlzLl9nYWxsZXJ5VG9vbGJhciA9ICQoXCJkaXZcIiksIHRoaXMuX2ltZ0NvdW50ZXIgPSAkKFwicFwiKSwgdGhpcy5fZnVsbHNjcmVlbkJ0biA9ICQoXCJidXR0b25cIiksIHRoaXMuX3pvb21CdG4gPSAkKFwiYnV0dG9uXCIpO1xuICAgIGNvbnN0IHQgPSAkKFwiYnV0dG9uXCIpLCBlID0gJChcImRpdlwiKSwgaSA9ICQoXCJkaXZcIik7XG4gICAgaC5hZGRDbGFzcyh0aGlzLl9nYWxsZXJ5VG9vbGJhciwgYCR7dGhpcy5fY2xhc3Nlcy50b29sYmFyfWApLCBoLmFkZENsYXNzKHRoaXMuX2ltZ0NvdW50ZXIsIGAke3RoaXMuX2NsYXNzZXMuZ2FsbGVyeUNvdW50ZXJ9YCksIGguYWRkQ2xhc3ModGhpcy5fZnVsbHNjcmVlbkJ0biwgYCR7dGhpcy5fY2xhc3Nlcy5mdWxsc2NyZWVuQnRufWApLCBoLmFkZENsYXNzKHRoaXMuX3pvb21CdG4sIGAke3RoaXMuX2NsYXNzZXMuem9vbUluQnRufWApLCBoLmFkZENsYXNzKHRoaXMuX3pvb21CdG4sIHRoaXMuX2NsYXNzZXMuem9vbUJ0biksIGguYWRkQ2xhc3MoZSwgYCR7dGhpcy5fY2xhc3Nlcy5sZWZ0VG9vbHN9YCksIGguYWRkQ2xhc3MoaSwgYCR7dGhpcy5fY2xhc3Nlcy5yaWdodFRvb2xzfWApLCBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMuY2xvc2VCdG59YCksIHRoaXMuX2Z1bGxzY3JlZW5CdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnNob3dGdWxsc2NyZWVuSWNvblRlbXBsYXRlLCB0LmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5jbG9zZUljb25UZW1wbGF0ZSwgdGhpcy5fem9vbUJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuem9vbUluSWNvblRlbXBsYXRlLCB0aGlzLl9mdWxsc2NyZWVuQnRuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJUb2dnbGUgZnVsbHNjcmVlblwiKSwgdGhpcy5fem9vbUJ0bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiWm9vbSBpblwiKSwgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiQ2xvc2VcIiksIGMub24oXG4gICAgICB0aGlzLl9mdWxsc2NyZWVuQnRuLFxuICAgICAgTWUsXG4gICAgICAoKSA9PiB0aGlzLnRvZ2dsZUZ1bGxzY3JlZW4oKVxuICAgICksIGMub24oXG4gICAgICB0aGlzLl96b29tQnRuLFxuICAgICAgTWUsXG4gICAgICAoKSA9PiB0aGlzLl90b2dnbGVab29tKClcbiAgICApLCBjLm9uKHQsIE1lLCAoKSA9PiB0aGlzLmNsb3NlKCkpLCBlLmFwcGVuZCh0aGlzLl9pbWdDb3VudGVyKSwgaS5hcHBlbmQodGhpcy5fZnVsbHNjcmVlbkJ0biksIGkuYXBwZW5kKHRoaXMuX3pvb21CdG4pLCBpLmFwcGVuZCh0KSwgdGhpcy5fZ2FsbGVyeVRvb2xiYXIuYXBwZW5kKGUpLCB0aGlzLl9nYWxsZXJ5VG9vbGJhci5hcHBlbmQoaSksIHRoaXMuX2dhbGxlcnkuYXBwZW5kKHRoaXMuX2dhbGxlcnlUb29sYmFyKTtcbiAgfVxuICBfYXBwZW5kQ29udGVudCgpIHtcbiAgICB0aGlzLl9nYWxsZXJ5Q29udGVudCA9ICQoXCJkaXZcIiksIGguYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9nYWxsZXJ5Q29udGVudCxcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMuZ2FsbGVyeUNvbnRlbnR9YFxuICAgICksIHRoaXMuX2dhbGxlcnkuYXBwZW5kKHRoaXMuX2dhbGxlcnlDb250ZW50KTtcbiAgfVxuICBfYXBwZW5kTG9hZGVyKCkge1xuICAgIHRoaXMuX2xvYWRlciA9ICQoXCJkaXZcIik7XG4gICAgY29uc3QgdCA9ICQoXCJkaXZcIiksIGUgPSAkKFwic3BhblwiKTtcbiAgICBoLmFkZENsYXNzKHRoaXMuX2xvYWRlciwgYCR7dGhpcy5fY2xhc3Nlcy5sb2FkZXJ9YCksIGguYWRkQ2xhc3ModCwgYCR7dGhpcy5fY2xhc3Nlcy5zcGlubmVyfWApLCBoLmFkZENsYXNzKGUsIGAke3RoaXMuX2NsYXNzZXMuc3Bpbm5lckNvbnRlbnR9YCksIHQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInN0YXR1c1wiKSwgZS5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuc3Bpbm5lckNvbnRlbnQsIHQuYXBwZW5kKGUpLCB0aGlzLl9sb2FkZXIuYXBwZW5kKHQpLCB0aGlzLl9nYWxsZXJ5LmFwcGVuZCh0aGlzLl9sb2FkZXIpO1xuICB9XG4gIF9hcHBlbmRBcnJvd3MoKSB7XG4gICAgdGhpcy5fbGVmdEFycm93V3JhcHBlciA9ICQoXCJkaXZcIiksIGguYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5wcmV2QnRuV3JhcHBlcn1gXG4gICAgKTtcbiAgICBjb25zdCB0ID0gJChcImJ1dHRvblwiKTtcbiAgICB0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJQcmV2aW91c1wiKSwgaC5hZGRDbGFzcyh0LCBgJHt0aGlzLl9jbGFzc2VzLnByZXZCdG59YCksIGMub24odCwgTWUsICgpID0+IHRoaXMuc2xpZGUoXCJsZWZ0XCIpKSwgdGhpcy5fbGVmdEFycm93V3JhcHBlci5hcHBlbmQodCksIHRoaXMuX3JpZ2h0QXJyb3dXcmFwcGVyID0gJChcImRpdlwiKSwgaC5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX3JpZ2h0QXJyb3dXcmFwcGVyLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5uZXh0QnRuV3JhcHBlcn1gXG4gICAgKSwgdGhpcy5fcmlnaHRBcnJvdyA9ICQoXCJidXR0b25cIiksIHRoaXMuX3JpZ2h0QXJyb3cuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIk5leHRcIiksIGguYWRkQ2xhc3ModGhpcy5fcmlnaHRBcnJvdywgYCR7dGhpcy5fY2xhc3Nlcy5uZXh0QnRufWApLCBjLm9uKHRoaXMuX3JpZ2h0QXJyb3csIE1lLCAoKSA9PiB0aGlzLnNsaWRlKCkpLCB0aGlzLl9yaWdodEFycm93V3JhcHBlci5hcHBlbmQodGhpcy5fcmlnaHRBcnJvdyksIHRoaXMuX3JpZ2h0QXJyb3cuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLm5leHRJY29uVGVtcGxhdGUsIHQuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnByZXZJY29uVGVtcGxhdGUsIHRoaXMuX2dldEltYWdlcygpLCAhKHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSkgJiYgKHRoaXMuX2dhbGxlcnkuYXBwZW5kKHRoaXMuX2xlZnRBcnJvd1dyYXBwZXIpLCB0aGlzLl9nYWxsZXJ5LmFwcGVuZCh0aGlzLl9yaWdodEFycm93V3JhcHBlcikpO1xuICB9XG4gIF9hcHBlbmRDYXB0aW9uKCkge1xuICAgIGNvbnN0IHQgPSAkKFwiZGl2XCIpLCBlID0gJChcInBcIik7XG4gICAgZS5zZXRBdHRyaWJ1dGUoVWwsIFwiXCIpLCBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMuY2FwdGlvbldyYXBwZXJ9YCksIGguYWRkQ2xhc3MoZSwgYCR7dGhpcy5fY2xhc3Nlcy5jYXB0aW9ufWApLCB0LmFwcGVuZChlKSwgdGhpcy5fZ2FsbGVyeS5hcHBlbmQodCk7XG4gIH1cbiAgX3NvcnRJbWFnZXMoKSB7XG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLl9hY3RpdmVJbWc7IHQrKylcbiAgICAgIHRoaXMuX2ltYWdlcy5wdXNoKHRoaXMuX2ltYWdlcy5zaGlmdCgpKTtcbiAgfVxuICBhc3luYyBfbG9hZEltYWdlcygpIHtcbiAgICBjb25zdCB0ID0gW10sIGUgPSBbXTtcbiAgICB0aGlzLl9nYWxsZXJ5Q29udGVudC5pbm5lckhUTUwgPSBcIlwiO1xuICAgIGxldCBpID0gMDtcbiAgICByZXR1cm4gdGhpcy5faW1hZ2VzLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgIHQucHVzaChcbiAgICAgICAgbmV3IFByb21pc2UoKHIpID0+IHtcbiAgICAgICAgICBjb25zdCBhID0gbmV3IEltYWdlKCksIGwgPSAkKFwiZGl2XCIpO1xuICAgICAgICAgIGguYWRkQ2xhc3MobCwgYCR7dGhpcy5fY2xhc3Nlcy5pbWdXcmFwcGVyfWApLCBoLmFkZENsYXNzKGEsIGAke3RoaXMuX2NsYXNzZXMuaW1nfWApLCB0aGlzLl9hZGRJbWdTdHlsZXMoYSwgbCwgaSwgbywgbiksIGwuYXBwZW5kKGEpLCB0aGlzLl9nYWxsZXJ5Q29udGVudC5hcHBlbmQobCksIGEub25sb2FkID0gciwgYS5zcmMgPSBuLmRhdGFzZXQudGVJbWcgfHwgbi5zcmMsIGUucHVzaChhKSwgaSArPSAxMDA7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pLCBhd2FpdCBQcm9taXNlLmFsbCh0KSwgZTtcbiAgfVxuICBfYWRkSW1nU3R5bGVzKHQsIGUsIGksIG4sIG8pIHtcbiAgICB0LmFsdCA9IG8uYWx0LCB0LmRyYWdnYWJsZSA9ICExLCBoLnN0eWxlKGUsIHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICBsZWZ0OiBgJHtpfSVgLFxuICAgICAgdG9wOiAwXG4gICAgfSksIChvLmRhdGFzZXQudGVDYXB0aW9uIHx8IG8uZGF0YXNldC50ZUNhcHRpb24gPT09IFwiXCIpICYmICh0LmRhdGFzZXQuY2FwdGlvbiA9IG8uZGF0YXNldC50ZUNhcHRpb24pLCBpID09PSAwID8gKG8ud2lkdGggPCBvLmhlaWdodCAmJiBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMudmVydGljYWx9YCksIGguc3R5bGUoZSwgeyBvcGFjaXR5OiAxIH0pLCB0LnNldEF0dHJpYnV0ZShEdCwgXCJcIikpIDogdC5yZW1vdmVBdHRyaWJ1dGUoRHQpLCBuID09PSB0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMSAmJiB0aGlzLl9pbWFnZXMubGVuZ3RoID4gMSAmJiBoLnN0eWxlKGUsIHsgbGVmdDogXCItMTAwJVwiIH0pO1xuICB9XG4gIF9yZXNpemVJbWFnZXModCkge1xuICAgIHQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgdGhpcy5fY2FsY3VsYXRlSW1nU2l6ZShlKTtcbiAgICB9KTtcbiAgfVxuICBfY2FsY3VsYXRlSW1nU2l6ZSh0KSB7XG4gICAgdC53aWR0aCA+PSB0LmhlaWdodCA/ICh0LnN0eWxlLndpZHRoID0gXCIxMDAlXCIsIHQuc3R5bGUubWF4V2lkdGggPSBcIjEwMCVcIiwgdC5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIiwgdC5zdHlsZS50b3AgPSBgJHsodC5wYXJlbnROb2RlLm9mZnNldEhlaWdodCAtIHQuaGVpZ2h0KSAvIDJ9cHhgLCB0LnN0eWxlLmxlZnQgPSAwKSA6ICh0LnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiLCB0LnN0eWxlLm1heEhlaWdodCA9IFwiMTAwJVwiLCB0LnN0eWxlLndpZHRoID0gXCJhdXRvXCIsIHQuc3R5bGUubGVmdCA9IGAkeyh0LnBhcmVudE5vZGUub2Zmc2V0V2lkdGggLSB0LndpZHRoKSAvIDJ9cHhgLCB0LnN0eWxlLnRvcCA9IDApLCB0LndpZHRoID49IHQucGFyZW50Tm9kZS5vZmZzZXRXaWR0aCAmJiAodC5zdHlsZS53aWR0aCA9IGAke3QucGFyZW50Tm9kZS5vZmZzZXRXaWR0aH1weGAsIHQuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCIsIHQuc3R5bGUubGVmdCA9IDAsIHQuc3R5bGUudG9wID0gYCR7KHQucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHQgLSB0LmhlaWdodCkgLyAyfXB4YCksIHQuaGVpZ2h0ID49IHQucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHQgJiYgKHQuc3R5bGUuaGVpZ2h0ID0gYCR7dC5wYXJlbnROb2RlLm9mZnNldEhlaWdodH1weGAsIHQuc3R5bGUud2lkdGggPSBcImF1dG9cIiwgdC5zdHlsZS50b3AgPSAwLCB0LnN0eWxlLmxlZnQgPSBgJHsodC5wYXJlbnROb2RlLm9mZnNldFdpZHRoIC0gdC53aWR0aCkgLyAyfXB4YCksIHRoaXMuX3Bvc2l0aW9uWCA9IHBhcnNlRmxvYXQodC5zdHlsZS5sZWZ0KSB8fCAwLCB0aGlzLl9wb3NpdGlvblkgPSBwYXJzZUZsb2F0KHQuc3R5bGUudG9wKSB8fCAwO1xuICB9XG4gIF9vblJlc2l6ZSgpIHtcbiAgICB0aGlzLl9pbWFnZXMgPSBkLmZpbmQoXCJpbWdcIiwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQpLCB0aGlzLl9pbWFnZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdGhpcy5fY2FsY3VsYXRlSW1nU2l6ZSh0KTtcbiAgICB9KTtcbiAgfVxuICBfb25GdWxsc2NyZWVuQ2hhbmdlKCkge1xuICAgIChkb2N1bWVudC53ZWJraXRJc0Z1bGxTY3JlZW4gfHwgZG9jdW1lbnQubW96RnVsbFNjcmVlbiB8fCBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50KSA9PT0gdm9pZCAwICYmICh0aGlzLl9mdWxsc2NyZWVuID0gITEsIHRoaXMuX2Z1bGxzY3JlZW5CdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnNob3dGdWxsc2NyZWVuSWNvblRlbXBsYXRlLCB0aGlzLl9mdWxsc2NyZWVuQnRuLnJlbW92ZUF0dHJpYnV0ZShEdCkpO1xuICB9XG4gIF9iZWZvcmVTbGlkZUV2ZW50cygpIHtcbiAgICB0aGlzLl9hbmltYXRpb25TdGFydCgpLCB0aGlzLl9yZXN0b3JlRGVmYXVsdFpvb20oKSwgdGhpcy5fcmVzdG9yZURlZmF1bHRQb3NpdGlvbigpLCB0aGlzLl9yZXNldERvdWJsZVRhcCgpO1xuICB9XG4gIF9zbGlkZUhvcml6b250YWxseSh0KSB7XG4gICAgdGhpcy5faW1hZ2VzID0gZC5maW5kKFwiaW1nXCIsIHRoaXMuX2dhbGxlcnlDb250ZW50KSwgdGhpcy5faW1hZ2VzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGxldCBpO1xuICAgICAgdCA9PT0gXCJyaWdodFwiID8gKGkgPSBwYXJzZUludChlLnBhcmVudE5vZGUuc3R5bGUubGVmdCwgMTApIC0gMTAwLCBpIDwgLTEwMCAmJiAoaSA9ICh0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMikgKiAxMDApKSA6IChpID0gcGFyc2VJbnQoZS5wYXJlbnROb2RlLnN0eWxlLmxlZnQsIDEwKSArIDEwMCwgaSA9PT0gKHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxKSAqIDEwMCAmJiAoaSA9IC0xMDApKSwgdGhpcy5fc2xpZGVJbWcoZSwgaSk7XG4gICAgfSksIHRoaXMuX3VwZGF0ZUFjdGl2ZUltZyh0KTtcbiAgfVxuICBfc2xpZGVJbWcodCwgZSkge1xuICAgIGUgPT09IDAgPyAodC5zZXRBdHRyaWJ1dGUoRHQsIFwiXCIpLCBoLnN0eWxlKHQucGFyZW50Tm9kZSwgeyBvcGFjaXR5OiAxLCB0cmFuc2Zvcm06IFwic2NhbGUoMSlcIiB9KSkgOiAodC5yZW1vdmVBdHRyaWJ1dGUoRHQpLCBoLnN0eWxlKHQucGFyZW50Tm9kZSwge1xuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwLjI1KVwiXG4gICAgfSkpLCB0LnBhcmVudE5vZGUuc3R5bGUubGVmdCA9IGAke2V9JWA7XG4gIH1cbiAgX3NsaWRlVG9UYXJnZXQodCkge1xuICAgIHQgPT09IFwiZmlyc3RcIiAmJiB0aGlzLl9hY3RpdmVJbWcgPT09IDAgfHwgdCA9PT0gXCJsYXN0XCIgJiYgdGhpcy5fYWN0aXZlSW1nID09PSB0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMSB8fCAodGhpcy5yZXNldCgpLCB0aGlzLl9yZW1vdmVFdmVudHMoKSwgdGhpcy5fc2hvd0xvYWRlcigpLCB0aGlzLl9nZXRJbWFnZXMoKSwgdGhpcy5fYWN0aXZlSW1nID0gdCA9PT0gXCJmaXJzdFwiID8gMCA6IHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxLCB0aGlzLl9zb3J0SW1hZ2VzKCksIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwLjI1KVwiLFxuICAgICAgb3BhY2l0eTogMFxuICAgIH0pLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2xvYWRJbWFnZXMoKS50aGVuKChlKSA9PiB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZUltYWdlcyhlKSwgdGhpcy5fYWRkRXZlbnRzKCksIHRoaXMuX3VwZGF0ZUNhcHRpb24oKSwgdGhpcy5faGlkZUxvYWRlcigpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBoLnN0eWxlKHRoaXMuY3VycmVudEltZy5wYXJlbnROb2RlLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMSlcIixcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgfSk7XG4gICAgfSwgNDAwKSk7XG4gIH1cbiAgX3VwZGF0ZUFjdGl2ZUltZyh0KSB7XG4gICAgdCA9PT0gXCJyaWdodFwiICYmICh0aGlzLl9hY3RpdmVJbWcgPT09IHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxID8gdGhpcy5fYWN0aXZlSW1nID0gMCA6IHRoaXMuX2FjdGl2ZUltZysrKSwgdCA9PT0gXCJsZWZ0XCIgJiYgKHRoaXMuX2FjdGl2ZUltZyA9PT0gMCA/IHRoaXMuX2FjdGl2ZUltZyA9IHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxIDogdGhpcy5fYWN0aXZlSW1nLS0pO1xuICB9XG4gIF9hZnRlclNsaWRlRXZlbnRzKCkge1xuICAgIHRoaXMuX3VwZGF0ZUNvdW50ZXIoKSwgdGhpcy5fdXBkYXRlQ2FwdGlvbigpO1xuICB9XG4gIF91cGRhdGVDb3VudGVyKCkge1xuICAgIHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSB8fCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2ltZ0NvdW50ZXIuaW5uZXJIVE1MID0gYCR7dGhpcy5fYWN0aXZlSW1nICsgMX0gLyAke3RoaXMuX2ltYWdlcy5sZW5ndGh9YDtcbiAgICB9LCAyMDApO1xuICB9XG4gIF91cGRhdGVDYXB0aW9uKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbGV0IHQgPSB0aGlzLmN1cnJlbnRJbWcuYWx0O1xuICAgICAgKHRoaXMuY3VycmVudEltZy5kYXRhc2V0LmNhcHRpb24gfHwgdGhpcy5jdXJyZW50SW1nLmRhdGFzZXQuY2FwdGlvbiA9PT0gXCJcIikgJiYgKHQgPSB0aGlzLmN1cnJlbnRJbWcuZGF0YXNldC5jYXB0aW9uKSwgZC5maW5kT25lKFxuICAgICAgICBgWyR7VWx9XWAsXG4gICAgICAgIHRoaXMuX2dhbGxlcnlcbiAgICAgICkuaW5uZXJIVE1MID0gdDtcbiAgICB9LCAyMDApO1xuICB9XG4gIF90b2dnbGVUZW1wbGF0ZSgpIHtcbiAgICB0aGlzLl9nYWxsZXJ5LnN0eWxlLnZpc2liaWxpdHkgPT09IFwidmlzaWJsZVwiID8gKGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwLjI1KVwiXG4gICAgfSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5faGlkZUdhbGxlcnkoKSwgdGhpcy5fZW5hYmxlU2Nyb2xsKCksIHRoaXMuX3Nob3dMb2FkZXIoKTtcbiAgICB9LCAxMDApKSA6ICh0aGlzLl9zaG93R2FsbGVyeSgpLCB0aGlzLl9kaXNhYmxlU2Nyb2xsKCksIHRoaXMuX3VwZGF0ZUNvdW50ZXIoKSwgdGhpcy5fdXBkYXRlQ2FwdGlvbigpLCB0aGlzLl9zZXRUb29sc1RvZ2dsZVRpbW91dCgpLCB0aGlzLl9oaWRlTG9hZGVyKCkpO1xuICB9XG4gIF9zaG93TG9hZGVyKCkge1xuICAgIGguc3R5bGUodGhpcy5fbG9hZGVyLCB7IG9wYWNpdHk6IDEgfSk7XG4gIH1cbiAgX2hpZGVMb2FkZXIoKSB7XG4gICAgaC5zdHlsZSh0aGlzLl9sb2FkZXIsIHsgb3BhY2l0eTogMCB9KTtcbiAgfVxuICBfaGlkZUdhbGxlcnkoKSB7XG4gICAgaC5zdHlsZSh0aGlzLl9nYWxsZXJ5LCB7XG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgICB2aXNpYmlsaXR5OiBcImhpZGRlblwiXG4gICAgfSk7XG4gIH1cbiAgX3Nob3dHYWxsZXJ5KCkge1xuICAgIGguc3R5bGUodGhpcy5fZ2FsbGVyeSwge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHBvaW50ZXJFdmVudHM6IFwiaW5pdGlhbFwiLFxuICAgICAgdmlzaWJpbGl0eTogXCJ2aXNpYmxlXCJcbiAgICB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBoLnN0eWxlKHRoaXMuY3VycmVudEltZy5wYXJlbnROb2RlLCB7IHRyYW5zZm9ybTogXCJzY2FsZSgxKVwiIH0pO1xuICAgIH0sIDUwKTtcbiAgfVxuICBfdG9nZ2xlWm9vbSgpIHtcbiAgICB0aGlzLl96b29tICE9PSAxID8gdGhpcy56b29tT3V0KCkgOiB0aGlzLnpvb21JbigpO1xuICB9XG4gIF91cGRhdGVab29tQnRuKCkge1xuICAgIHRoaXMuX3pvb20gPiAxID8gKHRoaXMuX3pvb21CdG4uc2V0QXR0cmlidXRlKER0LCBcIlwiKSwgdGhpcy5fem9vbUJ0bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiWm9vbSBvdXRcIiksIHRoaXMuX3pvb21CdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnpvb21PdXRJY29uVGVtcGxhdGUpIDogKHRoaXMuX3pvb21CdG4ucmVtb3ZlQXR0cmlidXRlKER0KSwgdGhpcy5fem9vbUJ0bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiWm9vbSBpblwiKSwgdGhpcy5fem9vbUJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuem9vbUluSWNvblRlbXBsYXRlKTtcbiAgfVxuICBfdXBkYXRlSW1nUG9zaXRpb24oKSB7XG4gICAgdGhpcy5fem9vbSA9PT0gMSAmJiB0aGlzLl9yZXN0b3JlRGVmYXVsdFBvc2l0aW9uKCk7XG4gIH1cbiAgX2FkZEV2ZW50cygpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKFwiaW1nXCIsIHRoaXMuX2dhbGxlcnlDb250ZW50KTtcbiAgICB0aGlzLl9vbldpbmRvd1RvdWNobW92ZSA9IHRoaXMuX29uV2luZG93VG91Y2htb3ZlLmJpbmQodGhpcyksIHRoaXMuX29uV2luZG93VG91Y2hzdGFydCA9IHRoaXMuX29uV2luZG93VG91Y2hzdGFydC5iaW5kKHRoaXMpLCB0aGlzLl9vbkltZ01vdXNlZG93biA9IHRoaXMuX29uTW91c2Vkb3duLmJpbmQodGhpcyksIHRoaXMuX29uSW1nTW91c2Vtb3ZlID0gdGhpcy5fb25Nb3VzZW1vdmUuYmluZCh0aGlzKSwgdGhpcy5fb25JbWdXaGVlbCA9IHRoaXMuX29uWm9vbS5iaW5kKHRoaXMpLCB0aGlzLl9vbkltZ01vdXNldXAgPSB0aGlzLl9vbk1vdXNldXAuYmluZCh0aGlzKSwgdGhpcy5fb25JbWdUb3VjaGVuZCA9IHRoaXMuX29uVG91Y2hlbmQuYmluZCh0aGlzKSwgdGhpcy5fb25JbWdEb3VibGVDbGljayA9IHRoaXMuX29uRG91YmxlQ2xpY2suYmluZCh0aGlzKSwgdGhpcy5fb25XaW5kb3dSZXNpemUgPSB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpLCB0aGlzLl9vbldpbmRvd0Z1bGxzY3JlZW5DaGFuZ2UgPSB0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2UuYmluZCh0aGlzKSwgdGhpcy5fb25BbnlJbWdBY3Rpb24gPSB0aGlzLl9yZXNldFRvb2xzVG9nZ2xlci5iaW5kKHRoaXMpLCB0aGlzLl9vbkdhbGxlcnlDbGljayA9IHRoaXMuX29uQmFja2Ryb3BDbGljay5iaW5kKHRoaXMpLCB0aGlzLl9vbktleXVwRXZlbnQgPSB0aGlzLl9vbktleXVwLmJpbmQodGhpcyksIHRoaXMuX29uUmlnaHRBcnJvd0tleWRvd25FdmVudCA9IHRoaXMuX29uUmlnaHRBcnJvd0tleWRvd24uYmluZCh0aGlzKSwgdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bkV2ZW50ID0gdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bi5iaW5kKHRoaXMpLCB0LmZvckVhY2goKGUpID0+IHtcbiAgICAgIGMub24oZSwgXCJtb3VzZWRvd25cIiwgdGhpcy5fb25JbWdNb3VzZWRvd24sIHtcbiAgICAgICAgcGFzc2l2ZTogITBcbiAgICAgIH0pLCBjLm9uKGUsIFwidG91Y2hzdGFydFwiLCB0aGlzLl9vbkltZ01vdXNlZG93biwge1xuICAgICAgICBwYXNzaXZlOiAhMFxuICAgICAgfSksIGMub24oZSwgXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25JbWdNb3VzZW1vdmUsIHtcbiAgICAgICAgcGFzc2l2ZTogITBcbiAgICAgIH0pLCBjLm9uKGUsIFwidG91Y2htb3ZlXCIsIHRoaXMuX29uSW1nTW91c2Vtb3ZlLCB7XG4gICAgICAgIHBhc3NpdmU6ICEwXG4gICAgICB9KSwgYy5vbihlLCBcIndoZWVsXCIsIHRoaXMuX29uSW1nV2hlZWwsIHsgcGFzc2l2ZTogITAgfSksIGMub24oZSwgXCJkYmxjbGlja1wiLCB0aGlzLl9vbkltZ0RvdWJsZUNsaWNrLCB7XG4gICAgICAgIHBhc3NpdmU6ICEwXG4gICAgICB9KTtcbiAgICB9KSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9vbldpbmRvd1RvdWNobW92ZSwge1xuICAgICAgcGFzc2l2ZTogITFcbiAgICB9KSwgYy5vbih3aW5kb3csIFwidG91Y2hzdGFydFwiLCB0aGlzLl9vbldpbmRvd1RvdWNoc3RhcnQpLCBjLm9uKHdpbmRvdywgXCJtb3VzZXVwXCIsIHRoaXMuX29uSW1nTW91c2V1cCksIGMub24od2luZG93LCBcInRvdWNoZW5kXCIsIHRoaXMuX29uSW1nVG91Y2hlbmQpLCBjLm9uKHdpbmRvdywgXCJyZXNpemVcIiwgdGhpcy5fb25XaW5kb3dSZXNpemUpLCBjLm9uKHdpbmRvdywgXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSksIGMub24od2luZG93LCBcImtleXVwXCIsIHRoaXMuX29uS2V5dXBFdmVudCksIGMub24od2luZG93LCBcImZ1bGxzY3JlZW5jaGFuZ2VcIiwgdGhpcy5fb25XaW5kb3dGdWxsc2NyZWVuQ2hhbmdlKSwgYy5vbih0aGlzLl9nYWxsZXJ5LCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbkFueUltZ0FjdGlvbiksIGMub24odGhpcy5fZ2FsbGVyeSwgXCJjbGlja1wiLCB0aGlzLl9vbkdhbGxlcnlDbGljayksIGMub24oXG4gICAgICB0aGlzLl9yaWdodEFycm93LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICB0aGlzLl9vblJpZ2h0QXJyb3dLZXlkb3duRXZlbnRcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fZnVsbHNjcmVlbkJ0bixcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bkV2ZW50XG4gICAgKTtcbiAgfVxuICBfcmVtb3ZlRXZlbnRzKCkge1xuICAgIGQuZmluZChcImltZ1wiLCB0aGlzLl9nYWxsZXJ5Q29udGVudCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgYy5vZmYoZSwgXCJtb3VzZWRvd25cIiwgdGhpcy5fb25JbWdNb3VzZWRvd24pLCBjLm9mZihlLCBcInRvdWNoc3RhcnRcIiwgdGhpcy5fb25JbWdNb3VzZWRvd24pLCBjLm9mZihlLCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbkltZ01vdXNlbW92ZSksIGMub2ZmKGUsIFwidG91Y2htb3ZlXCIsIHRoaXMuX29uSW1nTW91c2Vtb3ZlKSwgYy5vZmYoZSwgXCJ3aGVlbFwiLCB0aGlzLl9vbkltZ1doZWVsKSwgYy5vZmYoZSwgXCJkYmxjbGlja1wiLCB0aGlzLl9vbkltZ0RvdWJsZUNsaWNrKTtcbiAgICB9KSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9vbldpbmRvd1RvdWNobW92ZSwge1xuICAgICAgcGFzc2l2ZTogITFcbiAgICB9KSwgYy5vZmYod2luZG93LCBcInRvdWNoc3RhcnRcIiwgdGhpcy5fb25XaW5kb3dUb3VjaHN0YXJ0KSwgYy5vZmYod2luZG93LCBcIm1vdXNldXBcIiwgdGhpcy5fb25JbWdNb3VzZXVwKSwgYy5vZmYod2luZG93LCBcInRvdWNoZW5kXCIsIHRoaXMuX29uSW1nVG91Y2hlbmQpLCBjLm9mZih3aW5kb3csIFwicmVzaXplXCIsIHRoaXMuX29uV2luZG93UmVzaXplKSwgYy5vZmYod2luZG93LCBcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX29uV2luZG93UmVzaXplKSwgYy5vZmYod2luZG93LCBcImtleXVwXCIsIHRoaXMuX29uS2V5dXBFdmVudCksIGMub2ZmKFxuICAgICAgd2luZG93LFxuICAgICAgXCJmdWxsc2NyZWVuY2hhbmdlXCIsXG4gICAgICB0aGlzLl9vbldpbmRvd0Z1bGxzY3JlZW5DaGFuZ2VcbiAgICApLCBjLm9mZih0aGlzLl9nYWxsZXJ5LCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbkFueUltZ0FjdGlvbiksIGMub2ZmKHRoaXMuX2dhbGxlcnksIFwiY2xpY2tcIiwgdGhpcy5fb25HYWxsZXJ5Q2xpY2spLCBjLm9mZihcbiAgICAgIHRoaXMuX3JpZ2h0QXJyb3csXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIHRoaXMuX29uUmlnaHRBcnJvd0tleWRvd25FdmVudFxuICAgICksIGMub2ZmKFxuICAgICAgdGhpcy5fZnVsbHNjcmVlbkJ0bixcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bkV2ZW50XG4gICAgKTtcbiAgfVxuICBfb25Nb3VzZWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0LnRvdWNoZXMsIGkgPSBlID8gZVswXS5jbGllbnRYIDogdC5jbGllbnRYLCBuID0gZSA/IGVbMF0uY2xpZW50WSA6IHQuY2xpZW50WTtcbiAgICB0aGlzLl9vcmlnaW5hbFBvc2l0aW9uWCA9IHBhcnNlRmxvYXQodGhpcy5jdXJyZW50SW1nLnN0eWxlLmxlZnQpIHx8IDAsIHRoaXMuX29yaWdpbmFsUG9zaXRpb25ZID0gcGFyc2VGbG9hdCh0aGlzLmN1cnJlbnRJbWcuc3R5bGUudG9wKSB8fCAwLCB0aGlzLl9wb3NpdGlvblggPSB0aGlzLl9vcmlnaW5hbFBvc2l0aW9uWCwgdGhpcy5fcG9zaXRpb25ZID0gdGhpcy5fb3JpZ2luYWxQb3NpdGlvblksIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWCA9IGkgKiAoMSAvIHRoaXMuX3pvb20pIC0gdGhpcy5fcG9zaXRpb25YLCB0aGlzLl9tb3VzZWRvd25Qb3NpdGlvblkgPSBuICogKDEgLyB0aGlzLl96b29tKSAtIHRoaXMuX3Bvc2l0aW9uWSwgdGhpcy5fbW91c2Vkb3duID0gITAsIHQudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIgJiYgdC50b3VjaGVzLmxlbmd0aCA+IDEgJiYgKHRoaXMuX211bHRpdG91Y2ggPSAhMCwgdGhpcy5fdG91Y2hab29tUG9zaXRpb24gPSB0LnRvdWNoZXMpO1xuICB9XG4gIF9vbk1vdXNlbW92ZSh0KSB7XG4gICAgaWYgKCF0aGlzLl9tb3VzZWRvd24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHQudG91Y2hlcywgaSA9IGUgPyBlWzBdLmNsaWVudFggOiB0LmNsaWVudFgsIG4gPSBlID8gZVswXS5jbGllbnRZIDogdC5jbGllbnRZO1xuICAgIGlmIChlICYmIHRoaXMuX3Jlc2V0VG9vbHNUb2dnbGVyKCksICF0aGlzLl9tdWx0aXRvdWNoKVxuICAgICAgaWYgKHRoaXMuX3pvb20gIT09IDEpXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uWCA9IGkgKiAoMSAvIHRoaXMuX3pvb20pIC0gdGhpcy5fbW91c2Vkb3duUG9zaXRpb25YLCB0aGlzLl9wb3NpdGlvblkgPSBuICogKDEgLyB0aGlzLl96b29tKSAtIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWSwgaC5zdHlsZSh0aGlzLmN1cnJlbnRJbWcsIHtcbiAgICAgICAgICBsZWZ0OiBgJHt0aGlzLl9wb3NpdGlvblh9cHhgLFxuICAgICAgICAgIHRvcDogYCR7dGhpcy5fcG9zaXRpb25ZfXB4YFxuICAgICAgICB9KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5faW1hZ2VzLmxlbmd0aCA8PSAxKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25YID0gaSAqICgxIC8gdGhpcy5fem9vbSkgLSB0aGlzLl9tb3VzZWRvd25Qb3NpdGlvblgsIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLCB7IGxlZnQ6IGAke3RoaXMuX3Bvc2l0aW9uWH1weGAgfSk7XG4gICAgICB9XG4gIH1cbiAgX29uTW91c2V1cCh0KSB7XG4gICAgdGhpcy5fbW91c2Vkb3duID0gITEsIHRoaXMuX21vdmVJbWcodC50YXJnZXQpO1xuICB9XG4gIF9vblRvdWNoZW5kKHQpIHtcbiAgICB0aGlzLl9tb3VzZWRvd24gPSAhMSwgdGhpcy5fbXVsdGl0b3VjaCA/IHQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDAgJiYgKHRoaXMuX211bHRpdG91Y2ggPSAhMSwgdGhpcy5fdG91Y2hab29tUG9zaXRpb24gPSBbXSkgOiB0aGlzLl9tdWx0aXRvdWNoIHx8ICh0aGlzLl9jaGVja0RvdWJsZVRhcCh0KSwgdGhpcy5fbW92ZUltZyh0LnRhcmdldCkpO1xuICB9XG4gIF9jYWxjdWxhdGVUb3VjaFpvb20odCkge1xuICAgIGNvbnN0IGUgPSBNYXRoLmh5cG90KFxuICAgICAgdGhpcy5fdG91Y2hab29tUG9zaXRpb25bMV0ucGFnZVggLSB0aGlzLl90b3VjaFpvb21Qb3NpdGlvblswXS5wYWdlWCxcbiAgICAgIHRoaXMuX3RvdWNoWm9vbVBvc2l0aW9uWzFdLnBhZ2VZIC0gdGhpcy5fdG91Y2hab29tUG9zaXRpb25bMF0ucGFnZVlcbiAgICApLCBpID0gTWF0aC5oeXBvdChcbiAgICAgIHQudG91Y2hlc1sxXS5wYWdlWCAtIHQudG91Y2hlc1swXS5wYWdlWCxcbiAgICAgIHQudG91Y2hlc1sxXS5wYWdlWSAtIHQudG91Y2hlc1swXS5wYWdlWVxuICAgICksIG4gPSBNYXRoLmFicyhlIC0gaSksIG8gPSB0LnZpZXcuc2NyZWVuLndpZHRoO1xuICAgIG4gPiBvICogMC4wMyAmJiAoZSA8PSBpID8gdGhpcy56b29tSW4oKSA6IHRoaXMuem9vbU91dCgpLCB0aGlzLl90b3VjaFpvb21Qb3NpdGlvbiA9IHQudG91Y2hlcyk7XG4gIH1cbiAgX29uV2luZG93VG91Y2hzdGFydCh0KSB7XG4gICAgdC50b3VjaGVzLmxlbmd0aCA+IDEgJiYgKHRoaXMuX211bHRpdG91Y2ggPSAhMCwgdGhpcy5fdG91Y2hab29tUG9zaXRpb24gPSB0LnRvdWNoZXMpO1xuICB9XG4gIF9vbldpbmRvd1RvdWNobW92ZSh0KSB7XG4gICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LnR5cGUgPT09IFwidG91Y2htb3ZlXCIgJiYgdC50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEgJiYgdGhpcy5fY2FsY3VsYXRlVG91Y2hab29tKHQpO1xuICB9XG4gIF9vblJpZ2h0QXJyb3dLZXlkb3duKHQpIHtcbiAgICBzd2l0Y2ggKHQua2V5Q29kZSkge1xuICAgICAgY2FzZSA5OlxuICAgICAgICBpZiAodC5zaGlmdEtleSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9mb2N1c0Z1bGxzY3JlZW5CdG4oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIF9vbkZ1bGxzY3JlZW5CdG5LZXlkb3duKHQpIHtcbiAgICBzd2l0Y2ggKHQua2V5Q29kZSkge1xuICAgICAgY2FzZSA5OlxuICAgICAgICBpZiAoIXQuc2hpZnRLZXkpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fZm9jdXNSaWdodEFycm93KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBfb25LZXl1cCh0KSB7XG4gICAgc3dpdGNoICh0aGlzLl9yZXNldFRvb2xzVG9nZ2xlcigpLCB0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIHRoaXMuc2xpZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM3OlxuICAgICAgICB0aGlzLnNsaWRlKFwibGVmdFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3OlxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzNjpcbiAgICAgICAgdGhpcy5zbGlkZShcImZpcnN0XCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzU6XG4gICAgICAgIHRoaXMuc2xpZGUoXCJsYXN0XCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIHRoaXMuem9vbUluKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0MDpcbiAgICAgICAgdGhpcy56b29tT3V0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBfZm9jdXNGdWxsc2NyZWVuQnRuKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fZnVsbHNjcmVlbkJ0bi5mb2N1cygpO1xuICAgIH0sIDEwMCk7XG4gIH1cbiAgX2ZvY3VzUmlnaHRBcnJvdygpIHtcbiAgICB0aGlzLl9yaWdodEFycm93LmZvY3VzKCk7XG4gIH1cbiAgX21vdmVJbWcodCkge1xuICAgIGlmICh0aGlzLl9tdWx0aXRvdWNoIHx8IHRoaXMuX3pvb20gIT09IDEgfHwgdCAhPT0gdGhpcy5jdXJyZW50SW1nIHx8IHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5fcG9zaXRpb25YIC0gdGhpcy5fb3JpZ2luYWxQb3NpdGlvblg7XG4gICAgZSA+IDAgPyB0aGlzLnNsaWRlKFwibGVmdFwiKSA6IGUgPCAwICYmIHRoaXMuc2xpZGUoKTtcbiAgfVxuICBfY2hlY2tEb3VibGVUYXAodCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9kb3VibGVUYXBUaW1lcik7XG4gICAgY29uc3QgaSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gdGhpcy5fdGFwVGltZTtcbiAgICB0aGlzLl90YXBDb3VudGVyID4gMCAmJiBpIDwgNTAwID8gKHRoaXMuX29uRG91YmxlQ2xpY2sodCksIHRoaXMuX2RvdWJsZVRhcFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl90YXBUaW1lID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCksIHRoaXMuX3RhcENvdW50ZXIgPSAwO1xuICAgIH0sIDMwMCkpIDogKHRoaXMuX3RhcENvdW50ZXIrKywgdGhpcy5fdGFwVGltZSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpKTtcbiAgfVxuICBfcmVzZXREb3VibGVUYXAoKSB7XG4gICAgdGhpcy5fdGFwVGltZSA9IDAsIHRoaXMuX3RhcENvdW50ZXIgPSAwLCBjbGVhclRpbWVvdXQodGhpcy5fZG91YmxlVGFwVGltZXIpO1xuICB9XG4gIF9vbkRvdWJsZUNsaWNrKHQpIHtcbiAgICB0aGlzLl9tdWx0aXRvdWNoIHx8ICh0LnRvdWNoZXMgfHwgdGhpcy5fc2V0TmV3UG9zaXRpb25Pblpvb21Jbih0KSwgdGhpcy5fem9vbSAhPT0gMSA/IHRoaXMuX3Jlc3RvcmVEZWZhdWx0Wm9vbSgpIDogdGhpcy56b29tSW4oKSk7XG4gIH1cbiAgX29uWm9vbSh0KSB7XG4gICAgaWYgKHQuZGVsdGFZID4gMClcbiAgICAgIHRoaXMuem9vbU91dCgpO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX3pvb20gPj0gMylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fc2V0TmV3UG9zaXRpb25Pblpvb21Jbih0KSwgdGhpcy56b29tSW4oKTtcbiAgICB9XG4gIH1cbiAgX29uQmFja2Ryb3BDbGljayh0KSB7XG4gICAgdGhpcy5fcmVzZXRUb29sc1RvZ2dsZXIoKSwgdC50YXJnZXQudGFnTmFtZSA9PT0gXCJESVZcIiAmJiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgX3NldE5ld1Bvc2l0aW9uT25ab29tSW4odCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl96b29tVGltZXIpLCB0aGlzLl9wb3NpdGlvblggPSB3aW5kb3cuaW5uZXJXaWR0aCAvIDIgLSB0Lm9mZnNldFggLSA1MCwgdGhpcy5fcG9zaXRpb25ZID0gd2luZG93LmlubmVySGVpZ2h0IC8gMiAtIHQub2Zmc2V0WSAtIDUwLCB0aGlzLmN1cnJlbnRJbWcuc3R5bGUudHJhbnNpdGlvbiA9IFwiYWxsIDAuNXMgZWFzZS1vdXRcIiwgdGhpcy5jdXJyZW50SW1nLnN0eWxlLmxlZnQgPSBgJHt0aGlzLl9wb3NpdGlvblh9cHhgLCB0aGlzLmN1cnJlbnRJbWcuc3R5bGUudG9wID0gYCR7dGhpcy5fcG9zaXRpb25ZfXB4YCwgdGhpcy5fem9vbVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRJbWcuc3R5bGUudHJhbnNpdGlvbiA9IFwibm9uZVwiO1xuICAgIH0sIDUwMCk7XG4gIH1cbiAgX3Jlc2V0VG9vbHNUb2dnbGVyKCkge1xuICAgIHRoaXMuX3Nob3dUb29scygpLCBjbGVhclRpbWVvdXQodGhpcy5fdG9vbHNUb2dnbGVUaW1lciksIHRoaXMuX3NldFRvb2xzVG9nZ2xlVGltb3V0KCk7XG4gIH1cbiAgX3NldFRvb2xzVG9nZ2xlVGltb3V0KCkge1xuICAgIHRoaXMuX3Rvb2xzVG9nZ2xlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2hpZGVUb29scygpLCBjbGVhclRpbWVvdXQodGhpcy5fdG9vbHNUb2dnbGVUaW1lcik7XG4gICAgfSwgNGUzKTtcbiAgfVxuICBfaGlkZVRvb2xzKCkge1xuICAgIGguc3R5bGUodGhpcy5fZ2FsbGVyeVRvb2xiYXIsIHsgb3BhY2l0eTogMCB9KSwgaC5zdHlsZSh0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyLCB7IG9wYWNpdHk6IDAgfSksIGguc3R5bGUodGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIsIHsgb3BhY2l0eTogMCB9KTtcbiAgfVxuICBfc2hvd1Rvb2xzKCkge1xuICAgIGguc3R5bGUodGhpcy5fZ2FsbGVyeVRvb2xiYXIsIHsgb3BhY2l0eTogMSB9KSwgaC5zdHlsZSh0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyLCB7IG9wYWNpdHk6IDEgfSksIGguc3R5bGUodGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIsIHsgb3BhY2l0eTogMSB9KTtcbiAgfVxuICBfZGlzYWJsZVNjcm9sbCgpIHtcbiAgICBoLmFkZENsYXNzKGRvY3VtZW50LmJvZHksIFwib3ZlcmZsb3cteS1oaWRkZW4gcmVsYXRpdmVcIiksIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ICYmIGguYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgXCJtZDpwci1bMTdweF1cIik7XG4gIH1cbiAgX2VuYWJsZVNjcm9sbCgpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGgucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgXCJvdmVyZmxvdy15LWhpZGRlbiByZWxhdGl2ZVwiKSwgaC5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCBcIm1kOnByLVsxN3B4XVwiKTtcbiAgICB9LCAzMDApO1xuICB9XG4gIF9hbmltYXRpb25TdGFydCgpIHtcbiAgICB0aGlzLl9hbmltYXRpbmcgPSAhMCwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9hbmltYXRpbmcgPSAhMTtcbiAgICB9LCA0MDApO1xuICB9XG4gIF9yZXN0b3JlRGVmYXVsdFpvb20oKSB7XG4gICAgdGhpcy5fem9vbSAhPT0gMSAmJiAodGhpcy5fem9vbSA9IDEsIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7dGhpcy5fem9vbX0pYFxuICAgIH0pLCB0aGlzLl91cGRhdGVab29tQnRuKCksIHRoaXMuX3VwZGF0ZUltZ1Bvc2l0aW9uKCkpO1xuICB9XG4gIF9yZXN0b3JlRGVmYXVsdEZ1bGxzY3JlZW4oKSB7XG4gICAgdGhpcy5fZnVsbHNjcmVlbiAmJiB0aGlzLnRvZ2dsZUZ1bGxzY3JlZW4oKTtcbiAgfVxuICBfcmVzdG9yZURlZmF1bHRQb3NpdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fem9vbVRpbWVyKTtcbiAgICBjb25zdCB0ID0gdGhpcy5jdXJyZW50SW1nO1xuICAgIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHsgbGVmdDogMCwgdG9wOiAwIH0pLCBoLnN0eWxlKHRoaXMuY3VycmVudEltZywge1xuICAgICAgdHJhbnNpdGlvbjogXCJhbGwgMC41cyBlYXNlLW91dFwiLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH0pLCB0aGlzLl9jYWxjdWxhdGVJbWdTaXplKHQpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLCB7IHRyYW5zaXRpb246IFwibm9uZVwiIH0pO1xuICAgIH0sIDUwMCk7XG4gIH1cbiAgYXN5bmMgX3RyaWdnZXJFdmVudHModCwgZSkge1xuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgJHt0fS50ZS5saWdodGJveGApLCBlICYmIGF3YWl0IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGAke2V9LnRlLmxpZ2h0Ym94YCk7XG4gICAgfSwgNTA1KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgT2kpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbiAgc3RhdGljIHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29uc3QgZSA9IGQuY2xvc2VzdChcbiAgICAgICAgdC50YXJnZXQsXG4gICAgICAgIGAke0ZofWBcbiAgICAgICk7XG4gICAgICAobm4uZ2V0SW5zdGFuY2UoZSkgfHwgbmV3IG5uKGUpKS5vcGVuKHQpO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0gQS5nZXREYXRhKHRoaXMsIE9pKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcgbm4odGhpcywgbikpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgaTAgPSB7XG4gIGlzUmVxdWlyZWQ6IFwiVGhpcyBpcyByZXF1aXJlZFwiLFxuICBpc0VtYWlsOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIixcbiAgaXNMb25nZXJUaGFuOiBcIlRoaXMgZmllbGQgbXVzdCBiZSBsb25nZXIgdGhhbiB7bGVuZ3RofSBjaGFyYWN0ZXJzXCIsXG4gIGlzU2hvcnRlclRoYW46IFwiVGhpcyBmaWVsZCBtdXN0IGJlIHNob3J0ZXIgdGhhbiB7bGVuZ3RofSBjaGFyYWN0ZXJzXCIsXG4gIGlzQ2hlY2tlZDogXCJUaGlzIGlzIHJlcXVpcmVkXCIsXG4gIGlzUGhvbmU6IFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgcGhvbmUgbnVtYmVyXCIsXG4gIGlzTnVtYmVyOiBcIkV4cGVjdGVkIHZhbHVlIHdpdGggdHlwZSBOdW1iZXJcIixcbiAgaXNTdHJpbmc6IFwiRXhwZWN0ZWQgdmFsdWUgd2l0aCB0eXBlIFN0cmluZ1wiLFxuICBpc0Jvb2xlYW46IFwiRXhwZWN0ZWQgdmFsdWUgd2l0aCB0eXBlIEJvb2xlYW5cIixcbiAgaXNEYXRlOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGRhdGVcIixcbiAgaXMxMmhGb3JtYXQ6IFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgdGltZSBpbiAxMmggZm9ybWF0XCIsXG4gIGlzMjRoRm9ybWF0OiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIHRpbWUgaW4gMjRoIGZvcm1hdFwiXG59LCBzMCA9IHtcbiAgaXNSZXF1aXJlZDogKHMsIHQpID0+IChzID09IG51bGwgPyB2b2lkIDAgOiBzLnRyaW0oKSkgPyAhMCA6IHQsXG4gIGlzRW1haWw6IChzLCB0KSA9PiAvXlthLXpBLVowLTkuXyUrLV0rQFthLXpBLVowLTkuLV0rXFwuW2EtekEtWl17Mix9JC8udGVzdChzKSA/ICEwIDogdCxcbiAgaXNMb25nZXJUaGFuOiAocywgdCwgZSkgPT4gcy5sZW5ndGggPiBlID8gITAgOiB0LnJlcGxhY2UoXCJ7bGVuZ3RofVwiLCBlKSxcbiAgaXNTaG9ydGVyVGhhbjogKHMsIHQsIGUpID0+IHMubGVuZ3RoIDwgZSA/ICEwIDogdC5yZXBsYWNlKFwie2xlbmd0aH1cIiwgZSksXG4gIGlzQ2hlY2tlZDogKHMpID0+IHMgPyAhMCA6IFwiVGhpcyBpcyByZXF1aXJlZFwiLFxuICBpc1Bob25lOiAocywgdCkgPT4gcy5sZW5ndGggPT09IDkgPyAhMCA6IHQsXG4gIGlzTnVtYmVyOiAocywgdCkgPT4gcyAmJiAhaXNOYU4oTnVtYmVyKHMpKSA/ICEwIDogdCxcbiAgaXNTdHJpbmc6IChzLCB0KSA9PiB0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gITAgOiB0LFxuICBpc0Jvb2xlYW46IChzLCB0KSA9PiB0eXBlb2YgcyA9PSBcImJvb2xlYW5cIiA/ICEwIDogdCxcbiAgaXNEYXRlOiAocywgdCkgPT4ge1xuICAgIGNvbnN0IGUgPSAvXihbMC05XXsxLDJ9KVxcLyhbMC05XXsxLDJ9KVxcLyhbMC05XXs0fSkkLztcbiAgICByZXR1cm4gcy5tYXRjaChlKSA/ICEwIDogdDtcbiAgfSxcbiAgaXMxMmhGb3JtYXQ6IChzLCB0KSA9PiB7XG4gICAgY29uc3QgZSA9IC9eKDA/WzEtOV18MVswLTJdKTpbMC01XVswLTldIFtBUGFwXVttTV0kLztcbiAgICByZXR1cm4gcy5tYXRjaChlKSA/ICEwIDogdDtcbiAgfSxcbiAgaXMyNGhGb3JtYXQ6IChzLCB0KSA9PiB7XG4gICAgY29uc3QgZSA9IC9eKD86WzAxXVxcZHwyWzAtM10pOlswLTVdWzAtOV0kLztcbiAgICByZXR1cm4gcy5tYXRjaChlKSA/ICEwIDogdDtcbiAgfVxufSwgRG8gPSBcInZhbGlkYXRpb25cIiwgaXIgPSBcInRlLnZhbGlkYXRpb25cIiwgeW4gPSBgLiR7aXJ9YCwgWWggPSBcImRhdGEtdGUtdmFsaWRhdGVcIiwgTHMgPSBcImRhdGEtdGUtdmFsaWRhdGVkXCIsIE5zID0gXCJkYXRhLXRlLXZhbGlkYXRpb24tc3RhdGVcIiwgTXMgPSBcImRhdGEtdGUtdmFsaWRhdGlvbi1mZWVkYmFja1wiLCAkbyA9IFwiZGF0YS10ZS12YWxpZC1mZWVkYmFja1wiLCBScyA9IFwiZGF0YS10ZS1pbnZhbGlkLWZlZWRiYWNrXCIsIFhsID0gXCJkYXRhLXRlLXZhbGlkYXRpb24tcnVsZXNldFwiLCBuMCA9IFwiZGF0YS10ZS1zdWJtaXQtYnRuLXJlZlwiLCBvMCA9IGBbJHtZaH1dYCwgcjAgPSBcIltkYXRhLXRlLWlucHV0LW5vdGNoLXJlZl0gZGl2XCIsIGEwID0gYFske24wfV1gLCBsMCA9IGB2YWxpZGF0ZWQke3lufWAsIGMwID0gYHZhbGlkJHt5bn1gLCBoMCA9IGBpbnZhbGlkJHt5bn1gLCBkMCA9IGBjaGFuZ2VkJHt5bn1gLCB1MCA9IHtcbiAgdmFsaWRGZWVkYmFjazogXCJzdHJpbmdcIixcbiAgaW52YWxpZEZlZWRiYWNrOiBcInN0cmluZ1wiLFxuICBkaXNhYmxlRmVlZGJhY2s6IFwiYm9vbGVhblwiLFxuICBjdXN0b21SdWxlczogXCJvYmplY3RcIixcbiAgY3VzdG9tRXJyb3JNZXNzYWdlczogXCJvYmplY3RcIixcbiAgYWN0aXZlVmFsaWRhdGlvbjogXCJib29sZWFuXCIsXG4gIHN1Ym1pdENhbGxiYWNrOiBcIihmdW5jdGlvbnxudWxsKVwiXG59LCBHbCA9IHtcbiAgdmFsaWRGZWVkYmFjazogXCJMb29rcyBnb29kIVwiLFxuICBpbnZhbGlkRmVlZGJhY2s6IFwiU29tZXRoaW5nIGlzIHdyb25nIVwiLFxuICBkaXNhYmxlRmVlZGJhY2s6ICExLFxuICBjdXN0b21SdWxlczoge30sXG4gIGN1c3RvbUVycm9yTWVzc2FnZXM6IHt9LFxuICBhY3RpdmVWYWxpZGF0aW9uOiAhMSxcbiAgc3VibWl0Q2FsbGJhY2s6IG51bGxcbn0sIHAwID0ge1xuICAvLyBkZWZhdWx0IG5vdGNoXG4gIG5vdGNoTGVhZGluZ1ZhbGlkOiBcImJvcmRlci1bIzE0YTQ0ZF0gZGFyazpib3JkZXItWyMxNGE0NGRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bLTFweF8wXzBfIzE0YTQ0ZCxfMF8xcHhfMF8wXyMxNGE0NGQsXzBfLTFweF8wXzBfIzE0YTQ0ZF0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLVsjMTRhNDRkXVwiLFxuICBub3RjaE1pZGRsZVZhbGlkOiBcImJvcmRlci1bIzE0YTQ0ZF0gZGFyazpib3JkZXItWyMxNGE0NGRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMF8xcHhfMF8wXyMxNGE0NGRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1bIzE0YTQ0ZF1cIixcbiAgbm90Y2hUcmFpbGluZ1ZhbGlkOiBcImJvcmRlci1bIzE0YTQ0ZF0gZGFyazpib3JkZXItWyMxNGE0NGRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMXB4XzBfMF8jMTRhNDRkLF8wXy0xcHhfMF8wXyMxNGE0NGQsXzBfMXB4XzBfMF8jMTRhNDRkXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItWyMxNGE0NGRdXCIsXG4gIG5vdGNoTGVhZGluZ0ludmFsaWQ6IFwiYm9yZGVyLVsjZGM0YzY0XSBkYXJrOmJvcmRlci1bI2RjNGM2NF0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVstMXB4XzBfMF8jZGM0YzY0LF8wXzFweF8wXzBfI2RjNGM2NCxfMF8tMXB4XzBfMF8jZGM0YzY0XSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItWyNkYzRjNjRdXCIsXG4gIG5vdGNoTWlkZGxlSW52YWxpZDogXCJib3JkZXItWyNkYzRjNjRdIGRhcms6Ym9yZGVyLVsjZGM0YzY0XSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzBfMXB4XzBfMF8jZGM0YzY0XSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItWyNkYzRjNjRdXCIsXG4gIG5vdGNoVHJhaWxpbmdJbnZhbGlkOiBcImJvcmRlci1bI2RjNGM2NF0gZGFyazpib3JkZXItWyNkYzRjNjRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMXB4XzBfMF8jZGM0YzY0LF8wXy0xcHhfMF8wXyNkYzRjNjQsXzBfMXB4XzBfMF8jZGM0YzY0XSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItWyNkYzRjNjRdXCIsXG4gIC8vIGJhc2ljIGlucHV0c1xuICBiYXNpY0lucHV0VmFsaWQ6IFwiIWJvcmRlci1bIzE0YTQ0ZF0gZm9jdXM6IWJvcmRlci1bIzE0YTQ0ZF0gZm9jdXM6IXNoYWRvdy1baW5zZXRfMF8wXzBfMXB4XyMxNGE0NGRdXCIsXG4gIGJhc2ljSW5wdXRJbnZhbGlkOiBcIiFib3JkZXItWyNkYzRjNjRdIGZvY3VzOiFib3JkZXItWyNkYzRjNjRdIGZvY3VzOiFzaGFkb3ctW2luc2V0XzBfMF8wXzFweF8jZGM0YzY0XVwiLFxuICAvLyBjaGVja2JveFxuICBjaGVja2JveFZhbGlkOiBcImNoZWNrZWQ6IWJvcmRlci1bIzE0YTQ0ZF0gY2hlY2tlZDohYmctWyMxNGE0NGRdIGNoZWNrZWQ6YWZ0ZXI6IWJnLVsjMTRhNDRkXVwiLFxuICBjaGVja2JveEludmFsaWQ6IFwiY2hlY2tlZDohYm9yZGVyLVsjZGM0YzY0XSBjaGVja2VkOiFiZy1bI2RjNGM2NF0gY2hlY2tlZDphZnRlcjohYmctWyNkYzRjNjRdXCIsXG4gIHJhZGlvVmFsaWQ6IFwiY2hlY2tlZDohYm9yZGVyLVsjMTRhNDRkXSBjaGVja2VkOmFmdGVyOiFiZy1bIzE0YTQ0ZF1cIixcbiAgcmFkaW9JbnZhbGlkOiBcImNoZWNrZWQ6IWJvcmRlci1bI2RjNGM2NF0gY2hlY2tlZDphZnRlcjohYmctWyNkYzRjNjRdXCIsXG4gIC8vIGxhYmVsc1xuICBsYWJlbFZhbGlkOiBcIiF0ZXh0LVsjMTRhNDRkXVwiLFxuICBsYWJlbEludmFsaWQ6IFwiIXRleHQtWyNkYzRjNjRdXCIsXG4gIC8vIGZlZWRiYWNrXG4gIHZhbGlkRmVlZGJhY2s6IFwiYWJzb2x1dGUgdG9wLWZ1bGwgbGVmdC0wIG0tMSB3LWF1dG8gdGV4dC1zbSB0ZXh0LVsjMTRhNDRkXSBhbmltYXRlLVtmYWRlLWluXzAuM3NfYm90aF1cIixcbiAgaW52YWxpZEZlZWRiYWNrOiBcImFic29sdXRlIHRvcC1mdWxsIGxlZnQtMCBtLTEgdy1hdXRvIHRleHQtc20gdGV4dC1bI2RjNGM2NF0gYW5pbWF0ZS1bZmFkZS1pbl8wLjNzX2JvdGhdXCIsXG4gIC8vIGVsZW1lbnQgdmFsaWRhdGVkXG4gIGVsZW1lbnRWYWxpZGF0ZWQ6IFwibWItOFwiXG59LCBfMCA9IHtcbiAgbm90Y2hMZWFkaW5nVmFsaWQ6IFwic3RyaW5nXCIsXG4gIG5vdGNoTWlkZGxlVmFsaWQ6IFwic3RyaW5nXCIsXG4gIG5vdGNoVHJhaWxpbmdWYWxpZDogXCJzdHJpbmdcIixcbiAgbm90Y2hMZWFkaW5nSW52YWxpZDogXCJzdHJpbmdcIixcbiAgbm90Y2hNaWRkbGVJbnZhbGlkOiBcInN0cmluZ1wiLFxuICBub3RjaFRyYWlsaW5nSW52YWxpZDogXCJzdHJpbmdcIixcbiAgYmFzaWNJbnB1dFZhbGlkOiBcInN0cmluZ1wiLFxuICBiYXNpY0lucHV0SW52YWxpZDogXCJzdHJpbmdcIixcbiAgY2hlY2tib3hWYWxpZDogXCJzdHJpbmdcIixcbiAgY2hlY2tib3hJbnZhbGlkOiBcInN0cmluZ1wiLFxuICByYWRpb1ZhbGlkOiBcInN0cmluZ1wiLFxuICByYWRpb0ludmFsaWQ6IFwic3RyaW5nXCIsXG4gIGxhYmVsVmFsaWQ6IFwic3RyaW5nXCIsXG4gIGxhYmVsSW52YWxpZDogXCJzdHJpbmdcIixcbiAgdmFsaWRGZWVkYmFjazogXCJzdHJpbmdcIixcbiAgaW52YWxpZEZlZWRiYWNrOiBcInN0cmluZ1wiLFxuICBlbGVtZW50VmFsaWRhdGVkOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgamggZXh0ZW5kcyBmdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2VsZW1lbnQgJiYgQS5zZXREYXRhKHQsIGlyLCB0aGlzKSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5faXNWYWxpZCA9ICEwLCB0aGlzLl9zaG91bGRBcHBseUlucHV0RXZlbnRzID0gITAsIHRoaXMuX3N1Ym1pdENhbGxiYWNrID0gbnVsbCwgdGhpcy5fZXJyb3JNZXNzYWdlcyA9IHtcbiAgICAgIC4uLmkwLFxuICAgICAgLi4udGhpcy5fY29uZmlnLmN1c3RvbUVycm9yTWVzc2FnZXNcbiAgICB9LCB0aGlzLl92YWxpZGF0aW9uRWxlbWVudHMgPSB0aGlzLl9nZXRWYWxpZGF0aW9uRWxlbWVudHMoKSwgdGhpcy5fdmFsaWRhdGlvbkVsZW1lbnRzLmZvckVhY2goKHsgZWxlbWVudDogbiwgaW5wdXQ6IG8gfSkgPT4ge1xuICAgICAgdGhpcy5fY3JlYXRlRmVlZGJhY2tXcmFwcGVyKG4sIG8pO1xuICAgIH0pLCB0aGlzLl92YWxpZGF0aW9uT2JzZXJ2ZXIgPSB0aGlzLl93YXRjaEZvclZhbGlkYXRpb25DaGFuZ2VzKCksIHRoaXMuX3ZhbGlkYXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuX2VsZW1lbnQsIHsgYXR0cmlidXRlczogITAgfSksIHRoaXMuX3N1Ym1pdEJ1dHRvbiA9IG51bGwsIHRoaXMuX2hhbmRsZVN1Ym1pdEJ1dHRvbigpLCB0aGlzLl92YWxpZGF0aW9uUmVzdWx0ID0gW107XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiB1MDtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIEdsO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gRG87XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgdmFyIHQ7XG4gICAgKHQgPSB0aGlzLl92YWxpZGF0aW9uT2JzZXJ2ZXIpID09IG51bGwgfHwgdC5kaXNjb25uZWN0KCksIHRoaXMuX3ZhbGlkYXRpb25PYnNlcnZlciA9IG51bGwsIHRoaXMuX3N1Ym1pdENhbGxiYWNrID0gbnVsbCwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoTHMpLCB0aGlzLl9yZW1vdmVJbnB1dEV2ZW50cygpLCB0aGlzLl9yZW1vdmVWYWxpZGF0aW9uVHJhY2VzKCksIHRoaXMuX3ZhbGlkYXRpb25SZXN1bHQgPSBbXSwgdGhpcy5fc3VibWl0QnV0dG9uICYmIGMub2ZmKHRoaXMuX3N1Ym1pdEJ1dHRvbiwgXCJjbGlja1wiKSwgdGhpcy5fY29uZmlnLmFjdGl2ZVZhbGlkYXRpb24gJiYgKHRoaXMuX3ZhbGlkYXRpb25FbGVtZW50cy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBjb25zdCB7IGlucHV0OiBpIH0gPSBlO1xuICAgICAgYy5vZmYoaSwgXCJpbnB1dFwiKTtcbiAgICB9KSwgdGhpcy5fc2hvdWxkQXBwbHlJbnB1dEV2ZW50cyA9ICEwKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9yZW1vdmVWYWxpZGF0aW9uVHJhY2VzKCkge1xuICAgIHRoaXMuX3JlbW92ZUZlZWRiYWNrV3JhcHBlcigpLCB0aGlzLl92YWxpZGF0aW9uRWxlbWVudHMuZm9yRWFjaCgoeyBlbGVtZW50OiB0LCBjbGFzc2VzOiBlLCBpbml0aWFsSFRNTDogaSB9KSA9PiB7XG4gICAgICB0LmNsYXNzTmFtZSA9IGUsIHQuaW5uZXJIVE1MID0gaSwgdC5yZW1vdmVBdHRyaWJ1dGUoTnMpLCB0LnJlbW92ZUF0dHJpYnV0ZShScyksIHQucmVtb3ZlQXR0cmlidXRlKCRvKTtcbiAgICB9KSwgdGhpcy5fdmFsaWRhdGlvbkVsZW1lbnRzID0gW107XG4gIH1cbiAgX2dldFZhbGlkYXRpb25FbGVtZW50cygpIHtcbiAgICByZXR1cm4gZC5maW5kKFxuICAgICAgbzAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKS5tYXAoKGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSBkLmZpbmRPbmUoXCJpbnB1dFwiLCBlKSB8fCBkLmZpbmRPbmUoXCJ0ZXh0YXJlYVwiLCBlKSwgbiA9IGQuZmluZE9uZShcInNlbGVjdFwiLCBlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpLm5hbWUgfHwgaS5pZCB8fCAobiA9PSBudWxsID8gdm9pZCAwIDogbi5uYW1lKSB8fCBldChcInZhbGlkYXRpb24tXCIpLFxuICAgICAgICBlbGVtZW50OiBlLFxuICAgICAgICB0eXBlOiBlLmdldEF0dHJpYnV0ZShZaCksXG4gICAgICAgIGlucHV0OiBpLFxuICAgICAgICB2YWxpZEZlZWRiYWNrOiBlLmdldEF0dHJpYnV0ZSgkbyksXG4gICAgICAgIGludmFsaWRGZWVkYmFjazogZS5nZXRBdHRyaWJ1dGUoUnMpLFxuICAgICAgICBjbGFzc2VzOiBlLmNsYXNzTmFtZSxcbiAgICAgICAgaW5pdGlhbEhUTUw6IGUuaW5uZXJIVE1MLFxuICAgICAgICBydWxlc2V0OiBlLmdldEF0dHJpYnV0ZShYbClcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgX2NyZWF0ZUZlZWRiYWNrV3JhcHBlcih0LCBlKSB7XG4gICAgaWYgKHQucXVlcnlTZWxlY3RvckFsbChgWyR7TXN9XWApLmxlbmd0aCA+IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGkuc2V0QXR0cmlidXRlKE1zLCBcIlwiKSwgZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGkpO1xuICB9XG4gIF9yZW1vdmVGZWVkYmFja1dyYXBwZXIoKSB7XG4gICAgZC5maW5kKFxuICAgICAgYFske01zfV1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfVxuICBfd2F0Y2hGb3JWYWxpZGF0aW9uQ2hhbmdlcygpIHtcbiAgICByZXR1cm4gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKGUpID0+IHtcbiAgICAgIGUuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICBjb25zdCB7IGF0dHJpYnV0ZU5hbWU6IG4gfSA9IGk7XG4gICAgICAgIG4gPT09IExzICYmICh0aGlzLl9oYW5kbGVWYWxpZGF0aW9uKCksIHRoaXMuX2NvbmZpZy5hY3RpdmVWYWxpZGF0aW9uICYmIHRoaXMuX3Nob3VsZEFwcGx5SW5wdXRFdmVudHMgJiYgdGhpcy5fYXBwbHlJbnB1dEV2ZW50cygpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVWYWxpZGF0aW9uKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKExzKSAmJiAodGhpcy5fdmFsaWRhdGlvblJlc3VsdCA9IFtdLCB0aGlzLl9pc1ZhbGlkID0gITAsIHRoaXMuX3ZhbGlkYXRpb25FbGVtZW50cy5mb3JFYWNoKFxuICAgICAgKHQpID0+IHRoaXMuX3ZhbGlkYXRlU2luZ2xlRWxlbWVudCh0KVxuICAgICksIHRoaXMuX2VtaXRFdmVudHModGhpcy5faXNWYWxpZCksIHRoaXMuX3N1Ym1pdENhbGxiYWNrICYmIHRoaXMuX3N1Ym1pdENhbGxiYWNrKHRoaXMuX2lzVmFsaWQpKTtcbiAgfVxuICBfdmFsaWRhdGVTaW5nbGVFbGVtZW50KHQpIHtcbiAgICB2YXIgcDtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGUsIHR5cGU6IGksIGlucHV0OiBuLCBydWxlc2V0OiBvLCBpZDogciB9ID0gdDtcbiAgICBvICYmIHRoaXMuX3ZhbGlkYXRlQnlSdWxlc2V0KHQpO1xuICAgIGNvbnN0IGEgPSBlLmdldEF0dHJpYnV0ZShOcyk7XG4gICAgaWYgKGEgIT09IFwidmFsaWRcIiAmJiBhICE9PSBcImludmFsaWRcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsID0gYS5yZXBsYWNlKFxuICAgICAgYS5jaGFyQXQoMCksXG4gICAgICBhLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpXG4gICAgKTtcbiAgICBpID09PSBcImlucHV0XCIgJiYgdGhpcy5fcmVzdHlsZU5vdGNoZXMoZSwgbCksIGkgPT09IFwiYmFzaWNcIiAmJiB0aGlzLl9yZXN0eWxlQmFzaWNJbnB1dHMobiwgbCksIChpID09PSBcImNoZWNrYm94XCIgfHwgaSA9PT0gXCJyYWRpb1wiKSAmJiB0aGlzLl9yZXN0eWxlQ2hlY2tib3hlcyhuLCBsLCBpKSwgdGhpcy5fcmVzdHlsZUxhYmVscyhlLCBsKSwgYSA9PT0gXCJpbnZhbGlkXCIgJiYgKHRoaXMuX2lzVmFsaWQgPSAhMSksIHRoaXMuX2NvbmZpZy5kaXNhYmxlRmVlZGJhY2sgfHwgdGhpcy5fYXBwbHlGZWVkYmFjayhlLCBhKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGQwLCB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBuYW1lOiByLFxuICAgICAgICByZXN1bHQ6IGEsXG4gICAgICAgIHZhbGlkYXRpb246IChwID0gdGhpcy5fdmFsaWRhdGlvblJlc3VsdFtyXSkgPT0gbnVsbCA/IHZvaWQgMCA6IHAudmFsaWRhdGlvblxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF92YWxpZGF0ZUJ5UnVsZXNldCh7IGVsZW1lbnQ6IHQsIHR5cGU6IGUsIGludmFsaWRGZWVkYmFjazogaSwgaW5wdXQ6IG4sIGlkOiBvIH0pIHtcbiAgICBjb25zdCByID0gdGhpcy5fZ2V0UnVsZXNldCh0KTtcbiAgICBpZiAoIXIubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSBlID09PSBcImNoZWNrYm94XCIgfHwgZSA9PT0gXCJyYWRpb1wiID8gbi5jaGVja2VkIDogbi52YWx1ZTtcbiAgICBsZXQgbCA9IFwiXCIsIHAgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHUgb2Ygcikge1xuICAgICAgY29uc3QgXyA9IHUuY2FsbGJhY2soXG4gICAgICAgIGEsXG4gICAgICAgIHRoaXMuX2Vycm9yTWVzc2FnZXNbdS5uYW1lXSB8fCB0aGlzLl9jb25maWcuaW52YWxpZEZlZWRiYWNrLFxuICAgICAgICB1LnBhcmFtZXRlclxuICAgICAgKTtcbiAgICAgIHAucHVzaCh7XG4gICAgICAgIHJlc3VsdDogXyA9PT0gITAsXG4gICAgICAgIG5hbWU6IHUubmFtZSxcbiAgICAgICAgZnVsbE5hbWU6IHUuZnVsbE5hbWVcbiAgICAgIH0pLCB0eXBlb2YgXyA9PSBcInN0cmluZ1wiICYmICFsICYmIChsID0gXyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl92YWxpZGF0aW9uUmVzdWx0W29dID0geyBlbGVtZW50OiB0LCB2YWxpZGF0aW9uOiBwIH0sICFsKSB7XG4gICAgICB0LnNldEF0dHJpYnV0ZShOcywgXCJ2YWxpZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdC5zZXRBdHRyaWJ1dGUoTnMsIFwiaW52YWxpZFwiKSwgaSB8fCB0LnNldEF0dHJpYnV0ZShScywgbCk7XG4gIH1cbiAgX2hhbmRsZUlucHV0Q2hhbmdlKHQpIHtcbiAgICB0aGlzLl92YWxpZGF0ZVNpbmdsZUVsZW1lbnQodCk7XG4gIH1cbiAgX2dldFJ1bGVzZXQodCkge1xuICAgIGNvbnN0IGkgPSB0LmdldEF0dHJpYnV0ZShYbCkuc3BsaXQoXCJ8XCIpO1xuICAgIGxldCBuID0gW107XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIC4uLnMwLFxuICAgICAgLi4udGhpcy5fY29uZmlnLmN1c3RvbVJ1bGVzXG4gICAgfTtcbiAgICByZXR1cm4gaS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICBjb25zdCBhID0gdGhpcy5fZ2V0UnVsZURhdGEociwgbyk7XG4gICAgICBhLmNhbGxiYWNrID8gbi5wdXNoKGEpIDogY29uc29sZS53YXJuKGBSdWxlICR7cn0gZG9lcyBub3QgZXhpc3RgKTtcbiAgICB9KSwgbjtcbiAgfVxuICBfZ2V0UnVsZURhdGEodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0LnNwbGl0KFwiKFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2FsbGJhY2s6IGVbaVswXV0sXG4gICAgICBwYXJhbWV0ZXI6IGlbMV0gPyBpWzFdLnNwbGl0KFwiKVwiKVswXSA6IG51bGwsXG4gICAgICBuYW1lOiBpWzBdLFxuICAgICAgZnVsbE5hbWU6IHRcbiAgICB9O1xuICB9XG4gIF9hcHBseUZlZWRiYWNrKHQsIGUpIHtcbiAgICBjb25zdCBpID0gZC5maW5kT25lKFxuICAgICAgYFske01zfV1gLFxuICAgICAgdFxuICAgICksIG4gPSB0LmdldEF0dHJpYnV0ZSgkbykgfHwgdGhpcy5fY29uZmlnLnZhbGlkRmVlZGJhY2ssIG8gPSB0LmdldEF0dHJpYnV0ZShScykgfHwgdGhpcy5fY29uZmlnLmludmFsaWRGZWVkYmFjaztcbiAgICBoLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXMuZWxlbWVudFZhbGlkYXRlZCksIGkudGV4dENvbnRlbnQgPSBlID09PSBcInZhbGlkXCIgPyBuIDogbywgaS5jbGFzc05hbWUgPSB0aGlzLl9jbGFzc2VzW2UgPT09IFwidmFsaWRcIiA/IFwidmFsaWRGZWVkYmFja1wiIDogXCJpbnZhbGlkRmVlZGJhY2tcIl07XG4gIH1cbiAgX3Jlc3R5bGVDaGVja2JveGVzKHQsIGUsIGkpIHtcbiAgICBoLnJlbW92ZUNsYXNzKHQsIHRoaXMuX2NsYXNzZXMuY2hlY2tib3hWYWxpZCksIGgucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5jaGVja2JveEludmFsaWQpLCBoLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXNbYCR7aX0ke2V9YF0pO1xuICB9XG4gIF9yZXN0eWxlQmFzaWNJbnB1dHModCwgZSkge1xuICAgIGgucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5iYXNpY0lucHV0VmFsaWQpLCBoLnJlbW92ZUNsYXNzKHQsIHRoaXMuX2NsYXNzZXMuYmFzaWNJbnB1dEludmFsaWQpLCBoLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXNbYGJhc2ljSW5wdXQke2V9YF0pO1xuICB9XG4gIF9yZXN0eWxlTm90Y2hlcyh0LCBlKSB7XG4gICAgZC5maW5kKHIwLCB0KS5mb3JFYWNoKChuLCBvKSA9PiB7XG4gICAgICBsZXQgciA9IG8gPT09IDAgPyBcIm5vdGNoTGVhZGluZ1wiIDogbyA9PT0gMSA/IFwibm90Y2hNaWRkbGVcIiA6IFwibm90Y2hUcmFpbGluZ1wiO1xuICAgICAgbi5jbGFzc05hbWUgPSBcIlwiLCBoLmFkZENsYXNzKG4sIHBoW3JdKSwgciArPSBlLCBoLmFkZENsYXNzKG4sIHRoaXMuX2NsYXNzZXNbcl0pO1xuICAgIH0pO1xuICB9XG4gIF9yZXN0eWxlTGFiZWxzKHQsIGUpIHtcbiAgICBjb25zdCBpID0gZC5maW5kKFwibGFiZWxcIiwgdCk7XG4gICAgaS5sZW5ndGggJiYgaS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBoLnJlbW92ZUNsYXNzKG4sIHRoaXMuX2NsYXNzZXMubGFiZWxWYWxpZCksIGgucmVtb3ZlQ2xhc3MobiwgdGhpcy5fY2xhc3Nlcy5sYWJlbEludmFsaWQpLCBoLmFkZENsYXNzKG4sIHRoaXMuX2NsYXNzZXNbYGxhYmVsJHtlfWBdKTtcbiAgICB9KTtcbiAgfVxuICBfZW1pdEV2ZW50cyh0KSB7XG4gICAgaWYgKGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBsMCksIHQpIHtcbiAgICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBjMCwge1xuICAgICAgICB2YWx1ZTogdGhpcy5fdmFsaWRhdGlvblJlc3VsdFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBoMCwge1xuICAgICAgdmFsdWU6IHRoaXMuX3ZhbGlkYXRpb25SZXN1bHRcbiAgICB9KTtcbiAgfVxuICBfYXBwbHlJbnB1dEV2ZW50cygpIHtcbiAgICB0aGlzLl92YWxpZGF0aW9uRWxlbWVudHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgeyBpbnB1dDogZSwgZWxlbWVudDogaSB9ID0gdDtcbiAgICAgIGMub24oXG4gICAgICAgIGUsXG4gICAgICAgIFwiaW5wdXRcIixcbiAgICAgICAgKCkgPT4gdGhpcy5faGFuZGxlSW5wdXRDaGFuZ2UodClcbiAgICAgICksIGMub24oXG4gICAgICAgIGksXG4gICAgICAgIFwidmFsdWVDaGFuZ2UudGUuc2VsZWN0XCIsXG4gICAgICAgICgpID0+IHRoaXMuX2RlbGF5ZWRJbnB1dENoYW5nZSh0KVxuICAgICAgKSwgYy5vbihcbiAgICAgICAgaSxcbiAgICAgICAgXCJpdGVtU2VsZWN0LnRlLmF1dG9jb21wbGV0ZVwiLFxuICAgICAgICAoKSA9PiB0aGlzLl9kZWxheWVkSW5wdXRDaGFuZ2UodClcbiAgICAgICk7XG4gICAgfSksIHRoaXMuX3Nob3VsZEFwcGx5SW5wdXRFdmVudHMgPSAhMTtcbiAgfVxuICBfcmVtb3ZlSW5wdXRFdmVudHMoKSB7XG4gICAgdGhpcy5fdmFsaWRhdGlvbkVsZW1lbnRzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgaW5wdXQ6IGUsIGVsZW1lbnQ6IGkgfSA9IHQ7XG4gICAgICBjLm9mZihcbiAgICAgICAgZSxcbiAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICAoKSA9PiB0aGlzLl9oYW5kbGVJbnB1dENoYW5nZSh0KVxuICAgICAgKSwgYy5vZmYoXG4gICAgICAgIGksXG4gICAgICAgIFwidmFsdWVDaGFuZ2UudGUuc2VsZWN0XCIsXG4gICAgICAgICgpID0+IHRoaXMuX2RlbGF5ZWRJbnB1dENoYW5nZSh0KVxuICAgICAgKSwgYy5vZmYoXG4gICAgICAgIGksXG4gICAgICAgIFwiaXRlbVNlbGVjdC50ZS5hdXRvY29tcGxldGVcIixcbiAgICAgICAgKCkgPT4gdGhpcy5fZGVsYXllZElucHV0Q2hhbmdlKHQpXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIF9kZWxheWVkSW5wdXRDaGFuZ2UodCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5faGFuZGxlSW5wdXRDaGFuZ2UodCk7XG4gICAgfSwgMTApO1xuICB9XG4gIF9oYW5kbGVTdWJtaXRCdXR0b24oKSB7XG4gICAgdGhpcy5fc3VibWl0QnV0dG9uID0gZC5maW5kT25lKFxuICAgICAgYTAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fc3VibWl0QnV0dG9uICYmIGMub24oXG4gICAgICB0aGlzLl9zdWJtaXRCdXR0b24sXG4gICAgICBcImNsaWNrXCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlU3VibWl0QnV0dG9uQ2xpY2sodClcbiAgICApO1xuICB9XG4gIF9oYW5kbGVTdWJtaXRCdXR0b25DbGljayh0KSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKExzLCAhMCksIHRoaXMuX2NvbmZpZy5zdWJtaXRDYWxsYmFjaykge1xuICAgICAgdGhpcy5fc3VibWl0Q2FsbGJhY2sgPSAoZSkgPT4gdGhpcy5fY29uZmlnLnN1Ym1pdENhbGxiYWNrKHQsIGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLkdsLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdCA/IHQgOiB7fVxuICAgIH0sIEkoRG8sIHQsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ucDAsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoRG8sIHQsIF8wKSwgdDtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIGlyKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gamguZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChlW3RdID09PSB2b2lkIDAgfHwgdC5zdGFydHNXaXRoKFwiX1wiKSB8fCB0ID09PSBcImNvbnN0cnVjdG9yXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFFpIHtcbiAgX2dldENvb3JkaW5hdGVzKHQpIHtcbiAgICBjb25zdCBbZV0gPSB0LnRvdWNoZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgIHk6IGUuY2xpZW50WVxuICAgIH07XG4gIH1cbiAgX2dldERpcmVjdGlvbih7IHg6IHQsIHk6IGUgfSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB7XG4gICAgICAgIGRpcmVjdGlvbjogdCA8IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICAgICAgdmFsdWU6IE1hdGguYWJzKHQpXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICBkaXJlY3Rpb246IGUgPCAwID8gXCJ1cFwiIDogXCJkb3duXCIsXG4gICAgICAgIHZhbHVlOiBNYXRoLmFicyhlKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgX2dldE9yaWdpbih7IHg6IHQsIHk6IGUgfSwgeyB4OiBpLCB5OiBuIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdCAtIGksXG4gICAgICB5OiBlIC0gblxuICAgIH07XG4gIH1cbiAgX2dldERpc3RhbmNlQmV0d2VlblR3b1BvaW50cyh0LCBlLCBpLCBuKSB7XG4gICAgcmV0dXJuIE1hdGguaHlwb3QoZSAtIHQsIG4gLSBpKTtcbiAgfVxuICBfZ2V0TWlkUG9pbnQoeyB4MTogdCwgeDI6IGUsIHkxOiBpLCB5MjogbiB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6ICh0ICsgZSkgLyAyLFxuICAgICAgeTogKGkgKyBuKSAvIDJcbiAgICB9O1xuICB9XG4gIF9nZXRWZWN0b3JMZW5ndGgoeyB4MTogdCwgeDI6IGUsIHkxOiBpLCB5MjogbiB9KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgoZSAtIHQpICoqIDIgKyAobiAtIGkpICoqIDIpO1xuICB9XG4gIF9nZXRSaWdodE1vc3RUb3VjaCh0KSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGNvbnN0IGkgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgIHJldHVybiB0LmZvckVhY2goKG4pID0+IHtcbiAgICAgIG4uY2xpZW50WCA+IGkgJiYgKGUgPSBuKTtcbiAgICB9KSwgZTtcbiAgfVxuICBfZ2V0QW5nbGUodCwgZSwgaSwgbikge1xuICAgIHJldHVybiBNYXRoLmF0YW4yKG4gLSBlLCBpIC0gdCk7XG4gIH1cbiAgX2dldEFuZ3VsYXJEaXN0YW5jZSh0LCBlKSB7XG4gICAgcmV0dXJuIGUgLSB0O1xuICB9XG4gIF9nZXRDZW50ZXJYWSh7IHgxOiB0LCB4MjogZSwgeTE6IGksIHkyOiBuIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdCArIChlIC0gdCkgLyAyLFxuICAgICAgeTogaSArIChuIC0gaSkgLyAyXG4gICAgfTtcbiAgfVxuICBfZ2V0UGluY2hUb3VjaE9yaWdpbih0KSB7XG4gICAgY29uc3QgW2UsIGldID0gdCwgbiA9IHtcbiAgICAgIHgxOiBlLmNsaWVudFgsXG4gICAgICB4MjogaS5jbGllbnRYLFxuICAgICAgeTE6IGUuY2xpZW50WSxcbiAgICAgIHkyOiBpLmNsaWVudFlcbiAgICB9O1xuICAgIHJldHVybiBbdGhpcy5fZ2V0VmVjdG9yTGVuZ3RoKG4pLCB0aGlzLl9nZXRDZW50ZXJYWShuKV07XG4gIH1cbiAgX2dldFBvc2l0aW9uKHsgeDE6IHQsIHgyOiBlLCB5MTogaSwgeTI6IG4gfSkge1xuICAgIHJldHVybiB7IHgxOiB0LCB4MjogZSwgeTE6IGksIHkyOiBuIH07XG4gIH1cbn1cbmNvbnN0IExvID0gXCJwcmVzc1wiLCBmMCA9IFwicHJlc3N1cFwiLCBtMCA9IHtcbiAgdGltZTogXCJudW1iZXJcIixcbiAgcG9pbnRlcnM6IFwibnVtYmVyXCJcbn0sIGcwID0ge1xuICB0aW1lOiAyNTAsXG4gIHBvaW50ZXJzOiAxXG59O1xuY2xhc3MgYjAgZXh0ZW5kcyBRaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSkge1xuICAgIHN1cGVyKCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl90aW1lciA9IG51bGw7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIExvO1xuICB9XG4gIGhhbmRsZVRvdWNoU3RhcnQodCkge1xuICAgIGNvbnN0IHsgdGltZTogZSwgcG9pbnRlcnM6IGkgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgdC50b3VjaGVzLmxlbmd0aCA9PT0gaSAmJiAodGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBMbywgeyB0b3VjaDogdCwgdGltZTogZSB9KSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGYwLCB7IHRvdWNoOiB0IH0pO1xuICAgIH0sIGUpKTtcbiAgfVxuICBoYW5kbGVUb3VjaEVuZCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5nMCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gSShMbywgZSwgbTApLCBlO1xuICB9XG59XG5jb25zdCB2MCA9IFwic3dpcGVcIiwgVDAgPSB7XG4gIHRocmVzaG9sZDogXCJudW1iZXJcIixcbiAgZGlyZWN0aW9uOiBcInN0cmluZ1wiXG59LCBFMCA9IHtcbiAgdGhyZXNob2xkOiAxMCxcbiAgZGlyZWN0aW9uOiBcImFsbFwiXG59O1xuY2xhc3MgQzAge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpO1xuICB9XG4gIGhhbmRsZVRvdWNoU3RhcnQodCkge1xuICAgIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSB0aGlzLl9nZXRDb29yZGluYXRlcyh0KTtcbiAgfVxuICBoYW5kbGVUb3VjaE1vdmUodCkge1xuICAgIGlmICghdGhpcy5fc3RhcnRQb3NpdGlvbilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZXModCksIGkgPSB7XG4gICAgICB4OiBlLnggLSB0aGlzLl9zdGFydFBvc2l0aW9uLngsXG4gICAgICB5OiBlLnkgLSB0aGlzLl9zdGFydFBvc2l0aW9uLnlcbiAgICB9LCBuID0gdGhpcy5fZ2V0RGlyZWN0aW9uKGkpO1xuICAgIGlmICh0aGlzLl9vcHRpb25zLmRpcmVjdGlvbiA9PT0gXCJhbGxcIikge1xuICAgICAgaWYgKG4ueS52YWx1ZSA8IHRoaXMuX29wdGlvbnMudGhyZXNob2xkICYmIG4ueC52YWx1ZSA8IHRoaXMuX29wdGlvbnMudGhyZXNob2xkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByID0gbi55LnZhbHVlID4gbi54LnZhbHVlID8gbi55LmRpcmVjdGlvbiA6IG4ueC5kaXJlY3Rpb247XG4gICAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYHN3aXBlJHtyfWAsIHsgdG91Y2g6IHQgfSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBcInN3aXBlXCIsIHsgdG91Y2g6IHQsIGRpcmVjdGlvbjogciB9KSwgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG8gPSB0aGlzLl9vcHRpb25zLmRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgfHwgdGhpcy5fb3B0aW9ucyA9PT0gXCJyaWdodFwiID8gXCJ4XCIgOiBcInlcIjtcbiAgICBuW29dLmRpcmVjdGlvbiA9PT0gdGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gJiYgbltvXS52YWx1ZSA+IHRoaXMuX29wdGlvbnMudGhyZXNob2xkICYmIChjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYHN3aXBlJHtuW29dLmRpcmVjdGlvbn1gLCB7XG4gICAgICB0b3VjaDogdFxuICAgIH0pLCB0aGlzLl9zdGFydFBvc2l0aW9uID0gbnVsbCk7XG4gIH1cbiAgaGFuZGxlVG91Y2hFbmQoKSB7XG4gICAgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IG51bGw7XG4gIH1cbiAgX2dldENvb3JkaW5hdGVzKHQpIHtcbiAgICBjb25zdCBbZV0gPSB0LnRvdWNoZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgIHk6IGUuY2xpZW50WVxuICAgIH07XG4gIH1cbiAgX2dldERpcmVjdGlvbih0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHtcbiAgICAgICAgZGlyZWN0aW9uOiB0LnggPCAwID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIsXG4gICAgICAgIHZhbHVlOiBNYXRoLmFicyh0LngpXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICBkaXJlY3Rpb246IHQueSA8IDAgPyBcInVwXCIgOiBcImRvd25cIixcbiAgICAgICAgdmFsdWU6IE1hdGguYWJzKHQueSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5FMCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gSSh2MCwgZSwgVDApLCBlO1xuICB9XG59XG5jb25zdCBadCA9IFwicGFuXCIsIEEwID0gYCR7WnR9c3RhcnRgLCB5MCA9IGAke1p0fWVuZGAsIHcwID0gYCR7WnR9bW92ZWAsIGswID0gXCJsZWZ0XCIsIHgwID0gXCJyaWdodFwiLCBPMCA9IHtcbiAgdGhyZXNob2xkOiBcIm51bWJlclwiLFxuICBkaXJlY3Rpb246IFwic3RyaW5nXCIsXG4gIHBvaW50ZXJzOiBcIm51bWJlclwiXG59LCBTMCA9IHtcbiAgdGhyZXNob2xkOiAyMCxcbiAgZGlyZWN0aW9uOiBcImFsbFwiLFxuICBwb2ludGVyczogMVxufTtcbmNsYXNzIEkwIGV4dGVuZHMgUWkge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30pIHtcbiAgICBzdXBlcigpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fc3RhcnRUb3VjaCA9IG51bGw7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFp0O1xuICB9XG4gIGhhbmRsZVRvdWNoU3RhcnQodCkge1xuICAgIHRoaXMuX3N0YXJ0VG91Y2ggPSB0aGlzLl9nZXRDb29yZGluYXRlcyh0KSwgdGhpcy5fbW92ZWRUb3VjaCA9IHQsIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBBMCwgeyB0b3VjaDogdCB9KTtcbiAgfVxuICBoYW5kbGVUb3VjaE1vdmUodCkge1xuICAgIHQudHlwZSA9PT0gXCJ0b3VjaG1vdmVcIiAmJiB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgeyB0aHJlc2hvbGQ6IGUsIGRpcmVjdGlvbjogaSB9ID0gdGhpcy5fb3B0aW9ucywgbiA9IHRoaXMuX2dldENvb3JkaW5hdGVzKHQpLCBvID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZXModGhpcy5fbW92ZWRUb3VjaCksIHIgPSB0aGlzLl9nZXRPcmlnaW4obiwgdGhpcy5fc3RhcnRUb3VjaCksIGEgPSB0aGlzLl9nZXRPcmlnaW4obiwgbyksIGwgPSB0aGlzLl9nZXREaXJlY3Rpb24ociksIHAgPSB0aGlzLl9nZXREaXJlY3Rpb24oYSksIHsgeDogdSwgeTogXyB9ID0gbDtcbiAgICBpZiAoaSA9PT0gXCJhbGxcIiAmJiAoXy52YWx1ZSA+IGUgfHwgdS52YWx1ZSA+IGUpKSB7XG4gICAgICBjb25zdCBnID0gXy52YWx1ZSA+IHUudmFsdWUgPyBfLmRpcmVjdGlvbiA6IHUuZGlyZWN0aW9uO1xuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGAke1p0fSR7Z31gLCB7IHRvdWNoOiB0IH0pLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWnQsIHtcbiAgICAgICAgLi4uYSxcbiAgICAgICAgdG91Y2g6IHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBmID0gaSA9PT0gazAgfHwgaSA9PT0geDAgPyBcInhcIiA6IFwieVwiO1xuICAgIHBbZl0uZGlyZWN0aW9uID09PSBpICYmIGxbZl0udmFsdWUgPiBlICYmIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgJHtadH0ke2l9YCwge1xuICAgICAgdG91Y2g6IHQsXG4gICAgICBbZl06IG5bZl0gLSBvW2ZdXG4gICAgfSksIHRoaXMuX21vdmVkVG91Y2ggPSB0LCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdzAsIHsgdG91Y2g6IHQgfSk7XG4gIH1cbiAgaGFuZGxlVG91Y2hFbmQodCkge1xuICAgIHQudHlwZSA9PT0gXCJ0b3VjaGVuZFwiICYmIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fbW92ZWRUb3VjaCA9IG51bGwsIHRoaXMuX3N0YXJ0VG91Y2ggPSBudWxsLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgeTAsIHsgdG91Y2g6IHQgfSk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLlMwLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBJKFp0LCBlLCBPMCksIGU7XG4gIH1cbn1cbmNvbnN0IFVlID0gXCJwaW5jaFwiLCBEMCA9IGAke1VlfWVuZGAsICQwID0gYCR7VWV9c3RhcnRgLCBMMCA9IGAke1VlfW1vdmVgLCBOMCA9IHtcbiAgdGhyZXNob2xkOiBcIm51bWJlclwiLFxuICBwb2ludGVyczogXCJudW1iZXJcIlxufSwgTTAgPSB7XG4gIHRocmVzaG9sZDogMTAsXG4gIHBvaW50ZXJzOiAyXG59O1xuY2xhc3MgUjAgZXh0ZW5kcyBRaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSkge1xuICAgIHN1cGVyKCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9zdGFydFRvdWNoID0gbnVsbCwgdGhpcy5fb3JpZ2luID0gbnVsbCwgdGhpcy5fdG91Y2ggPSBudWxsLCB0aGlzLl9tYXRoID0gbnVsbCwgdGhpcy5fcmF0aW8gPSBudWxsO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBVZTtcbiAgfVxuICBnZXQgaXNOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9zdGFydFRvdWNoID09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHRoaXMuX3RvdWNoID09IFwibnVtYmVyXCIgJiYgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICFpc05hTih0aGlzLl9zdGFydFRvdWNoKSAmJiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgIWlzTmFOKHRoaXMuX3RvdWNoKTtcbiAgfVxuICBoYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICBpZiAodC50b3VjaGVzLmxlbmd0aCAhPT0gdGhpcy5fb3B0aW9ucy5wb2ludGVycylcbiAgICAgIHJldHVybjtcbiAgICB0LnR5cGUgPT09IFwidG91Y2hzdGFydFwiICYmIHQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBbZSwgaV0gPSB0aGlzLl9nZXRQaW5jaFRvdWNoT3JpZ2luKHQudG91Y2hlcyk7XG4gICAgdGhpcy5fdG91Y2ggPSBlLCB0aGlzLl9vcmlnaW4gPSBpLCB0aGlzLl9zdGFydFRvdWNoID0gdGhpcy5fdG91Y2gsIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCAkMCwge1xuICAgICAgdG91Y2g6IHQsXG4gICAgICByYXRpbzogdGhpcy5fcmF0aW8sXG4gICAgICBvcmlnaW46IHRoaXMuX29yaWdpblxuICAgIH0pO1xuICB9XG4gIGhhbmRsZVRvdWNoTW92ZSh0KSB7XG4gICAgY29uc3QgeyB0aHJlc2hvbGQ6IGUsIHBvaW50ZXJzOiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIHQudG91Y2hlcy5sZW5ndGggPT09IGkgJiYgKHQudHlwZSA9PT0gXCJ0b3VjaG1vdmVcIiAmJiB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX3RvdWNoID0gdGhpcy5fZ2V0UGluY2hUb3VjaE9yaWdpbih0LnRvdWNoZXMpWzBdLCB0aGlzLl9yYXRpbyA9IHRoaXMuX3RvdWNoIC8gdGhpcy5fc3RhcnRUb3VjaCwgdGhpcy5pc051bWJlciAmJiAodGhpcy5fb3JpZ2luLnggPiBlIHx8IHRoaXMuX29yaWdpbi55ID4gZSkgJiYgKHRoaXMuX3N0YXJ0VG91Y2ggPSB0aGlzLl90b3VjaCwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFVlLCB7XG4gICAgICB0b3VjaDogdCxcbiAgICAgIHJhdGlvOiB0aGlzLl9yYXRpbyxcbiAgICAgIG9yaWdpbjogdGhpcy5fb3JpZ2luXG4gICAgfSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBMMCwge1xuICAgICAgdG91Y2g6IHQsXG4gICAgICByYXRpbzogdGhpcy5fcmF0aW8sXG4gICAgICBvcmlnaW46IHRoaXMuX29yaWdpblxuICAgIH0pKSk7XG4gIH1cbiAgaGFuZGxlVG91Y2hFbmQodCkge1xuICAgIHRoaXMuaXNOdW1iZXIgJiYgKHRoaXMuX3N0YXJ0VG91Y2ggPSBudWxsLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRDAsIHtcbiAgICAgIHRvdWNoOiB0LFxuICAgICAgcmF0aW86IHRoaXMuX3JhdGlvLFxuICAgICAgb3JpZ2luOiB0aGlzLl9vcmlnaW5cbiAgICB9KSk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLk0wLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBJKFVlLCBlLCBOMCksIGU7XG4gIH1cbn1cbmNvbnN0IE5vID0gXCJ0YXBcIiwgUDAgPSB7XG4gIGludGVydmFsOiBcIm51bWJlclwiLFxuICB0aW1lOiBcIm51bWJlclwiLFxuICB0YXBzOiBcIm51bWJlclwiLFxuICBwb2ludGVyczogXCJudW1iZXJcIlxufSwgQjAgPSB7XG4gIGludGVydmFsOiA1MDAsXG4gIHRpbWU6IDI1MCxcbiAgdGFwczogMSxcbiAgcG9pbnRlcnM6IDFcbn07XG5jbGFzcyBIMCBleHRlbmRzIFFpIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl90aW1lciA9IG51bGwsIHRoaXMuX3RhcENvdW50ID0gMDtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTm87XG4gIH1cbiAgaGFuZGxlVG91Y2hTdGFydCh0KSB7XG4gICAgY29uc3QgeyB4OiBlLCB5OiBpIH0gPSB0aGlzLl9nZXRDb29yZGluYXRlcyh0KSwgeyBpbnRlcnZhbDogbiwgdGFwczogbywgcG9pbnRlcnM6IHIgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgcmV0dXJuIHQudG91Y2hlcy5sZW5ndGggPT09IHIgJiYgKHRoaXMuX3RhcENvdW50ICs9IDEsIHRoaXMuX3RhcENvdW50ID09PSAxICYmICh0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fdGFwQ291bnQgPSAwO1xuICAgIH0sIG4pKSwgdGhpcy5fdGFwQ291bnQgPT09IG8gJiYgKGNsZWFyVGltZW91dCh0aGlzLl90aW1lciksIHRoaXMuX3RhcENvdW50ID0gMCwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIE5vLCB7XG4gICAgICB0b3VjaDogdCxcbiAgICAgIG9yaWdpbjoge1xuICAgICAgICB4OiBlLFxuICAgICAgICB5OiBpXG4gICAgICB9XG4gICAgfSkpKSwgdDtcbiAgfVxuICBoYW5kbGVUb3VjaEVuZCgpIHtcbiAgfVxuICBoYW5kbGVUb3VjaE1vdmUoKSB7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLkIwLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBJKE5vLCBlLCBQMCksIGU7XG4gIH1cbn1cbmNvbnN0IFdpID0gXCJyb3RhdGVcIiwgVjAgPSBgJHtXaX1lbmRgLCBXMCA9IGAke1dpfXN0YXJ0YCwgRjAgPSB7XG4gIGFuZ2xlOiBcIm51bWJlclwiLFxuICBwb2ludGVyczogXCJudW1iZXJcIlxufSwgWTAgPSB7XG4gIGFuZ2xlOiAwLFxuICBwb2ludGVyczogMlxufTtcbmNsYXNzIGowIGV4dGVuZHMgUWkge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX29yaWdpbiA9IHt9O1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBXaTtcbiAgfVxuICBoYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICB0LnR5cGUgPT09IFwidG91Y2hzdGFydFwiICYmIHQucHJldmVudERlZmF1bHQoKSwgISh0LnRvdWNoZXMubGVuZ3RoIDwgMikgJiYgKHRoaXMuX3N0YXJ0VG91Y2ggPSB0LCB0aGlzLl9vcmlnaW4gPSB7fSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFcwLCB7IHRvdWNoOiB0IH0pKTtcbiAgfVxuICBoYW5kbGVUb3VjaE1vdmUodCkge1xuICAgIHQudHlwZSA9PT0gXCJ0b3VjaG1vdmVcIiAmJiB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IGUsIGk7XG4gICAgY29uc3QgbiA9IHQudG91Y2hlcztcbiAgICBpZiAobi5sZW5ndGggPT09IDEgJiYgdGhpcy5fb3B0aW9ucy5wb2ludGVycyA9PT0gMSkge1xuICAgICAgY29uc3QgeyBsZWZ0OiBvLCB0b3A6IHIsIHdpZHRoOiBhLCBoZWlnaHQ6IGwgfSA9IHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBlID0ge1xuICAgICAgICB4OiBvICsgYSAvIDIsXG4gICAgICAgIHk6IHIgKyBsIC8gMlxuICAgICAgfSwgaSA9IG5bMF07XG4gICAgfSBlbHNlIGlmICh0LnRvdWNoZXMubGVuZ3RoID09PSAyICYmIHRoaXMuX29wdGlvbnMucG9pbnRlcnMgPT09IDIpIHtcbiAgICAgIGNvbnN0IFtvLCByXSA9IHQudG91Y2hlcywgYSA9IHtcbiAgICAgICAgeDE6IHIuY2xpZW50WCxcbiAgICAgICAgeDI6IG8uY2xpZW50WCxcbiAgICAgICAgeTE6IHIuY2xpZW50WSxcbiAgICAgICAgeTI6IG8uY2xpZW50WVxuICAgICAgfTtcbiAgICAgIGUgPSB0aGlzLl9nZXRNaWRQb2ludChhKSwgaSA9IHRoaXMuX2dldFJpZ2h0TW9zdFRvdWNoKHQudG91Y2hlcyk7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jdXJyZW50QW5nbGUgPSB0aGlzLl9nZXRBbmdsZShcbiAgICAgIGUueCxcbiAgICAgIGUueSxcbiAgICAgIGkuY2xpZW50WCxcbiAgICAgIGkuY2xpZW50WVxuICAgICksIHRoaXMuX29yaWdpbi5pbml0aWFsQW5nbGUgPyAodGhpcy5fb3JpZ2luLmNoYW5nZSA9IHRoaXMuX2dldEFuZ3VsYXJEaXN0YW5jZShcbiAgICAgIHRoaXMuX29yaWdpbi5wcmV2aW91c0FuZ2xlLFxuICAgICAgdGhpcy5jdXJyZW50QW5nbGVcbiAgICApLCB0aGlzLl9vcmlnaW4uZGlzdGFuY2UgKz0gdGhpcy5fb3JpZ2luLmNoYW5nZSkgOiAodGhpcy5fb3JpZ2luLmluaXRpYWxBbmdsZSA9IHRoaXMuX29yaWdpbi5wcmV2aW91c0FuZ2xlID0gdGhpcy5jdXJyZW50QW5nbGUsIHRoaXMuX29yaWdpbi5kaXN0YW5jZSA9IHRoaXMuX29yaWdpbi5jaGFuZ2UgPSAwKSwgdGhpcy5fb3JpZ2luLnByZXZpb3VzQW5nbGUgPSB0aGlzLmN1cnJlbnRBbmdsZSwgdGhpcy5yb3RhdGUgPSB7XG4gICAgICBjdXJyZW50QW5nbGU6IHRoaXMuY3VycmVudEFuZ2xlLFxuICAgICAgZGlzdGFuY2U6IHRoaXMuX29yaWdpbi5kaXN0YW5jZSxcbiAgICAgIGNoYW5nZTogdGhpcy5fb3JpZ2luLmNoYW5nZVxuICAgIH0sIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBXaSwgeyAuLi50aGlzLnJvdGF0ZSwgdG91Y2g6IHQgfSk7XG4gIH1cbiAgaGFuZGxlVG91Y2hFbmQodCkge1xuICAgIHQudHlwZSA9PT0gXCJ0b3VjaGVuZFwiICYmIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fb3JpZ2luID0ge30sIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBWMCwgeyB0b3VjaDogdCB9KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4uWTAsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEkoV2ksIGUsIEYwKSwgZTtcbiAgfVxufVxuY29uc3Qgc3IgPSBcInRvdWNoXCIsIE1vID0gYHRlLiR7c3J9YCwgSzAgPSB7XG4gIGV2ZW50OiBcInN0cmluZ1wiXG59LCB6MCA9IHtcbiAgZXZlbnQ6IFwic3dpcGVcIlxufTtcbmNsYXNzIEtoIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2V2ZW50ID0gdGhpcy5fb3B0aW9ucy5ldmVudCwgdGhpcy5zd2lwZSA9IHRoaXMuX2V2ZW50ID09PSBcInN3aXBlXCIgPyBuZXcgQzAodCwgZSkgOiBudWxsLCB0aGlzLnByZXNzID0gdGhpcy5fZXZlbnQgPT09IFwicHJlc3NcIiA/IG5ldyBiMCh0LCBlKSA6IG51bGwsIHRoaXMucGFuID0gdGhpcy5fZXZlbnQgPT09IFwicGFuXCIgPyBuZXcgSTAodCwgZSkgOiBudWxsLCB0aGlzLnBpbmNoID0gdGhpcy5fZXZlbnQgPT09IFwicGluY2hcIiA/IG5ldyBSMCh0LCBlKSA6IG51bGwsIHRoaXMudGFwID0gdGhpcy5fZXZlbnQgPT09IFwidGFwXCIgPyBuZXcgSDAodCwgZSkgOiBudWxsLCB0aGlzLnJvdGF0ZSA9IHRoaXMuX2V2ZW50ID09PSBcInJvdGF0ZVwiID8gbmV3IGowKHQsIGUpIDogbnVsbCwgdGhpcy5fdG91Y2hTdGFydEhhbmRsZXIgPSAoaSkgPT4gdGhpcy5faGFuZGxlVG91Y2hTdGFydChpKSwgdGhpcy5fdG91Y2hNb3ZlSGFuZGxlciA9IChpKSA9PiB0aGlzLl9oYW5kbGVUb3VjaE1vdmUoaSksIHRoaXMuX3RvdWNoRW5kSGFuZGxlciA9IChpKSA9PiB0aGlzLl9oYW5kbGVUb3VjaEVuZChpKSwgYy5vbih0aGlzLl9lbGVtZW50LCBcInRvdWNoc3RhcnRcIiwgdGhpcy5fdG91Y2hTdGFydEhhbmRsZXIpLCBjLm9uKHRoaXMuX2VsZW1lbnQsIFwidG91Y2htb3ZlXCIsIHRoaXMuX3RvdWNoTW92ZUhhbmRsZXIpLCBjLm9uKHRoaXMuX2VsZW1lbnQsIFwidG91Y2hlbmRcIiwgdGhpcy5fdG91Y2hFbmRIYW5kbGVyKSwgdGhpcy5fZWxlbWVudCAmJiBBLnNldERhdGEodCwgTW8sIHRoaXMpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBzcjtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwidG91Y2hzdGFydFwiLCB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlciksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwidG91Y2htb3ZlXCIsIHRoaXMuX3RvdWNoTW92ZUhhbmRsZXIpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBcInRvdWNoZW5kXCIsIHRoaXMuX3RvdWNoRW5kSGFuZGxlciksIHRoaXMuc3dpcGUgPSBudWxsLCB0aGlzLnByZXNzID0gbnVsbCwgdGhpcy5wYW4gPSBudWxsLCB0aGlzLnBpbmNoID0gbnVsbCwgdGhpcy50YXAgPSBudWxsLCB0aGlzLnJvdGF0ZSA9IG51bGw7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLnowLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBJKHNyLCBlLCBLMCksIGU7XG4gIH1cbiAgX2hhbmRsZVRvdWNoU3RhcnQodCkge1xuICAgIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoU3RhcnQodCk7XG4gIH1cbiAgX2hhbmRsZVRvdWNoTW92ZSh0KSB7XG4gICAgdGhpc1t0aGlzLl9ldmVudF0uaGFuZGxlVG91Y2hNb3ZlICYmIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoTW92ZSh0KTtcbiAgfVxuICBfaGFuZGxlVG91Y2hFbmQodCkge1xuICAgIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoRW5kKHQpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgZSA9IEEuZ2V0RGF0YSh0aGlzLCBNbyk7XG4gICAgICBjb25zdCBpID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIWUgJiYgL2Rpc3Bvc2UvLnRlc3QodCkpICYmIChlIHx8IChlID0gbmV3IEtoKHRoaXMsIGkpKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIHJldHVybiBlW3RdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEEuZ2V0RGF0YSh0LCBNbyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgbnIgPSBcInNtb290aFNjcm9sbFwiLCBTaSA9IGB0ZS4ke25yfWAsIE9yID0gYC4ke1NpfWAsIFUwID0ge1xuICBjb250YWluZXI6IFwic3RyaW5nXCIsXG4gIG9mZnNldDogXCJudW1iZXJcIixcbiAgZWFzaW5nOiBcInN0cmluZ1wiLFxuICBkdXJhdGlvbjogXCJudW1iZXJcIlxufSwgWDAgPSB7XG4gIGNvbnRhaW5lcjogXCJib2R5XCIsXG4gIG9mZnNldDogMCxcbiAgZWFzaW5nOiBcImxpbmVhclwiLFxuICBkdXJhdGlvbjogNTAwXG59LCBHMCA9IGBzY3JvbGxTdGFydCR7T3J9YCwgcTAgPSBgc2Nyb2xsRW5kJHtPcn1gLCBaMCA9IGBzY3JvbGxDYW5jZWwke09yfWA7XG5jbGFzcyB6aCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9ocmVmID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLCB0aGlzLmlzQ2FuY2VsID0gITEsIHRoaXMuX2VsZW1lbnQgJiYgKEEuc2V0RGF0YSh0LCBTaSwgdGhpcyksIHRoaXMuX3NldHVwKCkpO1xuICB9XG4gIC8vIGdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBucjtcbiAgfVxuICBnZXQgaXNXaW5kb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuY29udGFpbmVyID09PSBcImJvZHlcIjtcbiAgfVxuICBnZXQgY29udGFpbmVyVG9TY3JvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNXaW5kb3cgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBkLmZpbmRPbmUoXG4gICAgICB0aGlzLl9vcHRpb25zLmNvbnRhaW5lcixcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICAgICk7XG4gIH1cbiAgZ2V0IGVsRnJvbUhyZWZFeGlzdCgpIHtcbiAgICByZXR1cm4gISFkLmZpbmRPbmUodGhpcy5faHJlZiwgdGhpcy5jb250YWluZXJUb1Njcm9sbCk7XG4gIH1cbiAgZ2V0IG9mZnNldEZyb21FbCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jb250YWluZXJUb1Njcm9sbC5zY3JvbGxUb3AsIGUgPSBkLmZpbmRPbmUodGhpcy5faHJlZiwgdGhpcy5jb250YWluZXJUb1Njcm9sbCk7XG4gICAgaWYgKHRoaXMuaXNXaW5kb3cpXG4gICAgICByZXR1cm4gaC5vZmZzZXQoZSkudG9wIC0gdGhpcy5fb3B0aW9ucy5vZmZzZXQgKyB0O1xuICAgIGNvbnN0IGkgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnksIG4gPSB0aGlzLmNvbnRhaW5lclRvU2Nyb2xsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnk7XG4gICAgcmV0dXJuIGkgLSBuIC0gdGhpcy5fb3B0aW9ucy5vZmZzZXQgKyB0O1xuICB9XG4gIGdldCBlYXNpbmdGdW5jdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fb3B0aW9ucy5lYXNpbmcsIGUgPSBgX21vdGlvbiR7dFswXS50b1VwcGVyQ2FzZSgpfSR7dC5zbGljZSgxKX1gO1xuICAgIHJldHVybiB0aGlzW2VdID8gdGhpc1tlXSA6IHRoaXMuX21vdGlvbkxpbmVhcjtcbiAgfVxuICAvLyBwdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICBjLm9mZih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsIHRoaXMuX2hhbmRsZUNsaWNrKSwgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIFNpKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgY2FuY2VsU2Nyb2xsKCkge1xuICAgIHRoaXMuaXNDYW5jZWwgPSAhMDtcbiAgfVxuICAvLyBwcml2YXRlXG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5YMCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gSShuciwgZSwgVTApLCBlO1xuICB9XG4gIF9pblZpZXdwb3J0KCkge1xuICAgIGlmICh0aGlzLmlzV2luZG93KVxuICAgICAgcmV0dXJuICEwO1xuICAgIGNvbnN0IHQgPSB0aGlzLmNvbnRhaW5lclRvU2Nyb2xsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB0LnRvcCA+PSAwICYmIHQuYm90dG9tIDw9ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCk7XG4gIH1cbiAgX3NldHVwKCkge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgdGhpcy5faHJlZiA8IFwidVwiLCBlID0gdGhpcy5faHJlZi5pbmNsdWRlcyhcIiNcIik7XG4gICAgdCAmJiBlICYmIHRoaXMuZWxGcm9tSHJlZkV4aXN0ICYmICh0aGlzLl9zY3JvbGxPbkNsaWNrRXZlbnQoKSwgdGhpcy5fcHJldmVudE5hdGl2ZVNjcm9sbCgpKTtcbiAgfVxuICBfc2Nyb2xsT25DbGlja0V2ZW50KCkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCAodCkgPT4ge1xuICAgICAgdGhpcy5faGFuZGxlQ2xpY2sodCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUNsaWNrKHQpIHtcbiAgICB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuaXNDYW5jZWwgPSAhMSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEcwKTtcbiAgICBjb25zdCBlID0gdGhpcy5jb250YWluZXJUb1Njcm9sbCwgaSA9IHRoaXMuY29udGFpbmVyVG9TY3JvbGwuc2Nyb2xsVG9wLCBuID0gdGhpcy5vZmZzZXRGcm9tRWwsIG8gPSAwLCByID0gMSAvIHRoaXMuX29wdGlvbnMuZHVyYXRpb24sIGEgPSA0LjI1LCBsID0gdGhpcy5lYXNpbmdGdW5jdGlvbjtcbiAgICB0aGlzLl9pblZpZXdwb3J0KCkgPyB0aGlzLl9zY3JvbGxPbk5leHRUaWNrKFxuICAgICAgZSxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgbyxcbiAgICAgIHIsXG4gICAgICBhLFxuICAgICAgbFxuICAgICkgOiAodGhpcy5fc2Nyb2xsT25OZXh0VGljayhcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICB0aGlzLmNvbnRhaW5lclRvU2Nyb2xsLm9mZnNldFRvcCxcbiAgICAgIG8sXG4gICAgICByLFxuICAgICAgYSxcbiAgICAgIGxcbiAgICApLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3Njcm9sbE9uTmV4dFRpY2soXG4gICAgICAgIGUsXG4gICAgICAgIGksXG4gICAgICAgIG4sXG4gICAgICAgIG8sXG4gICAgICAgIHIsXG4gICAgICAgIGEsXG4gICAgICAgIGxcbiAgICAgICksIHRoaXMuaXNDYW5jZWwgPSAhMTtcbiAgICB9LCB0aGlzLl9vcHRpb25zLmR1cmF0aW9uKSk7XG4gIH1cbiAgX3Njcm9sbE9uTmV4dFRpY2sodCwgZSwgaSwgbiwgbywgciwgYSkge1xuICAgIGNvbnN0IGwgPSBuIDwgMCwgcCA9IG4gPiAxLCB1ID0gbyA8PSAwO1xuICAgIGlmIChsIHx8IHAgfHwgdSB8fCB0aGlzLmlzQ2FuY2VsKSB7XG4gICAgICBpZiAodGhpcy5pc0NhbmNlbCkge1xuICAgICAgICB0aGlzLmlzSW5WaWV3cG9ydCAmJiAodGhpcy5pc0NhbmNlbCA9ICExKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFowKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHEwKSwgdC5zY3JvbGxUb3AgPSBpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0LnNjcm9sbFRvKHtcbiAgICAgIHRvcDogZSAtIChlIC0gaSkgKiBhKG4pXG4gICAgfSksIG4gKz0gbyAqIHIsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fc2Nyb2xsT25OZXh0VGljayhcbiAgICAgICAgdCxcbiAgICAgICAgZSxcbiAgICAgICAgaSxcbiAgICAgICAgbixcbiAgICAgICAgbyxcbiAgICAgICAgcixcbiAgICAgICAgYVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBfcHJldmVudERlZmF1bHQodCkge1xuICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfcHJldmVudE5hdGl2ZVNjcm9sbCgpIHtcbiAgICBsZXQgdCA9ICExO1xuICAgIHRyeSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0ZXN0XCIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJwYXNzaXZlXCIsIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IHQgPSAhMFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChuKSB7XG4gICAgICB0aGlzLl9zY3JvbGxFcnJvciA9IG47XG4gICAgfVxuICAgIGNvbnN0IGUgPSB0ID8geyBwYXNzaXZlOiAhMSB9IDogITEsIGkgPSBcIm9ud2hlZWxcIiBpbiAkKFwiZGl2XCIpID8gXCJ3aGVlbFwiIDogXCJtb3VzZXdoZWVsXCI7XG4gICAgdGhpcy5pc1dpbmRvdyAmJiAodGhpcy5fZGVsZXRlU2Nyb2xsT25TdGFydChlLCBpKSwgdGhpcy5fYWRkU2Nyb2xsT25FbmQoZSwgaSksIHRoaXMuX2FkZFNjcm9sbE9uQ2FuY2VsKGUsIGkpKTtcbiAgfVxuICBfZGVsZXRlU2Nyb2xsT25TdGFydCh0LCBlKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcInNjcm9sbFN0YXJ0LnRlLnNtb290aFNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihlLCB0aGlzLl9wcmV2ZW50RGVmYXVsdCwgdCksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX3ByZXZlbnREZWZhdWx0LCB0KTtcbiAgICB9KTtcbiAgfVxuICBfYWRkU2Nyb2xsT25FbmQodCwgZSkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJzY3JvbGxFbmQudGUuc21vb3RoU2Nyb2xsXCIsICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGUsIHRoaXMuX3ByZXZlbnREZWZhdWx0LCB0KSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fcHJldmVudERlZmF1bHQsIHQpO1xuICAgIH0pO1xuICB9XG4gIF9hZGRTY3JvbGxPbkNhbmNlbCh0LCBlKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcInNjcm9sbENhbmNlbC50ZS5zbW9vdGhTY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgdGhpcy5fcHJldmVudERlZmF1bHQsIHQpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9wcmV2ZW50RGVmYXVsdCwgdCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gTW90aW9uc1xuICAvLyBMaW5lYXJcbiAgX21vdGlvbkxpbmVhcih0KSB7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgLy8gRWFzZS1JblxuICBfbW90aW9uRWFzZUluUXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xuICB9XG4gIF9tb3Rpb25FYXNlSW5DdWJpYyh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfVxuICBfbW90aW9uRWFzZUluUXVhcnQodCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0O1xuICB9XG4gIF9tb3Rpb25FYXNlSW5RdWludCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xuICB9XG4gIC8vIEVhc2UtSW4tT3V0XG4gIF9tb3Rpb25FYXNlSW5PdXRRdWFkKHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0O1xuICB9XG4gIF9tb3Rpb25FYXNlSW5PdXRDdWJpYyh0KSB7XG4gICAgcmV0dXJuIHQgLz0gMC41LCB0IDwgMSA/IHQgKiB0ICogdCAvIDIgOiAodCAtPSAyLCAodCAqIHQgKiB0ICsgMikgLyAyKTtcbiAgfVxuICBfbW90aW9uRWFzZUluT3V0UXVhcnQodCkge1xuICAgIHJldHVybiB0IC89IDAuNSwgdCA8IDEgPyAwLjUgKiB0ICogdCAqIHQgKiB0IDogKHQgLT0gMiwgLSh0ICogdCAqIHQgKiB0IC0gMikgLyAyKTtcbiAgfVxuICBfbW90aW9uRWFzZUluT3V0UXVpbnQodCkge1xuICAgIHJldHVybiB0IC89IDAuNSwgdCA8IDEgPyB0ICogdCAqIHQgKiB0ICogdCAvIDIgOiAodCAtPSAyLCAodCAqIHQgKiB0ICogdCAqIHQgKyAyKSAvIDIpO1xuICB9XG4gIC8vIEVhc2UtT3V0XG4gIF9tb3Rpb25FYXNlT3V0UXVhZCh0KSB7XG4gICAgcmV0dXJuIC10ICogKHQgLSAyKTtcbiAgfVxuICBfbW90aW9uRWFzZU91dEN1YmljKHQpIHtcbiAgICByZXR1cm4gdC0tLCB0ICogdCAqIHQgKyAxO1xuICB9XG4gIF9tb3Rpb25FYXNlT3V0UXVhcnQodCkge1xuICAgIHJldHVybiB0LS0sIC0odCAqIHQgKiB0ICogdCAtIDEpO1xuICB9XG4gIF9tb3Rpb25FYXNlT3V0UXVpbnQodCkge1xuICAgIHJldHVybiB0LS0sIHQgKiB0ICogdCAqIHQgKiB0ICsgMTtcbiAgfVxuICAvLyBzdGF0aWNcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIFNpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgZSA9IEEuZ2V0RGF0YSh0aGlzLCBTaSk7XG4gICAgICBjb25zdCBpID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKGUgfHwgKGUgPSBuZXcgemgodGhpcywgaSkpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBxbCA9IFwibGF6eUxvYWRcIiwgUHMgPSBcInRlLmxhenlMb2FkXCIsIFEwID0gXCJbZGF0YS10ZS1sYXp5LWxvYWQtaW5pdF1cIiwgWmwgPSBcImRhdGEtdGUtbGF6eS1sb2FkXCIsIEowID0gXCJvbkxvYWQudGUubGF6eVwiLCB0QyA9IFwib25FcnJvci50ZS5sYXp5XCIsIFFsID0gW1wiaW1nXCIsIFwidmlkZW9cIl0sIGVDID0ge1xuICBsYXp5U3JjOiBcIihzdHJpbmd8bnVsbClcIixcbiAgbGF6eURlbGF5OiBcIm51bWJlclwiLFxuICBsYXp5QW5pbWF0aW9uOiBcInN0cmluZ1wiLFxuICBsYXp5T2Zmc2V0OiBcIm51bWJlclwiLFxuICBsYXp5UGxhY2Vob2xkZXI6IFwiKHN0cmluZ3x1bmRlZmluZWQpXCIsXG4gIGxhenlFcnJvcjogXCIoc3RyaW5nfHVuZGVmaW5lZClcIlxufSwgaUMgPSB7XG4gIGxhenlTcmM6IG51bGwsXG4gIGxhenlEZWxheTogNTAwLFxuICBsYXp5QW5pbWF0aW9uOiBcIltmYWRlLWluXzFzX2Vhc2UtaW4tb3V0XVwiLFxuICBsYXp5T2Zmc2V0OiAwXG59O1xuY2xhc3Mgb3Ige1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2VsZW1lbnQgJiYgQS5zZXREYXRhKHQsIFBzLCB0aGlzKSwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5zY3JvbGxIYW5kbGVyID0gdGhpcy5fc2Nyb2xsSGFuZGxlci5iaW5kKHRoaXMpLCB0aGlzLmVycm9ySGFuZGxlciA9IHRoaXMuX3NldEVsZW1lbnRFcnJvci5iaW5kKHRoaXMpLCB0aGlzLl9jaGlsZHJlbkluc3RhbmNlcyA9IG51bGwsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gcWw7XG4gIH1cbiAgZ2V0IG9mZnNldFZhbHVlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICBnZXQgaW5WaWV3cG9ydCgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJldHVybiB0LnkgPiAwICYmIHQueSA8IHdpbmRvdy5pbm5lckhlaWdodCAmJiB0aGlzLm9mZnNldFZhbHVlcy55ID49IHQueSAmJiB0aGlzLm9mZnNldFZhbHVlcy55IDw9IHQueSArIHQuaGVpZ2h0ICYmIHRoaXMub2Zmc2V0VmFsdWVzLnkgPD0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vZmZzZXRWYWx1ZXMudG9wICsgdGhpcy5fb3B0aW9ucy5sYXp5T2Zmc2V0IDw9IHdpbmRvdy5pbm5lckhlaWdodCAmJiB0aGlzLm9mZnNldFZhbHVlcy5ib3R0b20gPj0gMDtcbiAgfVxuICBnZXQgcGFyZW50KCkge1xuICAgIGNvbnN0IFt0XSA9IGQucGFyZW50cyhcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBRMFxuICAgICk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgZ2V0IG5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQubm9kZU5hbWU7XG4gIH1cbiAgZ2V0IGlzQ29udGFpbmVyKCkge1xuICAgIHJldHVybiAhZC5tYXRjaGVzKHRoaXMuX2VsZW1lbnQsIFFsKTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgUHMpLCB0aGlzLl9hbmltYXRpb24gJiYgKHRoaXMuX2FuaW1hdGlvbi5kaXNwb3NlKCksIHRoaXMuX2FuaW1hdGlvbiA9IG51bGwpLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fY2hpbGRyZW5JbnN0YW5jZXMgJiYgdGhpcy5fY2hpbGRyZW5JbnN0YW5jZXMuZm9yRWFjaCgodCkgPT4gdC5kaXNwb3NlKCkpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFpsLCBcIlwiKSwgdGhpcy5pc0NvbnRhaW5lcikge1xuICAgICAgdGhpcy5fc2V0dXBDb250YWluZXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc2V0dXBFbGVtZW50KCk7XG4gIH1cbiAgX3NldHVwRWxlbWVudCgpIHtcbiAgICBjLm9uZSh0aGlzLl9lbGVtZW50LCBcImVycm9yXCIsIHRoaXMuZXJyb3JIYW5kbGVyKSwgdGhpcy5fb3B0aW9ucy5sYXp5UGxhY2Vob2xkZXIgJiYgdGhpcy5fc2V0UGxhY2Vob2xkZXIoKSwgdGhpcy5fYW5pbWF0aW9uID0gbmV3IHdyKHRoaXMuX2VsZW1lbnQsIHtcbiAgICAgIGFuaW1hdGlvbjogYCR7dGhpcy5fb3B0aW9ucy5sYXp5QW5pbWF0aW9ufWAsXG4gICAgICBhbmltYXRpb25TdGFydDogXCJvbkxvYWRcIlxuICAgIH0pLCBjLm9uZSh0aGlzLl9lbGVtZW50LCBcImxvYWRcIiwgKCkgPT4gdGhpcy5fc2Nyb2xsSGFuZGxlcigpKSwgdGhpcy5wYXJlbnQgJiYgYy5vbih0aGlzLnBhcmVudCwgXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyKSwgYy5vbih3aW5kb3csIFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlcik7XG4gIH1cbiAgX3Njcm9sbEhhbmRsZXIoKSB7XG4gICAgdGhpcy5pblZpZXdwb3J0ICYmICh0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9zZXRTcmMoKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoWmwpLCB0aGlzLl9yZW1vdmVBdHRycygpLCB0aGlzLl9hbmltYXRpb24uaW5pdCgpO1xuICAgIH0sIHRoaXMuX29wdGlvbnMubGF6eURlbGF5KSwgdGhpcy5wYXJlbnQgJiYgYy5vZmYodGhpcy5wYXJlbnQsIFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlciksIGMub2ZmKHdpbmRvdywgXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyKSk7XG4gIH1cbiAgX3NldEVsZW1lbnRFcnJvcigpIHtcbiAgICAhdGhpcy5fb3B0aW9ucy5sYXp5RXJyb3IgfHwgdGhpcy5fZWxlbWVudC5zcmMgPT09IHRoaXMuX29wdGlvbnMubGF6eUVycm9yID8gdGhpcy5fZWxlbWVudC5hbHQgPSBcIjQwNCBub3QgZm91bmRcIiA6IHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwic3JjXCIsIHRoaXMuX29wdGlvbnMubGF6eUVycm9yKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRDKTtcbiAgfVxuICBfc2V0U3JjKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwic3JjXCIsIHRoaXMuX29wdGlvbnMubGF6eVNyYyksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBKMCk7XG4gIH1cbiAgX3NldFBsYWNlaG9sZGVyKCkge1xuICAgIHRoaXMubm9kZSA9PT0gXCJJTUdcIiA/IHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwic3JjXCIsIHRoaXMuX29wdGlvbnMubGF6eVBsYWNlaG9sZGVyKSA6IHRoaXMubm9kZSA9PT0gXCJWSURFT1wiICYmIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwicG9zdGVyXCIsIHRoaXMuX29wdGlvbnMubGF6eVBsYWNlaG9sZGVyKTtcbiAgfVxuICBfcmVtb3ZlQXR0cnMoKSB7XG4gICAgW1wic3JjXCIsIFwiZGVsYXlcIiwgXCJhbmltYXRpb25cIiwgXCJwbGFjZWhvbGRlclwiLCBcIm9mZnNldFwiLCBcImVycm9yXCJdLmZvckVhY2goXG4gICAgICAodCkgPT4ge1xuICAgICAgICBoLnJlbW92ZURhdGFBdHRyaWJ1dGUodGhpcy5fZWxlbWVudCwgYGxhenktJHt0fWApO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX3NldHVwQ29udGFpbmVyKCkge1xuICAgIHRoaXMuX2NoaWxkcmVuSW5zdGFuY2VzID0gZC5jaGlsZHJlbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBRbFxuICAgICkubWFwKCh0KSA9PiBuZXcgb3IodCwgdGhpcy5fb3B0aW9ucykpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5pQyxcbiAgICAgIC4uLnQsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpXG4gICAgfTtcbiAgICByZXR1cm4gSShxbCwgZSwgZUMpLCBlO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgUHMpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBlID0gQS5nZXREYXRhKHRoaXMsIFBzKTtcbiAgICAgIGNvbnN0IGkgPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoZSB8fCAoZSA9IG5ldyBvcih0aGlzLCBpKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEpsID0gXCJjbGlwYm9hcmRcIiwgSWkgPSBcInRlLmNsaXBib2FyZFwiLCBzQyA9IGAuJHtJaX1gLCBuQyA9IHtcbiAgY2xpcGJvYXJkVGFyZ2V0OiBudWxsXG59LCBvQyA9IHtcbiAgY2xpcGJvYXJkVGFyZ2V0OiBcIm51bGx8c3RyaW5nXCJcbn0sIHJDID0gYGNvcHkke3NDfWA7XG5jbGFzcyBVaCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gZSwgdGhpcy5fZWxlbWVudCAmJiAoQS5zZXREYXRhKHQsIElpLCB0aGlzKSwgdGhpcy5faW5pdENvcHkgPSB0aGlzLl9pbml0Q29weS5iaW5kKHRoaXMpLCB0aGlzLl9zZXR1cCgpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gSmw7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLm5DLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRoaXMuX29wdGlvbnNcbiAgICB9O1xuICAgIHJldHVybiBJKEpsLCB0LCBvQyksIHQ7XG4gIH1cbiAgZ2V0IGNsaXBib2FyZFRhcmdldCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKHRoaXMub3B0aW9ucy5jbGlwYm9hcmRUYXJnZXQpO1xuICB9XG4gIGdldCBjb3B5VGV4dCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jbGlwYm9hcmRUYXJnZXQuaGFzQXR0cmlidXRlKFxuICAgICAgXCJkYXRhLXRlLWNsaXBib2FyZC10ZXh0XCJcbiAgICApLCBlID0gdGhpcy5jbGlwYm9hcmRUYXJnZXQudmFsdWUsIGkgPSB0aGlzLmNsaXBib2FyZFRhcmdldC50ZXh0Q29udGVudDtcbiAgICByZXR1cm4gdCA/IHRoaXMuY2xpcGJvYXJkVGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtdGUtY2xpcGJvYXJkLXRleHRcIikgOiBlIHx8IGk7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9pbml0Q29weSksIEEucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBJaSksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX3NldHVwKCkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9pbml0Q29weSk7XG4gIH1cbiAgX2luaXRDb3B5KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jcmVhdGVOZXdJbnB1dCgpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodCksIHRoaXMuX3NlbGVjdElucHV0KHQpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgckMsIHtcbiAgICAgIGNvcHlUZXh0OiB0aGlzLmNvcHlUZXh0XG4gICAgfSksIHQucmVtb3ZlKCk7XG4gIH1cbiAgX2NyZWF0ZU5ld0lucHV0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNsaXBib2FyZFRhcmdldC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIgPyBcInRleHRhcmVhXCIgOiBcImlucHV0XCIsIGUgPSAkKHQpO1xuICAgIHJldHVybiBlLnZhbHVlID0gdGhpcy5jb3B5VGV4dCwgaC5hZGRDbGFzcyhlLCBcIi1sZWZ0LVs5OTk5cHhdIGFic29sdXRlXCIpLCBlO1xuICB9XG4gIF9zZWxlY3RJbnB1dCh0KSB7XG4gICAgdC5zZWxlY3QoKSwgdC5mb2N1cygpLCB0LnNldFNlbGVjdGlvblJhbmdlKDAsIDk5OTk5KSwgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJjb3B5XCIpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGUgPSBBLmdldERhdGEodGhpcywgSWkpO1xuICAgICAgY29uc3QgaSA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmIChlIHx8IChlID0gbmV3IFVoKHRoaXMsIGkpKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgSWkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IHJyID0gXCJpbmZpbml0ZVNjcm9sbFwiLCBCcyA9IGB0ZS4ke3JyfWAsIGFDID0ge1xuICBpbmZpbml0ZURpcmVjdGlvbjogXCJ5XCJcbn0sIGxDID0ge1xuICBpbmZpbml0ZURpcmVjdGlvbjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIFhoIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9lbGVtZW50ICYmIEEuc2V0RGF0YSh0LCBCcywgdGhpcyksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuc2Nyb2xsSGFuZGxlciA9IHRoaXMuX3Njcm9sbEhhbmRsZXIuYmluZCh0aGlzKSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBycjtcbiAgfVxuICBnZXQgcmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICBnZXQgY29uZGl0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50ID09PSB3aW5kb3cgPyBNYXRoLmFicyhcbiAgICAgIHdpbmRvdy5zY3JvbGxZICsgd2luZG93LmlubmVySGVpZ2h0IC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgICkgPCAxIDogdGhpcy5fb3B0aW9ucy5pbmZpbml0ZURpcmVjdGlvbiA9PT0gXCJ4XCIgPyB0aGlzLnJlY3Qud2lkdGggKyB0aGlzLl9lbGVtZW50LnNjcm9sbExlZnQgKyAxMCA+PSB0aGlzLl9lbGVtZW50LnNjcm9sbFdpZHRoIDogTWF0aC5jZWlsKHRoaXMucmVjdC5oZWlnaHQgKyB0aGlzLl9lbGVtZW50LnNjcm9sbFRvcCkgPj0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyKSwgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIEJzKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwic2Nyb2xsXCIsICgpID0+IHRoaXMuX3Njcm9sbEhhbmRsZXIoKSk7XG4gIH1cbiAgX3Njcm9sbEhhbmRsZXIoKSB7XG4gICAgdGhpcy5jb25kaXRpb24gJiYgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwiY29tcGxldGUudGUuaW5maW5pdGVTY3JvbGxcIiksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlcik7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLmFDLFxuICAgICAgLi4udGhpcy5fZWxlbWVudCAhPT0gd2luZG93ID8gaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSA6IHt9LFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEkocnIsIGUsIGxDKSwgZTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIEJzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgZSA9IEEuZ2V0RGF0YSh0aGlzLCBCcyk7XG4gICAgICBjb25zdCBpID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKGUgfHwgKGUgPSBuZXcgWGgodGhpcywgaSkpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjQyh7IGJhY2tkcm9wSUQ6IHMgfSwgdCkge1xuICBjb25zdCBlID0gJChcImRpdlwiKTtcbiAgcmV0dXJuIGguYWRkQ2xhc3MoXG4gICAgZSxcbiAgICBgJHt0LmJhY2tkcm9wfSAke3QuYmFja2Ryb3BDb2xvcn1gXG4gICksIGUuaWQgPSBzLCBlO1xufVxuY29uc3QgRmkgPSBcImxvYWRpbmdNYW5hZ2VtZW50XCIsIEhzID0gYHRlLiR7Rml9YCwgaEMgPSBcIltkYXRhLXRlLWxvYWRpbmctaWNvbi1yZWZdXCIsIGRDID0gXCJbZGF0YS10ZS1sb2FkaW5nLXRleHQtcmVmXVwiLCB1QyA9IGBzaG93LnRlLiR7Rml9YCwgcEMgPSB7XG4gIGJhY2tkcm9wOiBcIihudWxsfGJvb2xlYW4pXCIsXG4gIGJhY2tkcm9wSUQ6IFwiKG51bGx8c3RyaW5nfG51bWJlcilcIixcbiAgZGVsYXk6IFwiKG51bGx8bnVtYmVyKVwiLFxuICBsb2FkZXI6IFwiKG51bGx8c3RyaW5nfG51bWJlcilcIixcbiAgcGFyZW50U2VsZWN0b3I6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBsb2FkaW5nSWNvbjogXCJib29sZWFuXCIsXG4gIGxvYWRpbmdUZXh0OiBcImJvb2xlYW5cIixcbiAgc2Nyb2xsOiBcImJvb2xlYW5cIlxufSwgX0MgPSB7XG4gIGJhY2tkcm9wOiAhMCxcbiAgYmFja2Ryb3BJRDogbnVsbCxcbiAgZGVsYXk6IDAsXG4gIGxvYWRlcjogXCJcIixcbiAgcGFyZW50U2VsZWN0b3I6IG51bGwsXG4gIHNjcm9sbDogITAsXG4gIGxvYWRpbmdUZXh0OiAhMCxcbiAgbG9hZGluZ0ljb246ICEwXG59LCBmQyA9IHtcbiAgbG9hZGluZ1NwaW5uZXI6IFwiYWJzb2x1dGUgdG9wLVs1MCVdIGxlZnQtWzUwJV0gLXRyYW5zbGF0ZS14LVs1MCVdIC10cmFuc2xhdGUteS1bNTAlXSBmbGV4IGZsZXgtY29sIGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciB6LTQwXCIsXG4gIHNwaW5uZXJDb2xvcjogXCJ0ZXh0LXByaW1hcnkgZGFyazp0ZXh0LXByaW1hcnktNDAwXCIsXG4gIGJhY2tkcm9wOiBcInctZnVsbCBoLWZ1bGwgZml4ZWQgdG9wLTAgbGVmdC0wIGJvdHRvbS0wIHJpZ2h0LTAgei0zMFwiLFxuICBiYWNrZHJvcENvbG9yOiBcImJnLVtyZ2JhKDAsMCwwLDAuNCldXCJcbn0sIG1DID0ge1xuICBsb2FkaW5nU3Bpbm5lcjogXCJzdHJpbmdcIixcbiAgc3Bpbm5lckNvbG9yOiBcInN0cmluZ1wiLFxuICBiYWNrZHJvcDogXCJzdHJpbmdcIixcbiAgYmFja2Ryb3BDb2xvcjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIEdoIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9lbGVtZW50ICYmIEEuc2V0RGF0YSh0LCBIcywgdGhpcyksIHRoaXMuX2JhY2tkcm9wRWxlbWVudCA9IG51bGwsIHRoaXMuX3BhcmVudEVsZW1lbnQgPSBkLmZpbmRPbmUodGhpcy5fb3B0aW9ucy5wYXJlbnRTZWxlY3RvciksIHRoaXMuX2xvYWRpbmdJY29uID0gZC5maW5kT25lKFxuICAgICAgaEMsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fbG9hZGluZ1RleHQgPSBkLmZpbmRPbmUoXG4gICAgICBkQyxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLmluaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gRmk7XG4gIH1cbiAgLy8gUHVibGljXG4gIGluaXQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2xvYWRpbmdJY29uLmNsb25lTm9kZSghMCksIGUgPSB0aGlzLl9sb2FkaW5nVGV4dC5jbG9uZU5vZGUoITApO1xuICAgIHRoaXMuX3JlbW92ZUVsZW1lbnRzT25TdGFydCgpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGguYWRkQ2xhc3MoXG4gICAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAgIGAke3RoaXMuX2NsYXNzZXMubG9hZGluZ1NwaW5uZXJ9ICR7dGhpcy5fY2xhc3Nlcy5zcGlubmVyQ29sb3J9YFxuICAgICAgKSwgdGhpcy5fc2V0QmFja2Ryb3AoKSwgdGhpcy5fc2V0TG9hZGluZ0ljb24odCksIHRoaXMuX3NldExvYWRpbmdUZXh0KGUpLCB0aGlzLl9zZXRTY3JvbGxPcHRpb24oKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHVDKTtcbiAgICB9LCB0aGlzLl9vcHRpb25zLmRlbGF5KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIEEucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBIcyksIGgucmVtb3ZlQ2xhc3MoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5sb2FkaW5nU3Bpbm5lcn0gJHt0aGlzLl9jbGFzc2VzLnNwaW5uZXJDb2xvcn1gXG4gICAgKTtcbiAgICBjb25zdCB0ID0gdGhpcy5fb3B0aW9ucy5kZWxheTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3JlbW92ZUJhY2tkcm9wKCksIHRoaXMuX2JhY2tkcm9wRWxlbWVudCA9IG51bGwsIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9vcHRpb25zID0gbnVsbDtcbiAgICB9LCB0KTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9zZXRCYWNrZHJvcCgpIHtcbiAgICBjb25zdCB7IGJhY2tkcm9wOiB0IH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIHQgJiYgKHRoaXMuX2JhY2tkcm9wRWxlbWVudCA9IGNDKHRoaXMuX29wdGlvbnMsIHRoaXMuX2NsYXNzZXMpLCB0aGlzLl9wYXJlbnRFbGVtZW50ICE9PSBudWxsID8gKGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJhYnNvbHV0ZVwiKSwgaC5hZGRDbGFzcyh0aGlzLl9wYXJlbnRFbGVtZW50LCBcInJlbGF0aXZlXCIpLCBoLmFkZENsYXNzKHRoaXMuX2JhY2tkcm9wRWxlbWVudCwgXCJhYnNvbHV0ZVwiKSwgdGhpcy5fcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9iYWNrZHJvcEVsZW1lbnQpKSA6IChoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIFwiIWZpeGVkXCIpLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2JhY2tkcm9wRWxlbWVudCksIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCkpKTtcbiAgfVxuICBfcmVtb3ZlQmFja2Ryb3AoKSB7XG4gICAgY29uc3QgeyBiYWNrZHJvcDogdCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICB0ICYmICh0aGlzLl9wYXJlbnRFbGVtZW50ICE9PSBudWxsID8gKGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJhYnNvbHV0ZVwiKSwgaC5yZW1vdmVDbGFzcyh0aGlzLl9wYXJlbnRFbGVtZW50LCBcInJlbGF0aXZlXCIpLCB0aGlzLl9iYWNrZHJvcEVsZW1lbnQucmVtb3ZlKCkpIDogKHRoaXMuX2JhY2tkcm9wRWxlbWVudC5yZW1vdmUoKSwgdGhpcy5fZWxlbWVudC5yZW1vdmUoKSkpO1xuICB9XG4gIF9zZXRMb2FkaW5nSWNvbih0KSB7XG4gICAgaWYgKCF0aGlzLl9vcHRpb25zLmxvYWRpbmdJY29uKSB7XG4gICAgICB0LnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKHQpLCB0LmlkID0gdGhpcy5fb3B0aW9ucy5sb2FkZXI7XG4gIH1cbiAgX3NldExvYWRpbmdUZXh0KHQpIHtcbiAgICBpZiAoIXRoaXMuX29wdGlvbnMubG9hZGluZ1RleHQpIHtcbiAgICAgIHQucmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnQuYXBwZW5kQ2hpbGQodCk7XG4gIH1cbiAgX3JlbW92ZUVsZW1lbnRzT25TdGFydCgpIHtcbiAgICB0aGlzLl9lbGVtZW50ICE9PSBudWxsICYmICh0aGlzLl9sb2FkaW5nSWNvbi5yZW1vdmUoKSwgdGhpcy5fbG9hZGluZ1RleHQucmVtb3ZlKCkpO1xuICB9XG4gIF9zZXRTY3JvbGxPcHRpb24oKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2Nyb2xsKSB7XG4gICAgICBpZiAodGhpcy5fcGFyZW50RWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICBoLmFkZENsYXNzKGRvY3VtZW50LmJvZHksIFwib3ZlcmZsb3ctYXV0b1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaC5hZGRDbGFzcyh0aGlzLl9wYXJlbnRFbGVtZW50LCBcIm92ZXJmbG93LWF1dG9cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9wYXJlbnRFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIGguYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgXCJvdmVyZmxvdy1oaWRkZW5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGguYWRkQ2xhc3ModGhpcy5fcGFyZW50RWxlbWVudCwgXCJvdmVyZmxvdy1oaWRkZW5cIik7XG4gICAgfVxuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5fQyxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gSShGaSwgZSwgcEMpLCBlO1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uZkMsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoRmksIHQsIG1DKSwgdDtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIEhzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgZSA9IEEuZ2V0RGF0YSh0aGlzLCBIcyk7XG4gICAgICBjb25zdCBpID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKGUgfHwgKGUgPSBuZXcgR2godGhpcywgaSkpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBnQyA9IChzKSA9PiB7XG4gIGNvbnN0IHQgPSAvXigwP1sxLTldfDFbMDEyXSkoOlswLTVdXFxkKSBbQVBhcF1bbU1dJC8sIGUgPSAvXihbMC05XXwwWzAtOV18MVswLTldfDJbMC0zXSk6WzAtNV1bMC05XSg6WzAtNV1bMC05XSk/JC87XG4gIHJldHVybiBzLm1hdGNoKHQpIHx8IHMubWF0Y2goZSk7XG59LCBiQyA9IChzKSA9PiBzICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzKSA9PT0gXCJbb2JqZWN0IERhdGVdXCIgJiYgIWlzTmFOKHMpLCB2QyA9IChzKSA9PiBzLmdldE1vbnRoKCksIFRDID0gKHMpID0+IHMuZ2V0RnVsbFllYXIoKSwgRUMgPSAocykgPT4gcy5tYXRjaCgvW14oZG15KV17MSx9L2cpLCBDQyA9IChzLCB0LCBlLCBpKSA9PiB7XG4gIGxldCBuO1xuICBlWzBdICE9PSBlWzFdID8gbiA9IGVbMF0gKyBlWzFdIDogbiA9IGVbMF07XG4gIGNvbnN0IG8gPSBuZXcgUmVnRXhwKGBbJHtufV1gKSwgciA9IHMuc3BsaXQobyksIGEgPSB0LnNwbGl0KG8pLCBsID0gdC5pbmRleE9mKFwibW1tXCIpICE9PSAtMSwgcCA9IFtdO1xuICBmb3IgKGxldCBiID0gMDsgYiA8IGEubGVuZ3RoOyBiKyspXG4gICAgYVtiXS5pbmRleE9mKFwieXlcIikgIT09IC0xICYmIChwWzBdID0geyB2YWx1ZTogcltiXSwgZm9ybWF0OiBhW2JdIH0pLCBhW2JdLmluZGV4T2YoXCJtXCIpICE9PSAtMSAmJiAocFsxXSA9IHsgdmFsdWU6IHJbYl0sIGZvcm1hdDogYVtiXSB9KSwgYVtiXS5pbmRleE9mKFwiZFwiKSAhPT0gLTEgJiYgYVtiXS5sZW5ndGggPD0gMiAmJiAocFsyXSA9IHsgdmFsdWU6IHJbYl0sIGZvcm1hdDogYVtiXSB9KTtcbiAgbGV0IHU7XG4gIHQuaW5kZXhPZihcIm1tbW1cIikgIT09IC0xID8gdSA9IGkubW9udGhzRnVsbCA6IHUgPSBpLm1vbnRoc1Nob3J0O1xuICBjb25zdCBfID0gTnVtYmVyKHBbMF0udmFsdWUpLCBmID0gbCA/IEFDKHBbMV0udmFsdWUsIHUpIDogTnVtYmVyKHBbMV0udmFsdWUpIC0gMSwgZyA9IE51bWJlcihwWzJdLnZhbHVlKTtcbiAgcmV0dXJuIEN0KF8sIGYsIGcpO1xufSwgQUMgPSAocywgdCkgPT4gdC5maW5kSW5kZXgoKGUpID0+IGUgPT09IHMpLCB5QyA9IChzLCB0LCBlKSA9PiBgXG4gIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtlLnBpY2tlckljb259XCIgZGF0YS10ZS1kYXRlcGlja2VyLXRvZ2dsZS1idXR0b24tcmVmPlxuICAgICR7c31cbiAgPC9idXR0b24+XG4gIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtlLnBpY2tlckljb259XCIgZGF0YS10ZS10aW1lcGlja2VyLXRvZ2dsZS1idXR0b24tcmVmPlxuICAgICR7dH1cbiAgPC9idXR0b24+XG5gLCB3QyA9IChzLCB0KSA9PiBgXG4gIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHt0LnRvZ2dsZUJ1dHRvbn1cIiBkYXRhLXRlLWRhdGUtdGltZXBpY2tlci10b2dnbGUtcmVmPlxuICAgICR7c30gXG4gIDwvYnV0dG9uPlxuYCwgb24gPSBcImRhdGV0aW1lcGlja2VyXCIsIERpID0gYHRlLiR7b259YCwgU3IgPSBgLiR7RGl9YCwgcWggPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1pbml0XCIsIFpoID0gXCJkYXRhLXRlLXRpbWVwaWNrZXItaW5pdFwiLCBrQyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWhlYWRlclwiLCB4QyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNhbmNlbC1idXR0b24tcmVmXCIsIE9DID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItb2stYnV0dG9uLXJlZlwiLCBSbyA9IFwiZGF0YS10ZS10aW1lcGlja2VyLXdyYXBwZXJcIiwgdGMgPSBcImRhdGEtdGUtdGltZXBpY2tlci1jYW5jZWxcIiwgU0MgPSBcImRhdGEtdGUtdGltZXBpY2tlci1zdWJtaXRcIiwgSUMgPSBcImRhdGEtdGUtdGltZXBpY2tlci1jbGVhclwiLCBlYyA9IFwiZGF0YS10ZS1idXR0b25zLXRpbWVwaWNrZXJcIiwgREMgPSBcImRhdGEtdGUtZGF0ZS10aW1lcGlja2VyLXRvZ2dsZS1yZWZcIiwgJEMgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtYnV0dG9uLXJlZlwiLCBMQyA9IFwiZGF0YS10ZS10aW1lcGlja2VyLXRvZ2dsZS1idXR0b24tcmVmXCIsIE5DID0gYFske1pofV1gLCBNQyA9IGBbJHtxaH1dYCwgUkMgPSBgWyR7REN9XWAsIFBDID0gYFske0xDfV1gLCBCQyA9IFwiW2RhdGEtdGUtaW5wdXQtbm90Y2gtcmVmXVwiLCBIQyA9IFwiW2RhdGEtdGUtZGF0ZS10aW1lcGlja2VyLXRvZ2dsZS1yZWZdXCIsIFZDID0gXCJbZGF0YS10ZS10aW1lcGlja2VyLWVsZW1lbnRzLXdyYXBwZXJdXCIsIFdDID0gXCJbZGF0YS10ZS10aW1lcGlja2VyLWNsb2NrLXdyYXBwZXJdXCIsIEZDID0gYG9wZW4ke1NyfWAsIFlDID0gYGNsb3NlJHtTcn1gLCBqQyA9IGBkYXRldGltZUNoYW5nZSR7U3J9YCwgaWMgPSBcImNsb3NlLnRlLmRhdGVwaWNrZXJcIiwgc2MgPSBcImlucHV0LnRlLnRpbWVwaWNrZXJcIiwgUmUgPSAkKFwiZGl2XCIpLCBuYyA9IHtcbiAgaW5saW5lOiAhMSxcbiAgdG9nZ2xlQnV0dG9uOiAhMCxcbiAgY29udGFpbmVyOiBcImJvZHlcIixcbiAgZGlzYWJsZWQ6ICExLFxuICBkaXNhYmxlUGFzdDogITEsXG4gIGRpc2FibGVGdXR1cmU6ICExLFxuICBkZWZhdWx0VGltZTogXCJcIixcbiAgZGVmYXVsdERhdGU6IFwiXCIsXG4gIHRpbWVwaWNrZXI6IHt9LFxuICBkYXRlcGlja2VyOiB7fSxcbiAgc2hvd0Zvcm1hdDogITEsXG4gIGRhdGVUaW1lcGlja2VyVG9nZ2xlSWNvblRlbXBsYXRlOiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIj5cbiAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNi43NSAyLjI1QS43NS43NSAwIDAxNy41IDN2MS41aDlWM0EuNzUuNzUgMCAwMTE4IDN2MS41aC43NWEzIDMgMCAwMTMgM3YxMS4yNWEzIDMgMCAwMS0zIDNINS4yNWEzIDMgMCAwMS0zLTNWNy41YTMgMyAwIDAxMy0zSDZWM2EuNzUuNzUgMCAwMS43NS0uNzV6bTEzLjUgOWExLjUgMS41IDAgMDAtMS41LTEuNUg1LjI1YTEuNSAxLjUgMCAwMC0xLjUgMS41djcuNWExLjUgMS41IDAgMDAxLjUgMS41aDEzLjVhMS41IDEuNSAwIDAwMS41LTEuNXYtNy41elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiAvPlxuICA8L3N2Zz5gLFxuICBkYXRlcGlja2VyVG9nZ2xlSWNvblRlbXBsYXRlOiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIj5cbiAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNi43NSAyLjI1QS43NS43NSAwIDAxNy41IDN2MS41aDlWM0EuNzUuNzUgMCAwMTE4IDN2MS41aC43NWEzIDMgMCAwMTMgM3YxMS4yNWEzIDMgMCAwMS0zIDNINS4yNWEzIDMgMCAwMS0zLTNWNy41YTMgMyAwIDAxMy0zSDZWM2EuNzUuNzUgMCAwMS43NS0uNzV6bTEzLjUgOWExLjUgMS41IDAgMDAtMS41LTEuNUg1LjI1YTEuNSAxLjUgMCAwMC0xLjUgMS41djcuNWExLjUgMS41IDAgMDAxLjUgMS41aDEzLjVhMS41IDEuNSAwIDAwMS41LTEuNXYtNy41elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiAvPlxuICA8L3N2Zz5gLFxuICB0aW1lcGlja2VyVG9nZ2xlSWNvblRlbXBsYXRlOiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTIgNnY2aDQuNW00LjUgMGE5IDkgMCAxMS0xOCAwIDkgOSAwIDAxMTggMHpcIiAvPlxuICA8L3N2Zz5gXG59LCBLQyA9IHtcbiAgaW5saW5lOiBcImJvb2xlYW5cIixcbiAgdG9nZ2xlQnV0dG9uOiBcImJvb2xlYW5cIixcbiAgY29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBkaXNhYmxlZDogXCJib29sZWFuXCIsXG4gIGRpc2FibGVQYXN0OiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZUZ1dHVyZTogXCJib29sZWFuXCIsXG4gIGRlZmF1bHRUaW1lOiBcIihzdHJpbmd8ZGF0ZXxudW1iZXIpXCIsXG4gIGRlZmF1bHREYXRlOiBcIihzdHJpbmd8ZGF0ZXxudW1iZXIpXCIsXG4gIHRpbWVwaWNrZXI6IFwib2JqZWN0XCIsXG4gIGRhdGVwaWNrZXI6IFwib2JqZWN0XCIsXG4gIHNob3dGb3JtYXQ6IFwiYm9vbGVhblwiLFxuICBkYXRlVGltZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZTogXCJzdHJpbmdcIlxufSwgekMgPSB7XG4gIHRvZ2dsZUJ1dHRvbjogXCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNvbnRlbnQtY2VudGVyIFsmPnN2Z106dy01IFsmPnN2Z106aC01IGFic29sdXRlIG91dGxpbmUtbm9uZSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCByaWdodC0wLjUgdG9wLTEvMiAtdHJhbnNsYXRlLXgtMS8yIC10cmFuc2xhdGUteS0xLzIgaG92ZXI6dGV4dC1wcmltYXJ5IGZvY3VzOnRleHQtcHJpbWFyeSBkYXJrOmhvdmVyOnRleHQtcHJpbWFyeS00MDAgZGFyazpmb2N1czp0ZXh0LXByaW1hcnktNDAwIGRhcms6dGV4dC1uZXV0cmFsLTIwMFwiLFxuICBwaWNrZXJJY29uOiBcIlsmPnN2Z106dy02IFsmPnN2Z106aC02IFsmPnN2Z106bXgtYXV0byBbJj5zdmddOnBvaW50ZXItZXZlbnRzLW5vbmUgdy0xLzIgcHgtMS41IHB5LVsxcHhdIHJvdW5kZWQtWzEwcHhdIG1pbi1oLVs0MHB4XSBjdXJzb3ItcG9pbnRlciBvdXRsaW5lLW5vbmUgYm9yZGVyLW5vbmUgdGV4dC13aGl0ZSBob3ZlcjpiZy1wcmltYXJ5LTYwMCBkYXJrOmhvdmVyOmJnLW5ldXRyYWwtNjAwXCIsXG4gIGJ1dHRvbnNDb250YWluZXI6IFwiZmxleCBqdXN0aWZ5LWV2ZW5seSBpdGVtcy1lbmQgYmctcHJpbWFyeSBkYXJrOmJnLXppbmMtODAwIGRhcms6ZGF0YS1bdGUtYnV0dG9ucy10aW1lcGlja2VyXTpiZy16aW5jLTcwMFwiLFxuICB0aW1lcGlja2VyOiB7fSxcbiAgZGF0ZXBpY2tlcjoge31cbn0sIFVDID0ge1xuICB0b2dnbGVCdXR0b246IFwic3RyaW5nXCIsXG4gIHBpY2tlckljb246IFwic3RyaW5nXCIsXG4gIGJ1dHRvbnNDb250YWluZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXI6IFwib2JqZWN0XCIsXG4gIGRhdGVwaWNrZXI6IFwib2JqZWN0XCJcbn07XG5jbGFzcyBRaCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5faW5wdXQgPSBkLmZpbmRPbmUoXCJpbnB1dFwiLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX3RpbWVwaWNrZXIgPSBudWxsLCB0aGlzLl9kYXRlcGlja2VyID0gbnVsbCwgdGhpcy5fZGF0ZVZhbHVlID0gdGhpcy5fb3B0aW9ucy5kZWZhdWx0RGF0ZSA/IHRoaXMuX29wdGlvbnMuZGVmYXVsdERhdGUgOiBcIlwiLCB0aGlzLl90aW1lVmFsdWUgPSB0aGlzLl9vcHRpb25zLmRlZmF1bHRUaW1lID8gdGhpcy5fb3B0aW9ucy5kZWZhdWx0VGltZSA6IFwiXCIsIHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgPSAhMSwgdGhpcy5fZm9ybWF0ID0gdGhpcy5fb3B0aW9ucy5kYXRlcGlja2VyLmZvcm1hdCA/IHRoaXMuX29wdGlvbnMuZGF0ZXBpY2tlci5mb3JtYXQgOiBcImRkL21tL3l5eXlcIiwgdGhpcy5fY2FuY2VsID0gITEsIHRoaXMuX3Njcm9sbEJhciA9IG5ldyB0aSgpLCB0aGlzLl9lbGVtZW50ICYmIEEuc2V0RGF0YSh0LCBEaSwgdGhpcyksIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gb247XG4gIH1cbiAgZ2V0IHRvZ2dsZUJ1dHRvbigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFJDLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgbm90Y2goKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShCQywgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjLm9mZih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsIHRoaXMuX29wZW5EYXRlUGlja2VyKSwgYy5vZmYodGhpcy5faW5wdXQsIFwiaW5wdXRcIiwgdGhpcy5faGFuZGxlSW5wdXQpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIpLCBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgRGkpLCB0aGlzLl9yZW1vdmVUaW1lUGlja2VyKCksIHRoaXMuX3JlbW92ZURhdGVwaWNrZXIoKSwgdGhpcy50b2dnbGVCdXR0b24ucmVtb3ZlKCksIHRoaXMuX29wdGlvbnMgPSBuYywgdGhpcy5fdGltZXBpY2tlciA9IG51bGwsIHRoaXMuX2RhdGVwaWNrZXIgPSBudWxsLCB0aGlzLl9kYXRlVmFsdWUgPSBudWxsLCB0aGlzLl90aW1lVmFsdWUgPSBudWxsLCB0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0ID0gbnVsbDtcbiAgfVxuICB1cGRhdGUodCA9IHt9KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldENvbmZpZyh7IC4uLnRoaXMuX29wdGlvbnMsIC4uLnQgfSk7XG4gICAgdGhpcy5kaXNwb3NlKCksIHRoaXMuX29wdGlvbnMgPSBlLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9hZGREYXRlcGlja2VyKCksIHRoaXMuX2FkZFRpbWVQaWNrZXIoKSwgdGhpcy5fYXBwZW5kVG9nZ2xlQnV0dG9uKCksIHRoaXMuX2xpc3RlblRvVG9nZ2xlQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9Vc2VySW5wdXQoKSwgdGhpcy5fZGlzYWJsZUlucHV0KCksIHRoaXMuX3NldEluaXRpYWxEZWZhdWx0SW5wdXQoKSwgdGhpcy5fYXBwbHlGb3JtYXRQbGFjZWhvbGRlcigpLCB0aGlzLl9vcHRpb25zLmRpc2FibGVQYXN0ICYmIHRoaXMuX2hhbmRsZVRpbWVwaWNrZXJEaXNhYmxlUGFzdCgpLCB0aGlzLl9vcHRpb25zLmRpc2FibGVGdXR1cmUgJiYgdGhpcy5faGFuZGxlVGltZXBpY2tlckRpc2FibGVGdXR1cmUoKTtcbiAgfVxuICBfcmVtb3ZlRGF0ZXBpY2tlcigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKE1DKTtcbiAgICB0ICYmIHQucmVtb3ZlKCk7XG4gIH1cbiAgX2FkZERhdGVwaWNrZXIoKSB7XG4gICAgY29uc3QgdCA9ICQoXCJkaXZcIik7XG4gICAgdC5pZCA9IHRoaXMuX2VsZW1lbnQuaWQgPyBgZGF0ZXBpY2tlci0ke3RoaXMuX2VsZW1lbnQuaWR9YCA6IGV0KFwiZGF0ZXBpY2tlci1cIik7XG4gICAgY29uc3QgZSA9ICc8aW5wdXQgdHlwZT1cInRleHRcIj4nO1xuICAgIHQuaW5uZXJIVE1MID0gZSwgdC5zZXRBdHRyaWJ1dGUocWgsIFwiXCIpLCB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKHQpLCBoLmFkZENsYXNzKHQsIFwiaGlkZGVuXCIpO1xuICAgIGxldCBpID0ge1xuICAgICAgLi4udGhpcy5fb3B0aW9ucy5kYXRlcGlja2VyLFxuICAgICAgY29udGFpbmVyOiB0aGlzLl9vcHRpb25zLmNvbnRhaW5lcixcbiAgICAgIGRpc2FibGVQYXN0OiB0aGlzLl9vcHRpb25zLmRpc2FibGVQYXN0LFxuICAgICAgZGlzYWJsZUZ1dHVyZTogdGhpcy5fb3B0aW9ucy5kaXNhYmxlRnV0dXJlXG4gICAgfTtcbiAgICAodGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5fb3B0aW9ucy5kYXRlcGlja2VyLmlubGluZSkgJiYgKGkgPSB7IC4uLmksIGlubGluZTogITAgfSksIHRoaXMuX2RhdGVwaWNrZXIgPSBuZXcgb2codCwgaSwge1xuICAgICAgLi4udGhpcy5fY2xhc3Nlcy5kYXRlcGlja2VyXG4gICAgfSksIHRoaXMuX2RhdGVwaWNrZXIuX2lucHV0LnZhbHVlID0gdGhpcy5fZGF0ZVZhbHVlO1xuICB9XG4gIF9yZW1vdmVUaW1lUGlja2VyKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoTkMpO1xuICAgIHQgJiYgKHQucmVtb3ZlKCksIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpKTtcbiAgfVxuICBfYWRkVGltZVBpY2tlcigpIHtcbiAgICBjb25zdCB0ID0gJChcImRpdlwiKTtcbiAgICB0LmlkID0gdGhpcy5fZWxlbWVudC5pZCA/IGB0aW1lcGlja2VyLSR7dGhpcy5fZWxlbWVudC5pZH1gIDogZXQoXCJ0aW1lcGlja2VyLVwiKTtcbiAgICBjb25zdCBlID0gJzxpbnB1dCB0eXBlPVwidGV4dFwiPic7XG4gICAgdC5pbm5lckhUTUwgPSBlLCB0LnNldEF0dHJpYnV0ZShaaCwgXCJcIiksIHRoaXMuX2VsZW1lbnQuYXBwZW5kQ2hpbGQodCksIGguYWRkQ2xhc3ModCwgXCJoaWRkZW5cIik7XG4gICAgbGV0IGkgPSB7XG4gICAgICAuLi50aGlzLl9vcHRpb25zLnRpbWVwaWNrZXIsXG4gICAgICBjb250YWluZXI6IHRoaXMuX29wdGlvbnMuY29udGFpbmVyXG4gICAgfTtcbiAgICAodGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5fb3B0aW9ucy50aW1lcGlja2VyLmlubGluZSkgJiYgKGkgPSB7IC4uLmksIGlubGluZTogITAgfSksIHRoaXMuX3RpbWVwaWNrZXIgPSBuZXcgU2codCwgaSwge1xuICAgICAgLi4udGhpcy5fY2xhc3Nlcy50aW1lcGlja2VyXG4gICAgfSksIHRoaXMuX3RpbWVwaWNrZXIuaW5wdXQudmFsdWUgPSB0aGlzLl90aW1lVmFsdWU7XG4gIH1cbiAgX2FkZEljb25CdXR0b25zKCkge1xuICAgIGlmIChoLmFkZENsYXNzKFJlLCB0aGlzLl9jbGFzc2VzLmJ1dHRvbnNDb250YWluZXIpLCBSZS5pbm5lckhUTUwgPSB5QyhcbiAgICAgIHRoaXMuX29wdGlvbnMuZGF0ZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMudGltZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZSxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCBSZS5yZW1vdmVBdHRyaWJ1dGUoZWMpLCAhKHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX29wdGlvbnMuZGF0ZXBpY2tlci5pbmxpbmUpKSB7XG4gICAgICBpZiAodGhpcy5fc2Nyb2xsQmFyLmhpZGUoKSwgdGhpcy5fZGF0ZXBpY2tlci5faXNPcGVuKVxuICAgICAgICBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske2tDfV1gLFxuICAgICAgICAgIGRvY3VtZW50LmJvZHlcbiAgICAgICAgKS5hcHBlbmRDaGlsZChSZSk7XG4gICAgICBlbHNlIGlmICh0aGlzLl90aW1lcGlja2VyLl9tb2RhbCAmJiAhdGhpcy5fb3B0aW9ucy50aW1lcGlja2VyLmlubGluZSkge1xuICAgICAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgICAgIFZDLFxuICAgICAgICAgIGRvY3VtZW50LmJvZHlcbiAgICAgICAgKSwgZSA9IGQuZmluZE9uZShcbiAgICAgICAgICBXQyxcbiAgICAgICAgICBkb2N1bWVudC5ib2R5XG4gICAgICAgICk7XG4gICAgICAgIFJlLnNldEF0dHJpYnV0ZShlYywgXCJcIiksIHQuaW5zZXJ0QmVmb3JlKFJlLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2VuYWJsZU9yRGlzYWJsZVRvZ2dsZUJ1dHRvbigpIHtcbiAgICB0aGlzLl9vcHRpb25zLmRpc2FibGVkID8gKHRoaXMudG9nZ2xlQnV0dG9uLmRpc2FibGVkID0gITAsIGguYWRkQ2xhc3ModGhpcy50b2dnbGVCdXR0b24sIFwicG9pbnRlci1ldmVudHMtbm9uZVwiKSkgOiAodGhpcy50b2dnbGVCdXR0b24uZGlzYWJsZWQgPSAhMSwgaC5yZW1vdmVDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbiwgXCJwb2ludGVyLWV2ZW50cy1ub25lXCIpKTtcbiAgfVxuICBfYXBwZW5kVG9nZ2xlQnV0dG9uKCkge1xuICAgIHRoaXMuX29wdGlvbnMudG9nZ2xlQnV0dG9uICYmICh0aGlzLl9lbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChcbiAgICAgIFwiYmVmb3JlZW5kXCIsXG4gICAgICB3QyhcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5kYXRlVGltZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZSxcbiAgICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICAgKVxuICAgICksIHRoaXMuX2VuYWJsZU9yRGlzYWJsZVRvZ2dsZUJ1dHRvbigpKTtcbiAgfVxuICBfYXBwbHlGb3JtYXRQbGFjZWhvbGRlcigpIHtcbiAgICB0aGlzLl9vcHRpb25zLnNob3dGb3JtYXQgJiYgKHRoaXMuX2lucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5fZm9ybWF0KTtcbiAgfVxuICBfbGlzdGVuVG9DYW5jZWxDbGljaygpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgYFske3hDfV1gLFxuICAgICAgZG9jdW1lbnQuYm9keVxuICAgICk7XG4gICAgYy5vbmUodCwgXCJtb3VzZWRvd25cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fY2FuY2VsID0gITAsIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpLCBjLm9mZih0LCBcIm1vdXNlZG93blwiKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9Ub2dnbGVDbGljaygpIHtcbiAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgSEMsICh0KSA9PiB7XG4gICAgICB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX29wZW5EYXRlUGlja2VyKCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvVXNlcklucHV0KCkge1xuICAgIGMub24odGhpcy5faW5wdXQsIFwiaW5wdXRcIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZUlucHV0KHQudGFyZ2V0LnZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICBfZGlzYWJsZUlucHV0KCkge1xuICAgIHRoaXMuX29wdGlvbnMuZGlzYWJsZWQgJiYgKHRoaXMuX2lucHV0LmRpc2FibGVkID0gXCJ0cnVlXCIpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ubmMsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkob24sIHQsIEtDKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnpDLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKG9uLCB0LCBVQyksIHQ7XG4gIH1cbiAgX2hhbmRsZUlucHV0KHQpIHtcbiAgICBjb25zdCBlID0gdC5zcGxpdChcIiwgXCIpLCBpID0gRUModGhpcy5fZm9ybWF0KSwgbiA9IGVbMF0sIG8gPSBlWzFdIHx8IFwiXCIsIHIgPSBDQyhcbiAgICAgIG4sXG4gICAgICB0aGlzLl9mb3JtYXQsXG4gICAgICBpLFxuICAgICAgdGhpcy5fZGF0ZXBpY2tlci5fb3B0aW9uc1xuICAgICk7XG4gICAgZS5sZW5ndGggPT09IDIgJiYgKGJDKHIpICYmIGdDKG8pID8gKHRoaXMuX2RhdGVWYWx1ZSA9IG4sIHRoaXMuX3RpbWVWYWx1ZSA9IG8sIHRoaXMuX2RhdGVwaWNrZXIuX2lucHV0LnZhbHVlID0gdGhpcy5fZGF0ZVZhbHVlLCB0aGlzLl9kYXRlcGlja2VyLl9hY3RpdmVEYXRlID0gdGhpcy5fZGF0ZVZhbHVlLCB0aGlzLl9kYXRlcGlja2VyLl9zZWxlY3RlZFllYXIgPSBUQyhyKSwgdGhpcy5fZGF0ZXBpY2tlci5fc2VsZWN0ZWRNb250aCA9IHZDKHIpLCB0aGlzLl9kYXRlcGlja2VyLl9oZWFkZXJEYXRlID0gciwgdGhpcy5fdGltZXBpY2tlci5pbnB1dC52YWx1ZSA9IHRoaXMuX3RpbWVWYWx1ZSwgdGhpcy5fdGltZXBpY2tlci5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICExKSA6ICh0aGlzLl9kYXRlcGlja2VyLl9hY3RpdmVEYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHRoaXMuX2RhdGVwaWNrZXIuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX2RhdGVwaWNrZXIuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLl9kYXRlcGlja2VyLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9kYXRlcGlja2VyLl9oZWFkZXJEYXRlID0gbnVsbCwgdGhpcy5fZGF0ZXBpY2tlci5faGVhZGVyTW9udGggPSBudWxsLCB0aGlzLl9kYXRlcGlja2VyLl9oZWFkZXJZZWFyID0gbnVsbCwgdGhpcy5fdGltZXBpY2tlci5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICEwKSk7XG4gIH1cbiAgX29wZW5EYXRlUGlja2VyKCkge1xuICAgIGlmIChjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRkMpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fZGF0ZXBpY2tlci5vcGVuKCksIHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX3Njcm9sbEJhci5oaWRlKCksICh0aGlzLl9vcHRpb25zLmlubGluZSB8fCB0aGlzLl9vcHRpb25zLmRhdGVwaWNrZXIuaW5saW5lKSAmJiB0aGlzLl9vcGVuRHJvcGRvd25EYXRlKCksIHRoaXMuX2FkZEljb25CdXR0b25zKCksIHRoaXMuX2xpc3RlblRvQ2FuY2VsQ2xpY2soKSwgdGhpcy5fb3B0aW9ucy5pbmxpbmUgJiYgdGhpcy5fZGF0ZXBpY2tlci5faXNPcGVuICYmIGguYWRkQ2xhc3ModGhpcy50b2dnbGVCdXR0b24sIFwicG9pbnRlci1ldmVudHMtbm9uZVwiKSwgYy5vbmUodGhpcy5fZGF0ZXBpY2tlci5fZWxlbWVudCwgaWMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9kYXRlVmFsdWUgPSB0aGlzLl9kYXRlcGlja2VyLl9pbnB1dC52YWx1ZSwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZSgpLCB0aGlzLl9jYW5jZWwpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsID0gITE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBpID0gITE7XG4gICAgICBjLm9uKHRoaXMuX2RhdGVwaWNrZXIuY29udGFpbmVyLCBcImNsaWNrXCIsIChuKSA9PiB7XG4gICAgICAgICF0aGlzLl9kYXRlcGlja2VyLl9zZWxlY3RlZERhdGUgJiYgbi50YXJnZXQuaGFzQXR0cmlidXRlKE9DKSB8fCBpIHx8ICh0aGlzLl9vcGVuVGltZVBpY2tlcigpLCBpID0gITAsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGkgPSAhMTtcbiAgICAgICAgfSwgNTAwKSk7XG4gICAgICB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7Um99XWAsXG4gICAgICAgICAgZG9jdW1lbnQuYm9keVxuICAgICAgICApIHx8IHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuICAgICAgfSwgMTApLCB0aGlzLl9vcHRpb25zLmlubGluZSAmJiBoLnJlbW92ZUNsYXNzKHRoaXMudG9nZ2xlQnV0dG9uLCBcInBvaW50ZXItZXZlbnRzLW5vbmVcIik7XG4gICAgfSk7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcbiAgICAgIFBDLFxuICAgICAgZG9jdW1lbnQuYm9keVxuICAgICk7XG4gICAgYy5vbihlLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2RhdGVwaWNrZXIuY2xvc2UoKSwgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKSwgYy50cmlnZ2VyKHRoaXMuX2RhdGVwaWNrZXIuX2VsZW1lbnQsIGljKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlVGltZXBpY2tlckRpc2FibGVQYXN0KCkge1xuICAgIGNvbnN0IHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICB0LnNldEhvdXJzKDAsIDAsIDAsIDApLCBjLm9uKFxuICAgICAgdGhpcy5fZGF0ZXBpY2tlci5fZWxlbWVudCxcbiAgICAgIFwiZGF0ZUNoYW5nZS50ZS5kYXRlcGlja2VyXCIsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuX3NlbGVjdGVkRGF0ZS5nZXRUaW1lKCkgPT09IHQuZ2V0VGltZSgpID8gdGhpcy5fdGltZXBpY2tlci51cGRhdGUoeyBkaXNhYmxlUGFzdDogITAgfSkgOiB0aGlzLl90aW1lcGlja2VyLnVwZGF0ZSh7IGRpc2FibGVQYXN0OiAhMSB9KTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVUaW1lcGlja2VyRGlzYWJsZUZ1dHVyZSgpIHtcbiAgICBjb25zdCB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgdC5zZXRIb3VycygwLCAwLCAwLCAwKSwgYy5vbihcbiAgICAgIHRoaXMuX2RhdGVwaWNrZXIuX2VsZW1lbnQsXG4gICAgICBcImRhdGVDaGFuZ2UudGUuZGF0ZXBpY2tlclwiLFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLl9kYXRlcGlja2VyLl9zZWxlY3RlZERhdGUuZ2V0VGltZSgpID09PSB0LmdldFRpbWUoKSA/IHRoaXMuX3RpbWVwaWNrZXIudXBkYXRlKHsgZGlzYWJsZUZ1dHVyZTogITAgfSkgOiB0aGlzLl90aW1lcGlja2VyLnVwZGF0ZSh7IGRpc2FibGVGdXR1cmU6ICExIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUVzY2FwZUtleSgpIHtcbiAgICBjLm9uZShkb2N1bWVudC5ib2R5LCBcImtleXVwXCIsICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske1JvfV1gLFxuICAgICAgICAgIGRvY3VtZW50LmJvZHlcbiAgICAgICAgKSB8fCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgICAgIH0sIDI1MCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUNhbmNlbEJ1dHRvbigpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgYFske3RjfV1gLFxuICAgICAgZG9jdW1lbnQuYm9keVxuICAgICk7XG4gICAgYy5vbmUodCwgXCJtb3VzZWRvd25cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XG4gICAgfSk7XG4gIH1cbiAgX29wZW5Ecm9wZG93bkRhdGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2RhdGVwaWNrZXIuX3BvcHBlcjtcbiAgICB0LnN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSA9IHRoaXMuX2lucHV0LCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgfVxuICBfb3BlblRpbWVQaWNrZXIoKSB7XG4gICAgYy50cmlnZ2VyKHRoaXMuX3RpbWVwaWNrZXIuZWxlbWVudFRvZ2dsZSwgXCJjbGlja1wiKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fYWRkSWNvbkJ1dHRvbnMoKSwgKHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX29wdGlvbnMudGltZXBpY2tlci5pbmxpbmUpICYmIHRoaXMuX29wZW5Ecm9wZG93blRpbWUoKSwgdGhpcy5fdGltZXBpY2tlci5fbW9kYWwpIHtcbiAgICAgICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7dGN9XWAsXG4gICAgICAgICAgZG9jdW1lbnQuYm9keVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9oYW5kbGVFc2NhcGVLZXkoKSwgdGhpcy5faGFuZGxlQ2FuY2VsQnV0dG9uKCksIGMub24odGhpcy5fdGltZXBpY2tlci5fbW9kYWwsIFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgICAoZS50YXJnZXQuaGFzQXR0cmlidXRlKFJvKSB8fCBlLnRhcmdldC5oYXNBdHRyaWJ1dGUoU0MpKSAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuICAgICAgICAgIH0sIDIwMCksIGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZShJQykgJiYgYy50cmlnZ2VyKFxuICAgICAgICAgICAgdGhpcy5fdGltZXBpY2tlci5fZWxlbWVudCxcbiAgICAgICAgICAgIHNjXG4gICAgICAgICAgKSwgZS50YXJnZXQuaGFzQXR0cmlidXRlKCRDKSAmJiAoYy50cmlnZ2VyKHQsIFwiY2xpY2tcIiksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb3BlbkRhdGVQaWNrZXIoKSwgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKTtcbiAgICAgICAgICB9LCAyMDApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSksIGMub25lKHRoaXMuX3RpbWVwaWNrZXIuX2VsZW1lbnQsIHNjLCAoKSA9PiB7XG4gICAgICB0aGlzLl90aW1lVmFsdWUgPSB0aGlzLl90aW1lcGlja2VyLmlucHV0LnZhbHVlLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBZQyk7XG4gICAgfSk7XG4gIH1cbiAgX29wZW5Ecm9wZG93blRpbWUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3RpbWVwaWNrZXIuX3BvcHBlcjtcbiAgICB0LnN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSA9IHRoaXMuX2lucHV0LCB0LnVwZGF0ZSgpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgfVxuICBfc2V0SW5pdGlhbERlZmF1bHRJbnB1dCgpIHtcbiAgICAodGhpcy5fb3B0aW9ucy5kZWZhdWx0RGF0ZSB8fCB0aGlzLl9vcHRpb25zLmRlZmF1bHRUaW1lKSAmJiB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCk7XG4gIH1cbiAgX3VwZGF0ZUlucHV0VmFsdWUoKSB7XG4gICAgdGhpcy5fdGltZVZhbHVlICYmIHRoaXMuX2RhdGVWYWx1ZSAmJiAodGhpcy5faW5wdXQudmFsdWUgPSBgJHt0aGlzLl9kYXRlVmFsdWV9LCAke3RoaXMuX3RpbWVWYWx1ZX1gLCBjLnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgakMsXG4gICAgICB7IHZhbHVlOiB0aGlzLl9pbnB1dC52YWx1ZSB9XG4gICAgKS5kZWZhdWx0UHJldmVudGVkKSB8fCAoYy50cmlnZ2VyKHRoaXMuX2lucHV0LCBcImZvY3VzXCIpLCB0aGlzLm5vdGNoICYmIHRoaXMubm90Y2gucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1pbnB1dC1mb2N1c2VkXCIpKTtcbiAgfVxuICAvLyBzdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0gQS5nZXREYXRhKHRoaXMsIERpKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcgUWgodGhpcywgbikpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgRGkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IHJuID0gXCJzdGlja3lcIiwgJGkgPSBgdGUuJHtybn1gLCBKaCA9IGAuJHskaX1gLCBYQyA9IGBhY3RpdmUke0pofWAsIEdDID0gYGluYWN0aXZlJHtKaH1gLCBxQyA9IHtcbiAgc3RpY2t5QW5pbWF0aW9uU3RpY2t5OiBcIlwiLFxuICBzdGlja3lBbmltYXRpb25VbnN0aWNreTogXCJcIixcbiAgc3RpY2t5Qm91bmRhcnk6ICExLFxuICBzdGlja3lEZWxheTogMCxcbiAgc3RpY2t5RGlyZWN0aW9uOiBcImRvd25cIixcbiAgc3RpY2t5TWVkaWE6IDAsXG4gIHN0aWNreU9mZnNldDogMCxcbiAgc3RpY2t5UG9zaXRpb246IFwidG9wXCIsXG4gIHN0aWNreVpJbmRleDogMTAwXG59LCBaQyA9IHtcbiAgc3RpY2t5QW5pbWF0aW9uU3RpY2t5OiBcInN0cmluZ1wiLFxuICBzdGlja3lBbmltYXRpb25VbnN0aWNreTogXCJzdHJpbmdcIixcbiAgc3RpY2t5Qm91bmRhcnk6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBzdGlja3lEZWxheTogXCJudW1iZXJcIixcbiAgc3RpY2t5RGlyZWN0aW9uOiBcInN0cmluZ1wiLFxuICBzdGlja3lNZWRpYTogXCJudW1iZXJcIixcbiAgc3RpY2t5T2Zmc2V0OiBcIm51bWJlclwiLFxuICBzdGlja3lQb3NpdGlvbjogXCJzdHJpbmdcIixcbiAgc3RpY2t5WkluZGV4OiBcIihzdHJpbmd8bnVtYmVyKVwiXG59LCBRQyA9IHtcbiAgc3RpY2t5QWN0aXZlOiBcIlwiXG59LCBKQyA9IHtcbiAgc3RpY2t5QWN0aXZlOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgdGQge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2hpZGRlbkVsZW1lbnQgPSBudWxsLCB0aGlzLl9lbGVtZW50UG9zaXRpb25TdHlsZXMgPSB7fSwgdGhpcy5fc2Nyb2xsRGlyZWN0aW9uID0gXCJcIiwgdGhpcy5faXNTdGlja2VkID0gITEsIHRoaXMuX2VsZW1lbnRPZmZzZXRUb3AgPSBudWxsLCB0aGlzLl9zY3JvbGxUb3AgPSAwLCB0aGlzLl9wdXNoUG9pbnQgPSBcIlwiLCB0aGlzLl9tYW51YWxseURlYWN0aXZhdGVkID0gITEsIHRoaXMuX2VsZW1lbnQgJiYgKHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCBBLnNldERhdGEodCwgJGksIHRoaXMpLCB0aGlzLl9pbml0KCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBybjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICBjb25zdCB7IHN0aWNreUFuaW1hdGlvblVuc3RpY2t5OiB0IH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGxldCB7IGFuaW1hdGlvbkR1cmF0aW9uOiBlIH0gPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpO1xuICAgIGUgPSB0ICE9PSBcIlwiID8gcGFyc2VGbG9hdChlKSAqIDFlMyA6IDAsIHRoaXMuX2Rpc2FibGVTdGlja3koKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgJGkpLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHRoaXMuX2hpZGRlbkVsZW1lbnQgPSBudWxsLCB0aGlzLl9lbGVtZW50UG9zaXRpb25TdHlsZXMgPSBudWxsLCB0aGlzLl9zY3JvbGxEaXJlY3Rpb24gPSBudWxsLCB0aGlzLl9pc1N0aWNrZWQgPSBudWxsLCB0aGlzLl9lbGVtZW50T2Zmc2V0VG9wID0gbnVsbCwgdGhpcy5fc2Nyb2xsVG9wID0gbnVsbCwgdGhpcy5fcHVzaFBvaW50ID0gbnVsbCwgdGhpcy5fbWFudWFsbHlEZWFjdGl2YXRlZCA9IG51bGw7XG4gICAgfSwgZSk7XG4gIH1cbiAgYWN0aXZlKCkge1xuICAgIHRoaXMuX2lzU3RpY2tlZCB8fCAodGhpcy5fY3JlYXRlSGlkZGVuRWxlbWVudCgpLCB0aGlzLl9lbmFibGVTdGlja3koKSwgdGhpcy5fY2hhbmdlQm91bmRhcnlQb3NpdGlvbigpLCB0aGlzLl9pc1N0aWNrZWQgPSAhMCwgdGhpcy5fbWFudWFsbHlEZWFjdGl2YXRlZCA9ICExKTtcbiAgfVxuICBpbmFjdGl2ZSgpIHtcbiAgICB0aGlzLl9pc1N0aWNrZWQgJiYgKHRoaXMuX2Rpc2FibGVTdGlja3koKSwgdGhpcy5faXNTdGlja2VkID0gITEsIHRoaXMuX21hbnVhbGx5RGVhY3RpdmF0ZWQgPSAhMCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl91c2VyQWN0aXZpdHlMaXN0ZW5lcigpO1xuICB9XG4gIF91c2VyQWN0aXZpdHlMaXN0ZW5lcigpIHtcbiAgICBjLm9uKHdpbmRvdywgXCJyZXNpemVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlRWxlbWVudFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUVsZW1lbnRPZmZzZXQoKTtcbiAgICB9KSwgYy5vbih3aW5kb3csIFwic2Nyb2xsXCIsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZWxlbWVudCB8fCB3aW5kb3cuaW5uZXJXaWR0aCA8PSB0aGlzLl9vcHRpb25zLnN0aWNreU1lZGlhIHx8IHRoaXMuX21hbnVhbGx5RGVhY3RpdmF0ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHsgc3RpY2t5RGlyZWN0aW9uOiBlIH0gPSB0aGlzLl9vcHRpb25zLCBpID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IHQuc2Nyb2xsVG9wO1xuICAgICAgdGhpcy5fdXBkYXRlRWxlbWVudE9mZnNldCgpLCB0aGlzLl91cGRhdGVQdXNoUG9pbnQoKSwgdGhpcy5fdXBkYXRlU2Nyb2xsRGlyZWN0aW9uKGkpLCB0aGlzLl9jbGVhckluUHJvZ3Jlc3NBbmltYXRpb25zKCk7XG4gICAgICBjb25zdCBuID0gW3RoaXMuX3Njcm9sbERpcmVjdGlvbiwgXCJib3RoXCJdLmluY2x1ZGVzKFxuICAgICAgICBlXG4gICAgICApLCBvID0gdGhpcy5fcHVzaFBvaW50IDw9IGksIHIgPSBvICYmICF0aGlzLl9pc1N0aWNrZWQgJiYgbiwgYSA9ICghbyB8fCAhbikgJiYgdGhpcy5faXNTdGlja2VkO1xuICAgICAgciAmJiAodGhpcy5fY3JlYXRlSGlkZGVuRWxlbWVudCgpLCB0aGlzLl9lbmFibGVTdGlja3koKSwgdGhpcy5fY2hhbmdlQm91bmRhcnlQb3NpdGlvbigpLCB0aGlzLl9pc1N0aWNrZWQgPSAhMCksIGEgJiYgKHRoaXMuX2Rpc2FibGVTdGlja3koKSwgdGhpcy5faXNTdGlja2VkID0gITEpLCB0aGlzLl9pc1N0aWNrZWQgJiYgKHRoaXMuX3VwZGF0ZVBvc2l0aW9uKHsgc3R5bGVzOiB0aGlzLl9lbGVtZW50UG9zaXRpb25TdHlsZXMgfSksIHRoaXMuX2NoYW5nZUJvdW5kYXJ5UG9zaXRpb24oKSksIHRoaXMuX3Njcm9sbFRvcCA9IGkgPD0gMCA/IDAgOiBpO1xuICAgIH0pO1xuICB9XG4gIF91cGRhdGVQdXNoUG9pbnQoKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5zdGlja3lQb3NpdGlvbiA9PT0gXCJ0b3BcIiA/IHRoaXMuX3B1c2hQb2ludCA9IHRoaXMuX2VsZW1lbnRPZmZzZXRUb3AgLSB0aGlzLl9vcHRpb25zLnN0aWNreURlbGF5IDogdGhpcy5fcHVzaFBvaW50ID0gdGhpcy5fZWxlbWVudE9mZnNldFRvcCArIHRoaXMuX2VsZW1lbnQuaGVpZ2h0IC0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgKyB0aGlzLl9vcHRpb25zLnN0aWNreURlbGF5O1xuICB9XG4gIF91cGRhdGVFbGVtZW50T2Zmc2V0KCkge1xuICAgIHRoaXMuX2hpZGRlbkVsZW1lbnQgPyB0aGlzLl9lbGVtZW50T2Zmc2V0VG9wID0gdGhpcy5faGlkZGVuRWxlbWVudC5vZmZzZXRUb3AgOiB0aGlzLl9lbGVtZW50T2Zmc2V0VG9wID0gdGhpcy5fZWxlbWVudC5vZmZzZXRUb3AsIHRoaXMuX29wdGlvbnMuc3RpY2t5QW5pbWF0aW9uVW5zdGlja3kgJiYgKHRoaXMuX2VsZW1lbnRPZmZzZXRUb3AgKz0gdGhpcy5fZWxlbWVudC5oZWlnaHQgfHwgMCk7XG4gIH1cbiAgX3VwZGF0ZUVsZW1lbnRQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy5faGlkZGVuRWxlbWVudCkge1xuICAgICAgY29uc3QgeyBsZWZ0OiB0IH0gPSB0aGlzLl9oaWRkZW5FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGhpcy5fZWxlbWVudFBvc2l0aW9uU3R5bGVzID0ge1xuICAgICAgICBsZWZ0OiBgJHt0fXB4YFxuICAgICAgfTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuX2VsZW1lbnRQb3NpdGlvblN0eWxlcyA9IHt9O1xuICAgIHRoaXMuX3NldFN0eWxlKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2VsZW1lbnRQb3NpdGlvblN0eWxlcyk7XG4gIH1cbiAgX3VwZGF0ZVNjcm9sbERpcmVjdGlvbih0KSB7XG4gICAgdCA+IHRoaXMuX3Njcm9sbFRvcCA/IHRoaXMuX3Njcm9sbERpcmVjdGlvbiA9IFwiZG93blwiIDogdGhpcy5fc2Nyb2xsRGlyZWN0aW9uID0gXCJ1cFwiO1xuICB9XG4gIF9jbGVhckluUHJvZ3Jlc3NBbmltYXRpb25zKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9zY3JvbGxEaXJlY3Rpb24gPT09IFwidXBcIiwgZSA9IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGlja3lBbmltYXRpb25VbnN0aWNreVxuICAgICksIGkgPSB3aW5kb3cuc2Nyb2xsWSA8PSB0aGlzLl9lbGVtZW50T2Zmc2V0VG9wIC0gdGhpcy5fZWxlbWVudC5oZWlnaHQ7XG4gICAgdCAmJiBlICYmIGkgJiYgKHRoaXMuX3JlbW92ZVVuc3RpY2t5QW5pbWF0aW9uKCksIHRoaXMuX3Jlc2V0U3R5bGVzKCksIHRoaXMuX3JlbW92ZUhpZGRlbkVsZW1lbnQoKSk7XG4gIH1cbiAgX2VuYWJsZVN0aWNreSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGlja3lBbmltYXRpb25TdGlja3k6IHQsXG4gICAgICBzdGlja3lBbmltYXRpb25VbnN0aWNreTogZSxcbiAgICAgIHN0aWNreU9mZnNldDogaSxcbiAgICAgIHN0aWNreVBvc2l0aW9uOiBuLFxuICAgICAgc3RpY2t5WkluZGV4OiBvXG4gICAgfSA9IHRoaXMuX29wdGlvbnMsIHsgaGVpZ2h0OiByLCBsZWZ0OiBhLCB3aWR0aDogbCB9ID0gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0ICE9PSBcIlwiICYmIHRoaXMuX3RvZ2dsZUNsYXNzKFxuICAgICAgdCxcbiAgICAgIGUsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fdG9nZ2xlQ2xhc3ModGhpcy5fY2xhc3Nlcy5zdGlja3lBY3RpdmUsIFwiXCIsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9zZXRTdHlsZSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICB0b3A6IG4gPT09IFwidG9wXCIgJiYgYCR7MCArIGl9cHhgLFxuICAgICAgYm90dG9tOiBuID09PSBcImJvdHRvbVwiICYmIGAkezAgKyBpfXB4YCxcbiAgICAgIGhlaWdodDogYCR7cn1weGAsXG4gICAgICB3aWR0aDogYCR7bH1weGAsXG4gICAgICBsZWZ0OiBgJHthfXB4YCxcbiAgICAgIHpJbmRleDogYCR7b31gLFxuICAgICAgcG9zaXRpb246IFwiZml4ZWRcIlxuICAgIH0pLCB0aGlzLl9oaWRkZW5FbGVtZW50LmhpZGRlbiA9ICExLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWEMpO1xuICB9XG4gIF9jaGFuZ2VCb3VuZGFyeVBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHsgc3RpY2t5UG9zaXRpb246IHQsIHN0aWNreUJvdW5kYXJ5OiBlLCBzdGlja3lPZmZzZXQ6IGkgfSA9IHRoaXMuX29wdGlvbnMsIHsgaGVpZ2h0OiBuIH0gPSB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBvID0ge1xuICAgICAgaGVpZ2h0OiB0aGlzLl9lbGVtZW50LnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0LFxuICAgICAgLi4udGhpcy5fZ2V0T2Zmc2V0KHRoaXMuX2VsZW1lbnQucGFyZW50RWxlbWVudClcbiAgICB9O1xuICAgIGxldCByO1xuICAgIGNvbnN0IGEgPSBkLmZpbmRPbmUoZSk7XG4gICAgYSA/IHIgPSB0aGlzLl9nZXRPZmZzZXQoYSkudG9wIC0gbiAtIGkgOiByID0gby5oZWlnaHQgKyBvW3RdIC0gbiAtIGk7XG4gICAgY29uc3QgbCA9IHQgPT09IFwidG9wXCIsIHAgPSB0ID09PSBcImJvdHRvbVwiLCB1ID0gZSwgXyA9IHIgPCAwLCBmID0gciA+IG8uaGVpZ2h0IC0gbjtcbiAgICBsZXQgZztcbiAgICBsICYmIChfICYmIHUgPyBnID0geyB0b3A6IGAke2kgKyByfXB4YCB9IDogZyA9IHsgdG9wOiBgJHtpICsgMH1weGAgfSksIHAgJiYgKF8gJiYgdSA/IGcgPSB7IGJvdHRvbTogYCR7aSArIHJ9cHhgIH0gOiBmICYmIHUgPyBnID0geyBib3R0b206IGAke2kgKyBvLmJvdHRvbX1weGAgfSA6IGcgPSB7IGJvdHRvbTogYCR7aSArIDB9cHhgIH0pLCB0aGlzLl9zZXRTdHlsZSh0aGlzLl9lbGVtZW50LCBnKTtcbiAgfVxuICBfZGlzYWJsZVN0aWNreSgpIHtcbiAgICBjb25zdCB7IHN0aWNreUFuaW1hdGlvblVuc3RpY2t5OiB0LCBzdGlja3lBbmltYXRpb25TdGlja3k6IGUgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgbGV0IHsgYW5pbWF0aW9uRHVyYXRpb246IGkgfSA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudCk7XG4gICAgaSA9IHQgIT09IFwiXCIgPyBwYXJzZUZsb2F0KGkpICogMWUzIDogMCwgdGhpcy5fb3B0aW9ucy5zdGlja3lBbmltYXRpb25VbnN0aWNreSAhPT0gXCJcIiAmJiB0aGlzLl90b2dnbGVDbGFzcyhcbiAgICAgIHQsXG4gICAgICBlLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoZSkgfHwgKHRoaXMuX3JlbW92ZVVuc3RpY2t5QW5pbWF0aW9uKCksIHRoaXMuX3Jlc2V0U3R5bGVzKCksIHRoaXMuX3JlbW92ZUhpZGRlbkVsZW1lbnQoKSwgdGhpcy5fdG9nZ2xlQ2xhc3MoXCJcIiwgdGhpcy5fY2xhc3Nlcy5zdGlja3lBY3RpdmUsIHRoaXMuX2VsZW1lbnQpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgR0MpKTtcbiAgICB9LCBpKTtcbiAgfVxuICBfY3JlYXRlSGlkZGVuRWxlbWVudCgpIHtcbiAgICB0aGlzLl9oaWRkZW5FbGVtZW50IHx8ICh0aGlzLl9oaWRkZW5FbGVtZW50ID0gdGhpcy5fY29weUVsZW1lbnQodGhpcy5fZWxlbWVudCkpO1xuICB9XG4gIF9yZW1vdmVIaWRkZW5FbGVtZW50KCkge1xuICAgIHRoaXMuX2hpZGRlbkVsZW1lbnQgJiYgKHRoaXMuX2hpZGRlbkVsZW1lbnQucmVtb3ZlKCksIHRoaXMuX2hpZGRlbkVsZW1lbnQgPSBudWxsKTtcbiAgfVxuICBfcmVtb3ZlVW5zdGlja3lBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fdG9nZ2xlQ2xhc3MoXCJcIiwgdGhpcy5fb3B0aW9ucy5zdGlja3lBbmltYXRpb25VbnN0aWNreSwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgX3Jlc2V0U3R5bGVzKCkge1xuICAgIHRoaXMuX3NldFN0eWxlKHRoaXMuX2VsZW1lbnQsIHtcbiAgICAgIHRvcDogbnVsbCxcbiAgICAgIGJvdHRvbTogbnVsbCxcbiAgICAgIHBvc2l0aW9uOiBudWxsLFxuICAgICAgbGVmdDogbnVsbCxcbiAgICAgIHpJbmRleDogbnVsbCxcbiAgICAgIHdpZHRoOiBudWxsLFxuICAgICAgaGVpZ2h0OiBudWxsXG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZVBvc2l0aW9uKHsgc3R5bGVzOiB0IH0pIHtcbiAgICB0aGlzLl9zZXRTdHlsZSh0aGlzLl9lbGVtZW50LCB0KTtcbiAgfVxuICBfdG9nZ2xlQ2xhc3ModCwgZSwgaSkge1xuICAgIHQgJiYgaC5hZGRDbGFzcyhpLCB0KSwgZSAmJiBoLnJlbW92ZUNsYXNzKGksIGUpO1xuICB9XG4gIF9nZXRPZmZzZXQodCkge1xuICAgIGNvbnN0IGUgPSBoLm9mZnNldCh0KSwgaSA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG4gPSBlLmxlZnQgPT09IDAgJiYgZS50b3AgPT09IDAgPyAwIDogd2luZG93LmlubmVySGVpZ2h0IC0gaS5ib3R0b207XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmUsXG4gICAgICBib3R0b206IG5cbiAgICB9O1xuICB9XG4gIF9jb3B5RWxlbWVudCh0KSB7XG4gICAgY29uc3QgeyBoZWlnaHQ6IGUsIHdpZHRoOiBpIH0gPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBuID0gdC5jbG9uZU5vZGUoITEpO1xuICAgIHJldHVybiBuLmhpZGRlbiA9ICEwLCB0aGlzLl9zZXRTdHlsZShuLCB7XG4gICAgICBoZWlnaHQ6IGAke2V9cHhgLFxuICAgICAgd2lkdGg6IGAke2l9cHhgLFxuICAgICAgb3BhY2l0eTogXCIwXCJcbiAgICB9KSwgdC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShuLCB0KSwgbjtcbiAgfVxuICBfZ2V0Q29uZmlnKHQgPSB7fSkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ucUMsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkocm4sIHQsIFpDKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlFDLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKHJuLCB0LCBKQyksIHQ7XG4gIH1cbiAgX3NldFN0eWxlKHQsIGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICB0LnN0eWxlW2ldID0gZVtpXTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSBBLmdldERhdGEodGhpcywgJGkpO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlfGhpZGUvLnRlc3QodCkpICYmIChpIHx8IChpID0gbmV3IHRkKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsICRpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCB0QSA9IFwiZGF0YS10ZS1hdXRvY29tcGxldGUtZHJvcGRvd24tcmVmXCIsIGVBID0gXCJkYXRhLXRlLWF1dG9jb21wbGV0ZS1pdGVtcy1saXN0LXJlZlwiLCBpQSA9IFwiZGF0YS10ZS1hdXRvY29tcGxldGUtaXRlbS1yZWZcIiwgc0EgPSBcImRhdGEtdGUtYXV0b2NvbXBsZXRlLWxvYWRlci1yZWZcIjtcbmZ1bmN0aW9uIG5BKHMsIHQpIHtcbiAgY29uc3QgeyBpZDogZSwgaXRlbXM6IGksIHdpZHRoOiBuLCBvcHRpb25zOiBvIH0gPSBzLCByID0gJChcImRpdlwiKTtcbiAgaC5hZGRDbGFzcyhyLCB0LmRyb3Bkb3duQ29udGFpbmVyKSwgaC5hZGRTdHlsZShyLCB7IHdpZHRoOiBgJHtufXB4YCB9KSwgci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBlKTtcbiAgY29uc3QgYSA9ICQoXCJkaXZcIik7XG4gIGEuc2V0QXR0cmlidXRlKHRBLCBcIlwiKSwgaC5hZGRDbGFzcyhhLCB0LmRyb3Bkb3duKTtcbiAgY29uc3QgbCA9ICQoXCJ1bFwiKSwgcCA9IG8ubGlzdEhlaWdodDtcbiAgbC5zZXRBdHRyaWJ1dGUoZUEsIFwiXCIpLCBoLmFkZENsYXNzKGwsIHQuYXV0b2NvbXBsZXRlTGlzdCksIGguYWRkQ2xhc3MobCwgdC5zY3JvbGxiYXIpLCBoLmFkZFN0eWxlKGwsIHsgbWF4SGVpZ2h0OiBgJHtwfXB4YCB9KSwgbC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibGlzdGJveFwiKTtcbiAgY29uc3QgdSA9IGVkKGksIG8pO1xuICByZXR1cm4gbC5pbm5lckhUTUwgPSB1LCBhLmFwcGVuZENoaWxkKGwpLCByLmFwcGVuZENoaWxkKGEpLCByO1xufVxuZnVuY3Rpb24gZWQocyA9IFtdLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSB0LmRpc3BsYXlWYWx1ZSwgbiA9IHQuaXRlbUNvbnRlbnQ7XG4gIHJldHVybiBgXG4gICAgJHtzLm1hcCgobywgcikgPT4ge1xuICAgIGNvbnN0IGEgPSB0eXBlb2YgbiA9PSBcImZ1bmN0aW9uXCIgPyBwbihuKG8pLCBzaCwgbnVsbCkgOiBpKG8pO1xuICAgIHJldHVybiBgPGxpIGRhdGEtdGUtaW5kZXg9XCIke3J9XCIgcm9sZT1cIm9wdGlvblwiIGNsYXNzPVwiJHtlfVwiICR7aUF9ID4ke2F9PC9saT5gO1xuICB9KS5qb2luKFwiXCIpfVxuICBgO1xufVxuZnVuY3Rpb24gb0Eocykge1xuICBjb25zdCB0ID0gJChcImRpdlwiKTtcbiAgdC5zZXRBdHRyaWJ1dGUoc0EsIFwiXCIpLCBoLmFkZENsYXNzKHQsIHMuYXV0b2NvbXBsZXRlTG9hZGVyKSwgaC5hZGRDbGFzcyh0LCBzLnNwaW5uZXJJY29uKSwgdC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwic3RhdHVzXCIpO1xuICBjb25zdCBlID0gJzxzcGFuIGNsYXNzPVwiYWJzb2x1dGUgLW0tcHggaC1weCB3LXB4IG92ZXJmbG93LWhpZGRlbiB3aGl0ZXNwYWNlLW5vd3JhcCBib3JkZXItMCBwLTAgW2NsaXA6cmVjdCgwLDAsMCwwKV1cIj5Mb2FkaW5nLi4uPC9zcGFuPic7XG4gIHJldHVybiB0LmlubmVySFRNTCA9IGUsIHQ7XG59XG5mdW5jdGlvbiByQShzLCB0KSB7XG4gIHJldHVybiBgPGxpIGNsYXNzPVwiJHt0LmF1dG9jb21wbGV0ZUl0ZW19XCI+JHtzfTwvbGk+YDtcbn1cbmNvbnN0IFBvID0gXCJhdXRvY29tcGxldGVcIiwgTGkgPSBcInRlLmF1dG9jb21wbGV0ZVwiLCBQZSA9IFwiZGF0YS10ZS1pbnB1dC1zdGF0ZS1hY3RpdmVcIiwgQm8gPSBcImRhdGEtdGUtYXV0b2NvbXBsZXRlLWl0ZW0tYWN0aXZlXCIsIG9jID0gXCJkYXRhLXRlLWlucHV0LWZvY3VzZWRcIiwgcmMgPSBcImRhdGEtdGUtYXV0b2NvbXBsZXRlLXN0YXRlLW9wZW5cIiwgYUEgPSBcImRhdGEtdGUtYXV0b2NvbXBsZXRlLWN1c3RvbS1jb250ZW50LXJlZlwiLCBsQSA9IFwiW2RhdGEtdGUtYXV0b2NvbXBsZXRlLWRyb3Bkb3duLXJlZl1cIiwgVnMgPSBcIltkYXRhLXRlLWF1dG9jb21wbGV0ZS1pdGVtcy1saXN0LXJlZl1cIiwgYWMgPSBcIltkYXRhLXRlLWF1dG9jb21wbGV0ZS1pdGVtLXJlZl1cIiwgY0EgPSBcIltkYXRhLXRlLWF1dG9jb21wbGV0ZS1sb2FkZXItcmVmXVwiLCBoQSA9IGBbJHthQX1dYCwgZEEgPSBcIltkYXRhLXRlLWlucHV0LW5vdGNoLXJlZl1cIiwgd24gPSBgLiR7TGl9YCwgdUEgPSBgY2xvc2Uke3dufWAsIHBBID0gYG9wZW4ke3dufWAsIGxjID0gYGl0ZW1TZWxlY3Qke3dufWAsIF9BID0gYHVwZGF0ZSR7d259YCwgZkEgPSB7XG4gIGF1dG9TZWxlY3Q6ICExLFxuICBjb250YWluZXI6IFwiYm9keVwiLFxuICBjdXN0b21Db250ZW50OiBcIlwiLFxuICBkZWJvdW5jZTogMzAwLFxuICBkaXNwbGF5VmFsdWU6IChzKSA9PiBzLFxuICBmaWx0ZXI6IG51bGwsXG4gIGl0ZW1Db250ZW50OiBudWxsLFxuICBsaXN0SGVpZ2h0OiAxOTAsXG4gIGxvYWRlckNsb3NlRGVsYXk6IDMwMCxcbiAgbm9SZXN1bHRzOiBcIk5vIHJlc3VsdHMgZm91bmRcIixcbiAgdGhyZXNob2xkOiAwXG59LCBtQSA9IHtcbiAgYXV0b1NlbGVjdDogXCJib29sZWFuXCIsXG4gIGNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgY3VzdG9tQ29udGVudDogXCJzdHJpbmdcIixcbiAgZGVib3VuY2U6IFwibnVtYmVyXCIsXG4gIGRpc3BsYXlWYWx1ZTogXCJmdW5jdGlvblwiLFxuICBmaWx0ZXI6IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIGl0ZW1Db250ZW50OiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBsaXN0SGVpZ2h0OiBcIm51bWJlclwiLFxuICBsb2FkZXJDbG9zZURlbGF5OiBcIm51bWJlclwiLFxuICBub1Jlc3VsdHM6IFwic3RyaW5nXCIsXG4gIHRocmVzaG9sZDogXCJudW1iZXJcIlxufSwgZ0EgPSB7XG4gIGF1dG9jb21wbGV0ZUl0ZW06IFwiZmxleCBmbGV4LXJvdyBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIHctZnVsbCBweC00IHB5LVswLjQzNzVyZW1dIHRydW5jYXRlIHRleHQtZ3JheS03MDAgYmctdHJhbnNwYXJlbnQgc2VsZWN0LW5vbmUgY3Vyc29yLXBvaW50ZXIgaG92ZXI6WyY6bm90KFtkYXRhLXRlLWF1dG9jb21wbGV0ZS1vcHRpb24tZGlzYWJsZWRdKV06YmctYmxhY2svNSBkYXRhLVt0ZS1hdXRvY29tcGxldGUtaXRlbS1hY3RpdmVdOmJnLWJsYWNrLzUgZGF0YS1bZGF0YS10ZS1hdXRvY29tcGxldGUtb3B0aW9uLWRpc2FibGVkXTp0ZXh0LWdyYXktNDAwIGRhdGEtW2RhdGEtdGUtYXV0b2NvbXBsZXRlLW9wdGlvbi1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6aG92ZXI6WyY6bm90KFtkYXRhLXRlLWF1dG9jb21wbGV0ZS1vcHRpb24tZGlzYWJsZWRdKV06Ymctd2hpdGUvMzAgZGFyazpkYXRhLVt0ZS1hdXRvY29tcGxldGUtaXRlbS1hY3RpdmVdOmJnLXdoaXRlLzMwXCIsXG4gIGF1dG9jb21wbGV0ZUxpc3Q6IFwibGlzdC1ub25lIG0tMCBwLTAgb3ZlcmZsb3cteS1hdXRvXCIsXG4gIGF1dG9jb21wbGV0ZUxvYWRlcjogXCJhYnNvbHV0ZSByaWdodC0xIHRvcC0yIHctWzEuNHJlbV0gaC1bMS40cmVtXSBib3JkZXItWzAuMTVlbV1cIixcbiAgZHJvcGRvd246IFwicmVsYXRpdmUgb3V0bGluZS1ub25lIG1pbi13LVsxMDBweF0gbS0wIHNjYWxlLXktWzAuOF0gb3BhY2l0eS0wIGJnLXdoaXRlIHNoYWRvdy1bMF8ycHhfNXB4XzBfcmdiYSgwLDAsMCwwLjE2KSxfMF8ycHhfMTBweF8wX3JnYmEoMCwwLDAsMC4xMildIHRyYW5zaXRpb24gZHVyYXRpb24tMjAwIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhdGEtW3RlLWF1dG9jb21wbGV0ZS1zdGF0ZS1vcGVuXTpzY2FsZS15LTEwMCBkYXRhLVt0ZS1hdXRvY29tcGxldGUtc3RhdGUtb3Blbl06b3BhY2l0eS0xMDAgZGFyazpiZy16aW5jLTcwMFwiLFxuICBkcm9wZG93bkNvbnRhaW5lcjogXCJ6LVsxMDcwXVwiLFxuICBzY3JvbGxiYXI6IFwiWyY6Oi13ZWJraXQtc2Nyb2xsYmFyXTp3LTEgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyXTpoLTEgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbl06YmxvY2sgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbl06aC0wIFsmOjotd2Via2l0LXNjcm9sbGJhci1idXR0b25dOmJnLXRyYW5zcGFyZW50IFsmOjotd2Via2l0LXNjcm9sbGJhci10cmFjay1waWVjZV06YmctdHJhbnNwYXJlbnQgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrLXBpZWNlXTpyb3VuZGVkLW5vbmUgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrLXBpZWNlXTogWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrLXBpZWNlXTpyb3VuZGVkLWwgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iXTpoLVs1MHB4XSBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJdOmJnLVsjOTk5XSBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJdOnJvdW5kZWRcIixcbiAgc3Bpbm5lckljb246IFwiaW5saW5lLWJsb2NrIGgtOCB3LTggYW5pbWF0ZS1zcGluIHJvdW5kZWQtZnVsbCBib3JkZXItNCBib3JkZXItc29saWQgYm9yZGVyLWN1cnJlbnQgYm9yZGVyLXItdHJhbnNwYXJlbnQgYWxpZ24tWy0wLjEyNWVtXSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtW3NwaW5fMS41c19saW5lYXJfaW5maW5pdGVdXCJcbn0sIGJBID0ge1xuICBhdXRvY29tcGxldGVJdGVtOiBcInN0cmluZ1wiLFxuICBhdXRvY29tcGxldGVMaXN0OiBcInN0cmluZ1wiLFxuICBhdXRvY29tcGxldGVMb2FkZXI6IFwic3RyaW5nXCIsXG4gIGRyb3Bkb3duOiBcInN0cmluZ1wiLFxuICBkcm9wZG93bkNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgc2Nyb2xsYmFyOiBcInN0cmluZ1wiLFxuICBzcGlubmVySWNvbjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIGlkIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fZ2V0Q29udGFpbmVyKCksIHRoaXMuX2lucHV0ID0gZC5maW5kT25lKFwiaW5wdXRcIiwgdCksIHRoaXMuX25vdGNoID0gZC5maW5kT25lKGRBLCB0KSwgdGhpcy5fY3VzdG9tQ29udGVudCA9IGQuZmluZE9uZShcbiAgICAgIGhBLFxuICAgICAgdFxuICAgICksIHRoaXMuX2xvYWRlciA9IG9BKHRoaXMuX2NsYXNzZXMpLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9kZWJvdW5jZVRpbWVvdXRJZCA9IG51bGwsIHRoaXMuX2xvYWRlclRpbWVvdXQgPSBudWxsLCB0aGlzLl9hY3RpdmVJdGVtSW5kZXggPSAtMSwgdGhpcy5fYWN0aXZlSXRlbSA9IG51bGwsIHRoaXMuX2ZpbHRlcmVkUmVzdWx0cyA9IG51bGwsIHRoaXMuX2xhc3RRdWVyeVZhbHVlID0gbnVsbCwgdGhpcy5fY2FuT3Blbk9uRm9jdXMgPSAhMCwgdGhpcy5faXNPcGVuID0gITEsIHRoaXMuX291dHNpZGVDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVPdXRzaWRlQ2xpY2suYmluZCh0aGlzKSwgdGhpcy5faW5wdXRGb2N1c0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVJbnB1dEZvY3VzLmJpbmQodGhpcyksIHRoaXMuX3VzZXJJbnB1dEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVVc2VySW5wdXQuYmluZCh0aGlzKSwgdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcyksIHQgJiYgQS5zZXREYXRhKHQsIExpLCB0aGlzKSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gUG87XG4gIH1cbiAgZ2V0IGZpbHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5maWx0ZXI7XG4gIH1cbiAgZ2V0IGRyb3Bkb3duKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUobEEsIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyKTtcbiAgfVxuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIGQuZmluZChhYywgdGhpcy5fZHJvcGRvd25Db250YWluZXIpO1xuICB9XG4gIGdldCBpdGVtc0xpc3QoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShWcywgdGhpcy5fZHJvcGRvd25Db250YWluZXIpO1xuICB9XG4gIGluaXRTZWFyY2godCkge1xuICAgIHRoaXMuX2ZpbHRlclJlc3VsdHModCk7XG4gIH1cbiAgX2dldENvbnRhaW5lcigpIHtcbiAgICB0aGlzLl9jb250YWluZXIgPSBkLmZpbmRPbmUodGhpcy5fb3B0aW9ucy5jb250YWluZXIpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uZkEsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoUG8sIHQsIG1BKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmdBLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKFBvLCB0LCBiQSksIHQ7XG4gIH1cbiAgX2luaXQoKSB7XG4gICAgdGhpcy5faW5pdERyb3Bkb3duKCksIHRoaXMuX3VwZGF0ZUlucHV0U3RhdGUoKSwgdGhpcy5fc2V0SW5wdXRBcmlhQXR0cmlidXRlcygpLCB0aGlzLl9saXN0ZW5Ub0lucHV0Rm9jdXMoKSwgdGhpcy5fbGlzdGVuVG9Vc2VySW5wdXQoKSwgdGhpcy5fbGlzdGVuVG9LZXlkb3duKCk7XG4gIH1cbiAgX2luaXREcm9wZG93bigpIHtcbiAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcklkID0gdGhpcy5fZWxlbWVudC5pZCA/IGBhdXRvY29tcGxldGUtZHJvcGRvd24tJHt0aGlzLl9lbGVtZW50LmlkfWAgOiBldChcImF1dG9jb21wbGV0ZS1kcm9wZG93bi1cIik7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIGlkOiB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcklkLFxuICAgICAgaXRlbXM6IFtdLFxuICAgICAgd2lkdGg6IHRoaXMuX2lucHV0Lm9mZnNldFdpZHRoLFxuICAgICAgb3B0aW9uczogdGhpcy5fb3B0aW9uc1xuICAgIH07XG4gICAgaWYgKHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyID0gbkEodCwgdGhpcy5fY2xhc3NlcyksIHRoaXMuX29wdGlvbnMuY3VzdG9tQ29udGVudCAhPT0gXCJcIikge1xuICAgICAgY29uc3QgZSA9IHRoaXMuX29wdGlvbnMuY3VzdG9tQ29udGVudCwgaSA9IHBuKFxuICAgICAgICBlLFxuICAgICAgICBzaCxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICAgIHRoaXMuZHJvcGRvd24uaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIGkpO1xuICAgIH1cbiAgfVxuICBfc2V0SW5wdXRBcmlhQXR0cmlidXRlcygpIHtcbiAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiY29tYm9ib3hcIiksIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgITEpLCB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLW93bnNcIiwgdGhpcy5fZHJvcGRvd25Db250YWluZXJJZCksIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgITApLCB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVcIiwgXCJvZmZcIik7XG4gIH1cbiAgX3VwZGF0ZUlucHV0U3RhdGUoKSB7XG4gICAgdmFyIHQsIGU7XG4gICAgdGhpcy5faW5wdXQudmFsdWUgIT09IFwiXCIgfHwgdGhpcy5faXNPcGVuID8gKHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShQZSwgXCJcIiksICh0ID0gdGhpcy5fbm90Y2gpID09IG51bGwgfHwgdC5zZXRBdHRyaWJ1dGUoUGUsIFwiXCIpKSA6ICh0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoUGUpLCAoZSA9IHRoaXMuX25vdGNoKSA9PSBudWxsIHx8IGUucmVtb3ZlQXR0cmlidXRlKFBlKSk7XG4gIH1cbiAgX2xpc3RlblRvSW5wdXRGb2N1cygpIHtcbiAgICBjLm9uKHRoaXMuX2lucHV0LCBcImZvY3VzXCIsIHRoaXMuX2lucHV0Rm9jdXNIYW5kbGVyKTtcbiAgfVxuICBfaGFuZGxlSW5wdXRGb2N1cyh0KSB7XG4gICAgY29uc3QgeyB2YWx1ZTogZSB9ID0gdC50YXJnZXQsIGkgPSB0aGlzLl9vcHRpb25zLnRocmVzaG9sZDtcbiAgICBpZiAoIXRoaXMuX2Nhbk9wZW5PbkZvY3VzKSB7XG4gICAgICB0aGlzLl9jYW5PcGVuT25Gb2N1cyA9ICEwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLmxlbmd0aCA8IGkgfHwgKHRoaXMuX2xhc3RRdWVyeVZhbHVlICE9PSBlID8gdGhpcy5fZmlsdGVyUmVzdWx0cyhlKSA6IHRoaXMub3BlbigpKTtcbiAgfVxuICBfbGlzdGVuVG9XaW5kb3dSZXNpemUoKSB7XG4gICAgYy5vbih3aW5kb3csIFwicmVzaXplXCIsIHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgfVxuICBfaGFuZGxlV2luZG93UmVzaXplKCkge1xuICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyICYmIHRoaXMuX3VwZGF0ZURyb3Bkb3duV2lkdGgoKTtcbiAgfVxuICBfdXBkYXRlRHJvcGRvd25XaWR0aCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5faW5wdXQub2Zmc2V0V2lkdGg7XG4gICAgaC5hZGRTdHlsZSh0aGlzLl9kcm9wZG93bkNvbnRhaW5lciwgeyB3aWR0aDogYCR7dH1weGAgfSk7XG4gIH1cbiAgX2xpc3RlblRvVXNlcklucHV0KCkge1xuICAgIGMub24odGhpcy5faW5wdXQsIFwiaW5wdXRcIiwgdGhpcy5fdXNlcklucHV0SGFuZGxlcik7XG4gIH1cbiAgX2hhbmRsZVVzZXJJbnB1dCh0KSB7XG4gICAgY29uc3QgeyB2YWx1ZTogZSB9ID0gdC50YXJnZXQsIGkgPSB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCwgbiA9IHRoaXMuX29wdGlvbnMuZGVib3VuY2U7XG4gICAgaWYgKHRoaXMuZmlsdGVyKSB7XG4gICAgICBpZiAoZS5sZW5ndGggPCBpKSB7XG4gICAgICAgIHRoaXMuX2lzT3BlbiAmJiB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RlYm91bmNlRmlsdGVyKGUsIG4pO1xuICAgIH1cbiAgfVxuICBfZGVib3VuY2VGaWx0ZXIodCwgZSkge1xuICAgIHRoaXMuX2RlYm91bmNlVGltZW91dElkICYmIGNsZWFyVGltZW91dCh0aGlzLl9kZWJvdW5jZVRpbWVvdXRJZCksIHRoaXMuX2RlYm91bmNlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9maWx0ZXJSZXN1bHRzKHQpO1xuICAgIH0sIGUpO1xuICB9XG4gIF9maWx0ZXJSZXN1bHRzKHQpIHtcbiAgICB0aGlzLl9sYXN0UXVlcnlWYWx1ZSA9IHQ7XG4gICAgY29uc3QgZSA9IHRoaXMuZmlsdGVyKHQpO1xuICAgIHRoaXMuX2lzUHJvbWlzZShlKSA/IHRoaXMuX2FzeW5jVXBkYXRlUmVzdWx0cyhlKSA6IHRoaXMuX3VwZGF0ZVJlc3VsdHMoZSk7XG4gIH1cbiAgX2lzUHJvbWlzZSh0KSB7XG4gICAgcmV0dXJuICEhdCAmJiB0eXBlb2YgdC50aGVuID09IFwiZnVuY3Rpb25cIjtcbiAgfVxuICBfYXN5bmNVcGRhdGVSZXN1bHRzKHQpIHtcbiAgICB0aGlzLl9yZXNldEFjdGl2ZUl0ZW0oKSwgdGhpcy5fc2hvd0xvYWRlcigpLCB0LnRoZW4oKGUpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZVJlc3VsdHMoZSksIHRoaXMuX2xvYWRlclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5faGlkZUxvYWRlcigpLCB0aGlzLl9sb2FkZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgIH0sIHRoaXMuX29wdGlvbnMubG9hZGVyQ2xvc2VEZWxheSk7XG4gICAgfSk7XG4gIH1cbiAgX3Jlc2V0QWN0aXZlSXRlbSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fYWN0aXZlSXRlbTtcbiAgICB0ICYmICh0LnJlbW92ZUF0dHJpYnV0ZShCbyksIHRoaXMuX2FjdGl2ZUl0ZW0gPSBudWxsLCB0aGlzLl9hY3RpdmVJdGVtSW5kZXggPSAtMSk7XG4gIH1cbiAgX3Nob3dMb2FkZXIoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9sb2FkZXIpO1xuICB9XG4gIF9oaWRlTG9hZGVyKCkge1xuICAgIGQuZmluZE9uZShjQSwgdGhpcy5fZWxlbWVudCkgJiYgdGhpcy5fZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl9sb2FkZXIpO1xuICB9XG4gIF91cGRhdGVSZXN1bHRzKHQpIHtcbiAgICB0aGlzLl9yZXNldEFjdGl2ZUl0ZW0oKSwgdGhpcy5fZmlsdGVyZWRSZXN1bHRzID0gdCwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIF9BLCB7IHJlc3VsdHM6IHQgfSk7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcbiAgICAgIFZzLFxuICAgICAgdGhpcy5fZHJvcGRvd25Db250YWluZXJcbiAgICApLCBpID0gZWQoXG4gICAgICB0LFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXMuYXV0b2NvbXBsZXRlSXRlbVxuICAgICksIG4gPSByQShcbiAgICAgIHRoaXMuX29wdGlvbnMubm9SZXN1bHRzLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdC5sZW5ndGggPT09IDAgJiYgdGhpcy5fb3B0aW9ucy5ub1Jlc3VsdHMgIT09IFwiXCIgPyBlLmlubmVySFRNTCA9IG4gOiBlLmlubmVySFRNTCA9IGksIHRoaXMuX2lzT3BlbiB8fCB0aGlzLm9wZW4oKSwgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci5mb3JjZVVwZGF0ZSgpO1xuICB9XG4gIF9saXN0ZW5Ub0tleWRvd24oKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpO1xuICB9XG4gIF9oYW5kbGVLZXlkb3duKHQpIHtcbiAgICB0aGlzLl9pc09wZW4gPyB0aGlzLl9oYW5kbGVPcGVuS2V5ZG93bih0KSA6IHRoaXMuX2hhbmRsZUNsb3NlZEtleWRvd24odCk7XG4gIH1cbiAgX2hhbmRsZU9wZW5LZXlkb3duKHQpIHtcbiAgICBjb25zdCBlID0gdC5rZXlDb2RlO1xuICAgIGlmIChlID09PSBrZSAmJiB0aGlzLl9vcHRpb25zLmF1dG9TZWxlY3QgJiYgdGhpcy5fc2VsZWN0QWN0aXZlSXRlbSgpLCBlID09PSB3ZSB8fCBlID09PSBVICYmIHQuYWx0S2V5KSB7XG4gICAgICB0aGlzLmNsb3NlKCksIHRoaXMuX2lucHV0LmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlID09PSB3ZSB8fCBlID09PSBVICYmIHQuYWx0S2V5IHx8IGUgPT09IGtlKSB7XG4gICAgICB0aGlzLmNsb3NlKCksIHRoaXMuX2lucHV0LmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoZSkge1xuICAgICAgY2FzZSB6OlxuICAgICAgICB0aGlzLl9zZXRBY3RpdmVJdGVtKHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCArIDEpLCB0aGlzLl9zY3JvbGxUb0l0ZW0odGhpcy5fYWN0aXZlSXRlbSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBVOlxuICAgICAgICB0aGlzLl9zZXRBY3RpdmVJdGVtKHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCAtIDEpLCB0aGlzLl9zY3JvbGxUb0l0ZW0odGhpcy5fYWN0aXZlSXRlbSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlSXRlbUluZGV4ID4gLTEgPyAodGhpcy5fc2V0QWN0aXZlSXRlbSgwKSwgdGhpcy5fc2Nyb2xsVG9JdGVtKHRoaXMuX2FjdGl2ZUl0ZW0pKSA6IHRoaXMuX2lucHV0LnNldFNlbGVjdGlvblJhbmdlKDAsIDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRWU6XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVJdGVtSW5kZXggPiAtMSlcbiAgICAgICAgICB0aGlzLl9zZXRBY3RpdmVJdGVtKHRoaXMuaXRlbXMubGVuZ3RoIC0gMSksIHRoaXMuX3Njcm9sbFRvSXRlbSh0aGlzLl9hY3RpdmVJdGVtKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgbiA9IHRoaXMuX2lucHV0LnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLl9pbnB1dC5zZXRTZWxlY3Rpb25SYW5nZShuLCBuKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXQ6XG4gICAgICAgIGlmICh0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA+IC0xKSB7XG4gICAgICAgICAgY29uc3QgbiA9IHRoaXMuX2ZpbHRlcmVkUmVzdWx0c1t0aGlzLl9hY3RpdmVJdGVtSW5kZXhdO1xuICAgICAgICAgIHRoaXMuX2hhbmRsZVNlbGVjdGlvbihuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfc2V0QWN0aXZlSXRlbSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuaXRlbXM7XG4gICAgZVt0XSAmJiB0aGlzLl91cGRhdGVBY3RpdmVJdGVtKGVbdF0sIHQpO1xuICB9XG4gIF91cGRhdGVBY3RpdmVJdGVtKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fYWN0aXZlSXRlbTtcbiAgICBpICYmIGkucmVtb3ZlQXR0cmlidXRlKEJvKSwgdC5zZXRBdHRyaWJ1dGUoQm8sIFwiXCIpLCB0aGlzLl9hY3RpdmVJdGVtSW5kZXggPSBlLCB0aGlzLl9hY3RpdmVJdGVtID0gdDtcbiAgfVxuICBfc2Nyb2xsVG9JdGVtKHQpIHtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuaXRlbXNMaXN0LCBpID0gZS5vZmZzZXRIZWlnaHQsIG4gPSB0aGlzLml0ZW1zLmluZGV4T2YodCksIG8gPSB0Lm9mZnNldEhlaWdodCwgciA9IGUuc2Nyb2xsVG9wO1xuICAgIGlmIChuID4gLTEpIHtcbiAgICAgIGNvbnN0IGEgPSBuICogbywgbCA9IGEgKyBvID4gciArIGk7XG4gICAgICBhIDwgciA/IGUuc2Nyb2xsVG9wID0gYSA6IGwgPyBlLnNjcm9sbFRvcCA9IGEgLSBpICsgbyA6IGUuc2Nyb2xsVG9wID0gcjtcbiAgICB9XG4gIH1cbiAgX2hhbmRsZUNsb3NlZEtleWRvd24odCkge1xuICAgIHQua2V5ID09PSBcIkVudGVyXCIgJiYgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IGUgPSB0LmtleUNvZGU7XG4gICAgKGUgPT09IGl0IHx8IGUgPT09IHogfHwgZSA9PT0geikgJiYgdGhpcy5vcGVuKCk7XG4gIH1cbiAgb3BlbigpIHtcbiAgICB0aGlzLl9sYXN0UXVlcnlWYWx1ZSA9PT0gbnVsbCAmJiB0aGlzLl9maWx0ZXJSZXN1bHRzKFwiXCIpO1xuICAgIGNvbnN0IHQgPSBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgcEEpO1xuICAgIHRoaXMuX2lzT3BlbiB8fCB0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX3VwZGF0ZURyb3Bkb3duV2lkdGgoKSwgdGhpcy5fbGlzdGVuVG9XaW5kb3dSZXNpemUoKSwgdGhpcy5fcG9wcGVyID0gc2UodGhpcy5fZWxlbWVudCwgdGhpcy5fZHJvcGRvd25Db250YWluZXIsIHtcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAxXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pLCB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZHJvcGRvd25Db250YWluZXIpLCB0aGlzLl9saXN0ZW5Ub091dHNpZGVDbGljaygpLCB0aGlzLl9saXN0ZW5Ub0l0ZW1zQ2xpY2soKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmRyb3Bkb3duLnNldEF0dHJpYnV0ZShyYywgXCJcIiksIHRoaXMuX2lzT3BlbiA9ICEwLCB0aGlzLl9zZXRJbnB1dEFjdGl2ZVN0eWxlcygpLCB0aGlzLl91cGRhdGVJbnB1dFN0YXRlKCk7XG4gICAgfSwgMCkpO1xuICB9XG4gIF9saXN0ZW5Ub091dHNpZGVDbGljaygpIHtcbiAgICBjLm9uKGRvY3VtZW50LCBcImNsaWNrXCIsIHRoaXMuX291dHNpZGVDbGlja0hhbmRsZXIpO1xuICB9XG4gIF9oYW5kbGVPdXRzaWRlQ2xpY2sodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9pbnB1dCA9PT0gdC50YXJnZXQsIGkgPSB0LnRhcmdldCA9PT0gdGhpcy5fZHJvcGRvd25Db250YWluZXIsIG4gPSB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciAmJiB0aGlzLl9kcm9wZG93bkNvbnRhaW5lci5jb250YWlucyh0LnRhcmdldCk7XG4gICAgIWUgJiYgIWkgJiYgIW4gJiYgdGhpcy5jbG9zZSgpO1xuICB9XG4gIF9saXN0ZW5Ub0l0ZW1zQ2xpY2soKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgIFZzLFxuICAgICAgdGhpcy5fZHJvcGRvd25Db250YWluZXJcbiAgICApO1xuICAgIGMub24odCwgXCJjbGlja1wiLCB0aGlzLl9oYW5kbGVJdGVtc0NsaWNrLmJpbmQodGhpcykpO1xuICB9XG4gIF9oYW5kbGVJdGVtc0NsaWNrKHQpIHtcbiAgICBjb25zdCBlID0gZC5jbG9zZXN0KHQudGFyZ2V0LCBhYyksIGkgPSBoLmdldERhdGFBdHRyaWJ1dGUoZSwgXCJpbmRleFwiKSwgbiA9IHRoaXMuX2ZpbHRlcmVkUmVzdWx0c1tpXTtcbiAgICB0aGlzLl9oYW5kbGVTZWxlY3Rpb24obik7XG4gIH1cbiAgX3NlbGVjdEFjdGl2ZUl0ZW0oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2ZpbHRlcmVkUmVzdWx0c1t0aGlzLl9hY3RpdmVJdGVtSW5kZXhdO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5fb3B0aW9ucy5kaXNwbGF5VmFsdWUodCk7XG4gICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGxjLCB7XG4gICAgICB2YWx1ZTogdFxuICAgIH0pLmRlZmF1bHRQcmV2ZW50ZWQgfHwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9jYW5PcGVuT25Gb2N1cyA9ICExLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKGUpLCB0aGlzLl91cGRhdGVJbnB1dFN0YXRlKCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgX2hhbmRsZVNlbGVjdGlvbih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX29wdGlvbnMuZGlzcGxheVZhbHVlKHQpLCBpID0gYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGxjLCB7XG4gICAgICB2YWx1ZTogdFxuICAgIH0pO1xuICAgIHQgIT09IHZvaWQgMCAmJiAoaS5kZWZhdWx0UHJldmVudGVkIHx8IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fY2FuT3Blbk9uRm9jdXMgPSAhMSwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZShlKSwgdGhpcy5fdXBkYXRlSW5wdXRTdGF0ZSgpLCB0aGlzLl9pbnB1dC5mb2N1cygpLCB0aGlzLmNsb3NlKCk7XG4gICAgfSwgMCkpO1xuICB9XG4gIF91cGRhdGVJbnB1dFZhbHVlKHQpIHtcbiAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IHQ7XG4gIH1cbiAgX3NldElucHV0QWN0aXZlU3R5bGVzKCkge1xuICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShvYywgXCJcIik7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdmFyIGU7XG4gICAgY29uc3QgdCA9IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB1QSk7XG4gICAgIXRoaXMuX2lzT3BlbiB8fCB0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX3Jlc2V0QWN0aXZlSXRlbSgpLCB0aGlzLl9yZW1vdmVEcm9wZG93bkV2ZW50cygpLCB0aGlzLmRyb3Bkb3duLnJlbW92ZUF0dHJpYnV0ZShyYyksIGMub24oXG4gICAgICB0aGlzLmRyb3Bkb3duLFxuICAgICAgXCJ0cmFuc2l0aW9uZW5kXCIsXG4gICAgICB0aGlzLl9oYW5kbGVEcm9wZG93blRyYW5zaXRpb25FbmQuYmluZCh0aGlzKVxuICAgICksIHRoaXMuX2lucHV0LnJlbW92ZUF0dHJpYnV0ZShvYyksIHRoaXMuX2lucHV0LnZhbHVlIHx8ICh0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoUGUpLCAoZSA9IHRoaXMuX25vdGNoKSA9PSBudWxsIHx8IGUucmVtb3ZlQXR0cmlidXRlKFBlKSkpO1xuICB9XG4gIF9yZW1vdmVEcm9wZG93bkV2ZW50cygpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgVnMsXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lclxuICAgICk7XG4gICAgYy5vZmYodCwgXCJjbGlja1wiKSwgYy5vZmYoZG9jdW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5fb3V0c2lkZUNsaWNrSGFuZGxlciksIGMub2ZmKHdpbmRvdywgXCJyZXNpemVcIiwgdGhpcy5faGFuZGxlV2luZG93UmVzaXplLmJpbmQodGhpcykpO1xuICB9XG4gIF9oYW5kbGVEcm9wZG93blRyYW5zaXRpb25FbmQodCkge1xuICAgIHRoaXMuX2lzT3BlbiAmJiB0ICYmIHQucHJvcGVydHlOYW1lID09PSBcIm9wYWNpdHlcIiAmJiAodGhpcy5fcG9wcGVyLmRlc3Ryb3koKSwgdGhpcy5fZHJvcGRvd25Db250YWluZXIgJiYgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyKSwgdGhpcy5faXNPcGVuID0gITEsIGMub2ZmKHRoaXMuZHJvcGRvd24sIFwidHJhbnNpdGlvbmVuZFwiKSwgdGhpcy5fY2FuT3Blbk9uRm9jdXMgPSAhMCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9pc09wZW4gJiYgdGhpcy5jbG9zZSgpLCB0aGlzLl9yZW1vdmVJbnB1dEFuZEVsZW1lbnRFdmVudHMoKSwgdGhpcy5fZHJvcGRvd25Db250YWluZXIucmVtb3ZlKCksIEEucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBMaSk7XG4gIH1cbiAgX3JlbW92ZUlucHV0QW5kRWxlbWVudEV2ZW50cygpIHtcbiAgICBjLm9mZih0aGlzLl9pbnB1dCwgXCJmb2N1c1wiLCB0aGlzLl9pbnB1dEZvY3VzSGFuZGxlciksIGMub2ZmKHRoaXMuX2lucHV0LCBcImlucHV0XCIsIHRoaXMuX3VzZXJJbnB1dEhhbmRsZXIpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgaSA9IEEuZ2V0RGF0YSh0aGlzLCBMaSk7XG4gICAgICBjb25zdCBuID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIWkgJiYgL2Rpc3Bvc2UvLnRlc3QodCkpICYmIChpIHx8IChpID0gbmV3IGlkKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIExpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCB2QSA9IChzLCB0KSA9PiBgPGRpdiBjbGFzcz1cIiR7cy5jb25uZWN0Q29udGFpbmVyfVwiICR7dH0+XG4gIDxkaXYgY2xhc3M9XCIke3MuY29ubmVjdH1cIj48L2Rpdj5cbiAgPC9kaXY+YCwgVEEgPSAocywgdCkgPT4gYDxkaXYgY2xhc3M9XCIke3MuaGFuZH1cIiAke3R9PlxuICAgIDxzcGFuPjwvc3Bhbj5cbiAgPC9kaXY+YCwgRUEgPSAocywgdCkgPT4gYFxuICAgIDxzcGFuIGNsYXNzPVwiJHtzLnRvb2x0aXB9XCIgJHt0fT5cbiAgICAgIDxzcGFuIGNsYXNzPVwiJHtzLnRvb2x0aXBWYWx1ZX1cIj48L3NwYW4+XG4gICAgPC9zcGFuPlxuICAgIGAsIHBlID0gKHMpID0+IHMudHlwZSA9PT0gXCJ0b3VjaG1vdmVcIiA/IHMudG91Y2hlc1swXS5jbGllbnRYIDogcy5jbGllbnRYLCBhbiA9IFwibXVsdGlSYW5nZVNsaWRlclwiLCBsbiA9IGB0ZS4ke2FufWAsIENBID0gYC4ke2xufWAsIGNjID0gYHZhbHVlQ2hhbmdlZCR7Q0F9YCwgX2UgPSBcImRhdGEtdGUtYWN0aXZlXCIsIGhjID0gXCJkYXRhLXRlLW11bHRpLXJhbmdlLXNsaWRlci1oYW5kLXJlZlwiLCBkYyA9IFwiZGF0YS10ZS1tdWx0aS1yYW5nZS1zbGlkZXItY29ubmVjdC1yZWZcIiwgdWMgPSBcImRhdGEtdGUtbXVsdGktcmFuZ2Utc2xpZGVyLXRvb2x0aXAtcmVmXCIsIEFBID0ge1xuICBtYXg6IFwibnVtYmVyXCIsXG4gIG1pbjogXCJudW1iZXJcIixcbiAgbnVtYmVyT2ZSYW5nZXM6IFwibnVtYmVyXCIsXG4gIHN0YXJ0VmFsdWVzOiBcIihhcnJheXxzdHJpbmcpXCIsXG4gIHN0ZXA6IFwiKHN0cmluZ3xudWxsfG51bWJlcilcIixcbiAgdG9vbHRpcDogXCJib29sZWFuXCJcbn0sIHlBID0ge1xuICBtYXg6IDEwMCxcbiAgbWluOiAwLFxuICBudW1iZXJPZlJhbmdlczogMixcbiAgc3RhcnRWYWx1ZXM6IFswLCAxMDBdLFxuICBzdGVwOiBudWxsLFxuICB0b29sdGlwOiAhMVxufSwgd0EgPSB7XG4gIGNvbm5lY3Q6IFwiei0xMCBoLWZ1bGwgdy1mdWxsIGJnLVsjZWVlXSB3aWxsLWNoYW5nZS10cmFuc2Zvcm0gZGFyazpiZy1bIzRmNGY0Zl1cIixcbiAgY29ubmVjdENvbnRhaW5lcjogXCJyZWxhdGl2ZSBib3JkZXItWzFweF0gYm9yZGVyLVsjZWVlXSB6LTAgaC1mdWxsIHctZnVsbCBvdmVyZmxvdy1oaWRkZW4gZGFyazpib3JkZXItWyM0ZjRmNGZdXCIsXG4gIGNvbnRhaW5lcjogXCJhcHBlcmFuY2Utbm9uZSByZWxhdGl2ZSBtLWF1dG8gdy1mdWxsIGN1cnNvci1wb2ludGVyIGgtMSBib3JkZXItMCBiZy10cmFuc3BhcmVudCBwLTAgZm9jdXM6b3V0bGluZS1ub25lIGRhcms6Ym9yZGVyLVsjNGY0ZjRmXVwiLFxuICBoYW5kOiBcImFwcGVyYW5jZS1ub25lIGFic29sdXRlIHRvcC1bNTAlXSBib3JkZXItMCAtbXQtMSBoLTQgdy00IGN1cnNvci1wb2ludGVyIHJvdW5kZWQtWzUwJV0gYm9yZGVyLTAgYmctcHJpbWFyeSB0cmFuc2l0aW9uLWNvbG9ycyBlYXNlLWluLW91dCB3aWxsLWNoYW5nZS10cmFuc2Zvcm0gYWN0aXZlOmJnLVsjYzRkNGVmXSBhY3RpdmU6ei02MFwiLFxuICB0b29sdGlwOiBcImFic29sdXRlIC10b3AtWzE4cHhdIG9yaWdpbi1bNTAlXzUwJV0gLXRyYW5zbGF0ZS14LVs2cHhdIC1yb3RhdGUtNDUgc2NhbGUtMCByb3VuZGVkLWJsLW5vbmUgcm91bmRlZC1ici0yeGwgcm91bmRlZC10bC0yeGwgcm91bmRlZC10ci0yeGwgYmctcHJpbWFyeSB0ZXh0LXdoaXRlIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLVsyMDBtc10gZGF0YS1bdGUtYWN0aXZlXTotdG9wLVszOHB4XSBkYXRhLVt0ZS1hY3RpdmVdOnNjYWxlLTEwMFwiLFxuICB0b29sdGlwVmFsdWU6IFwiYmxvY2sgaC1bMzBweF0gdy1bMzBweF0gLXRyYW5zbGF0ZS14LVs2cHhdIHRyYW5zbGF0ZS15LVs2cHhdIHJvdGF0ZS00NSB0ZXh0LWNlbnRlciB0ZXh0LVsxMHB4XVwiXG59LCBrQSA9IHtcbiAgY29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBjb25uZWN0Q29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBjb25uZWN0OiBcInN0cmluZ1wiLFxuICBoYW5kOiBcInN0cmluZ1wiLFxuICB0b29sdGlwOiBcInN0cmluZ1wiLFxuICB0b29sdGlwVmFsdWU6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBzZCBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9tb3VzZW1vdmUgPSAhMSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX21heFRyYW5zbGF0aW9uID0gbnVsbCwgdGhpcy5fbWluVHJhbnNsYXRpb24gPSBudWxsLCB0aGlzLl9jdXJyZW50U3RlcFZhbHVlID0gbnVsbCwgdGhpcy5fY2FuQ2hhbmdlU3RlcCA9ICExLCB0aGlzLmluaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gYW47XG4gIH1cbiAgZ2V0IGhhbmRzKCkge1xuICAgIHJldHVybiBkLmZpbmQoYFske2hjfV1gLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgY29ubmVjdCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKGBbJHtkY31dYCwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IGxlZnRDb25uZWN0UmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gIH1cbiAgZ2V0IGhhbmRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShgWyR7X2V9XWApO1xuICB9XG4gIGdldCBhY3RpdmVUb29sdGlwVmFsdWUoKSB7XG4gICAgcmV0dXJuIGQuZmluZChgWyR7dWN9XWApLmZpbHRlcihcbiAgICAgIChuKSA9PiBuLmhhc0F0dHJpYnV0ZShfZSlcbiAgICApWzBdLmNoaWxkcmVuWzBdO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX3NldENvbnRhaW5lckNsYXNzZXMoKSwgdGhpcy5fc2V0UmFuZ2VDb25uZWN0c0VsZW1lbnQoKSwgdGhpcy5fc2V0UmFuZ2VIYW5kbGVFbGVtZW50cygpLCB0aGlzLl9zZXRNYXhBbmRNaW5UcmFuc2xhdGlvbigpLCB0aGlzLl9zZXRUcmFuc29mcm1hdGlvbk9uU3RhcnQoKSwgdGhpcy5faGFuZGxlQ2xpY2tFdmVudE9uSGFuZCgpLCB0aGlzLl9oYW5kbGVFbmRNb3ZlRXZlbnREb2N1bWVudCgpLCB0aGlzLl9oYW5kbGVDbGlja09uUmFuZ2UoKSwgdGhpcy5fc2V0VG9vbHRpcFRvSGFuZCgpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIGxuKSwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHRoaXMuX21vdXNlbW92ZSA9IG51bGwsIHRoaXMuX21heFRyYW5zbGF0aW9uID0gbnVsbCwgdGhpcy5fbWluVHJhbnNsYXRpb24gPSBudWxsLCB0aGlzLl9jdXJyZW50U3RlcFZhbHVlID0gbnVsbCwgdGhpcy5fY2FuQ2hhbmdlU3RlcCA9IG51bGwsIHRoaXMuaGFuZHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgSy5vZmYodCwgXCJtb3VzZWRvd24gdG91Y2hzdGFydFwiKSwgSy5vZmYodCwgXCJtb3VzZXVwIHRvdWNoZW5kXCIpO1xuICAgIH0pLCBLLm9mZihkb2N1bWVudCwgXCJtb3VzZW1vdmUgdG91Y2htb3ZlXCIpLCBLLm9mZihkb2N1bWVudCwgXCJtb3VzZXVwIHRvdWNoZW5kXCIpLCBLLm9mZih0aGlzLmNvbm5lY3QsIFwibW91c2Vkb3duIHRvdWNoc3RhcnRcIik7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfc2V0TWF4QW5kTWluVHJhbnNsYXRpb24oKSB7XG4gICAgdGhpcy5fbWF4VHJhbnNsYXRpb24gPSB0aGlzLmNvbm5lY3Qub2Zmc2V0V2lkdGggLSB0aGlzLmhhbmRzWzBdLm9mZnNldFdpZHRoIC8gMiwgdGhpcy5fbWluVHJhbnNsYXRpb24gPSB0aGlzLmNvbm5lY3Qub2Zmc2V0TGVmdCAtIHRoaXMuaGFuZHNbMF0ub2Zmc2V0V2lkdGggLyAyO1xuICB9XG4gIF9zZXRUcmFuc29mcm1hdGlvbk9uU3RhcnQoKSB7XG4gICAgY29uc3QgeyBtYXg6IHQsIG1pbjogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBsZXQgeyBzdGFydFZhbHVlczogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICB0eXBlb2YgaSA9PSBcInN0cmluZ1wiICYmIChpID0gSlNPTi5wYXJzZShpLnJlcGxhY2UoLycvZywgJ1wiJykpKSwgaS5sZW5ndGggPT09IDAgPyB0aGlzLmhhbmRzLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGguc2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgICAgbixcbiAgICAgICAgXCJ0cmFuc2xhdGlvblwiLFxuICAgICAgICBNYXRoLnJvdW5kKHRoaXMuX21pblRyYW5zbGF0aW9uKVxuICAgICAgKSwgaC5hZGRTdHlsZShuLCB7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3RoaXMuX21pblRyYW5zbGF0aW9ufXB4LC0yNSUpYFxuICAgICAgfSk7XG4gICAgfSkgOiB0aGlzLmhhbmRzLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgIGlmIChpW29dID4gdCB8fCBpW29dIDwgZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGlbb10gPT09IHZvaWQgMCkge1xuICAgICAgICBoLnNldERhdGFBdHRyaWJ1dGUoXG4gICAgICAgICAgbixcbiAgICAgICAgICBcInRyYW5zbGF0aW9uXCIsXG4gICAgICAgICAgTWF0aC5yb3VuZCh0aGlzLl9tYXhUcmFuc2xhdGlvbilcbiAgICAgICAgKSwgaC5hZGRTdHlsZShuLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7dGhpcy5fbWF4VHJhbnNsYXRpb259cHgsLTI1JSlgLFxuICAgICAgICAgIHpJbmRleDogdGhpcy5oYW5kcy5sZW5ndGggLSBvXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhID0gKGlbb10gLSBlKSAvICh0IC0gZSkgKiB0aGlzLmNvbm5lY3Qub2Zmc2V0V2lkdGggLSBuLm9mZnNldFdpZHRoIC8gMjtcbiAgICAgIGguc2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgICAgbixcbiAgICAgICAgXCJ0cmFuc2xhdGlvblwiLFxuICAgICAgICBNYXRoLnJvdW5kKGEpXG4gICAgICApLCBoLmFkZFN0eWxlKG4sIHtcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7YX1weCwtMjUlKWAsXG4gICAgICAgIHpJbmRleDogdGhpcy5oYW5kcy5sZW5ndGggLSBvXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlT3V0T2ZNYXhSYW5nZVZhbHVlKHQsIGUpIHtcbiAgICB0aGlzLl91cGRhdGVIYW5kKHQsIHRoaXMuX21heFRyYW5zbGF0aW9uKSwgdGhpcy5fb3B0aW9ucy50b29sdGlwICYmICh0aGlzLmFjdGl2ZVRvb2x0aXBWYWx1ZS5pbm5lclRleHQgPSBlKTtcbiAgfVxuICBfaGFuZGxlT3V0T2ZNaW5SYW5nZVZhbHVlKHQsIGUpIHtcbiAgICB0aGlzLl91cGRhdGVIYW5kKHQsIHRoaXMuX21pblRyYW5zbGF0aW9uKSwgdGhpcy5fb3B0aW9ucy50b29sdGlwICYmICh0aGlzLmFjdGl2ZVRvb2x0aXBWYWx1ZS5pbm5lclRleHQgPSBlKTtcbiAgfVxuICBfaGFuZGxlTm9ybWFsTW92ZSh0LCBlLCBpKSB7XG4gICAgdGhpcy5fdXBkYXRlSGFuZCh0LCBlKSwgdGhpcy5fb3B0aW9ucy50b29sdGlwICYmICh0aGlzLmFjdGl2ZVRvb2x0aXBWYWx1ZS5pbm5lclRleHQgPSBNYXRoLnJvdW5kKGkpKTtcbiAgfVxuICBfaGFuZGxlQ2xpY2tFdmVudE9uSGFuZCgpIHtcbiAgICBjb25zdCB7IG1heDogdCwgbWluOiBlLCBzdGVwOiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIHRoaXMuaGFuZHMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgSy5vbihuLCBcIm1vdXNlZG93biB0b3VjaHN0YXJ0XCIsIChvKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9tb3VzZW1vdmUgPSAhMCwgbi5zZXRBdHRyaWJ1dGUoX2UsIFwiXCIpLCB0aGlzLl9vcHRpb25zLnRvb2x0aXAgJiYgbi5jaGlsZHJlblsxXS5zZXRBdHRyaWJ1dGUoX2UsIFwiXCIpLCB0aGlzLl9oYW5kbGVNb3ZlRXZlbnQobiksIHRoaXMuX2hhbmRsZUVuZE1vdmVFdmVudChuLCBvKSwgIXRoaXMuX2NhbkNoYW5nZVN0ZXAgJiYgaSAhPT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHIgPSBwZShvKSAtIHRoaXMubGVmdENvbm5lY3RSZWN0IC0gbi5vZmZzZXRXaWR0aCAvIDIsIGEgPSAocGUobykgLSB0aGlzLmxlZnRDb25uZWN0UmVjdCkgLyAodGhpcy5jb25uZWN0Lm9mZnNldFdpZHRoIC8gKHQgLSBlKSkgJSAodCAtIGUpO1xuICAgICAgICByID49IHRoaXMuX21heFRyYW5zbGF0aW9uID8gdGhpcy5faGFuZGxlT3V0T2ZNYXhSYW5nZVZhbHVlKG4sIHQpIDogciA8PSB0aGlzLl9taW5UcmFuc2xhdGlvbiA/IHRoaXMuX2hhbmRsZU91dE9mTWluUmFuZ2VWYWx1ZShuLCBlKSA6IHRoaXMuX2hhbmRsZU5vcm1hbE1vdmUobiwgciwgYSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfc2V0Q29udGFpbmVyQ2xhc3NlcygpIHtcbiAgICBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuY29udGFpbmVyKTtcbiAgfVxuICBfc2V0UmFuZ2VDb25uZWN0c0VsZW1lbnQoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5pbnNlcnRBZGphY2VudEhUTUwoXG4gICAgICBcImFmdGVyYmVnaW5cIixcbiAgICAgIHZBKFxuICAgICAgICB7XG4gICAgICAgICAgY29ubmVjdENvbnRhaW5lcjogdGhpcy5fY2xhc3Nlcy5jb25uZWN0Q29udGFpbmVyLFxuICAgICAgICAgIGNvbm5lY3Q6IHRoaXMuX2NsYXNzZXMuY29ubmVjdFxuICAgICAgICB9LFxuICAgICAgICBkY1xuICAgICAgKVxuICAgICk7XG4gIH1cbiAgX3NldFJhbmdlSGFuZGxlRWxlbWVudHMoKSB7XG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLl9vcHRpb25zLm51bWJlck9mUmFuZ2VzOyB0KyspXG4gICAgICB0aGlzLl9lbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChcbiAgICAgICAgXCJiZWZvcmVlbmRcIixcbiAgICAgICAgVEEoeyBoYW5kOiB0aGlzLl9jbGFzc2VzLmhhbmQgfSwgaGMpXG4gICAgICApO1xuICAgIHRoaXMuaGFuZHMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLW9yaWVudGF0aW9uXCIsIFwiaG9yaXpvbnRhbFwiKSwgdC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwic2xpZGVyXCIpLCBoLnNldERhdGFBdHRyaWJ1dGUodCwgXCJoYW5kbGVcIiwgZSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldFRvb2x0aXBUb0hhbmQoKSB7XG4gICAgdGhpcy5fb3B0aW9ucy50b29sdGlwICYmIHRoaXMuaGFuZHMuZm9yRWFjaCgodCkgPT4gdC5pbnNlcnRBZGphY2VudEhUTUwoXG4gICAgICBcImJlZm9yZWVuZFwiLFxuICAgICAgRUEoXG4gICAgICAgIHtcbiAgICAgICAgICB0b29sdGlwOiB0aGlzLl9jbGFzc2VzLnRvb2x0aXAsXG4gICAgICAgICAgdG9vbHRpcFZhbHVlOiB0aGlzLl9jbGFzc2VzLnRvb2x0aXBWYWx1ZVxuICAgICAgICB9LFxuICAgICAgICB1Y1xuICAgICAgKVxuICAgICkpO1xuICB9XG4gIF9oYW5kbGVNb3ZlRXZlbnQodCkge1xuICAgIGNvbnN0IHsgdG9vbHRpcDogZSwgc3RlcDogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBLLm9uKGRvY3VtZW50LCBcIm1vdXNlbW92ZSB0b3VjaG1vdmVcIiwgKG4pID0+IHtcbiAgICAgIG4udHlwZSA9PT0gXCJtb3VzZW1vdmVcIiAmJiBuLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCB7IG1heDogbywgbWluOiByLCBudW1iZXJPZlJhbmdlczogYSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgIGlmICh0Lmhhc0F0dHJpYnV0ZShfZSkpIHtcbiAgICAgICAgY29uc3QgbCA9IChwZShuKSAtIHRoaXMubGVmdENvbm5lY3RSZWN0KSAvIHRoaXMuY29ubmVjdC5vZmZzZXRXaWR0aCAqIG87XG4gICAgICAgIGxldCBwID0gKHBlKG4pIC0gdGhpcy5sZWZ0Q29ubmVjdFJlY3QpIC8gKHRoaXMuY29ubmVjdC5vZmZzZXRXaWR0aCAvIChvIC0gcikpICUgKG8gLSByKSArIHI7XG4gICAgICAgIGlmICgodGhpcy5fY3VycmVudFN0ZXBWYWx1ZSA9PT0gTWF0aC5yb3VuZChwKSB8fCBNYXRoLnJvdW5kKHApICUgaSAhPT0gMCkgJiYgaSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX2NhbkNoYW5nZVN0ZXAgPSAhMTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FuQ2hhbmdlU3RlcCA9ICEwO1xuICAgICAgICBsZXQgdSA9IHBlKG4pIC0gdGhpcy5sZWZ0Q29ubmVjdFJlY3QgLSB0Lm9mZnNldFdpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgXyA9IGguZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgICAgICB0aGlzLmhhbmRBY3RpdmUsXG4gICAgICAgICAgXCJoYW5kbGVcIlxuICAgICAgICApLCBmID0gaC5nZXREYXRhQXR0cmlidXRlKFxuICAgICAgICAgIHRoaXMuaGFuZEFjdGl2ZSxcbiAgICAgICAgICBcInRyYW5zbGF0aW9uXCJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHAgPCByKVxuICAgICAgICAgIHUgPSByIC0gdC5vZmZzZXRXaWR0aCAvIDIsIHAgPSByO1xuICAgICAgICBlbHNlIGlmIChsID49IG8pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBnID0gdGhpcy5oYW5kcy5tYXAoXG4gICAgICAgICAgKG0pID0+IGguZ2V0RGF0YUF0dHJpYnV0ZShtLCBcInRyYW5zbGF0aW9uXCIpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChhIDwgMilcbiAgICAgICAgICBNYXRoLnJvdW5kKHApICUgaSA9PT0gMCAmJiBpICE9PSBudWxsID8gKHRoaXMuX2N1cnJlbnRTdGVwVmFsdWUgPSBNYXRoLnJvdW5kKHApLCBoLmFkZFN0eWxlKHQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3V9cHgsLTI1JSlgXG4gICAgICAgICAgfSksIGUgJiYgKHRoaXMuYWN0aXZlVG9vbHRpcFZhbHVlLmlubmVyVGV4dCA9IE1hdGgucm91bmQocCkpKSA6IGkgPT09IG51bGwgJiYgKGguYWRkU3R5bGUodCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7dX1weCwtMjUlKWBcbiAgICAgICAgICB9KSwgZSAmJiAodGhpcy5hY3RpdmVUb29sdGlwVmFsdWUuaW5uZXJUZXh0ID0gTWF0aC5yb3VuZChwKSkpLCBoLnNldERhdGFBdHRyaWJ1dGUodCwgXCJ0cmFuc2xhdGlvblwiLCB1KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgbSA9IF8gPiAwICYmIF8gPCBhIC0gMTtcbiAgICAgICAgICBsZXQgYiA9IHUsIHYgPSAhMTtcbiAgICAgICAgICBjb25zdCBUID0gZ1tfICsgMV0sIHkgPSBnW18gLSAxXTtcbiAgICAgICAgICBfID09PSAwICYmIGYgPj0gVCA/IChiID0gVCwgdiA9IHUgPD0gYikgOiBfID09PSBhIC0gMSAmJiBmIDw9IHkgPyAoYiA9IHksIHYgPSB1ID49IGIpIDogbSAmJiAoZiA+PSBUIHx8IGYgPD0geSkgJiYgKGIgPSBmID49IFQgPyBUIDogeSwgdiA9IGIgPT09IFQgPyB1IDw9IGIgOiB1ID49IGIpLCBNYXRoLnJvdW5kKHApICUgaSA9PT0gMCAmJiBpICE9PSBudWxsID8gKHRoaXMuX2N1cnJlbnRTdGVwVmFsdWUgPSBNYXRoLnJvdW5kKHApLCBoLmFkZFN0eWxlKHQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke2J9cHgsLTI1JSlgXG4gICAgICAgICAgfSksIGUgJiYgYiA9PT0gdSAmJiB0aGlzLmFjdGl2ZVRvb2x0aXBWYWx1ZSAhPT0gbnVsbCAmJiAodGhpcy5hY3RpdmVUb29sdGlwVmFsdWUuaW5uZXJUZXh0ID0gTWF0aC5yb3VuZChwKSkpIDogaSA9PT0gbnVsbCAmJiAoaC5hZGRTdHlsZSh0LCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtifXB4LC0yNSUpYFxuICAgICAgICAgIH0pLCBlICYmIGIgPT09IHUgJiYgdGhpcy5hY3RpdmVUb29sdGlwVmFsdWUgIT09IG51bGwgJiYgKHRoaXMuYWN0aXZlVG9vbHRpcFZhbHVlLmlubmVyVGV4dCA9IE1hdGgucm91bmQocCkpKSwgaC5zZXREYXRhQXR0cmlidXRlKFxuICAgICAgICAgICAgdCxcbiAgICAgICAgICAgIFwidHJhbnNsYXRpb25cIixcbiAgICAgICAgICAgIHYgPyB1IDogYlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FuQ2hhbmdlU3RlcCAmJiB0aGlzLl9oYW5kbGVFdmVudENoYW5nZVZhbHVlc09uUmFuZ2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlRXZlbnRDaGFuZ2VWYWx1ZXNPblJhbmdlKCkge1xuICAgIGNvbnN0IHsgbWF4OiB0LCBtaW46IGUsIG51bWJlck9mUmFuZ2VzOiBpIH0gPSB0aGlzLl9vcHRpb25zLCBuID0gKHIpID0+IHtcbiAgICAgIGNvbnN0IGEgPSByLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSB0aGlzLmxlZnRDb25uZWN0UmVjdCArIHIub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgbGV0IGwgPSBhIC8gKHRoaXMuY29ubmVjdC5vZmZzZXRXaWR0aCAvICh0IC0gZSkpICUgKHQgLSBlKTtcbiAgICAgIHJldHVybiBhID09PSB0aGlzLmNvbm5lY3Qub2Zmc2V0V2lkdGggPyBsID0gdCA6IGwgKz0gZSwgaC5zZXREYXRhQXR0cmlidXRlKHIsIFwidmFsdWVcIiwgTWF0aC5yb3VuZChsICogMTApIC8gMTApLCB7IHZhbHVlOiBsIH07XG4gICAgfTtcbiAgICBpZiAoaSA8IDIpIHtcbiAgICAgIGNvbnN0IHsgdmFsdWU6IHIgfSA9IG4odGhpcy5oYW5kc1swXSk7XG4gICAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgY2MsIHtcbiAgICAgICAgdmFsdWVzOiB7IHZhbHVlOiByICsgZSwgcm91bmRlZDogTWF0aC5yb3VuZChyICsgZSkgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG8gPSB0aGlzLmhhbmRzLm1hcCgocikgPT4gbihyKSk7XG4gICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGNjLCB7XG4gICAgICB2YWx1ZXM6IHtcbiAgICAgICAgdmFsdWU6IG8ubWFwKCh7IHZhbHVlOiByIH0pID0+IHIgKyBlKSxcbiAgICAgICAgcm91bmRlZDogby5tYXAoKHsgdmFsdWU6IHIgfSkgPT4gTWF0aC5yb3VuZChyICsgZSkpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX3Jlc2V0SGFuZFN0YXRlKHQsIGUpIHtcbiAgICBjLm9mZih0LCBlKSwgdC5yZW1vdmVBdHRyaWJ1dGUoX2UpLCB0aGlzLl9vcHRpb25zLnRvb2x0aXAgJiYgdC5jaGlsZHJlblsxXS5yZW1vdmVBdHRyaWJ1dGUoX2UpO1xuICB9XG4gIF9oYW5kbGVFbmRNb3ZlRXZlbnREb2N1bWVudCgpIHtcbiAgICBLLm9uKGRvY3VtZW50LCBcIm1vdXNldXAgdG91Y2hlbmRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fbW91c2Vtb3ZlICYmICh0aGlzLmhhbmRzLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgdGhpcy5fcmVzZXRIYW5kU3RhdGUodCwgXCJtb3VzZW1vdmVcIik7XG4gICAgICB9KSwgSy5vZmYoZG9jdW1lbnQsIFwibW91c2Vtb3ZlIHRvdWNobW92ZVwiKSwgdGhpcy5fbW91c2Vtb3ZlID0gITEpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVFbmRNb3ZlRXZlbnQodCkge1xuICAgIEsub24odCwgXCJtb3VzZXVwIHRvdWNoZW5kXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3Jlc2V0SGFuZFN0YXRlKHQsIFwibW91c2Vtb3ZlXCIpLCBLLm9mZihkb2N1bWVudCwgXCJtb3VzZW1vdmUgdG91Y2htb3ZlXCIpLCB0aGlzLl9tb3VzZW1vdmUgPSAhMTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQ2xpY2tPblJhbmdlKCkge1xuICAgIHRoaXMuX29wdGlvbnMuc3RlcCA9PT0gbnVsbCAmJiBLLm9uKHRoaXMuY29ubmVjdCwgXCJtb3VzZWRvd24gdG91Y2hzdGFydFwiLCAodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IFtdO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgaWYgKHRoaXMuaGFuZHMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICB0aGlzLl9tb3VzZW1vdmUgPSAhMDtcbiAgICAgICAgY29uc3QgbyA9IHBlKHQpLCByID0gbi5vZmZzZXRXaWR0aCwgYSA9IGguZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgICAgICBuLFxuICAgICAgICAgIFwidHJhbnNsYXRpb25cIlxuICAgICAgICApLCBsID0gbyAtIHRoaXMubGVmdENvbm5lY3RSZWN0IC0gciAvIDI7XG4gICAgICAgIHRoaXMuX29wdGlvbnMubnVtYmVyT2ZSYW5nZXMgPCAyID8gdGhpcy5fdXBkYXRlSGFuZChuLCBsKSA6IChlLnB1c2goTWF0aC5hYnMobCAtIGEpKSwgZS5mb3JFYWNoKChwLCB1KSA9PiB7XG4gICAgICAgICAgcCA8IGVbaV0gJiYgKGkgPSB1KTtcbiAgICAgICAgfSkpO1xuICAgICAgfSksIHRoaXMuX29wdGlvbnMubnVtYmVyT2ZSYW5nZXMgPj0gMikge1xuICAgICAgICBjb25zdCBuID0gcGUodCkgLSB0aGlzLmxlZnRDb25uZWN0UmVjdCAtIHRoaXMuaGFuZHNbaV0ub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICB0aGlzLl91cGRhdGVBZGphY2VudEhhbmRzKGksIG4pO1xuICAgICAgfVxuICAgICAgdGhpcy5faGFuZGxlRXZlbnRDaGFuZ2VWYWx1ZXNPblJhbmdlKCk7XG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZUhhbmQodCwgZSkge1xuICAgIGguYWRkU3R5bGUodCwge1xuICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7ZX1weCwtMjUlKWBcbiAgICB9KSwgaC5zZXREYXRhQXR0cmlidXRlKHQsIFwidHJhbnNsYXRpb25cIiwgZSk7XG4gIH1cbiAgX3VwZGF0ZUFkamFjZW50SGFuZHModCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLmhhbmRzW3QgKyAxXSwgbiA9IHRoaXMuaGFuZHNbdCAtIDFdLCBvID0gaSA/IGguZ2V0RGF0YUF0dHJpYnV0ZShpLCBcInRyYW5zbGF0aW9uXCIpIDogdm9pZCAwLCByID0gbiA/IGguZ2V0RGF0YUF0dHJpYnV0ZShuLCBcInRyYW5zbGF0aW9uXCIpIDogdm9pZCAwO1xuICAgIGkgJiYgZSA+IG8gPyB0aGlzLl91cGRhdGVIYW5kKGksIGUpIDogbiAmJiBlIDwgciA/IHRoaXMuX3VwZGF0ZUhhbmQobiwgZSkgOiB0aGlzLl91cGRhdGVIYW5kKHRoaXMuaGFuZHNbdF0sIGUpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi55QSxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gSShhbiwgZSwgQUEpLCBlO1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ud0EsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoYW4sIHQsIGtBKSwgdDtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSBBLmdldERhdGEodGhpcywgbG4pO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlfGhpZGUvLnRlc3QodCkpICYmIChpIHx8IChpID0gbmV3IHNkKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIGxuKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCB4QSA9IChzKSA9PiB7XG4gIGdjKCgpID0+IHtcbiAgICBjb25zdCB0ID0gbWMoKTtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgZSA9IHMuTkFNRSwgaSA9IHQuZm5bZV07XG4gICAgICB0LmZuW2VdID0gcy5qUXVlcnlJbnRlcmZhY2UsIHQuZm5bZV0uQ29uc3RydWN0b3IgPSBzLCB0LmZuW2VdLm5vQ29uZmxpY3QgPSAoKSA9PiAodC5mbltlXSA9IGksIHMualF1ZXJ5SW50ZXJmYWNlKTtcbiAgICB9XG4gIH0pO1xufSwgT0EgPSAocywgdCkgPT4ge1xuICBjLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX1gLFxuICAgIHQsXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCBzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykudG9nZ2xlKCk7XG4gICAgfVxuICApO1xufSwgU0EgPSAocywgdCkgPT4ge1xuICBjLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX0uZGF0YS1hcGlgLFxuICAgIHQsXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKFtcIkFcIiwgXCJBUkVBXCJdLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkgJiYgZS5wcmV2ZW50RGVmYXVsdCgpLCBiZSh0aGlzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgcy5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpLnNob3coKTtcbiAgICB9XG4gICk7XG59LCBJQSA9IChzLCB0KSA9PiB7XG4gIGMub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfS5kYXRhLWFwaWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBjb25zdCBpID0gdGUodGhpcyk7XG4gICAgICBpZiAoW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBlLnByZXZlbnREZWZhdWx0KCksIGJlKHRoaXMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjLm9uZShpLCBzLkVWRU5UX0hJRERFTiwgKCkgPT4ge1xuICAgICAgICBNdCh0aGlzKSAmJiB0aGlzLmZvY3VzKCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG4gPSBkLmZpbmRPbmUocy5PUEVOX1NFTEVDVE9SKTtcbiAgICAgIG4gJiYgbiAhPT0gaSAmJiBzLmdldEluc3RhbmNlKG4pLmhpZGUoKSwgcy5nZXRPckNyZWF0ZUluc3RhbmNlKGkpLnRvZ2dsZSh0aGlzKTtcbiAgICB9XG4gICk7XG59LCBEQSA9IChzLCB0KSA9PiB7XG4gIGMub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfWAsXG4gICAgdCxcbiAgICAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgaSA9IGUudGFyZ2V0LmNsb3Nlc3QodCk7XG4gICAgICBzLmdldE9yQ3JlYXRlSW5zdGFuY2UoaSkudG9nZ2xlKCk7XG4gICAgfVxuICApO1xufSwgJEEgPSAocywgdCkgPT4ge1xuICBjLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX1gLFxuICAgIHQsXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgY29uc3QgaSA9IHRlKHRoaXMpO1xuICAgICAgW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBlLnByZXZlbnREZWZhdWx0KCksIGMub25lKGksIHMuRVZFTlRfU0hPVywgKHIpID0+IHtcbiAgICAgICAgci5kZWZhdWx0UHJldmVudGVkIHx8IGMub25lKGksIHMuRVZFTlRfSElEREVOLCAoKSA9PiB7XG4gICAgICAgICAgTXQodGhpcykgJiYgdGhpcy5mb2N1cygpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbiA9IGQuZmluZE9uZShcbiAgICAgICAgYFske3MuT1BFTl9TRUxFQ1RPUn09XCJ0cnVlXCJdYFxuICAgICAgKTtcbiAgICAgIG4gJiYgcy5nZXRJbnN0YW5jZShuKS5oaWRlKCksIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZShpKS50b2dnbGUodGhpcyk7XG4gICAgfVxuICApO1xufSwgTEEgPSAocywgdCkgPT4ge1xuICBjLm9uZShcbiAgICBkb2N1bWVudCxcbiAgICBcIm1vdXNlZG93blwiLFxuICAgIHQsXG4gICAgcy5hdXRvSW5pdGlhbChuZXcgcygpKVxuICApO1xufSwgTkEgPSAocywgdCkgPT4ge1xuICBjLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX0uZGF0YS1hcGlgLFxuICAgIHQsXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgKGUudGFyZ2V0LnRhZ05hbWUgPT09IFwiQVwiIHx8IGUuZGVsZWdhdGVUYXJnZXQgJiYgZS5kZWxlZ2F0ZVRhcmdldC50YWdOYW1lID09PSBcIkFcIikgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgaSA9IGxyKHRoaXMpO1xuICAgICAgZC5maW5kKGkpLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgcy5nZXRPckNyZWF0ZUluc3RhbmNlKG8sIHsgdG9nZ2xlOiAhMSB9KS50b2dnbGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcbn0sIE1BID0gKHMsIHQpID0+IHtcbiAgW10uc2xpY2UuY2FsbChcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHQpXG4gICkubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gbmV3IHMoaSk7XG4gIH0pO1xufSwgUkEgPSAocywgdCkgPT4ge1xuICBbXS5zbGljZS5jYWxsKFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodClcbiAgKS5tYXAoZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBuZXcgcyhpKTtcbiAgfSk7XG59LCBQQSA9IChzLCB0KSA9PiB7XG4gIGQuZmluZCh0KS5mb3JFYWNoKChlKSA9PiB7XG4gICAgbmV3IHMoZSk7XG4gIH0pLCBjLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX0uZGF0YS1hcGlgLFxuICAgIGAke3R9IGltZzpub3QoW2RhdGEtdGUtbGlnaHRib3gtZGlzYWJsZWRdKWAsXG4gICAgcy50b2dnbGUoKVxuICApO1xufSwgQkEgPSAocywgdCkgPT4ge1xuICBjb25zdCBlID0gKG8pID0+IG9bMF0gPT09IFwie1wiICYmIG9bby5sZW5ndGggLSAxXSA9PT0gXCJ9XCIgfHwgb1swXSA9PT0gXCJbXCIgJiYgb1tvLmxlbmd0aCAtIDFdID09PSBcIl1cIiwgaSA9IChvKSA9PiB0eXBlb2YgbyAhPSBcInN0cmluZ1wiID8gbyA6IGUobykgPyBKU09OLnBhcnNlKG8ucmVwbGFjZSgvJy9nLCAnXCInKSkgOiBvLCBuID0gKG8pID0+IHtcbiAgICBjb25zdCByID0ge307XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLmZvckVhY2goKGEpID0+IHtcbiAgICAgIGlmIChhLm1hdGNoKC9kYXRhc2V0LiovKSkge1xuICAgICAgICBjb25zdCBsID0gYS5zbGljZSg3LCA4KS50b0xvd2VyQ2FzZSgpLmNvbmNhdChhLnNsaWNlKDgpKTtcbiAgICAgICAgcltsXSA9IGkob1thXSk7XG4gICAgICB9XG4gICAgfSksIHI7XG4gIH07XG4gIGQuZmluZCh0KS5mb3JFYWNoKChvKSA9PiB7XG4gICAgaWYgKGguZ2V0RGF0YUF0dHJpYnV0ZShvLCBcImNoYXJ0XCIpICE9PSBcImJ1YmJsZVwiICYmIGguZ2V0RGF0YUF0dHJpYnV0ZShvLCBcImNoYXJ0XCIpICE9PSBcInNjYXR0ZXJcIikge1xuICAgICAgY29uc3QgciA9IGguZ2V0RGF0YUF0dHJpYnV0ZXMobyksIGEgPSB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkYXRhc2V0czogW24ocildXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gci5jaGFydCAmJiAoYS50eXBlID0gci5jaGFydCksIHIubGFiZWxzICYmIChhLmRhdGEubGFiZWxzID0gSlNPTi5wYXJzZShyLmxhYmVscy5yZXBsYWNlKC8nL2csICdcIicpKSksIG5ldyBzKG8sIHtcbiAgICAgICAgLi4uYSxcbiAgICAgICAgLi4ud2lbYS50eXBlXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KTtcbn07XG5jbGFzcyBIQSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5pdHMgPSBbXTtcbiAgfVxuICBnZXQgaW5pdGlhbGl6ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdHM7XG4gIH1cbiAgaXNJbml0ZWQodCkge1xuICAgIHJldHVybiB0aGlzLmluaXRzLmluY2x1ZGVzKHQpO1xuICB9XG4gIGFkZCh0KSB7XG4gICAgdGhpcy5pc0luaXRlZCh0KSB8fCB0aGlzLmluaXRzLnB1c2godCk7XG4gIH1cbn1cbmNvbnN0IGFyID0gbmV3IEhBKCksIE5pID0ge1xuICBhbGVydDoge1xuICAgIG5hbWU6IFwiQWxlcnRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1hbGVydC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgYW5pbWF0aW9uOiB7XG4gICAgbmFtZTogXCJBbmltYXRlXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtYW5pbWF0aW9uLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBjYXJvdXNlbDoge1xuICAgIG5hbWU6IFwiQ2Fyb3VzZWxcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jYXJvdXNlbC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgY2hpcHM6IHtcbiAgICBuYW1lOiBcIkNoaXBzSW5wdXRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jaGlwcy1pbnB1dC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgY2hpcDoge1xuICAgIG5hbWU6IFwiQ2hpcFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNoaXAtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExLFxuICAgIG9uSW5pdDogXCJpbml0XCJcbiAgfSxcbiAgZGF0ZXBpY2tlcjoge1xuICAgIG5hbWU6IFwiRGF0ZXBpY2tlclwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWRhdGVwaWNrZXItaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIGRhdGV0aW1lcGlja2VyOiB7XG4gICAgbmFtZTogXCJEYXRldGltZXBpY2tlclwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWRhdGUtdGltZXBpY2tlci1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgaW5wdXQ6IHtcbiAgICBuYW1lOiBcIklucHV0XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtaW5wdXQtd3JhcHBlci1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgcGVyZmVjdFNjcm9sbGJhcjoge1xuICAgIG5hbWU6IFwiUGVyZmVjdFNjcm9sbGJhclwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXBlcmZlY3Qtc2Nyb2xsYmFyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICByYXRpbmc6IHtcbiAgICBuYW1lOiBcIlJhdGluZ1wiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXJhdGluZy1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgc2Nyb2xsc3B5OiB7XG4gICAgbmFtZTogXCJTY3JvbGxTcHlcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1zcHk9J3Njcm9sbCddXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBzZWxlY3Q6IHtcbiAgICBuYW1lOiBcIlNlbGVjdFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXNlbGVjdC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgc2lkZW5hdjoge1xuICAgIG5hbWU6IFwiU2lkZW5hdlwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXNpZGVuYXYtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHN0ZXBwZXI6IHtcbiAgICBuYW1lOiBcIlN0ZXBwZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1zdGVwcGVyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICB0aW1lcGlja2VyOiB7XG4gICAgbmFtZTogXCJUaW1lcGlja2VyXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdGltZXBpY2tlci1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgdG9hc3Q6IHtcbiAgICBuYW1lOiBcIlRvYXN0XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9hc3QtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIGRhdGF0YWJsZToge1xuICAgIG5hbWU6IFwiRGF0YXRhYmxlXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtZGF0YXRhYmxlLWluaXRdXCJcbiAgfSxcbiAgcG9wY29uZmlybToge1xuICAgIG5hbWU6IFwiUG9wY29uZmlybVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRvZ2dsZT0ncG9wY29uZmlybSddXCJcbiAgfSxcbiAgdmFsaWRhdGlvbjoge1xuICAgIG5hbWU6IFwiVmFsaWRhdGlvblwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXZhbGlkYXRpb24taW5pdF1cIlxuICB9LFxuICBzbW9vdGhTY3JvbGw6IHtcbiAgICBuYW1lOiBcIlNtb290aFNjcm9sbFwiLFxuICAgIHNlbGVjdG9yOiBcImFbZGF0YS10ZS1zbW9vdGgtc2Nyb2xsLWluaXRdXCJcbiAgfSxcbiAgbGF6eUxvYWQ6IHtcbiAgICBuYW1lOiBcIkxhenlMb2FkXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtbGF6eS1sb2FkLWluaXRdXCJcbiAgfSxcbiAgY2xpcGJvYXJkOiB7XG4gICAgbmFtZTogXCJDbGlwYm9hcmRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jbGlwYm9hcmQtaW5pdF1cIlxuICB9LFxuICBpbmZpbml0ZVNjcm9sbDoge1xuICAgIG5hbWU6IFwiSW5maW5pdGVTY3JvbGxcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1pbmZpbml0ZS1zY3JvbGwtaW5pdF1cIlxuICB9LFxuICBsb2FkaW5nTWFuYWdlbWVudDoge1xuICAgIG5hbWU6IFwiTG9hZGluZ01hbmFnZW1lbnRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1sb2FkaW5nLW1hbmFnZW1lbnQtaW5pdF1cIlxuICB9LFxuICBzdGlja3k6IHtcbiAgICBuYW1lOiBcIlN0aWNreVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXN0aWNreS1pbml0XVwiXG4gIH0sXG4gIG11bHRpUmFuZ2VTbGlkZXI6IHtcbiAgICBuYW1lOiBcIk11bHRpUmFuZ2VTbGlkZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1tdWx0aS1yYW5nZS1zbGlkZXItaW5pdF1cIlxuICB9LFxuICAvLyBhZHZhbmNlZEluaXRzXG4gIGNoYXJ0OiB7XG4gICAgbmFtZTogXCJDaGFydFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNoYXJ0XVwiLFxuICAgIGlzVG9nZ2xlcjogITEsXG4gICAgYWR2YW5jZWQ6IEJBXG4gIH0sXG4gIC8vIHRvZ2dsZXJzXG4gIGJ1dHRvbjoge1xuICAgIG5hbWU6IFwiQnV0dG9uXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9nZ2xlPSdidXR0b24nXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IERBXG4gIH0sXG4gIGNvbGxhcHNlOiB7XG4gICAgbmFtZTogXCJDb2xsYXBzZVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNvbGxhcHNlLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogTkFcbiAgfSxcbiAgZHJvcGRvd246IHtcbiAgICBuYW1lOiBcIkRyb3Bkb3duXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtZHJvcGRvd24tdG9nZ2xlLXJlZl1cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBPQVxuICB9LFxuICBtb2RhbDoge1xuICAgIG5hbWU6IFwiTW9kYWxcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J21vZGFsJ11cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiAkQVxuICB9LFxuICByaXBwbGU6IHtcbiAgICBuYW1lOiBcIlJpcHBsZVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXJpcHBsZS1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IExBXG4gIH0sXG4gIG9mZmNhbnZhczoge1xuICAgIG5hbWU6IFwiT2ZmY2FudmFzXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtb2ZmY2FudmFzLXRvZ2dsZV1cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBJQVxuICB9LFxuICB0YWI6IHtcbiAgICBuYW1lOiBcIlRhYlwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRvZ2dsZT0ndGFiJ10sIFtkYXRhLXRlLXRvZ2dsZT0ncGlsbCddLCBbZGF0YS10ZS10b2dnbGU9J2xpc3QnXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IFNBXG4gIH0sXG4gIHRvb2x0aXA6IHtcbiAgICBuYW1lOiBcIlRvb2x0aXBcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J3Rvb2x0aXAnXVwiLFxuICAgIGlzVG9nZ2xlcjogITEsXG4gICAgY2FsbGJhY2s6IE1BXG4gIH0sXG4gIHBvcG92ZXI6IHtcbiAgICBuYW1lOiBcIlBvcG92ZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J3BvcG92ZXInXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IFJBXG4gIH0sXG4gIGxpZ2h0Ym94OiB7XG4gICAgbmFtZTogXCJMaWdodGJveFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWxpZ2h0Ym94LWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogUEFcbiAgfSxcbiAgdG91Y2g6IHtcbiAgICBuYW1lOiBcIlRvdWNoXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG91Y2gtaW5pdF1cIlxuICB9XG59LCBWQSA9IChzKSA9PiBOaVtzLk5BTUVdIHx8IG51bGwsIFdBID0gKHMsIHQpID0+IHtcbiAgaWYgKCFzIHx8ICF0LmFsbG93UmVpbml0cyAmJiBhci5pc0luaXRlZChzLk5BTUUpKVxuICAgIHJldHVybjtcbiAgYXIuYWRkKHMuTkFNRSk7XG4gIGNvbnN0IGUgPSBWQShzKSwgaSA9IChlID09IG51bGwgPyB2b2lkIDAgOiBlLmlzVG9nZ2xlcikgfHwgITE7XG4gIGlmICh4QShzKSwgZSAhPSBudWxsICYmIGUuYWR2YW5jZWQpIHtcbiAgICBlID09IG51bGwgfHwgZS5hZHZhbmNlZChzLCBlID09IG51bGwgPyB2b2lkIDAgOiBlLnNlbGVjdG9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGkpIHtcbiAgICBlID09IG51bGwgfHwgZS5jYWxsYmFjayhzLCBlID09IG51bGwgPyB2b2lkIDAgOiBlLnNlbGVjdG9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZC5maW5kKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuc2VsZWN0b3IpLmZvckVhY2goKG4pID0+IHtcbiAgICBsZXQgbyA9IHMuZ2V0SW5zdGFuY2Uobik7XG4gICAgbyB8fCAobyA9IG5ldyBzKG4pLCBlICE9IG51bGwgJiYgZS5vbkluaXQgJiYgb1tlLm9uSW5pdF0oKSk7XG4gIH0pO1xufSwgRkEgPSAocywgdCkgPT4ge1xuICBzLmZvckVhY2goKGUpID0+IFdBKGUsIHQpKTtcbn0sIFlBID0ge1xuICBhbGxvd1JlaW5pdHM6ICExLFxuICBjaGVja090aGVySW1wb3J0czogITFcbn0sIHFBID0gKHMsIHQgPSB7fSkgPT4ge1xuICB0ID0geyAuLi5ZQSwgLi4udCB9O1xuICBjb25zdCBlID0gT2JqZWN0LmtleXMoTmkpLm1hcCgoaSkgPT4ge1xuICAgIGlmICghIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoTmlbaV0uc2VsZWN0b3IpKSB7XG4gICAgICBjb25zdCBvID0gc1tOaVtpXS5uYW1lXTtcbiAgICAgIHJldHVybiAhbyAmJiAhYXIuaXNJbml0ZWQoaSkgJiYgdC5jaGVja090aGVySW1wb3J0cyAmJiBjb25zb2xlLndhcm4oXG4gICAgICAgIGBQbGVhc2UgaW1wb3J0ICR7TmlbaV0ubmFtZX0gZnJvbSBcInR3LWVsZW1lbnRzXCIgcGFja2FnZSBhbmQgYWRkIGl0IHRvIGEgb2JqZWN0IHBhcmFtZXRlciBpbnNpZGUgXCJpbml0VEVcIiBmdW5jdGlvbmBcbiAgICAgICksIG87XG4gICAgfVxuICB9KTtcbiAgRkEoZSwgdCk7XG59O1xuZXhwb3J0IHtcbiAgS28gYXMgQWxlcnQsXG4gIHdyIGFzIEFuaW1hdGUsXG4gIGlkIGFzIEF1dG9jb21wbGV0ZSxcbiAga2MgYXMgQnV0dG9uLFxuICBYdCBhcyBDYXJvdXNlbCxcbiAgTGggYXMgQ2hhcnQsXG4gIHZpIGFzIENoaXAsXG4gIFhBIGFzIENoaXBzSW5wdXQsXG4gIFVoIGFzIENsaXBib2FyZCxcbiAgUXQgYXMgQ29sbGFwc2UsXG4gIEhoIGFzIERhdGF0YWJsZSxcbiAgb2cgYXMgRGF0ZXBpY2tlcixcbiAgUWggYXMgRGF0ZXRpbWVwaWNrZXIsXG4gICR0IGFzIERyb3Bkb3duLFxuICBYaCBhcyBJbmZpbml0ZVNjcm9sbCxcbiAgViBhcyBJbnB1dCxcbiAgb3IgYXMgTGF6eUxvYWQsXG4gIG5uIGFzIExpZ2h0Ym94LFxuICBHaCBhcyBMb2FkaW5nTWFuYWdlbWVudCxcbiAgem8gYXMgTW9kYWwsXG4gIHNkIGFzIE11bHRpUmFuZ2VTbGlkZXIsXG4gIGpzIGFzIE9mZmNhbnZhcyxcbiAgQmggYXMgUGVyZmVjdFNjcm9sbGJhcixcbiAgV2ggYXMgUG9wY29uZmlybSxcbiAgbmggYXMgUG9wb3ZlcixcbiAgR0EgYXMgUmF0aW5nLFxuICBlaSBhcyBSaXBwbGUsXG4gIGFoIGFzIFNjcm9sbFNweSxcbiAga3IgYXMgU2VsZWN0LFxuICBDaSBhcyBTaWRlbmF2LFxuICB6aCBhcyBTbW9vdGhTY3JvbGwsXG4gIFVBIGFzIFN0ZXBwZXIsXG4gIHRkIGFzIFN0aWNreSxcbiAgbGggYXMgVGFiLFxuICBTZyBhcyBUaW1lcGlja2VyLFxuICBYbyBhcyBUb2FzdCxcbiAgcmkgYXMgVG9vbHRpcCxcbiAgS2ggYXMgVG91Y2gsXG4gIGpoIGFzIFZhbGlkYXRpb24sXG4gIHFBIGFzIGluaXRURVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR3LWVsZW1lbnRzLmVzLm1pbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==